// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// An attribute match configuration which can match an attribute key and value.
type AttributeMatchConfig struct {
	Key       *MatchConfig `json:"key"`
	Attribute *MatchConfig `json:"attribute"`
}

type BackendErrorObjectInput struct {
	SessionSecureID *string       `json:"session_secure_id,omitempty"`
	RequestID       *string       `json:"request_id,omitempty"`
	TraceID         *string       `json:"trace_id,omitempty"`
	SpanID          *string       `json:"span_id,omitempty"`
	LogCursor       *string       `json:"log_cursor,omitempty"`
	Event           string        `json:"event"`
	Type            string        `json:"type"`
	URL             string        `json:"url"`
	Source          string        `json:"source"`
	StackTrace      string        `json:"stackTrace"`
	Timestamp       time.Time     `json:"timestamp"`
	Payload         *string       `json:"payload,omitempty"`
	Service         *ServiceInput `json:"service"`
	Environment     string        `json:"environment"`
}

type ErrorObjectInput struct {
	Event        string             `json:"event"`
	Type         string             `json:"type"`
	URL          string             `json:"url"`
	Source       string             `json:"source"`
	LineNumber   int                `json:"lineNumber"`
	ColumnNumber int                `json:"columnNumber"`
	StackTrace   []*StackFrameInput `json:"stackTrace"`
	Timestamp    time.Time          `json:"timestamp"`
	Payload      *string            `json:"payload,omitempty"`
}

type InitializeSessionResponse struct {
	SecureID  string          `json:"secure_id"`
	ProjectID int             `json:"project_id"`
	Sampling  *SamplingConfig `json:"sampling,omitempty"`
}

// A match based log sampling configuration. A log matches if each specified matching configuration matches.
// If no matching configuration is specified, then all spans will match.
// The sampling ratio will be applied to all matching spans.
type LogSamplingConfig struct {
	// A list of attribute match configs.
	// In order to match each attribute listed must match. This is an implicit AND operation.
	Attributes []*AttributeMatchConfig `json:"attributes,omitempty"`
	// Matches against the log message.
	Message *MatchConfig `json:"message,omitempty"`
	// Matches against the severity of the log.
	SeverityText *MatchConfig `json:"severityText,omitempty"`
	// The ratio of logs to sample. Expressed in the form 1/n. So if the ratio is 10, then 1 out of
	// every 10 logs will be sampled. Setting the ratio to 0 will disable sampling for the log.
	SamplingRatio int `json:"samplingRatio"`
}

// A match configuration. Each field of this type represents a different type of match
// configuration. One and only 1 field should be populated.
//
// This is effectively a sum type/discriminated union, but isn't implemented as such to avoid
// this bug: https://github.com/99designs/gqlgen/issues/2741
type MatchConfig struct {
	// A match configuration which matches against a regular expression.
	// Can only match string attributes.
	RegexValue *string `json:"regexValue,omitempty"`
	// A match configuration which does an exact match against any value.
	MatchValue any `json:"matchValue,omitempty"`
}

type MetricInput struct {
	SessionSecureID string       `json:"session_secure_id"`
	SpanID          *string      `json:"span_id,omitempty"`
	ParentSpanID    *string      `json:"parent_span_id,omitempty"`
	TraceID         *string      `json:"trace_id,omitempty"`
	Group           *string      `json:"group,omitempty"`
	Name            string       `json:"name"`
	Value           float64      `json:"value"`
	Category        *string      `json:"category,omitempty"`
	Timestamp       time.Time    `json:"timestamp"`
	Tags            []*MetricTag `json:"tags,omitempty"`
}

type MetricTag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type Mutation struct {
}

type ReplayEventInput struct {
	Type      int     `json:"type"`
	Timestamp float64 `json:"timestamp"`
	Sid       float64 `json:"_sid"`
	Data      any     `json:"data"`
}

type ReplayEventsInput struct {
	Events []*ReplayEventInput `json:"events"`
}

type SamplingConfig struct {
	Spans []*SpanSamplingConfig `json:"spans,omitempty"`
	Logs  []*LogSamplingConfig  `json:"logs,omitempty"`
}

type ServiceInput struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

// An event matcher configuration which matches span events within a span.
type SpanEventMatchConfig struct {
	Name       *MatchConfig            `json:"name,omitempty"`
	Attributes []*AttributeMatchConfig `json:"attributes,omitempty"`
}

// A match based span sampling configuration. A span matches if each specified matching configuration
// matches.
// If no matching configuration is specified, then all spans will match.
// The sampling ratio will be applied to all matching spans.
type SpanSamplingConfig struct {
	Name *MatchConfig `json:"name,omitempty"`
	// A list of attribute match configs.
	// In order to match each attribute listed must match. This is an implicit AND operation.
	Attributes []*AttributeMatchConfig `json:"attributes,omitempty"`
	// A list of span event match configs.
	Events []*SpanEventMatchConfig `json:"events,omitempty"`
	// The ratio of spans to sample. Expressed in the form 1/n. So if the ratio is 10, then 1 out of
	// every 10 spans will be sampled. Setting the ratio to 0 will disable sampling for the span.
	SamplingRatio int `json:"samplingRatio"`
}

type StackFrameInput struct {
	FunctionName *string `json:"functionName,omitempty"`
	Args         []any   `json:"args,omitempty"`
	FileName     *string `json:"fileName,omitempty"`
	LineNumber   *int    `json:"lineNumber,omitempty"`
	ColumnNumber *int    `json:"columnNumber,omitempty"`
	IsEval       *bool   `json:"isEval,omitempty"`
	IsNative     *bool   `json:"isNative,omitempty"`
	Source       *string `json:"source,omitempty"`
}

type PublicGraphError string

const (
	PublicGraphErrorBillingQuotaExceeded PublicGraphError = "BillingQuotaExceeded"
)

var AllPublicGraphError = []PublicGraphError{
	PublicGraphErrorBillingQuotaExceeded,
}

func (e PublicGraphError) IsValid() bool {
	switch e {
	case PublicGraphErrorBillingQuotaExceeded:
		return true
	}
	return false
}

func (e PublicGraphError) String() string {
	return string(e)
}

func (e *PublicGraphError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublicGraphError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublicGraphError", str)
	}
	return nil
}

func (e PublicGraphError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
