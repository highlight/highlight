// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/lib/pq"
)

type Connection interface {
	IsConnection()
	GetPageInfo() *PageInfo
}

type Edge interface {
	IsEdge()
	GetCursor() string
}

type AWSMarketplaceSubscription struct {
	CustomerIdentifier   string `json:"customer_identifier"`
	CustomerAwsAccountID string `json:"customer_aws_account_id"`
	ProductCode          string `json:"product_code"`
}

type AccessibleJiraResources struct {
	ID        string   `json:"id"`
	URL       string   `json:"url"`
	Name      string   `json:"name"`
	Scopes    []string `json:"scopes,omitempty"`
	AvatarURL string   `json:"avatarUrl"`
}

type Account struct {
	ID                   int        `json:"id"`
	Name                 string     `json:"name"`
	SessionCountCur      int        `json:"session_count_cur"`
	ViewCountCur         int        `json:"view_count_cur"`
	SessionCountPrev     int        `json:"session_count_prev"`
	ViewCountPrev        int        `json:"view_count_prev"`
	SessionCountPrevPrev int        `json:"session_count_prev_prev"`
	SessionLimit         int        `json:"session_limit"`
	PaidPrev             int        `json:"paid_prev"`
	PaidPrevPrev         int        `json:"paid_prev_prev"`
	Email                string     `json:"email"`
	SubscriptionStart    *time.Time `json:"subscription_start,omitempty"`
	PlanTier             string     `json:"plan_tier"`
	UnlimitedMembers     bool       `json:"unlimited_members"`
	StripeCustomerID     string     `json:"stripe_customer_id"`
	MemberCount          int        `json:"member_count"`
	MemberLimit          *int       `json:"member_limit,omitempty"`
}

type AccountDetails struct {
	ID                   int                     `json:"id"`
	Name                 string                  `json:"name"`
	SessionCountPerMonth []*NamedCount           `json:"session_count_per_month,omitempty"`
	SessionCountPerDay   []*NamedCount           `json:"session_count_per_day,omitempty"`
	StripeCustomerID     string                  `json:"stripe_customer_id"`
	Members              []*AccountDetailsMember `json:"members"`
}

type AccountDetailsMember struct {
	ID         int        `json:"id"`
	Name       string     `json:"name"`
	Email      string     `json:"email"`
	LastActive *time.Time `json:"last_active,omitempty"`
}

type AdminAboutYouDetails struct {
	FirstName               string  `json:"first_name"`
	LastName                string  `json:"last_name"`
	UserDefinedRole         string  `json:"user_defined_role"`
	UserDefinedPersona      string  `json:"user_defined_persona"`
	UserDefinedTeamSize     string  `json:"user_defined_team_size"`
	HeardAbout              string  `json:"heard_about"`
	PhoneHomeContactAllowed bool    `json:"phone_home_contact_allowed"`
	Referral                string  `json:"referral"`
	Phone                   *string `json:"phone,omitempty"`
}

type AdminAndWorkspaceDetails struct {
	FirstName                   string  `json:"first_name"`
	LastName                    string  `json:"last_name"`
	UserDefinedRole             string  `json:"user_defined_role"`
	UserDefinedTeamSize         string  `json:"user_defined_team_size"`
	HeardAbout                  string  `json:"heard_about"`
	PhoneHomeContactAllowed     bool    `json:"phone_home_contact_allowed"`
	Referral                    string  `json:"referral"`
	WorkspaceName               string  `json:"workspace_name"`
	AllowedAutoJoinEmailOrigins *string `json:"allowed_auto_join_email_origins,omitempty"`
	PromoCode                   *string `json:"promo_code,omitempty"`
}

type AlertDestinationInput struct {
	DestinationType AlertDestinationType `json:"destination_type"`
	TypeID          string               `json:"type_id"`
	TypeName        string               `json:"type_name"`
}

type AlertStateChange struct {
	ID            int        `json:"id"`
	Timestamp     time.Time  `json:"timestamp"`
	AlertID       int        `json:"AlertID"`
	State         AlertState `json:"State"`
	PreviousState AlertState `json:"PreviousState"`
	Title         string     `json:"Title"`
	GroupByKey    string     `json:"GroupByKey"`
}

type AllProjectSettings struct {
	ID                                int            `json:"id"`
	VerboseID                         string         `json:"verbose_id"`
	Name                              string         `json:"name"`
	BillingEmail                      *string        `json:"billing_email,omitempty"`
	WorkspaceID                       int            `json:"workspace_id"`
	ExcludedUsers                     pq.StringArray `json:"excluded_users,omitempty"`
	ErrorFilters                      pq.StringArray `json:"error_filters,omitempty"`
	ErrorJSONPaths                    pq.StringArray `json:"error_json_paths,omitempty"`
	RageClickWindowSeconds            *int           `json:"rage_click_window_seconds,omitempty"`
	RageClickRadiusPixels             *int           `json:"rage_click_radius_pixels,omitempty"`
	RageClickCount                    *int           `json:"rage_click_count,omitempty"`
	FilterChromeExtension             *bool          `json:"filter_chrome_extension,omitempty"`
	FilterSessionsWithoutError        bool           `json:"filterSessionsWithoutError"`
	AutoResolveStaleErrorsDayInterval int            `json:"autoResolveStaleErrorsDayInterval"`
	Sampling                          *Sampling      `json:"sampling"`
}

type AverageSessionLength struct {
	Length float64 `json:"length"`
}

type BillingDetails struct {
	Plan                 *Plan   `json:"plan"`
	Meter                int64   `json:"meter"`
	MembersMeter         int64   `json:"membersMeter"`
	ErrorsMeter          int64   `json:"errorsMeter"`
	LogsMeter            int64   `json:"logsMeter"`
	TracesMeter          int64   `json:"tracesMeter"`
	SessionsDailyAverage float64 `json:"sessionsDailyAverage"`
	ErrorsDailyAverage   float64 `json:"errorsDailyAverage"`
	LogsDailyAverage     float64 `json:"logsDailyAverage"`
	TracesDailyAverage   float64 `json:"tracesDailyAverage"`
	SessionsBillingLimit *int64  `json:"sessionsBillingLimit,omitempty"`
	ErrorsBillingLimit   *int64  `json:"errorsBillingLimit,omitempty"`
	LogsBillingLimit     *int64  `json:"logsBillingLimit,omitempty"`
	TracesBillingLimit   *int64  `json:"tracesBillingLimit,omitempty"`
}

type CategoryHistogramBucket struct {
	Category string `json:"category"`
	Count    int    `json:"count"`
}

type CategoryHistogramPayload struct {
	Buckets []*CategoryHistogramBucket `json:"buckets"`
}

type ClickUpFolder struct {
	ID    string         `json:"id"`
	Name  string         `json:"name"`
	Lists []*ClickUpList `json:"lists"`
}

type ClickUpList struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ClickUpProjectMapping struct {
	ProjectID      int    `json:"project_id"`
	ClickupSpaceID string `json:"clickup_space_id"`
}

type ClickUpProjectMappingInput struct {
	ProjectID      int    `json:"project_id"`
	ClickupSpaceID string `json:"clickup_space_id"`
}

type ClickUpSpace struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ClickUpTask struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ClickUpTeam struct {
	ID     string          `json:"id"`
	Name   string          `json:"name"`
	Spaces []*ClickUpSpace `json:"spaces"`
}

type ClickhouseQuery struct {
	IsAnd     bool                    `json:"isAnd"`
	Rules     [][]string              `json:"rules"`
	DateRange *DateRangeRequiredInput `json:"dateRange"`
}

type DashboardDefinition struct {
	ID                int                      `json:"id"`
	UpdatedAt         time.Time                `json:"updated_at"`
	ProjectID         int                      `json:"project_id"`
	Name              string                   `json:"name"`
	Metrics           []*DashboardMetricConfig `json:"metrics"`
	LastAdminToEditID *int                     `json:"last_admin_to_edit_id,omitempty"`
	Layout            *string                  `json:"layout,omitempty"`
	IsDefault         *bool                    `json:"is_default,omitempty"`
}

type DashboardMetricConfig struct {
	Name                     string                   `json:"name"`
	Description              string                   `json:"description"`
	ComponentType            *MetricViewComponentType `json:"component_type,omitempty"`
	MaxGoodValue             *float64                 `json:"max_good_value,omitempty"`
	MaxNeedsImprovementValue *float64                 `json:"max_needs_improvement_value,omitempty"`
	PoorValue                *float64                 `json:"poor_value,omitempty"`
	Units                    *string                  `json:"units,omitempty"`
	HelpArticle              *string                  `json:"help_article,omitempty"`
	ChartType                *DashboardChartType      `json:"chart_type,omitempty"`
	Aggregator               *MetricAggregator        `json:"aggregator,omitempty"`
	MinValue                 *float64                 `json:"min_value,omitempty"`
	MinPercentile            *float64                 `json:"min_percentile,omitempty"`
	MaxValue                 *float64                 `json:"max_value,omitempty"`
	MaxPercentile            *float64                 `json:"max_percentile,omitempty"`
	Filters                  []*MetricTagFilter       `json:"filters,omitempty"`
	Groups                   []string                 `json:"groups,omitempty"`
}

type DashboardMetricConfigInput struct {
	Name                     string                   `json:"name"`
	Description              string                   `json:"description"`
	ComponentType            *MetricViewComponentType `json:"component_type,omitempty"`
	MaxGoodValue             *float64                 `json:"max_good_value,omitempty"`
	MaxNeedsImprovementValue *float64                 `json:"max_needs_improvement_value,omitempty"`
	PoorValue                *float64                 `json:"poor_value,omitempty"`
	Units                    *string                  `json:"units,omitempty"`
	HelpArticle              *string                  `json:"help_article,omitempty"`
	ChartType                *DashboardChartType      `json:"chart_type,omitempty"`
	Aggregator               *MetricAggregator        `json:"aggregator,omitempty"`
	MinValue                 *float64                 `json:"min_value,omitempty"`
	MinPercentile            *float64                 `json:"min_percentile,omitempty"`
	MaxValue                 *float64                 `json:"max_value,omitempty"`
	MaxPercentile            *float64                 `json:"max_percentile,omitempty"`
	Filters                  []*MetricTagFilterInput  `json:"filters,omitempty"`
	Groups                   []string                 `json:"groups,omitempty"`
}

type DashboardParamsInput struct {
	DateRange         *DateRangeRequiredInput `json:"date_range"`
	ResolutionMinutes *int                    `json:"resolution_minutes,omitempty"`
	Timezone          *string                 `json:"timezone,omitempty"`
	Units             *string                 `json:"units,omitempty"`
	Aggregator        MetricAggregator        `json:"aggregator"`
	Filters           []*MetricTagFilterInput `json:"filters,omitempty"`
	Groups            []string                `json:"groups,omitempty"`
}

type DashboardPayload struct {
	Date       string           `json:"date"`
	Value      float64          `json:"value"`
	Aggregator MetricAggregator `json:"aggregator"`
	Group      *string          `json:"group,omitempty"`
}

type DateHistogramBucketSize struct {
	CalendarInterval OpenSearchCalendarInterval `json:"calendar_interval"`
	Multiple         int                        `json:"multiple"`
}

type DateHistogramOptions struct {
	BucketSize *DateHistogramBucketSize `json:"bucket_size"`
	TimeZone   string                   `json:"time_zone"`
	Bounds     *DateRangeInput          `json:"bounds"`
}

type DateRangeInput struct {
	StartDate *time.Time `json:"start_date,omitempty"`
	EndDate   *time.Time `json:"end_date,omitempty"`
}

type DateRangeRequiredInput struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type DateRangeRequiredOutput struct {
	StartDate *time.Time `json:"start_date,omitempty"`
	EndDate   *time.Time `json:"end_date,omitempty"`
}

type DiscordChannelInput struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

type EnhancedUserDetailsResult struct {
	ID      *int          `json:"id,omitempty"`
	Name    *string       `json:"name,omitempty"`
	Avatar  *string       `json:"avatar,omitempty"`
	Bio     *string       `json:"bio,omitempty"`
	Socials []*SocialLink `json:"socials,omitempty"`
	Email   *string       `json:"email,omitempty"`
}

type ErrorDistributionItem struct {
	ErrorGroupID int       `json:"error_group_id"`
	Date         time.Time `json:"date"`
	Name         string    `json:"name"`
	Value        int64     `json:"value"`
}

type ErrorGroupFrequenciesParamsInput struct {
	DateRange         *DateRangeRequiredInput `json:"date_range"`
	ResolutionMinutes int                     `json:"resolution_minutes"`
}

type ErrorGroupTagAggregation struct {
	Key     string                            `json:"key"`
	Buckets []*ErrorGroupTagAggregationBucket `json:"buckets"`
}

type ErrorGroupTagAggregationBucket struct {
	Key      string  `json:"key"`
	DocCount int64   `json:"doc_count"`
	Percent  float64 `json:"percent"`
}

type ErrorMetadata struct {
	ErrorID         int        `json:"error_id"`
	SessionID       int        `json:"session_id"`
	SessionSecureID string     `json:"session_secure_id"`
	Environment     *string    `json:"environment,omitempty"`
	Timestamp       *time.Time `json:"timestamp,omitempty"`
	Os              *string    `json:"os,omitempty"`
	Browser         *string    `json:"browser,omitempty"`
	VisitedURL      *string    `json:"visited_url,omitempty"`
	Fingerprint     string     `json:"fingerprint"`
	Identifier      *string    `json:"identifier,omitempty"`
	UserProperties  *string    `json:"user_properties,omitempty"`
	RequestID       *string    `json:"request_id,omitempty"`
	Payload         *string    `json:"payload,omitempty"`
}

type ErrorObjectNode struct {
	ID                 int                     `json:"id"`
	CreatedAt          time.Time               `json:"createdAt"`
	Event              string                  `json:"event"`
	Timestamp          time.Time               `json:"timestamp"`
	Session            *ErrorObjectNodeSession `json:"session,omitempty"`
	ServiceVersion     string                  `json:"serviceVersion"`
	ServiceName        string                  `json:"serviceName"`
	ErrorGroupSecureID string                  `json:"errorGroupSecureID"`
}

type ErrorObjectNodeSession struct {
	SecureID    string  `json:"secureID"`
	Email       *string `json:"email,omitempty"`
	Fingerprint *int    `json:"fingerprint,omitempty"`
	Excluded    bool    `json:"excluded"`
}

type ErrorObjectResults struct {
	ErrorObjects []*ErrorObjectNode `json:"error_objects"`
	TotalCount   int64              `json:"totalCount"`
}

type ErrorTrace struct {
	FileName                   *string             `json:"fileName,omitempty"`
	LineNumber                 *int                `json:"lineNumber,omitempty"`
	FunctionName               *string             `json:"functionName,omitempty"`
	ColumnNumber               *int                `json:"columnNumber,omitempty"`
	Error                      *string             `json:"error,omitempty"`
	SourceMappingErrorMetadata *SourceMappingError `json:"sourceMappingErrorMetadata,omitempty"`
	LineContent                *string             `json:"lineContent,omitempty"`
	LinesBefore                *string             `json:"linesBefore,omitempty"`
	LinesAfter                 *string             `json:"linesAfter,omitempty"`
	ExternalLink               *string             `json:"externalLink,omitempty"`
	EnhancementSource          *EnhancementSource  `json:"enhancementSource,omitempty"`
	EnhancementVersion         *string             `json:"enhancementVersion,omitempty"`
}

type FunnelStep struct {
	Title string `json:"title"`
	Query string `json:"query"`
}

type FunnelStepInput struct {
	Title string `json:"title"`
	Query string `json:"query"`
}

type GitHubRepo struct {
	RepoID string `json:"repo_id"`
	Name   string `json:"name"`
	Key    string `json:"key"`
}

type GitlabProject struct {
	ID                int    `json:"id"`
	Name              string `json:"name"`
	NameWithNameSpace string `json:"nameWithNameSpace"`
}

type GraphInput struct {
	ID                *int               `json:"id,omitempty"`
	VisualizationID   int                `json:"visualizationId"`
	AfterGraphID      *int               `json:"afterGraphId,omitempty"`
	Type              string             `json:"type"`
	Title             string             `json:"title"`
	ProductType       ProductType        `json:"productType"`
	Query             string             `json:"query"`
	Metric            string             `json:"metric"`
	FunctionType      MetricAggregator   `json:"functionType"`
	GroupByKeys       pq.StringArray     `json:"groupByKeys,omitempty"`
	BucketByKey       *string            `json:"bucketByKey,omitempty"`
	BucketCount       *int               `json:"bucketCount,omitempty"`
	BucketInterval    *int               `json:"bucketInterval,omitempty"`
	Limit             *int               `json:"limit,omitempty"`
	LimitFunctionType *MetricAggregator  `json:"limitFunctionType,omitempty"`
	LimitMetric       *string            `json:"limitMetric,omitempty"`
	FunnelSteps       []*FunnelStepInput `json:"funnelSteps,omitempty"`
	Display           *string            `json:"display,omitempty"`
	NullHandling      *string            `json:"nullHandling,omitempty"`
}

type HeightList struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

type HeightTask struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type HeightWorkspace struct {
	ID    string `json:"id"`
	Model string `json:"model"`
	Name  string `json:"name"`
	URL   string `json:"url"`
}

type HistogramBucket struct {
	Bucket     float64 `json:"bucket"`
	RangeStart float64 `json:"range_start"`
	RangeEnd   float64 `json:"range_end"`
	Count      int     `json:"count"`
}

type IntegrationProjectMappingInput struct {
	ProjectID  int    `json:"project_id"`
	ExternalID string `json:"external_id"`
}

type IntegrationStatus struct {
	Integrated   bool       `json:"integrated"`
	ResourceType string     `json:"resourceType"`
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
}

type Invoice struct {
	AmountDue    *int64     `json:"amountDue,omitempty"`
	AmountPaid   *int64     `json:"amountPaid,omitempty"`
	AttemptCount *int64     `json:"attemptCount,omitempty"`
	Date         *time.Time `json:"date,omitempty"`
	URL          *string    `json:"url,omitempty"`
	Status       *string    `json:"status,omitempty"`
}

type IssuesSearchResult struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	IssueURL string `json:"issue_url"`
}

type JiraIssueType struct {
	Self             string              `json:"self"`
	ID               string              `json:"id"`
	Description      string              `json:"description"`
	IconURL          string              `json:"iconUrl"`
	Name             string              `json:"name"`
	UntranslatedName string              `json:"untranslatedName"`
	Subtask          bool                `json:"subtask"`
	Scope            *JiraIssueTypeScope `json:"scope,omitempty"`
}

type JiraIssueTypeScope struct {
	Type    string                 `json:"type"`
	Project *JiraProjectIdentifier `json:"project,omitempty"`
}

type JiraProject struct {
	Name       string           `json:"name"`
	Key        string           `json:"key"`
	ID         string           `json:"id"`
	Self       string           `json:"self"`
	IssueTypes []*JiraIssueType `json:"issueTypes,omitempty"`
}

type JiraProjectIdentifier struct {
	ID string `json:"id"`
}

type JiraTeam struct {
	TeamID string `json:"team_id"`
	Name   string `json:"name"`
	Key    string `json:"key"`
}

type LengthRangeInput struct {
	Min *float64 `json:"min,omitempty"`
	Max *float64 `json:"max,omitempty"`
}

type LinearTeam struct {
	TeamID string `json:"team_id"`
	Name   string `json:"name"`
	Key    string `json:"key"`
}

type Log struct {
	ProjectID       int                    `json:"projectID"`
	Timestamp       time.Time              `json:"timestamp"`
	Level           LogLevel               `json:"level"`
	Message         string                 `json:"message"`
	LogAttributes   map[string]interface{} `json:"logAttributes"`
	TraceID         *string                `json:"traceID,omitempty"`
	SpanID          *string                `json:"spanID,omitempty"`
	SecureSessionID *string                `json:"secureSessionID,omitempty"`
	Source          *string                `json:"source,omitempty"`
	ServiceName     *string                `json:"serviceName,omitempty"`
	ServiceVersion  *string                `json:"serviceVersion,omitempty"`
	Environment     *string                `json:"environment,omitempty"`
}

type LogAlertInput struct {
	ProjectID              int                           `json:"project_id"`
	Name                   string                        `json:"name"`
	CountThreshold         int                           `json:"count_threshold"`
	BelowThreshold         bool                          `json:"below_threshold"`
	ThresholdWindow        int                           `json:"threshold_window"`
	SlackChannels          []*SanitizedSlackChannelInput `json:"slack_channels"`
	DiscordChannels        []*DiscordChannelInput        `json:"discord_channels"`
	MicrosoftTeamsChannels []*MicrosoftTeamsChannelInput `json:"microsoft_teams_channels"`
	WebhookDestinations    []*WebhookDestinationInput    `json:"webhook_destinations"`
	Emails                 []string                      `json:"emails"`
	Disabled               bool                          `json:"disabled"`
	Default                *bool                         `json:"default,omitempty"`
	Query                  string                        `json:"query"`
}

type LogConnection struct {
	Edges    []*LogEdge `json:"edges"`
	PageInfo *PageInfo  `json:"pageInfo"`
}

func (LogConnection) IsConnection()               {}
func (this LogConnection) GetPageInfo() *PageInfo { return this.PageInfo }

type LogEdge struct {
	Cursor string `json:"cursor"`
	Node   *Log   `json:"node"`
}

func (LogEdge) IsEdge()                {}
func (this LogEdge) GetCursor() string { return this.Cursor }

type LogLine struct {
	Timestamp time.Time `json:"timestamp"`
	Body      string    `json:"body"`
	Severity  *LogLevel `json:"severity,omitempty"`
	Labels    string    `json:"labels"`
}

type LogsHistogram struct {
	Buckets      []*LogsHistogramBucket `json:"buckets"`
	TotalCount   uint64                 `json:"totalCount"`
	ObjectCount  uint64                 `json:"objectCount"`
	SampleFactor float64                `json:"sampleFactor"`
}

type LogsHistogramBucket struct {
	BucketID uint64                      `json:"bucketId"`
	Counts   []*LogsHistogramBucketCount `json:"counts"`
}

type LogsHistogramBucketCount struct {
	Count uint64   `json:"count"`
	Level LogLevel `json:"level"`
}

type MatchedErrorTag struct {
	ID          int     `json:"id"`
	Title       string  `json:"title"`
	Description string  `json:"description"`
	Score       float64 `json:"score"`
}

type MetricBucket struct {
	BucketID    uint64           `json:"bucket_id"`
	BucketMin   float64          `json:"bucket_min"`
	BucketMax   float64          `json:"bucket_max"`
	Group       []string         `json:"group"`
	Column      MetricColumn     `json:"column"`
	MetricType  MetricAggregator `json:"metric_type"`
	MetricValue *float64         `json:"metric_value,omitempty"`
}

type MetricPreview struct {
	Date  time.Time `json:"date"`
	Value float64   `json:"value"`
}

type MetricTagFilter struct {
	Tag   string            `json:"tag"`
	Op    MetricTagFilterOp `json:"op"`
	Value string            `json:"value"`
}

type MetricTagFilterInput struct {
	Tag   string            `json:"tag"`
	Op    MetricTagFilterOp `json:"op"`
	Value string            `json:"value"`
}

type MetricsBuckets struct {
	Buckets      []*MetricBucket `json:"buckets"`
	BucketCount  uint64          `json:"bucket_count"`
	SampleFactor float64         `json:"sample_factor"`
}

type MicrosoftTeamsChannelInput struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

type Mutation struct {
}

type NamedCount struct {
	Name  string `json:"name"`
	Count int    `json:"count"`
}

type NetworkHistogramParamsInput struct {
	LookbackDays float64                  `json:"lookback_days"`
	Attribute    *NetworkRequestAttribute `json:"attribute,omitempty"`
}

type NewUsersCount struct {
	Count int64 `json:"count"`
}

type OAuthClient struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	AppName   string    `json:"app_name"`
}

type PageInfo struct {
	HasNextPage     bool   `json:"hasNextPage"`
	HasPreviousPage bool   `json:"hasPreviousPage"`
	StartCursor     string `json:"startCursor"`
	EndCursor       string `json:"endCursor"`
}

type Plan struct {
	Type                PlanType                    `json:"type"`
	Interval            SubscriptionInterval        `json:"interval"`
	MembersLimit        *int64                      `json:"membersLimit,omitempty"`
	EnableBillingLimits bool                        `json:"enableBillingLimits"`
	AwsMpSubscription   *AWSMarketplaceSubscription `json:"aws_mp_subscription,omitempty"`
	SessionsLimit       int64                       `json:"sessionsLimit"`
	ErrorsLimit         int64                       `json:"errorsLimit"`
	LogsLimit           int64                       `json:"logsLimit"`
	TracesLimit         int64                       `json:"tracesLimit"`
	SessionsRate        float64                     `json:"sessionsRate"`
	ErrorsRate          float64                     `json:"errorsRate"`
	LogsRate            float64                     `json:"logsRate"`
	TracesRate          float64                     `json:"tracesRate"`
}

type QueryInput struct {
	Query     string                  `json:"query"`
	DateRange *DateRangeRequiredInput `json:"date_range"`
	Sort      *SortInput              `json:"sort,omitempty"`
}

type QueryKey struct {
	Name string  `json:"name"`
	Type KeyType `json:"type"`
}

type QueryOutput struct {
	Query     string                   `json:"query"`
	DateRange *DateRangeRequiredOutput `json:"date_range"`
}

type RageClickEventForProject struct {
	Identifier      string `json:"identifier"`
	SessionSecureID string `json:"session_secure_id"`
	TotalClicks     int    `json:"total_clicks"`
	UserProperties  string `json:"user_properties"`
}

type ReferrerTablePayload struct {
	Host    string  `json:"host"`
	Count   int     `json:"count"`
	Percent float64 `json:"percent"`
}

type S3File struct {
	Key *string `json:"key,omitempty"`
}

type Sampling struct {
	SessionSamplingRate    float64 `json:"session_sampling_rate"`
	ErrorSamplingRate      float64 `json:"error_sampling_rate"`
	LogSamplingRate        float64 `json:"log_sampling_rate"`
	TraceSamplingRate      float64 `json:"trace_sampling_rate"`
	SessionMinuteRateLimit *int64  `json:"session_minute_rate_limit,omitempty"`
	ErrorMinuteRateLimit   *int64  `json:"error_minute_rate_limit,omitempty"`
	LogMinuteRateLimit     *int64  `json:"log_minute_rate_limit,omitempty"`
	TraceMinuteRateLimit   *int64  `json:"trace_minute_rate_limit,omitempty"`
	SessionExclusionQuery  *string `json:"session_exclusion_query,omitempty"`
	ErrorExclusionQuery    *string `json:"error_exclusion_query,omitempty"`
	LogExclusionQuery      *string `json:"log_exclusion_query,omitempty"`
	TraceExclusionQuery    *string `json:"trace_exclusion_query,omitempty"`
}

type SamplingInput struct {
	SessionSamplingRate    *float64 `json:"session_sampling_rate,omitempty"`
	ErrorSamplingRate      *float64 `json:"error_sampling_rate,omitempty"`
	LogSamplingRate        *float64 `json:"log_sampling_rate,omitempty"`
	TraceSamplingRate      *float64 `json:"trace_sampling_rate,omitempty"`
	SessionMinuteRateLimit *int64   `json:"session_minute_rate_limit,omitempty"`
	ErrorMinuteRateLimit   *int64   `json:"error_minute_rate_limit,omitempty"`
	LogMinuteRateLimit     *int64   `json:"log_minute_rate_limit,omitempty"`
	TraceMinuteRateLimit   *int64   `json:"trace_minute_rate_limit,omitempty"`
	SessionExclusionQuery  *string  `json:"session_exclusion_query,omitempty"`
	ErrorExclusionQuery    *string  `json:"error_exclusion_query,omitempty"`
	LogExclusionQuery      *string  `json:"log_exclusion_query,omitempty"`
	TraceExclusionQuery    *string  `json:"trace_exclusion_query,omitempty"`
}

type SanitizedAdmin struct {
	ID       int     `json:"id"`
	Name     *string `json:"name,omitempty"`
	Email    string  `json:"email"`
	PhotoURL *string `json:"photo_url,omitempty"`
}

type SanitizedAdminInput struct {
	ID    int     `json:"id"`
	Name  *string `json:"name,omitempty"`
	Email string  `json:"email"`
}

type SanitizedSlackChannel struct {
	WebhookChannel   *string `json:"webhook_channel,omitempty"`
	WebhookChannelID *string `json:"webhook_channel_id,omitempty"`
}

type SanitizedSlackChannelInput struct {
	WebhookChannelName *string `json:"webhook_channel_name,omitempty"`
	WebhookChannelID   *string `json:"webhook_channel_id,omitempty"`
}

type ServiceConnection struct {
	Edges    []*ServiceEdge `json:"edges"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

func (ServiceConnection) IsConnection()               {}
func (this ServiceConnection) GetPageInfo() *PageInfo { return this.PageInfo }

type ServiceEdge struct {
	Cursor string       `json:"cursor"`
	Node   *ServiceNode `json:"node"`
}

func (ServiceEdge) IsEdge()                {}
func (this ServiceEdge) GetCursor() string { return this.Cursor }

type ServiceNode struct {
	ID             int           `json:"id"`
	ProjectID      int           `json:"projectID"`
	Name           string        `json:"name"`
	Status         ServiceStatus `json:"status"`
	GithubRepoPath *string       `json:"githubRepoPath,omitempty"`
	BuildPrefix    *string       `json:"buildPrefix,omitempty"`
	GithubPrefix   *string       `json:"githubPrefix,omitempty"`
	ErrorDetails   []string      `json:"errorDetails,omitempty"`
}

type SessionAlertInput struct {
	ProjectID              int                           `json:"project_id"`
	Name                   string                        `json:"name"`
	CountThreshold         int                           `json:"count_threshold"`
	ThresholdWindow        int                           `json:"threshold_window"`
	SlackChannels          []*SanitizedSlackChannelInput `json:"slack_channels"`
	DiscordChannels        []*DiscordChannelInput        `json:"discord_channels"`
	MicrosoftTeamsChannels []*MicrosoftTeamsChannelInput `json:"microsoft_teams_channels"`
	WebhookDestinations    []*WebhookDestinationInput    `json:"webhook_destinations"`
	Emails                 []string                      `json:"emails"`
	Environments           []string                      `json:"environments"`
	Disabled               bool                          `json:"disabled"`
	Default                *bool                         `json:"default,omitempty"`
	Type                   SessionAlertType              `json:"type"`
	UserProperties         []*UserPropertyInput          `json:"user_properties"`
	ExcludeRules           []string                      `json:"exclude_rules"`
	TrackProperties        []*TrackPropertyInput         `json:"track_properties"`
}

type SessionCommentTagInput struct {
	ID   *int   `json:"id,omitempty"`
	Name string `json:"name"`
}

type SessionExportWithSession struct {
	CreatedAt    time.Time `json:"created_at"`
	Type         string    `json:"type"`
	URL          string    `json:"url"`
	Error        string    `json:"error"`
	SecureID     string    `json:"secure_id"`
	Identifier   string    `json:"identifier"`
	ActiveLength *int      `json:"active_length,omitempty"`
}

type SessionQuery struct {
	ID        int `json:"id"`
	ProjectID int `json:"project_id"`
}

type SessionsReportRow struct {
	Key                   string    `json:"key"`
	Email                 string    `json:"email"`
	NumSessions           uint64    `json:"num_sessions"`
	FirstSession          time.Time `json:"first_session"`
	LastSession           time.Time `json:"last_session"`
	NumDaysVisited        uint64    `json:"num_days_visited"`
	NumMonthsVisited      uint64    `json:"num_months_visited"`
	AvgActiveLengthMins   float64   `json:"avg_active_length_mins"`
	MaxActiveLengthMins   float64   `json:"max_active_length_mins"`
	TotalActiveLengthMins float64   `json:"total_active_length_mins"`
	AvgLengthMins         float64   `json:"avg_length_mins"`
	MaxLengthMins         float64   `json:"max_length_mins"`
	TotalLengthMins       float64   `json:"total_length_mins"`
	Location              string    `json:"location"`
}

type SlackSyncResponse struct {
	Success               bool `json:"success"`
	NewChannelsAddedCount int  `json:"newChannelsAddedCount"`
}

type SocialLink struct {
	Type SocialType `json:"type"`
	Link *string    `json:"link,omitempty"`
}

type SortInput struct {
	Column    string        `json:"column"`
	Direction SortDirection `json:"direction"`
}

type SortOutput struct {
	Column    string        `json:"column"`
	Direction SortDirection `json:"direction"`
}

type SourceMappingError struct {
	ErrorCode                  *SourceMappingErrorCode `json:"errorCode,omitempty"`
	StackTraceFileURL          *string                 `json:"stackTraceFileURL,omitempty"`
	SourcemapFetchStrategy     *string                 `json:"sourcemapFetchStrategy,omitempty"`
	SourceMapURL               *string                 `json:"sourceMapURL,omitempty"`
	MinifiedFetchStrategy      *string                 `json:"minifiedFetchStrategy,omitempty"`
	ActualMinifiedFetchedPath  *string                 `json:"actualMinifiedFetchedPath,omitempty"`
	MinifiedLineNumber         *int                    `json:"minifiedLineNumber,omitempty"`
	MinifiedColumnNumber       *int                    `json:"minifiedColumnNumber,omitempty"`
	ActualSourcemapFetchedPath *string                 `json:"actualSourcemapFetchedPath,omitempty"`
	SourcemapFileSize          *int                    `json:"sourcemapFileSize,omitempty"`
	MinifiedFileSize           *int                    `json:"minifiedFileSize,omitempty"`
	MappedLineNumber           *int                    `json:"mappedLineNumber,omitempty"`
	MappedColumnNumber         *int                    `json:"mappedColumnNumber,omitempty"`
}

type Subscription struct {
}

type SubscriptionDetails struct {
	BaseAmount           int64                 `json:"baseAmount"`
	Discount             *SubscriptionDiscount `json:"discount,omitempty"`
	LastInvoice          *Invoice              `json:"lastInvoice,omitempty"`
	BillingIssue         bool                  `json:"billingIssue"`
	BillingIngestBlocked bool                  `json:"billingIngestBlocked"`
}

type SubscriptionDiscount struct {
	Name    string     `json:"name"`
	Percent float64    `json:"percent"`
	Amount  int64      `json:"amount"`
	Until   *time.Time `json:"until,omitempty"`
}

type TopUsersPayload struct {
	ID                   int     `json:"id"`
	Identifier           string  `json:"identifier"`
	TotalActiveTime      int     `json:"total_active_time"`
	ActiveTimePercentage float64 `json:"active_time_percentage"`
	UserProperties       string  `json:"user_properties"`
}

type Trace struct {
	Timestamp       time.Time              `json:"timestamp"`
	TraceID         string                 `json:"traceID"`
	SpanID          string                 `json:"spanID"`
	ParentSpanID    string                 `json:"parentSpanID"`
	ProjectID       int                    `json:"projectID"`
	SecureSessionID string                 `json:"secureSessionID"`
	TraceState      string                 `json:"traceState"`
	SpanName        string                 `json:"spanName"`
	SpanKind        string                 `json:"spanKind"`
	Duration        int                    `json:"duration"`
	StartTime       int                    `json:"startTime"`
	ServiceName     string                 `json:"serviceName"`
	ServiceVersion  string                 `json:"serviceVersion"`
	Environment     string                 `json:"environment"`
	HasErrors       bool                   `json:"hasErrors"`
	TraceAttributes map[string]interface{} `json:"traceAttributes"`
	StatusCode      string                 `json:"statusCode"`
	StatusMessage   string                 `json:"statusMessage"`
	Events          []*TraceEvent          `json:"events,omitempty"`
	Links           []*TraceLink           `json:"links,omitempty"`
}

type TraceConnection struct {
	Edges    []*TraceEdge `json:"edges"`
	PageInfo *PageInfo    `json:"pageInfo"`
	Sampled  bool         `json:"sampled"`
}

func (TraceConnection) IsConnection()               {}
func (this TraceConnection) GetPageInfo() *PageInfo { return this.PageInfo }

type TraceEdge struct {
	Cursor string `json:"cursor"`
	Node   *Trace `json:"node"`
}

func (TraceEdge) IsEdge()                {}
func (this TraceEdge) GetCursor() string { return this.Cursor }

type TraceError struct {
	CreatedAt          time.Time `json:"created_at"`
	ID                 int       `json:"id"`
	TraceID            *string   `json:"trace_id,omitempty"`
	SpanID             *string   `json:"span_id,omitempty"`
	LogCursor          *string   `json:"log_cursor,omitempty"`
	Event              string    `json:"event"`
	Type               string    `json:"type"`
	Source             string    `json:"source"`
	ErrorGroupSecureID string    `json:"error_group_secure_id"`
	Timestamp          time.Time `json:"timestamp"`
}

type TraceEvent struct {
	Timestamp  time.Time              `json:"timestamp"`
	Name       string                 `json:"name"`
	Attributes map[string]interface{} `json:"attributes"`
}

type TraceLink struct {
	TraceID    string                 `json:"traceID"`
	SpanID     string                 `json:"spanID"`
	TraceState string                 `json:"traceState"`
	Attributes map[string]interface{} `json:"attributes"`
}

type TracePayload struct {
	Trace  []*Trace      `json:"trace"`
	Errors []*TraceError `json:"errors"`
}

type TrackPropertyInput struct {
	ID    *int   `json:"id,omitempty"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

type UsageHistory struct {
	Usage *MetricsBuckets `json:"usage"`
}

type User struct {
	ID int `json:"id"`
}

type UserFingerprintCount struct {
	Count int64 `json:"count"`
}

type UserPropertyInput struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

type Variable struct {
	Key            string         `json:"key"`
	DefaultValues  []string       `json:"defaultValues"`
	SuggestionType SuggestionType `json:"suggestionType"`
	Field          *string        `json:"field,omitempty"`
}

type VariableInput struct {
	Key            string         `json:"key"`
	DefaultValues  []string       `json:"defaultValues"`
	SuggestionType SuggestionType `json:"suggestionType"`
	Field          *string        `json:"field,omitempty"`
}

type VercelEnv struct {
	ID              string `json:"id"`
	Key             string `json:"key"`
	ConfigurationID string `json:"configurationId"`
}

type VercelProject struct {
	ID   string       `json:"id"`
	Name string       `json:"name"`
	Env  []*VercelEnv `json:"env"`
}

type VercelProjectMapping struct {
	VercelProjectID string `json:"vercel_project_id"`
	ProjectID       int    `json:"project_id"`
}

type VercelProjectMappingInput struct {
	VercelProjectID string  `json:"vercel_project_id"`
	NewProjectName  *string `json:"new_project_name,omitempty"`
	ProjectID       *int    `json:"project_id,omitempty"`
}

type VisualizationInput struct {
	ID         *int             `json:"id,omitempty"`
	ProjectID  int              `json:"projectId"`
	Name       *string          `json:"name,omitempty"`
	GraphIds   []int            `json:"graphIds,omitempty"`
	TimePreset *string          `json:"timePreset,omitempty"`
	Variables  []*VariableInput `json:"variables,omitempty"`
}

type WebSocketEvent struct {
	Message   string  `json:"message"`
	Name      string  `json:"name"`
	SocketID  string  `json:"socketId"`
	Type      string  `json:"type"`
	TimeStamp float64 `json:"timeStamp"`
	Size      int     `json:"size"`
}

type WebhookDestinationInput struct {
	URL           string  `json:"url"`
	Authorization *string `json:"authorization,omitempty"`
}

type WorkspaceForInviteLink struct {
	ExpirationDate  *time.Time `json:"expiration_date,omitempty"`
	InviteeEmail    *string    `json:"invitee_email,omitempty"`
	Secret          string     `json:"secret"`
	WorkspaceID     int        `json:"workspace_id"`
	WorkspaceName   string     `json:"workspace_name"`
	ExistingAccount bool       `json:"existing_account"`
	ProjectID       int        `json:"project_id"`
}

type AlertDestinationType string

const (
	AlertDestinationTypeSlack          AlertDestinationType = "Slack"
	AlertDestinationTypeDiscord        AlertDestinationType = "Discord"
	AlertDestinationTypeMicrosoftTeams AlertDestinationType = "MicrosoftTeams"
	AlertDestinationTypeWebhook        AlertDestinationType = "Webhook"
	AlertDestinationTypeEmail          AlertDestinationType = "Email"
)

var AllAlertDestinationType = []AlertDestinationType{
	AlertDestinationTypeSlack,
	AlertDestinationTypeDiscord,
	AlertDestinationTypeMicrosoftTeams,
	AlertDestinationTypeWebhook,
	AlertDestinationTypeEmail,
}

func (e AlertDestinationType) IsValid() bool {
	switch e {
	case AlertDestinationTypeSlack, AlertDestinationTypeDiscord, AlertDestinationTypeMicrosoftTeams, AlertDestinationTypeWebhook, AlertDestinationTypeEmail:
		return true
	}
	return false
}

func (e AlertDestinationType) String() string {
	return string(e)
}

func (e *AlertDestinationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertDestinationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertDestinationType", str)
	}
	return nil
}

func (e AlertDestinationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertState string

const (
	AlertStateNormal           AlertState = "Normal"
	AlertStatePending          AlertState = "Pending"
	AlertStateAlerting         AlertState = "Alerting"
	AlertStateAlertingSilently AlertState = "AlertingSilently"
	AlertStateNoData           AlertState = "NoData"
	AlertStateError            AlertState = "Error"
)

var AllAlertState = []AlertState{
	AlertStateNormal,
	AlertStatePending,
	AlertStateAlerting,
	AlertStateAlertingSilently,
	AlertStateNoData,
	AlertStateError,
}

func (e AlertState) IsValid() bool {
	switch e {
	case AlertStateNormal, AlertStatePending, AlertStateAlerting, AlertStateAlertingSilently, AlertStateNoData, AlertStateError:
		return true
	}
	return false
}

func (e AlertState) String() string {
	return string(e)
}

func (e *AlertState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertState", str)
	}
	return nil
}

func (e AlertState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DashboardChartType string

const (
	DashboardChartTypeTimeline    DashboardChartType = "Timeline"
	DashboardChartTypeTimelineBar DashboardChartType = "TimelineBar"
	DashboardChartTypeHistogram   DashboardChartType = "Histogram"
)

var AllDashboardChartType = []DashboardChartType{
	DashboardChartTypeTimeline,
	DashboardChartTypeTimelineBar,
	DashboardChartTypeHistogram,
}

func (e DashboardChartType) IsValid() bool {
	switch e {
	case DashboardChartTypeTimeline, DashboardChartTypeTimelineBar, DashboardChartTypeHistogram:
		return true
	}
	return false
}

func (e DashboardChartType) String() string {
	return string(e)
}

func (e *DashboardChartType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DashboardChartType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DashboardChartType", str)
	}
	return nil
}

func (e DashboardChartType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EmailOptOutCategory string

const (
	EmailOptOutCategoryAll            EmailOptOutCategory = "All"
	EmailOptOutCategoryDigests        EmailOptOutCategory = "Digests"
	EmailOptOutCategoryBilling        EmailOptOutCategory = "Billing"
	EmailOptOutCategorySessionDigests EmailOptOutCategory = "SessionDigests"
)

var AllEmailOptOutCategory = []EmailOptOutCategory{
	EmailOptOutCategoryAll,
	EmailOptOutCategoryDigests,
	EmailOptOutCategoryBilling,
	EmailOptOutCategorySessionDigests,
}

func (e EmailOptOutCategory) IsValid() bool {
	switch e {
	case EmailOptOutCategoryAll, EmailOptOutCategoryDigests, EmailOptOutCategoryBilling, EmailOptOutCategorySessionDigests:
		return true
	}
	return false
}

func (e EmailOptOutCategory) String() string {
	return string(e)
}

func (e *EmailOptOutCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmailOptOutCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmailOptOutCategory", str)
	}
	return nil
}

func (e EmailOptOutCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnhancementSource string

const (
	EnhancementSourceGithub    EnhancementSource = "github"
	EnhancementSourceSourcemap EnhancementSource = "sourcemap"
)

var AllEnhancementSource = []EnhancementSource{
	EnhancementSourceGithub,
	EnhancementSourceSourcemap,
}

func (e EnhancementSource) IsValid() bool {
	switch e {
	case EnhancementSourceGithub, EnhancementSourceSourcemap:
		return true
	}
	return false
}

func (e EnhancementSource) String() string {
	return string(e)
}

func (e *EnhancementSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnhancementSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnhancementSource", str)
	}
	return nil
}

func (e EnhancementSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ErrorState string

const (
	ErrorStateOpen     ErrorState = "OPEN"
	ErrorStateResolved ErrorState = "RESOLVED"
	ErrorStateIgnored  ErrorState = "IGNORED"
)

var AllErrorState = []ErrorState{
	ErrorStateOpen,
	ErrorStateResolved,
	ErrorStateIgnored,
}

func (e ErrorState) IsValid() bool {
	switch e {
	case ErrorStateOpen, ErrorStateResolved, ErrorStateIgnored:
		return true
	}
	return false
}

func (e ErrorState) String() string {
	return string(e)
}

func (e *ErrorState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorState", str)
	}
	return nil
}

func (e ErrorState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IngestReason string

const (
	IngestReasonSample IngestReason = "Sample"
	IngestReasonRate   IngestReason = "Rate"
	IngestReasonFilter IngestReason = "Filter"
)

var AllIngestReason = []IngestReason{
	IngestReasonSample,
	IngestReasonRate,
	IngestReasonFilter,
}

func (e IngestReason) IsValid() bool {
	switch e {
	case IngestReasonSample, IngestReasonRate, IngestReasonFilter:
		return true
	}
	return false
}

func (e IngestReason) String() string {
	return string(e)
}

func (e *IngestReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IngestReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IngestReason", str)
	}
	return nil
}

func (e IngestReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IntegrationType string

const (
	IntegrationTypeSlack          IntegrationType = "Slack"
	IntegrationTypeLinear         IntegrationType = "Linear"
	IntegrationTypeZapier         IntegrationType = "Zapier"
	IntegrationTypeFront          IntegrationType = "Front"
	IntegrationTypeVercel         IntegrationType = "Vercel"
	IntegrationTypeDiscord        IntegrationType = "Discord"
	IntegrationTypeClickUp        IntegrationType = "ClickUp"
	IntegrationTypeHeight         IntegrationType = "Height"
	IntegrationTypeGitHub         IntegrationType = "GitHub"
	IntegrationTypeJira           IntegrationType = "Jira"
	IntegrationTypeMicrosoftTeams IntegrationType = "MicrosoftTeams"
	IntegrationTypeGitLab         IntegrationType = "GitLab"
	IntegrationTypeHeroku         IntegrationType = "Heroku"
	IntegrationTypeCloudflare     IntegrationType = "Cloudflare"
)

var AllIntegrationType = []IntegrationType{
	IntegrationTypeSlack,
	IntegrationTypeLinear,
	IntegrationTypeZapier,
	IntegrationTypeFront,
	IntegrationTypeVercel,
	IntegrationTypeDiscord,
	IntegrationTypeClickUp,
	IntegrationTypeHeight,
	IntegrationTypeGitHub,
	IntegrationTypeJira,
	IntegrationTypeMicrosoftTeams,
	IntegrationTypeGitLab,
	IntegrationTypeHeroku,
	IntegrationTypeCloudflare,
}

func (e IntegrationType) IsValid() bool {
	switch e {
	case IntegrationTypeSlack, IntegrationTypeLinear, IntegrationTypeZapier, IntegrationTypeFront, IntegrationTypeVercel, IntegrationTypeDiscord, IntegrationTypeClickUp, IntegrationTypeHeight, IntegrationTypeGitHub, IntegrationTypeJira, IntegrationTypeMicrosoftTeams, IntegrationTypeGitLab, IntegrationTypeHeroku, IntegrationTypeCloudflare:
		return true
	}
	return false
}

func (e IntegrationType) String() string {
	return string(e)
}

func (e *IntegrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationType", str)
	}
	return nil
}

func (e IntegrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type KeyType string

const (
	KeyTypeBoolean   KeyType = "Boolean"
	KeyTypeCreatable KeyType = "Creatable"
	KeyTypeNumeric   KeyType = "Numeric"
	KeyTypeString    KeyType = "String"
)

var AllKeyType = []KeyType{
	KeyTypeBoolean,
	KeyTypeCreatable,
	KeyTypeNumeric,
	KeyTypeString,
}

func (e KeyType) IsValid() bool {
	switch e {
	case KeyTypeBoolean, KeyTypeCreatable, KeyTypeNumeric, KeyTypeString:
		return true
	}
	return false
}

func (e KeyType) String() string {
	return string(e)
}

func (e *KeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KeyType", str)
	}
	return nil
}

func (e KeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogLevel string

const (
	LogLevelTrace LogLevel = "trace"
	LogLevelDebug LogLevel = "debug"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
	LogLevelError LogLevel = "error"
	LogLevelFatal LogLevel = "fatal"
	LogLevelPanic LogLevel = "panic"
)

var AllLogLevel = []LogLevel{
	LogLevelTrace,
	LogLevelDebug,
	LogLevelInfo,
	LogLevelWarn,
	LogLevelError,
	LogLevelFatal,
	LogLevelPanic,
}

func (e LogLevel) IsValid() bool {
	switch e {
	case LogLevelTrace, LogLevelDebug, LogLevelInfo, LogLevelWarn, LogLevelError, LogLevelFatal, LogLevelPanic:
		return true
	}
	return false
}

func (e LogLevel) String() string {
	return string(e)
}

func (e *LogLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogLevel", str)
	}
	return nil
}

func (e LogLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogSource string

const (
	LogSourceFrontend LogSource = "frontend"
	LogSourceBackend  LogSource = "backend"
)

var AllLogSource = []LogSource{
	LogSourceFrontend,
	LogSourceBackend,
}

func (e LogSource) IsValid() bool {
	switch e {
	case LogSourceFrontend, LogSourceBackend:
		return true
	}
	return false
}

func (e LogSource) String() string {
	return string(e)
}

func (e *LogSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogSource", str)
	}
	return nil
}

func (e LogSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricAggregator string

const (
	MetricAggregatorCount            MetricAggregator = "Count"
	MetricAggregatorCountDistinct    MetricAggregator = "CountDistinct"
	MetricAggregatorCountDistinctKey MetricAggregator = "CountDistinctKey"
	MetricAggregatorMin              MetricAggregator = "Min"
	MetricAggregatorAvg              MetricAggregator = "Avg"
	MetricAggregatorP50              MetricAggregator = "P50"
	MetricAggregatorP90              MetricAggregator = "P90"
	MetricAggregatorP95              MetricAggregator = "P95"
	MetricAggregatorP99              MetricAggregator = "P99"
	MetricAggregatorMax              MetricAggregator = "Max"
	MetricAggregatorSum              MetricAggregator = "Sum"
	MetricAggregatorNone             MetricAggregator = "None"
)

var AllMetricAggregator = []MetricAggregator{
	MetricAggregatorCount,
	MetricAggregatorCountDistinct,
	MetricAggregatorCountDistinctKey,
	MetricAggregatorMin,
	MetricAggregatorAvg,
	MetricAggregatorP50,
	MetricAggregatorP90,
	MetricAggregatorP95,
	MetricAggregatorP99,
	MetricAggregatorMax,
	MetricAggregatorSum,
	MetricAggregatorNone,
}

func (e MetricAggregator) IsValid() bool {
	switch e {
	case MetricAggregatorCount, MetricAggregatorCountDistinct, MetricAggregatorCountDistinctKey, MetricAggregatorMin, MetricAggregatorAvg, MetricAggregatorP50, MetricAggregatorP90, MetricAggregatorP95, MetricAggregatorP99, MetricAggregatorMax, MetricAggregatorSum, MetricAggregatorNone:
		return true
	}
	return false
}

func (e MetricAggregator) String() string {
	return string(e)
}

func (e *MetricAggregator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricAggregator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricAggregator", str)
	}
	return nil
}

func (e MetricAggregator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricBucketBy string

const (
	MetricBucketByNone      MetricBucketBy = "None"
	MetricBucketByTimestamp MetricBucketBy = "Timestamp"
	MetricBucketByHistogram MetricBucketBy = "Histogram"
)

var AllMetricBucketBy = []MetricBucketBy{
	MetricBucketByNone,
	MetricBucketByTimestamp,
	MetricBucketByHistogram,
}

func (e MetricBucketBy) IsValid() bool {
	switch e {
	case MetricBucketByNone, MetricBucketByTimestamp, MetricBucketByHistogram:
		return true
	}
	return false
}

func (e MetricBucketBy) String() string {
	return string(e)
}

func (e *MetricBucketBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricBucketBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricBucketBy", str)
	}
	return nil
}

func (e MetricBucketBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricColumn string

const (
	MetricColumnDuration MetricColumn = "Duration"
)

var AllMetricColumn = []MetricColumn{
	MetricColumnDuration,
}

func (e MetricColumn) IsValid() bool {
	switch e {
	case MetricColumnDuration:
		return true
	}
	return false
}

func (e MetricColumn) String() string {
	return string(e)
}

func (e *MetricColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricColumn", str)
	}
	return nil
}

func (e MetricColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricTagFilterOp string

const (
	MetricTagFilterOpEquals   MetricTagFilterOp = "equals"
	MetricTagFilterOpContains MetricTagFilterOp = "contains"
)

var AllMetricTagFilterOp = []MetricTagFilterOp{
	MetricTagFilterOpEquals,
	MetricTagFilterOpContains,
}

func (e MetricTagFilterOp) IsValid() bool {
	switch e {
	case MetricTagFilterOpEquals, MetricTagFilterOpContains:
		return true
	}
	return false
}

func (e MetricTagFilterOp) String() string {
	return string(e)
}

func (e *MetricTagFilterOp) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricTagFilterOp(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricTagFilterOp", str)
	}
	return nil
}

func (e MetricTagFilterOp) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricViewComponentType string

const (
	MetricViewComponentTypeKeyPerformanceGauge MetricViewComponentType = "KeyPerformanceGauge"
	MetricViewComponentTypeSessionCountChart   MetricViewComponentType = "SessionCountChart"
	MetricViewComponentTypeErrorCountChart     MetricViewComponentType = "ErrorCountChart"
	MetricViewComponentTypeReferrersTable      MetricViewComponentType = "ReferrersTable"
	MetricViewComponentTypeActiveUsersTable    MetricViewComponentType = "ActiveUsersTable"
	MetricViewComponentTypeRageClicksTable     MetricViewComponentType = "RageClicksTable"
	MetricViewComponentTypeTopRoutesTable      MetricViewComponentType = "TopRoutesTable"
)

var AllMetricViewComponentType = []MetricViewComponentType{
	MetricViewComponentTypeKeyPerformanceGauge,
	MetricViewComponentTypeSessionCountChart,
	MetricViewComponentTypeErrorCountChart,
	MetricViewComponentTypeReferrersTable,
	MetricViewComponentTypeActiveUsersTable,
	MetricViewComponentTypeRageClicksTable,
	MetricViewComponentTypeTopRoutesTable,
}

func (e MetricViewComponentType) IsValid() bool {
	switch e {
	case MetricViewComponentTypeKeyPerformanceGauge, MetricViewComponentTypeSessionCountChart, MetricViewComponentTypeErrorCountChart, MetricViewComponentTypeReferrersTable, MetricViewComponentTypeActiveUsersTable, MetricViewComponentTypeRageClicksTable, MetricViewComponentTypeTopRoutesTable:
		return true
	}
	return false
}

func (e MetricViewComponentType) String() string {
	return string(e)
}

func (e *MetricViewComponentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricViewComponentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricViewComponentType", str)
	}
	return nil
}

func (e MetricViewComponentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkRequestAttribute string

const (
	NetworkRequestAttributeMethod           NetworkRequestAttribute = "method"
	NetworkRequestAttributeInitiatorType    NetworkRequestAttribute = "initiator_type"
	NetworkRequestAttributeURL              NetworkRequestAttribute = "url"
	NetworkRequestAttributeBodySize         NetworkRequestAttribute = "body_size"
	NetworkRequestAttributeResponseSize     NetworkRequestAttribute = "response_size"
	NetworkRequestAttributeStatus           NetworkRequestAttribute = "status"
	NetworkRequestAttributeLatency          NetworkRequestAttribute = "latency"
	NetworkRequestAttributeConnectLatency   NetworkRequestAttribute = "connect_latency"
	NetworkRequestAttributeDNSLatency       NetworkRequestAttribute = "dns_latency"
	NetworkRequestAttributeRedirectLatency  NetworkRequestAttribute = "redirect_latency"
	NetworkRequestAttributeRequestID        NetworkRequestAttribute = "request_id"
	NetworkRequestAttributeGraphqlOperation NetworkRequestAttribute = "graphql_operation"
)

var AllNetworkRequestAttribute = []NetworkRequestAttribute{
	NetworkRequestAttributeMethod,
	NetworkRequestAttributeInitiatorType,
	NetworkRequestAttributeURL,
	NetworkRequestAttributeBodySize,
	NetworkRequestAttributeResponseSize,
	NetworkRequestAttributeStatus,
	NetworkRequestAttributeLatency,
	NetworkRequestAttributeConnectLatency,
	NetworkRequestAttributeDNSLatency,
	NetworkRequestAttributeRedirectLatency,
	NetworkRequestAttributeRequestID,
	NetworkRequestAttributeGraphqlOperation,
}

func (e NetworkRequestAttribute) IsValid() bool {
	switch e {
	case NetworkRequestAttributeMethod, NetworkRequestAttributeInitiatorType, NetworkRequestAttributeURL, NetworkRequestAttributeBodySize, NetworkRequestAttributeResponseSize, NetworkRequestAttributeStatus, NetworkRequestAttributeLatency, NetworkRequestAttributeConnectLatency, NetworkRequestAttributeDNSLatency, NetworkRequestAttributeRedirectLatency, NetworkRequestAttributeRequestID, NetworkRequestAttributeGraphqlOperation:
		return true
	}
	return false
}

func (e NetworkRequestAttribute) String() string {
	return string(e)
}

func (e *NetworkRequestAttribute) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkRequestAttribute(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkRequestAttribute", str)
	}
	return nil
}

func (e NetworkRequestAttribute) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OpenSearchCalendarInterval string

const (
	OpenSearchCalendarIntervalMinute  OpenSearchCalendarInterval = "minute"
	OpenSearchCalendarIntervalHour    OpenSearchCalendarInterval = "hour"
	OpenSearchCalendarIntervalDay     OpenSearchCalendarInterval = "day"
	OpenSearchCalendarIntervalWeek    OpenSearchCalendarInterval = "week"
	OpenSearchCalendarIntervalMonth   OpenSearchCalendarInterval = "month"
	OpenSearchCalendarIntervalQuarter OpenSearchCalendarInterval = "quarter"
	OpenSearchCalendarIntervalYear    OpenSearchCalendarInterval = "year"
)

var AllOpenSearchCalendarInterval = []OpenSearchCalendarInterval{
	OpenSearchCalendarIntervalMinute,
	OpenSearchCalendarIntervalHour,
	OpenSearchCalendarIntervalDay,
	OpenSearchCalendarIntervalWeek,
	OpenSearchCalendarIntervalMonth,
	OpenSearchCalendarIntervalQuarter,
	OpenSearchCalendarIntervalYear,
}

func (e OpenSearchCalendarInterval) IsValid() bool {
	switch e {
	case OpenSearchCalendarIntervalMinute, OpenSearchCalendarIntervalHour, OpenSearchCalendarIntervalDay, OpenSearchCalendarIntervalWeek, OpenSearchCalendarIntervalMonth, OpenSearchCalendarIntervalQuarter, OpenSearchCalendarIntervalYear:
		return true
	}
	return false
}

func (e OpenSearchCalendarInterval) String() string {
	return string(e)
}

func (e *OpenSearchCalendarInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OpenSearchCalendarInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OpenSearchCalendarInterval", str)
	}
	return nil
}

func (e OpenSearchCalendarInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlanType string

const (
	PlanTypeFree       PlanType = "Free"
	PlanTypeLite       PlanType = "Lite"
	PlanTypeBasic      PlanType = "Basic"
	PlanTypeStartup    PlanType = "Startup"
	PlanTypeEnterprise PlanType = "Enterprise"
	PlanTypeUsageBased PlanType = "UsageBased"
	PlanTypeGraduated  PlanType = "Graduated"
	PlanTypeBusiness   PlanType = "Business"
)

var AllPlanType = []PlanType{
	PlanTypeFree,
	PlanTypeLite,
	PlanTypeBasic,
	PlanTypeStartup,
	PlanTypeEnterprise,
	PlanTypeUsageBased,
	PlanTypeGraduated,
	PlanTypeBusiness,
}

func (e PlanType) IsValid() bool {
	switch e {
	case PlanTypeFree, PlanTypeLite, PlanTypeBasic, PlanTypeStartup, PlanTypeEnterprise, PlanTypeUsageBased, PlanTypeGraduated, PlanTypeBusiness:
		return true
	}
	return false
}

func (e PlanType) String() string {
	return string(e)
}

func (e *PlanType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanType", str)
	}
	return nil
}

func (e PlanType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductType string

const (
	ProductTypeSessions ProductType = "Sessions"
	ProductTypeErrors   ProductType = "Errors"
	ProductTypeLogs     ProductType = "Logs"
	ProductTypeTraces   ProductType = "Traces"
	ProductTypeMetrics  ProductType = "Metrics"
	ProductTypeEvents   ProductType = "Events"
)

var AllProductType = []ProductType{
	ProductTypeSessions,
	ProductTypeErrors,
	ProductTypeLogs,
	ProductTypeTraces,
	ProductTypeMetrics,
	ProductTypeEvents,
}

func (e ProductType) IsValid() bool {
	switch e {
	case ProductTypeSessions, ProductTypeErrors, ProductTypeLogs, ProductTypeTraces, ProductTypeMetrics, ProductTypeEvents:
		return true
	}
	return false
}

func (e ProductType) String() string {
	return string(e)
}

func (e *ProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductType", str)
	}
	return nil
}

func (e ProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedErrorGroupKey string

const (
	ReservedErrorGroupKeyEvent    ReservedErrorGroupKey = "event"
	ReservedErrorGroupKeySecureID ReservedErrorGroupKey = "secure_id"
	ReservedErrorGroupKeyStatus   ReservedErrorGroupKey = "status"
	ReservedErrorGroupKeyTag      ReservedErrorGroupKey = "tag"
	ReservedErrorGroupKeyType     ReservedErrorGroupKey = "type"
)

var AllReservedErrorGroupKey = []ReservedErrorGroupKey{
	ReservedErrorGroupKeyEvent,
	ReservedErrorGroupKeySecureID,
	ReservedErrorGroupKeyStatus,
	ReservedErrorGroupKeyTag,
	ReservedErrorGroupKeyType,
}

func (e ReservedErrorGroupKey) IsValid() bool {
	switch e {
	case ReservedErrorGroupKeyEvent, ReservedErrorGroupKeySecureID, ReservedErrorGroupKeyStatus, ReservedErrorGroupKeyTag, ReservedErrorGroupKeyType:
		return true
	}
	return false
}

func (e ReservedErrorGroupKey) String() string {
	return string(e)
}

func (e *ReservedErrorGroupKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedErrorGroupKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedErrorGroupKey", str)
	}
	return nil
}

func (e ReservedErrorGroupKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedErrorObjectKey string

const (
	ReservedErrorObjectKeyBrowser         ReservedErrorObjectKey = "browser"
	ReservedErrorObjectKeyClientID        ReservedErrorObjectKey = "client_id"
	ReservedErrorObjectKeyEnvironment     ReservedErrorObjectKey = "environment"
	ReservedErrorObjectKeyHasSession      ReservedErrorObjectKey = "has_session"
	ReservedErrorObjectKeyOsName          ReservedErrorObjectKey = "os_name"
	ReservedErrorObjectKeySecureSessionID ReservedErrorObjectKey = "secure_session_id"
	ReservedErrorObjectKeyServiceName     ReservedErrorObjectKey = "service_name"
	ReservedErrorObjectKeyServiceVersion  ReservedErrorObjectKey = "service_version"
	ReservedErrorObjectKeyTimestamp       ReservedErrorObjectKey = "timestamp"
	ReservedErrorObjectKeyTraceID         ReservedErrorObjectKey = "trace_id"
	ReservedErrorObjectKeyVisitedURL      ReservedErrorObjectKey = "visited_url"
)

var AllReservedErrorObjectKey = []ReservedErrorObjectKey{
	ReservedErrorObjectKeyBrowser,
	ReservedErrorObjectKeyClientID,
	ReservedErrorObjectKeyEnvironment,
	ReservedErrorObjectKeyHasSession,
	ReservedErrorObjectKeyOsName,
	ReservedErrorObjectKeySecureSessionID,
	ReservedErrorObjectKeyServiceName,
	ReservedErrorObjectKeyServiceVersion,
	ReservedErrorObjectKeyTimestamp,
	ReservedErrorObjectKeyTraceID,
	ReservedErrorObjectKeyVisitedURL,
}

func (e ReservedErrorObjectKey) IsValid() bool {
	switch e {
	case ReservedErrorObjectKeyBrowser, ReservedErrorObjectKeyClientID, ReservedErrorObjectKeyEnvironment, ReservedErrorObjectKeyHasSession, ReservedErrorObjectKeyOsName, ReservedErrorObjectKeySecureSessionID, ReservedErrorObjectKeyServiceName, ReservedErrorObjectKeyServiceVersion, ReservedErrorObjectKeyTimestamp, ReservedErrorObjectKeyTraceID, ReservedErrorObjectKeyVisitedURL:
		return true
	}
	return false
}

func (e ReservedErrorObjectKey) String() string {
	return string(e)
}

func (e *ReservedErrorObjectKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedErrorObjectKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedErrorObjectKey", str)
	}
	return nil
}

func (e ReservedErrorObjectKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedErrorsJoinedKey string

const (
	// ReservedErrorObjectKey
	ReservedErrorsJoinedKeyID              ReservedErrorsJoinedKey = "id"
	ReservedErrorsJoinedKeyBrowser         ReservedErrorsJoinedKey = "browser"
	ReservedErrorsJoinedKeyClientID        ReservedErrorsJoinedKey = "client_id"
	ReservedErrorsJoinedKeyEnvironment     ReservedErrorsJoinedKey = "environment"
	ReservedErrorsJoinedKeyHasSession      ReservedErrorsJoinedKey = "has_session"
	ReservedErrorsJoinedKeyOsName          ReservedErrorsJoinedKey = "os_name"
	ReservedErrorsJoinedKeySecureSessionID ReservedErrorsJoinedKey = "secure_session_id"
	ReservedErrorsJoinedKeyServiceName     ReservedErrorsJoinedKey = "service_name"
	ReservedErrorsJoinedKeyServiceVersion  ReservedErrorsJoinedKey = "service_version"
	ReservedErrorsJoinedKeyTimestamp       ReservedErrorsJoinedKey = "timestamp"
	ReservedErrorsJoinedKeyTraceID         ReservedErrorsJoinedKey = "trace_id"
	ReservedErrorsJoinedKeyVisitedURL      ReservedErrorsJoinedKey = "visited_url"
	// ReservedErrorGroupKey
	ReservedErrorsJoinedKeyEvent    ReservedErrorsJoinedKey = "event"
	ReservedErrorsJoinedKeySecureID ReservedErrorsJoinedKey = "secure_id"
	ReservedErrorsJoinedKeyStatus   ReservedErrorsJoinedKey = "status"
	ReservedErrorsJoinedKeyTag      ReservedErrorsJoinedKey = "tag"
	ReservedErrorsJoinedKeyType     ReservedErrorsJoinedKey = "type"
)

var AllReservedErrorsJoinedKey = []ReservedErrorsJoinedKey{
	ReservedErrorsJoinedKeyID,
	ReservedErrorsJoinedKeyBrowser,
	ReservedErrorsJoinedKeyClientID,
	ReservedErrorsJoinedKeyEnvironment,
	ReservedErrorsJoinedKeyHasSession,
	ReservedErrorsJoinedKeyOsName,
	ReservedErrorsJoinedKeySecureSessionID,
	ReservedErrorsJoinedKeyServiceName,
	ReservedErrorsJoinedKeyServiceVersion,
	ReservedErrorsJoinedKeyTimestamp,
	ReservedErrorsJoinedKeyTraceID,
	ReservedErrorsJoinedKeyVisitedURL,
	ReservedErrorsJoinedKeyEvent,
	ReservedErrorsJoinedKeySecureID,
	ReservedErrorsJoinedKeyStatus,
	ReservedErrorsJoinedKeyTag,
	ReservedErrorsJoinedKeyType,
}

func (e ReservedErrorsJoinedKey) IsValid() bool {
	switch e {
	case ReservedErrorsJoinedKeyID, ReservedErrorsJoinedKeyBrowser, ReservedErrorsJoinedKeyClientID, ReservedErrorsJoinedKeyEnvironment, ReservedErrorsJoinedKeyHasSession, ReservedErrorsJoinedKeyOsName, ReservedErrorsJoinedKeySecureSessionID, ReservedErrorsJoinedKeyServiceName, ReservedErrorsJoinedKeyServiceVersion, ReservedErrorsJoinedKeyTimestamp, ReservedErrorsJoinedKeyTraceID, ReservedErrorsJoinedKeyVisitedURL, ReservedErrorsJoinedKeyEvent, ReservedErrorsJoinedKeySecureID, ReservedErrorsJoinedKeyStatus, ReservedErrorsJoinedKeyTag, ReservedErrorsJoinedKeyType:
		return true
	}
	return false
}

func (e ReservedErrorsJoinedKey) String() string {
	return string(e)
}

func (e *ReservedErrorsJoinedKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedErrorsJoinedKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedErrorsJoinedKey", str)
	}
	return nil
}

func (e ReservedErrorsJoinedKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedEventKey string

const (
	ReservedEventKeyBrowserName         ReservedEventKey = "browser_name"
	ReservedEventKeyBrowserVersion      ReservedEventKey = "browser_version"
	ReservedEventKeyCity                ReservedEventKey = "city"
	ReservedEventKeyCountry             ReservedEventKey = "country"
	ReservedEventKeyEnvironment         ReservedEventKey = "environment"
	ReservedEventKeyEvent               ReservedEventKey = "event"
	ReservedEventKeyFirstSession        ReservedEventKey = "first_session"
	ReservedEventKeyIdentified          ReservedEventKey = "identified"
	ReservedEventKeyIdentifier          ReservedEventKey = "identifier"
	ReservedEventKeyIP                  ReservedEventKey = "ip"
	ReservedEventKeyOsName              ReservedEventKey = "os_name"
	ReservedEventKeyOsVersion           ReservedEventKey = "os_version"
	ReservedEventKeySecureSessionID     ReservedEventKey = "secure_session_id"
	ReservedEventKeyServiceVersion      ReservedEventKey = "service_version"
	ReservedEventKeySessionActiveLength ReservedEventKey = "session_active_length"
	ReservedEventKeySessionLength       ReservedEventKey = "session_length"
	ReservedEventKeySessionPagesVisited ReservedEventKey = "session_pages_visited"
	ReservedEventKeyState               ReservedEventKey = "state"
)

var AllReservedEventKey = []ReservedEventKey{
	ReservedEventKeyBrowserName,
	ReservedEventKeyBrowserVersion,
	ReservedEventKeyCity,
	ReservedEventKeyCountry,
	ReservedEventKeyEnvironment,
	ReservedEventKeyEvent,
	ReservedEventKeyFirstSession,
	ReservedEventKeyIdentified,
	ReservedEventKeyIdentifier,
	ReservedEventKeyIP,
	ReservedEventKeyOsName,
	ReservedEventKeyOsVersion,
	ReservedEventKeySecureSessionID,
	ReservedEventKeyServiceVersion,
	ReservedEventKeySessionActiveLength,
	ReservedEventKeySessionLength,
	ReservedEventKeySessionPagesVisited,
	ReservedEventKeyState,
}

func (e ReservedEventKey) IsValid() bool {
	switch e {
	case ReservedEventKeyBrowserName, ReservedEventKeyBrowserVersion, ReservedEventKeyCity, ReservedEventKeyCountry, ReservedEventKeyEnvironment, ReservedEventKeyEvent, ReservedEventKeyFirstSession, ReservedEventKeyIdentified, ReservedEventKeyIdentifier, ReservedEventKeyIP, ReservedEventKeyOsName, ReservedEventKeyOsVersion, ReservedEventKeySecureSessionID, ReservedEventKeyServiceVersion, ReservedEventKeySessionActiveLength, ReservedEventKeySessionLength, ReservedEventKeySessionPagesVisited, ReservedEventKeyState:
		return true
	}
	return false
}

func (e ReservedEventKey) String() string {
	return string(e)
}

func (e *ReservedEventKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedEventKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedEventKey", str)
	}
	return nil
}

func (e ReservedEventKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedLogKey string

const (
	// Keep this in alpha order
	ReservedLogKeyEnvironment     ReservedLogKey = "environment"
	ReservedLogKeyLevel           ReservedLogKey = "level"
	ReservedLogKeyMessage         ReservedLogKey = "message"
	ReservedLogKeySecureSessionID ReservedLogKey = "secure_session_id"
	ReservedLogKeySpanID          ReservedLogKey = "span_id"
	ReservedLogKeyTraceID         ReservedLogKey = "trace_id"
	ReservedLogKeySource          ReservedLogKey = "source"
	ReservedLogKeyServiceName     ReservedLogKey = "service_name"
	ReservedLogKeyServiceVersion  ReservedLogKey = "service_version"
	ReservedLogKeyTimestamp       ReservedLogKey = "timestamp"
)

var AllReservedLogKey = []ReservedLogKey{
	ReservedLogKeyEnvironment,
	ReservedLogKeyLevel,
	ReservedLogKeyMessage,
	ReservedLogKeySecureSessionID,
	ReservedLogKeySpanID,
	ReservedLogKeyTraceID,
	ReservedLogKeySource,
	ReservedLogKeyServiceName,
	ReservedLogKeyServiceVersion,
	ReservedLogKeyTimestamp,
}

func (e ReservedLogKey) IsValid() bool {
	switch e {
	case ReservedLogKeyEnvironment, ReservedLogKeyLevel, ReservedLogKeyMessage, ReservedLogKeySecureSessionID, ReservedLogKeySpanID, ReservedLogKeyTraceID, ReservedLogKeySource, ReservedLogKeyServiceName, ReservedLogKeyServiceVersion, ReservedLogKeyTimestamp:
		return true
	}
	return false
}

func (e ReservedLogKey) String() string {
	return string(e)
}

func (e *ReservedLogKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedLogKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedLogKey", str)
	}
	return nil
}

func (e ReservedLogKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedSessionKey string

const (
	ReservedSessionKeyActiveLength       ReservedSessionKey = "active_length"
	ReservedSessionKeyBrowserName        ReservedSessionKey = "browser_name"
	ReservedSessionKeyBrowserVersion     ReservedSessionKey = "browser_version"
	ReservedSessionKeyCity               ReservedSessionKey = "city"
	ReservedSessionKeyCompleted          ReservedSessionKey = "completed"
	ReservedSessionKeyCountry            ReservedSessionKey = "country"
	ReservedSessionKeyEnvironment        ReservedSessionKey = "environment"
	ReservedSessionKeyExcluded           ReservedSessionKey = "excluded"
	ReservedSessionKeyFirstTime          ReservedSessionKey = "first_time"
	ReservedSessionKeyHasComments        ReservedSessionKey = "has_comments"
	ReservedSessionKeyHasErrors          ReservedSessionKey = "has_errors"
	ReservedSessionKeyHasRageClicks      ReservedSessionKey = "has_rage_clicks"
	ReservedSessionKeyIdentified         ReservedSessionKey = "identified"
	ReservedSessionKeyIdentifier         ReservedSessionKey = "identifier"
	ReservedSessionKeyIP                 ReservedSessionKey = "ip"
	ReservedSessionKeyLength             ReservedSessionKey = "length"
	ReservedSessionKeyNormalness         ReservedSessionKey = "normalness"
	ReservedSessionKeyOsName             ReservedSessionKey = "os_name"
	ReservedSessionKeyOsVersion          ReservedSessionKey = "os_version"
	ReservedSessionKeyPagesVisited       ReservedSessionKey = "pages_visited"
	ReservedSessionKeySample             ReservedSessionKey = "sample"
	ReservedSessionKeySecureID           ReservedSessionKey = "secure_id"
	ReservedSessionKeyServiceVersion     ReservedSessionKey = "service_version"
	ReservedSessionKeyState              ReservedSessionKey = "state"
	ReservedSessionKeyViewedByAnyone     ReservedSessionKey = "viewed_by_anyone"
	ReservedSessionKeyViewedByMe         ReservedSessionKey = "viewed_by_me"
	ReservedSessionKeyWithinBillingQuota ReservedSessionKey = "within_billing_quota"
	ReservedSessionKeyLocState           ReservedSessionKey = "loc_state"
	ReservedSessionKeyProcessed          ReservedSessionKey = "processed"
	ReservedSessionKeyViewed             ReservedSessionKey = "viewed"
)

var AllReservedSessionKey = []ReservedSessionKey{
	ReservedSessionKeyActiveLength,
	ReservedSessionKeyBrowserName,
	ReservedSessionKeyBrowserVersion,
	ReservedSessionKeyCity,
	ReservedSessionKeyCompleted,
	ReservedSessionKeyCountry,
	ReservedSessionKeyEnvironment,
	ReservedSessionKeyExcluded,
	ReservedSessionKeyFirstTime,
	ReservedSessionKeyHasComments,
	ReservedSessionKeyHasErrors,
	ReservedSessionKeyHasRageClicks,
	ReservedSessionKeyIdentified,
	ReservedSessionKeyIdentifier,
	ReservedSessionKeyIP,
	ReservedSessionKeyLength,
	ReservedSessionKeyNormalness,
	ReservedSessionKeyOsName,
	ReservedSessionKeyOsVersion,
	ReservedSessionKeyPagesVisited,
	ReservedSessionKeySample,
	ReservedSessionKeySecureID,
	ReservedSessionKeyServiceVersion,
	ReservedSessionKeyState,
	ReservedSessionKeyViewedByAnyone,
	ReservedSessionKeyViewedByMe,
	ReservedSessionKeyWithinBillingQuota,
	ReservedSessionKeyLocState,
	ReservedSessionKeyProcessed,
	ReservedSessionKeyViewed,
}

func (e ReservedSessionKey) IsValid() bool {
	switch e {
	case ReservedSessionKeyActiveLength, ReservedSessionKeyBrowserName, ReservedSessionKeyBrowserVersion, ReservedSessionKeyCity, ReservedSessionKeyCompleted, ReservedSessionKeyCountry, ReservedSessionKeyEnvironment, ReservedSessionKeyExcluded, ReservedSessionKeyFirstTime, ReservedSessionKeyHasComments, ReservedSessionKeyHasErrors, ReservedSessionKeyHasRageClicks, ReservedSessionKeyIdentified, ReservedSessionKeyIdentifier, ReservedSessionKeyIP, ReservedSessionKeyLength, ReservedSessionKeyNormalness, ReservedSessionKeyOsName, ReservedSessionKeyOsVersion, ReservedSessionKeyPagesVisited, ReservedSessionKeySample, ReservedSessionKeySecureID, ReservedSessionKeyServiceVersion, ReservedSessionKeyState, ReservedSessionKeyViewedByAnyone, ReservedSessionKeyViewedByMe, ReservedSessionKeyWithinBillingQuota, ReservedSessionKeyLocState, ReservedSessionKeyProcessed, ReservedSessionKeyViewed:
		return true
	}
	return false
}

func (e ReservedSessionKey) String() string {
	return string(e)
}

func (e *ReservedSessionKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedSessionKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedSessionKey", str)
	}
	return nil
}

func (e ReservedSessionKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReservedTraceKey string

const (
	ReservedTraceKeyEnvironment     ReservedTraceKey = "environment"
	ReservedTraceKeyHasErrors       ReservedTraceKey = "has_errors"
	ReservedTraceKeyLevel           ReservedTraceKey = "level"
	ReservedTraceKeyMessage         ReservedTraceKey = "message"
	ReservedTraceKeyMetricName      ReservedTraceKey = "metric_name"
	ReservedTraceKeyMetricValue     ReservedTraceKey = "metric_value"
	ReservedTraceKeySecureSessionID ReservedTraceKey = "secure_session_id"
	ReservedTraceKeySpanID          ReservedTraceKey = "span_id"
	ReservedTraceKeyTraceID         ReservedTraceKey = "trace_id"
	ReservedTraceKeyParentSpanID    ReservedTraceKey = "parent_span_id"
	ReservedTraceKeyTraceState      ReservedTraceKey = "trace_state"
	ReservedTraceKeySpanName        ReservedTraceKey = "span_name"
	ReservedTraceKeySpanKind        ReservedTraceKey = "span_kind"
	ReservedTraceKeyDuration        ReservedTraceKey = "duration"
	ReservedTraceKeyServiceName     ReservedTraceKey = "service_name"
	ReservedTraceKeyServiceVersion  ReservedTraceKey = "service_version"
	ReservedTraceKeyTimestamp       ReservedTraceKey = "timestamp"
	ReservedTraceKeyHighlightType   ReservedTraceKey = "highlight_type"
)

var AllReservedTraceKey = []ReservedTraceKey{
	ReservedTraceKeyEnvironment,
	ReservedTraceKeyHasErrors,
	ReservedTraceKeyLevel,
	ReservedTraceKeyMessage,
	ReservedTraceKeyMetricName,
	ReservedTraceKeyMetricValue,
	ReservedTraceKeySecureSessionID,
	ReservedTraceKeySpanID,
	ReservedTraceKeyTraceID,
	ReservedTraceKeyParentSpanID,
	ReservedTraceKeyTraceState,
	ReservedTraceKeySpanName,
	ReservedTraceKeySpanKind,
	ReservedTraceKeyDuration,
	ReservedTraceKeyServiceName,
	ReservedTraceKeyServiceVersion,
	ReservedTraceKeyTimestamp,
	ReservedTraceKeyHighlightType,
}

func (e ReservedTraceKey) IsValid() bool {
	switch e {
	case ReservedTraceKeyEnvironment, ReservedTraceKeyHasErrors, ReservedTraceKeyLevel, ReservedTraceKeyMessage, ReservedTraceKeyMetricName, ReservedTraceKeyMetricValue, ReservedTraceKeySecureSessionID, ReservedTraceKeySpanID, ReservedTraceKeyTraceID, ReservedTraceKeyParentSpanID, ReservedTraceKeyTraceState, ReservedTraceKeySpanName, ReservedTraceKeySpanKind, ReservedTraceKeyDuration, ReservedTraceKeyServiceName, ReservedTraceKeyServiceVersion, ReservedTraceKeyTimestamp, ReservedTraceKeyHighlightType:
		return true
	}
	return false
}

func (e ReservedTraceKey) String() string {
	return string(e)
}

func (e *ReservedTraceKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReservedTraceKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReservedTraceKey", str)
	}
	return nil
}

func (e ReservedTraceKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RetentionPeriod string

const (
	RetentionPeriodSevenDays    RetentionPeriod = "SevenDays"
	RetentionPeriodThirtyDays   RetentionPeriod = "ThirtyDays"
	RetentionPeriodThreeMonths  RetentionPeriod = "ThreeMonths"
	RetentionPeriodSixMonths    RetentionPeriod = "SixMonths"
	RetentionPeriodTwelveMonths RetentionPeriod = "TwelveMonths"
	RetentionPeriodTwoYears     RetentionPeriod = "TwoYears"
	RetentionPeriodThreeYears   RetentionPeriod = "ThreeYears"
)

var AllRetentionPeriod = []RetentionPeriod{
	RetentionPeriodSevenDays,
	RetentionPeriodThirtyDays,
	RetentionPeriodThreeMonths,
	RetentionPeriodSixMonths,
	RetentionPeriodTwelveMonths,
	RetentionPeriodTwoYears,
	RetentionPeriodThreeYears,
}

func (e RetentionPeriod) IsValid() bool {
	switch e {
	case RetentionPeriodSevenDays, RetentionPeriodThirtyDays, RetentionPeriodThreeMonths, RetentionPeriodSixMonths, RetentionPeriodTwelveMonths, RetentionPeriodTwoYears, RetentionPeriodThreeYears:
		return true
	}
	return false
}

func (e RetentionPeriod) String() string {
	return string(e)
}

func (e *RetentionPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RetentionPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RetentionPeriod", str)
	}
	return nil
}

func (e RetentionPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SavedSegmentEntityType string

const (
	SavedSegmentEntityTypeLog     SavedSegmentEntityType = "Log"
	SavedSegmentEntityTypeTrace   SavedSegmentEntityType = "Trace"
	SavedSegmentEntityTypeError   SavedSegmentEntityType = "Error"
	SavedSegmentEntityTypeSession SavedSegmentEntityType = "Session"
)

var AllSavedSegmentEntityType = []SavedSegmentEntityType{
	SavedSegmentEntityTypeLog,
	SavedSegmentEntityTypeTrace,
	SavedSegmentEntityTypeError,
	SavedSegmentEntityTypeSession,
}

func (e SavedSegmentEntityType) IsValid() bool {
	switch e {
	case SavedSegmentEntityTypeLog, SavedSegmentEntityTypeTrace, SavedSegmentEntityTypeError, SavedSegmentEntityTypeSession:
		return true
	}
	return false
}

func (e SavedSegmentEntityType) String() string {
	return string(e)
}

func (e *SavedSegmentEntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SavedSegmentEntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SavedSegmentEntityType", str)
	}
	return nil
}

func (e SavedSegmentEntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceStatus string

const (
	ServiceStatusHealthy ServiceStatus = "healthy"
	ServiceStatusError   ServiceStatus = "error"
	ServiceStatusCreated ServiceStatus = "created"
)

var AllServiceStatus = []ServiceStatus{
	ServiceStatusHealthy,
	ServiceStatusError,
	ServiceStatusCreated,
}

func (e ServiceStatus) IsValid() bool {
	switch e {
	case ServiceStatusHealthy, ServiceStatusError, ServiceStatusCreated:
		return true
	}
	return false
}

func (e ServiceStatus) String() string {
	return string(e)
}

func (e *ServiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceStatus", str)
	}
	return nil
}

func (e ServiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SessionAlertType string

const (
	SessionAlertTypeErrorAlert           SessionAlertType = "ERROR_ALERT"
	SessionAlertTypeNewUserAlert         SessionAlertType = "NEW_USER_ALERT"
	SessionAlertTypeTrackPropertiesAlert SessionAlertType = "TRACK_PROPERTIES_ALERT"
	SessionAlertTypeUserPropertiesAlert  SessionAlertType = "USER_PROPERTIES_ALERT"
	SessionAlertTypeRageClickAlert       SessionAlertType = "RAGE_CLICK_ALERT"
	SessionAlertTypeNewSessionAlert      SessionAlertType = "NEW_SESSION_ALERT"
)

var AllSessionAlertType = []SessionAlertType{
	SessionAlertTypeErrorAlert,
	SessionAlertTypeNewUserAlert,
	SessionAlertTypeTrackPropertiesAlert,
	SessionAlertTypeUserPropertiesAlert,
	SessionAlertTypeRageClickAlert,
	SessionAlertTypeNewSessionAlert,
}

func (e SessionAlertType) IsValid() bool {
	switch e {
	case SessionAlertTypeErrorAlert, SessionAlertTypeNewUserAlert, SessionAlertTypeTrackPropertiesAlert, SessionAlertTypeUserPropertiesAlert, SessionAlertTypeRageClickAlert, SessionAlertTypeNewSessionAlert:
		return true
	}
	return false
}

func (e SessionAlertType) String() string {
	return string(e)
}

func (e *SessionAlertType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SessionAlertType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SessionAlertType", str)
	}
	return nil
}

func (e SessionAlertType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SessionCommentType string

const (
	SessionCommentTypeAdmin    SessionCommentType = "Admin"
	SessionCommentTypeFeedback SessionCommentType = "FEEDBACK"
)

var AllSessionCommentType = []SessionCommentType{
	SessionCommentTypeAdmin,
	SessionCommentTypeFeedback,
}

func (e SessionCommentType) IsValid() bool {
	switch e {
	case SessionCommentTypeAdmin, SessionCommentTypeFeedback:
		return true
	}
	return false
}

func (e SessionCommentType) String() string {
	return string(e)
}

func (e *SessionCommentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SessionCommentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SessionCommentType", str)
	}
	return nil
}

func (e SessionCommentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SessionExcludedReason string

const (
	SessionExcludedReasonInitializing              SessionExcludedReason = "Initializing"
	SessionExcludedReasonNoActivity                SessionExcludedReason = "NoActivity"
	SessionExcludedReasonNoUserInteractionEvents   SessionExcludedReason = "NoUserInteractionEvents"
	SessionExcludedReasonNoTimelineIndicatorEvents SessionExcludedReason = "NoTimelineIndicatorEvents"
	SessionExcludedReasonNoError                   SessionExcludedReason = "NoError"
	SessionExcludedReasonNoUserEvents              SessionExcludedReason = "NoUserEvents"
	SessionExcludedReasonIgnoredUser               SessionExcludedReason = "IgnoredUser"
	SessionExcludedReasonBillingQuotaExceeded      SessionExcludedReason = "BillingQuotaExceeded"
	SessionExcludedReasonRetentionPeriodExceeded   SessionExcludedReason = "RetentionPeriodExceeded"
	SessionExcludedReasonSampled                   SessionExcludedReason = "Sampled"
	SessionExcludedReasonRateLimitMinute           SessionExcludedReason = "RateLimitMinute"
	SessionExcludedReasonExclusionFilter           SessionExcludedReason = "ExclusionFilter"
)

var AllSessionExcludedReason = []SessionExcludedReason{
	SessionExcludedReasonInitializing,
	SessionExcludedReasonNoActivity,
	SessionExcludedReasonNoUserInteractionEvents,
	SessionExcludedReasonNoTimelineIndicatorEvents,
	SessionExcludedReasonNoError,
	SessionExcludedReasonNoUserEvents,
	SessionExcludedReasonIgnoredUser,
	SessionExcludedReasonBillingQuotaExceeded,
	SessionExcludedReasonRetentionPeriodExceeded,
	SessionExcludedReasonSampled,
	SessionExcludedReasonRateLimitMinute,
	SessionExcludedReasonExclusionFilter,
}

func (e SessionExcludedReason) IsValid() bool {
	switch e {
	case SessionExcludedReasonInitializing, SessionExcludedReasonNoActivity, SessionExcludedReasonNoUserInteractionEvents, SessionExcludedReasonNoTimelineIndicatorEvents, SessionExcludedReasonNoError, SessionExcludedReasonNoUserEvents, SessionExcludedReasonIgnoredUser, SessionExcludedReasonBillingQuotaExceeded, SessionExcludedReasonRetentionPeriodExceeded, SessionExcludedReasonSampled, SessionExcludedReasonRateLimitMinute, SessionExcludedReasonExclusionFilter:
		return true
	}
	return false
}

func (e SessionExcludedReason) String() string {
	return string(e)
}

func (e *SessionExcludedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SessionExcludedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SessionExcludedReason", str)
	}
	return nil
}

func (e SessionExcludedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SessionLifecycle string

const (
	SessionLifecycleAll       SessionLifecycle = "All"
	SessionLifecycleLive      SessionLifecycle = "Live"
	SessionLifecycleCompleted SessionLifecycle = "Completed"
)

var AllSessionLifecycle = []SessionLifecycle{
	SessionLifecycleAll,
	SessionLifecycleLive,
	SessionLifecycleCompleted,
}

func (e SessionLifecycle) IsValid() bool {
	switch e {
	case SessionLifecycleAll, SessionLifecycleLive, SessionLifecycleCompleted:
		return true
	}
	return false
}

func (e SessionLifecycle) String() string {
	return string(e)
}

func (e *SessionLifecycle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SessionLifecycle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SessionLifecycle", str)
	}
	return nil
}

func (e SessionLifecycle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocialType string

const (
	SocialTypeGithub   SocialType = "Github"
	SocialTypeLinkedIn SocialType = "LinkedIn"
	SocialTypeTwitter  SocialType = "Twitter"
	SocialTypeFacebook SocialType = "Facebook"
	SocialTypeSite     SocialType = "Site"
)

var AllSocialType = []SocialType{
	SocialTypeGithub,
	SocialTypeLinkedIn,
	SocialTypeTwitter,
	SocialTypeFacebook,
	SocialTypeSite,
}

func (e SocialType) IsValid() bool {
	switch e {
	case SocialTypeGithub, SocialTypeLinkedIn, SocialTypeTwitter, SocialTypeFacebook, SocialTypeSite:
		return true
	}
	return false
}

func (e SocialType) String() string {
	return string(e)
}

func (e *SocialType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocialType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocialType", str)
	}
	return nil
}

func (e SocialType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SourceMappingErrorCode string

const (
	SourceMappingErrorCodeFileNameMissingFromSourcePath         SourceMappingErrorCode = "File_Name_Missing_From_Source_Path"
	SourceMappingErrorCodeErrorParsingStackTraceFileURL         SourceMappingErrorCode = "Error_Parsing_Stack_Trace_File_Url"
	SourceMappingErrorCodeErrorConstructingSourceMapURL         SourceMappingErrorCode = "Error_Constructing_Source_Map_URL"
	SourceMappingErrorCodeMissingSourceMapFileInS3              SourceMappingErrorCode = "Missing_Source_Map_File_In_S3"
	SourceMappingErrorCodeMinifiedFileMissingInS3AndURL         SourceMappingErrorCode = "Minified_File_Missing_In_S3_And_URL"
	SourceMappingErrorCodeSourcemapFileMissingInS3AndURL        SourceMappingErrorCode = "Sourcemap_File_Missing_In_S3_And_URL"
	SourceMappingErrorCodeMinifiedFileLarger                    SourceMappingErrorCode = "Minified_File_Larger"
	SourceMappingErrorCodeSourceMapFileLarger                   SourceMappingErrorCode = "Source_Map_File_Larger"
	SourceMappingErrorCodeInvalidSourceMapURL                   SourceMappingErrorCode = "Invalid_SourceMapURL"
	SourceMappingErrorCodeSourcemapLibraryCouldntParse          SourceMappingErrorCode = "Sourcemap_Library_Couldnt_Parse"
	SourceMappingErrorCodeSourcemapLibraryCouldntRetrieveSource SourceMappingErrorCode = "Sourcemap_Library_Couldnt_Retrieve_Source"
)

var AllSourceMappingErrorCode = []SourceMappingErrorCode{
	SourceMappingErrorCodeFileNameMissingFromSourcePath,
	SourceMappingErrorCodeErrorParsingStackTraceFileURL,
	SourceMappingErrorCodeErrorConstructingSourceMapURL,
	SourceMappingErrorCodeMissingSourceMapFileInS3,
	SourceMappingErrorCodeMinifiedFileMissingInS3AndURL,
	SourceMappingErrorCodeSourcemapFileMissingInS3AndURL,
	SourceMappingErrorCodeMinifiedFileLarger,
	SourceMappingErrorCodeSourceMapFileLarger,
	SourceMappingErrorCodeInvalidSourceMapURL,
	SourceMappingErrorCodeSourcemapLibraryCouldntParse,
	SourceMappingErrorCodeSourcemapLibraryCouldntRetrieveSource,
}

func (e SourceMappingErrorCode) IsValid() bool {
	switch e {
	case SourceMappingErrorCodeFileNameMissingFromSourcePath, SourceMappingErrorCodeErrorParsingStackTraceFileURL, SourceMappingErrorCodeErrorConstructingSourceMapURL, SourceMappingErrorCodeMissingSourceMapFileInS3, SourceMappingErrorCodeMinifiedFileMissingInS3AndURL, SourceMappingErrorCodeSourcemapFileMissingInS3AndURL, SourceMappingErrorCodeMinifiedFileLarger, SourceMappingErrorCodeSourceMapFileLarger, SourceMappingErrorCodeInvalidSourceMapURL, SourceMappingErrorCodeSourcemapLibraryCouldntParse, SourceMappingErrorCodeSourcemapLibraryCouldntRetrieveSource:
		return true
	}
	return false
}

func (e SourceMappingErrorCode) String() string {
	return string(e)
}

func (e *SourceMappingErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceMappingErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceMappingErrorCode", str)
	}
	return nil
}

func (e SourceMappingErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionInterval string

const (
	SubscriptionIntervalMonthly SubscriptionInterval = "Monthly"
	SubscriptionIntervalAnnual  SubscriptionInterval = "Annual"
)

var AllSubscriptionInterval = []SubscriptionInterval{
	SubscriptionIntervalMonthly,
	SubscriptionIntervalAnnual,
}

func (e SubscriptionInterval) IsValid() bool {
	switch e {
	case SubscriptionIntervalMonthly, SubscriptionIntervalAnnual:
		return true
	}
	return false
}

func (e SubscriptionInterval) String() string {
	return string(e)
}

func (e *SubscriptionInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionInterval", str)
	}
	return nil
}

func (e SubscriptionInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SuggestionType string

const (
	SuggestionTypeNone  SuggestionType = "None"
	SuggestionTypeValue SuggestionType = "Value"
	SuggestionTypeKey   SuggestionType = "Key"
)

var AllSuggestionType = []SuggestionType{
	SuggestionTypeNone,
	SuggestionTypeValue,
	SuggestionTypeKey,
}

func (e SuggestionType) IsValid() bool {
	switch e {
	case SuggestionTypeNone, SuggestionTypeValue, SuggestionTypeKey:
		return true
	}
	return false
}

func (e SuggestionType) String() string {
	return string(e)
}

func (e *SuggestionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestionType", str)
	}
	return nil
}

func (e SuggestionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
