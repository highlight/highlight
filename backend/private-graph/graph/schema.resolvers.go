package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math"
	"math/rand"
	"net/url"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/PaesslerAG/jsonpath"
	"github.com/aws/smithy-go/ptr"
	"github.com/clearbit/clearbit-go/clearbit"
	"github.com/highlight-run/highlight/backend/alerts"
	"github.com/highlight-run/highlight/backend/alerts/integrations/discord"
	"github.com/highlight-run/highlight/backend/alerts/integrations/webhook"
	"github.com/highlight-run/highlight/backend/apolloio"
	"github.com/highlight-run/highlight/backend/clickhouse"
	"github.com/highlight-run/highlight/backend/clickup"
	Email "github.com/highlight-run/highlight/backend/email"
	highlightErrors "github.com/highlight-run/highlight/backend/errors"
	"github.com/highlight-run/highlight/backend/front"
	"github.com/highlight-run/highlight/backend/hlog"
	"github.com/highlight-run/highlight/backend/integrations/height"
	"github.com/highlight-run/highlight/backend/lambda-functions/deleteSessions/utils"
	"github.com/highlight-run/highlight/backend/model"
	"github.com/highlight-run/highlight/backend/opensearch"
	"github.com/highlight-run/highlight/backend/pricing"
	"github.com/highlight-run/highlight/backend/private-graph/graph/generated"
	modelInputs "github.com/highlight-run/highlight/backend/private-graph/graph/model"
	"github.com/highlight-run/highlight/backend/storage"
	"github.com/highlight-run/highlight/backend/timeseries"
	"github.com/highlight-run/highlight/backend/util"
	"github.com/highlight-run/highlight/backend/vercel"
	"github.com/highlight-run/highlight/backend/zapier"
	highlight "github.com/highlight/highlight/sdk/highlight-go"
	"github.com/leonelquinteros/hubspot"
	"github.com/lib/pq"
	"github.com/openlyinc/pointy"
	e "github.com/pkg/errors"
	"github.com/rs/zerolog"
	zlog "github.com/rs/zerolog/log"
	"github.com/rs/zerolog/pkgerrors"
	"github.com/samber/lo"
	log "github.com/sirupsen/logrus"
	stripe "github.com/stripe/stripe-go/v72"
	"go.opentelemetry.io/otel/attribute"
	"golang.org/x/sync/errgroup"
	"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// Author is the resolver for the author field.
func (r *commentReplyResolver) Author(ctx context.Context, obj *model.CommentReply) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}
	if err := r.DB.Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).First(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin author for comment reply")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *errorAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *errorAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the WebhookDestinations field.
func (r *errorAlertResolver) WebhookDestinations(ctx context.Context, obj *model.ErrorAlert) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *errorAlertResolver) EmailsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*string, error) {
	return obj.GetEmailsToNotify()
}

// ExcludedEnvironments is the resolver for the ExcludedEnvironments field.
func (r *errorAlertResolver) ExcludedEnvironments(ctx context.Context, obj *model.ErrorAlert) ([]*string, error) {
	return obj.GetExcludedEnvironments()
}

// RegexGroups is the resolver for the RegexGroups field.
func (r *errorAlertResolver) RegexGroups(ctx context.Context, obj *model.ErrorAlert) ([]*string, error) {
	return obj.GetRegexGroups()
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *errorAlertResolver) DailyFrequency(ctx context.Context, obj *model.ErrorAlert) ([]*int64, error) {
	return obj.GetDailyFrequency(r.DB, obj.ID)
}

// Author is the resolver for the author field.
func (r *errorCommentResolver) Author(ctx context.Context, obj *model.ErrorComment) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}
	if err := r.DB.Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).First(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin for comment")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// Event is the resolver for the event field.
func (r *errorGroupResolver) Event(ctx context.Context, obj *model.ErrorGroup) ([]*string, error) {
	return util.JsonStringToStringArray(obj.Event), nil
}

// StructuredStackTrace is the resolver for the structured_stack_trace field.
func (r *errorGroupResolver) StructuredStackTrace(ctx context.Context, obj *model.ErrorGroup) ([]*modelInputs.ErrorTrace, error) {
	if (obj.MappedStackTrace == nil || *obj.MappedStackTrace == "") && obj.StackTrace == "" {
		return nil, nil
	}
	stackTraceString := obj.StackTrace
	if obj.MappedStackTrace != nil && *obj.MappedStackTrace != "" && *obj.MappedStackTrace != "null" {
		stackTraceString = *obj.MappedStackTrace
	}

	return r.UnmarshalStackTrace(stackTraceString)
}

// MetadataLog is the resolver for the metadata_log field.
func (r *errorGroupResolver) MetadataLog(ctx context.Context, obj *model.ErrorGroup) ([]*modelInputs.ErrorMetadata, error) {
	var metadataLogs []*modelInputs.ErrorMetadata
	r.DB.Raw(`
		SELECT
			s.id AS session_id,
			s.secure_id AS session_secure_id,
			e.id AS error_id,
			e.timestamp,
			s.os_name AS os,
			s.browser_name AS browser,
			e.url AS visited_url,
			s.fingerprint AS fingerprint,
			s.identifier AS identifier,
			s.environment,
			s.user_properties,
			e.request_id,
			e.payload
		FROM
			sessions AS s
			INNER JOIN (
			SELECT
				DISTINCT ON (session_id) session_id,
				id,
				timestamp,
				url,
				payload,
				request_id
			FROM
				error_objects
			WHERE
				error_group_id = ?
				AND project_id = ?
			ORDER BY
				session_id DESC
			LIMIT
				20
			) AS e ON s.id = e.session_id
		WHERE
			s.excluded <> true
			AND s.project_id = ?
		ORDER BY
			s.updated_at DESC
		LIMIT
			20;
	`,
		obj.ID,
		obj.ProjectID,
		obj.ProjectID,
	).Scan(&metadataLogs)
	return metadataLogs, nil
}

// State is the resolver for the state field.
func (r *errorGroupResolver) State(ctx context.Context, obj *model.ErrorGroup) (modelInputs.ErrorState, error) {
	switch obj.State {
	case model.ErrorGroupStates.OPEN:
		return modelInputs.ErrorStateOpen, nil
	case model.ErrorGroupStates.RESOLVED:
		return modelInputs.ErrorStateResolved, nil
	case model.ErrorGroupStates.IGNORED:
		return modelInputs.ErrorStateIgnored, nil
	default:
		return modelInputs.ErrorStateOpen, e.New("invalid error group state")
	}
}

// ErrorGroupSecureID is the resolver for the error_group_secure_id field.
func (r *errorObjectResolver) ErrorGroupSecureID(ctx context.Context, obj *model.ErrorObject) (string, error) {
	if obj != nil {
		var secureID string
		if err := r.DB.Raw(`SELECT secure_id FROM error_groups WHERE id = ? LIMIT 1`,
			obj.ErrorGroupID).Scan(&secureID).Error; err != nil {
			return "", e.Wrapf(err, "Failed to retrieve secure_id for error group, id: %d", obj.ErrorGroupID)
		}
		return secureID, nil
	}
	return "", nil
}

// Event is the resolver for the event field.
func (r *errorObjectResolver) Event(ctx context.Context, obj *model.ErrorObject) ([]*string, error) {
	return util.JsonStringToStringArray(obj.Event), nil
}

// StructuredStackTrace is the resolver for the structured_stack_trace field.
func (r *errorObjectResolver) StructuredStackTrace(ctx context.Context, obj *model.ErrorObject) ([]*modelInputs.ErrorTrace, error) {
	if (obj.MappedStackTrace == nil || *obj.MappedStackTrace == "") && *obj.StackTrace == "" {
		return nil, nil
	}
	stackTraceString := *obj.StackTrace
	if obj.MappedStackTrace != nil && *obj.MappedStackTrace != "" && *obj.MappedStackTrace != "null" {
		stackTraceString = *obj.MappedStackTrace
	}

	return r.UnmarshalStackTrace(stackTraceString)
}

// Session is the resolver for the session field.
func (r *errorObjectResolver) Session(ctx context.Context, obj *model.ErrorObject) (*model.Session, error) {
	if obj.SessionID == nil {
		return nil, nil
	}
	session := &model.Session{}
	if err := r.DB.Where("id = ?", obj.SessionID).First(&session).Error; err != nil {
		return nil, e.Wrap(err, "error reading session from error object")
	}
	return session, nil
}

// Params is the resolver for the params field.
func (r *errorSegmentResolver) Params(ctx context.Context, obj *model.ErrorSegment) (*model.ErrorSearchParams, error) {
	params := &model.ErrorSearchParams{}
	if obj.Params == nil {
		return params, nil
	}
	if err := json.Unmarshal([]byte(*obj.Params), params); err != nil {
		return nil, e.Wrapf(err, "error unmarshaling segment params")
	}
	return params, nil
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *logAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.LogAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *logAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.LogAlert) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the WebhookDestinations field.
func (r *logAlertResolver) WebhookDestinations(ctx context.Context, obj *model.LogAlert) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *logAlertResolver) EmailsToNotify(ctx context.Context, obj *model.LogAlert) ([]string, error) {
	emails, err := obj.GetEmailsToNotify()
	if err != nil {
		return nil, err
	}
	return lo.Map(emails, func(email *string, idx int) string {
		return *email
	}), nil
}

// ExcludedEnvironments is the resolver for the ExcludedEnvironments field.
func (r *logAlertResolver) ExcludedEnvironments(ctx context.Context, obj *model.LogAlert) ([]string, error) {
	envs, err := obj.GetExcludedEnvironments()
	if err != nil {
		return nil, err
	}
	return lo.Map(envs, func(env *string, idx int) string {
		return *env
	}), nil
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *logAlertResolver) DailyFrequency(ctx context.Context, obj *model.LogAlert) ([]*int64, error) {
	return obj.GetDailyFrequency(r.DB, obj.ID)
}

// ChannelsToNotify is the resolver for the channels_to_notify field.
func (r *metricMonitorResolver) ChannelsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*modelInputs.SanitizedSlackChannel, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for channels to notify")
	}
	channelString := "[]"
	if obj.ChannelsToNotify != nil {
		channelString = *obj.ChannelsToNotify
	}
	var sanitizedChannels []*modelInputs.SanitizedSlackChannel
	if err := json.Unmarshal([]byte(channelString), &sanitizedChannels); err != nil {
		return nil, e.Wrap(err, "error unmarshalling sanitized slack channels for metric monitors")
	}
	return sanitizedChannels, nil
}

// DiscordChannelsToNotify is the resolver for the discord_channels_to_notify field.
func (r *metricMonitorResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the webhook_destinations field.
func (r *metricMonitorResolver) WebhookDestinations(ctx context.Context, obj *model.MetricMonitor) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the emails_to_notify field.
func (r *metricMonitorResolver) EmailsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*string, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for emails to notify")
	}
	emailString := "[]"
	if obj.EmailsToNotify != nil {
		emailString = *obj.EmailsToNotify
	}
	var emailsToNotify []*string
	if err := json.Unmarshal([]byte(emailString), &emailsToNotify); err != nil {
		return nil, e.Wrap(err, "error unmarshalling emails to notify for metric monitors")
	}
	return emailsToNotify, nil
}

// Filters is the resolver for the filters field.
func (r *metricMonitorResolver) Filters(ctx context.Context, obj *model.MetricMonitor) ([]*modelInputs.MetricTagFilter, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for Slack or email notifications")
	}
	var filters []*model.DashboardMetricFilter
	if err := r.DB.Where(&model.DashboardMetricFilter{MetricMonitorID: obj.ID}).Find(&filters).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitor filters")
	}
	return lo.Map(filters, func(t *model.DashboardMetricFilter, i int) *modelInputs.MetricTagFilter {
		return &modelInputs.MetricTagFilter{
			Tag:   t.Tag,
			Op:    t.Op,
			Value: t.Value,
		}
	}), nil
}

// UpdateAdminAndCreateWorkspace is the resolver for the updateAdminAndCreateWorkspace field.
func (r *mutationResolver) UpdateAdminAndCreateWorkspace(ctx context.Context, adminAndWorkspaceDetails modelInputs.AdminAndWorkspaceDetails) (*model.Project, error) {
	if err := r.Transaction(func(transactionR *mutationResolver) error {
		// Update admin details
		if _, err := transactionR.UpdateAdminAboutYouDetails(ctx, modelInputs.AdminAboutYouDetails{
			FirstName:          adminAndWorkspaceDetails.FirstName,
			LastName:           adminAndWorkspaceDetails.LastName,
			UserDefinedRole:    adminAndWorkspaceDetails.UserDefinedRole,
			UserDefinedPersona: "",
			Referral:           adminAndWorkspaceDetails.Referral,
		}); err != nil {
			return e.Wrap(err, "error updating admin details")
		}

		// Create workspace
		workspace, err := transactionR.CreateWorkspace(ctx, adminAndWorkspaceDetails.WorkspaceName, adminAndWorkspaceDetails.PromoCode)
		if err != nil {
			return e.Wrap(err, "error creating workspace")
		}

		// Assign auto joinable domains for workspace
		if *adminAndWorkspaceDetails.AllowedAutoJoinEmailOrigins != "" {
			if _, err := transactionR.UpdateAllowedEmailOrigins(ctx, workspace.ID, *adminAndWorkspaceDetails.AllowedAutoJoinEmailOrigins); err != nil {
				return e.Wrap(err, "error assigning auto joinable email origins")
			}
		}

		// Create project
		projectName := fmt.Sprintf("%s App", adminAndWorkspaceDetails.WorkspaceName)
		if _, err := transactionR.CreateProject(ctx, projectName, workspace.ID); err != nil {
			return e.Wrap(err, "error creating project")
		}

		return nil
	}); err != nil {
		return nil, e.Wrap(err, "error during transaction")
	}

	projects, err := r.Query().Projects(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error fetching new project")
	}

	return projects[0], nil
}

// UpdateAdminAboutYouDetails is the resolver for the updateAdminAboutYouDetails field.
func (r *mutationResolver) UpdateAdminAboutYouDetails(ctx context.Context, adminDetails modelInputs.AdminAboutYouDetails) (bool, error) {
	admin, err := r.getCurrentAdmin(ctx)

	if err != nil {
		return false, err
	}

	fullName := adminDetails.FirstName + " " + adminDetails.LastName
	admin.FirstName = &adminDetails.FirstName
	admin.LastName = &adminDetails.LastName
	admin.Name = &fullName
	admin.UserDefinedRole = &adminDetails.UserDefinedRole
	admin.Referral = &adminDetails.Referral
	admin.UserDefinedPersona = &adminDetails.UserDefinedPersona
	admin.Phone = pointy.String("")
	admin.AboutYouDetailsFilled = &model.T

	if util.IsHubspotEnabled() {
		hubspotContactId, err := r.HubspotApi.CreateContactForAdmin(
			ctx,
			admin.ID,
			*admin.Email,
			*admin.UserDefinedRole,
			*admin.UserDefinedPersona,
			*admin.FirstName,
			*admin.LastName,
			*admin.Phone,
			*admin.Referral,
		)
		if err != nil {
			log.WithContext(ctx).Error(err, "error creating hubspot contact")
		}
		if hubspotContactId != nil {
			admin.HubspotContactID = hubspotContactId
		}
	}

	if err := r.DB.Save(admin).Error; err != nil {
		return false, err
	}

	return true, nil
}

// CreateAdmin is the resolver for the createAdmin field.
func (r *mutationResolver) CreateAdmin(ctx context.Context) (*model.Admin, error) {
	return r.createAdmin(ctx)
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, name string, workspaceID int) (*model.Project, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	project := &model.Project{
		Name:         &name,
		BillingEmail: admin.Email,
		WorkspaceID:  workspace.ID,
	}

	if err := r.DB.Create(project).Error; err != nil {
		return nil, e.Wrap(err, "error creating project")
	}

	return project, nil
}

// CreateWorkspace is the resolver for the createWorkspace field.
func (r *mutationResolver) CreateWorkspace(ctx context.Context, name string, promoCode *string) (*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	trialEnd := time.Now().Add(14 * 24 * time.Hour) // Trial expires 14 days from current day
	if promoCode != nil {
		trialDetails, ok := PromoCodes[strings.ToUpper(*promoCode)]
		if !ok {
			return nil, e.New("Could not create workspace: promo code is not valid.")
		}
		if time.Now().After(trialDetails.ValidUntil) {
			return nil, e.New("Could not create workspace: promo code has expired.")
		}

		trialEnd = time.Now().Add(time.Duration(trialDetails.TrialDays*24) * time.Hour)
	}

	workspace := &model.Workspace{
		Admins:                    []model.Admin{*admin},
		Name:                      &name,
		TrialEndDate:              &trialEnd,
		EligibleForTrialExtension: true, // Trial can be extended if user integrates + fills out form
		TrialExtensionEnabled:     false,
		PromoCode:                 promoCode,
	}

	if err := r.DB.Create(workspace).Error; err != nil {
		return nil, e.Wrap(err, "error creating workspace")
	}

	if util.IsHubspotEnabled() {
		// For the first admin in a workspace, we explicitly create the association if the hubspot company creation succeeds.
		if _, err := r.HubspotApi.CreateCompanyForWorkspace(ctx, workspace.ID, *admin.Email, name, r.DB); err != nil {
			log.WithContext(ctx).Error(err, "error creating hubspot company")
		} else if err := r.HubspotApi.CreateContactCompanyAssociation(ctx, admin.ID, workspace.ID, r.DB); err != nil {
			log.WithContext(ctx).Error(err, "error creating association between hubspot records with admin ID [%v] and workspace ID [%v]", admin.ID, workspace.ID)
		}
	}

	c := &stripe.Customer{}
	if os.Getenv("REACT_APP_ONPREM") != "true" {
		params := &stripe.CustomerParams{
			Name:  &name,
			Email: admin.Email,
		}
		params.AddMetadata("Workspace ID", strconv.Itoa(workspace.ID))
		c, err = r.StripeClient.Customers.New(params)
		if err != nil {
			log.WithContext(ctx).Error(err, "error creating stripe customer")
		}
	}

	if err := r.DB.Model(&workspace).Updates(&model.Workspace{StripeCustomerID: &c.ID}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace StripeCustomerID")
	}

	return workspace, nil
}

// EditProject is the resolver for the editProject field.
func (r *mutationResolver) EditProject(ctx context.Context, id int, name *string, billingEmail *string, excludedUsers pq.StringArray, errorJSONPaths pq.StringArray, rageClickWindowSeconds *int, rageClickRadiusPixels *int, rageClickCount *int, backendDomains pq.StringArray) (*model.Project, error) {
	project, err := r.isAdminInProject(ctx, id)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	for _, expression := range excludedUsers {
		_, err := regexp.Compile(expression)
		if err != nil {
			return nil, e.Wrap(err, "The regular expression '"+expression+"' is not valid")
		}
	}

	for _, path := range errorJSONPaths {
		_, err := jsonpath.New(path)
		if err != nil {
			return nil, e.Wrap(err, "The JSON path '"+path+"'is not valid")
		}
	}

	updates := &model.Project{
		Name:           name,
		BillingEmail:   billingEmail,
		ExcludedUsers:  excludedUsers,
		ErrorJsonPaths: errorJSONPaths,
		BackendDomains: backendDomains,
	}

	if rageClickWindowSeconds != nil {
		updates.RageClickWindowSeconds = *rageClickWindowSeconds
	}

	if rageClickRadiusPixels != nil {
		updates.RageClickRadiusPixels = *rageClickRadiusPixels
	}

	if rageClickCount != nil {
		updates.RageClickCount = *rageClickCount
	}

	if err := r.DB.Model(project).Updates(updates).Error; err != nil {
		return nil, e.Wrap(err, "error updating project fields")
	}
	return project, nil
}

// EditWorkspace is the resolver for the editWorkspace field.
func (r *mutationResolver) EditWorkspace(ctx context.Context, id int, name *string) (*model.Workspace, error) {
	workspace, err := r.isAdminInWorkspace(ctx, id)
	if err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}
	if err := r.DB.Model(workspace).Updates(&model.Workspace{
		Name: name,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace fields")
	}
	return workspace, nil
}

// MarkErrorGroupAsViewed is the resolver for the markErrorGroupAsViewed field.
func (r *mutationResolver) MarkErrorGroupAsViewed(ctx context.Context, errorSecureID string, viewed *bool) (*model.ErrorGroup, error) {
	eg, err := r.canAdminModifyErrorGroup(ctx, errorSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not error group owner")
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "admin not logged in")
	}

	// Update the the number of error groups viewed for the current admin.
	r.PrivateWorkerPool.SubmitRecover(func() {
		// Check if this admin has already viewed
		if _, err := r.isAdminInProject(ctx, eg.ProjectID); err != nil {
			log.WithContext(ctx).Infof("not adding error groups count to admin in hubspot; this is probably a demo project, with id [%v]", eg.ProjectID)
			return
		}
		var currentErrorGroupCount int64
		if err := r.DB.Raw(`
			select count(*)
			from error_group_admins_views
			where error_group_id = ? and admin_id = ?
	`, eg.ID, admin.ID).Scan(&currentErrorGroupCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying count of error group views from admin"))
			return
		} else if currentErrorGroupCount > 0 {
			log.WithContext(ctx).Info("not updating hubspot error group count; admin has already viewed this error group")
			return
		}

		var totalErrorGroupCount int64
		if err := r.DB.Raw(`
			select count(*)
			from error_group_admins_views
			where admin_id = ?
	`, admin.ID).Scan(&totalErrorGroupCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying total count of error group views from admin"))
			return
		}
		totalErrorGroupCountAsInt := int(totalErrorGroupCount) + 1

		if err := r.DB.Where(admin).Updates(&model.Admin{NumberOfErrorGroupsViewed: &totalErrorGroupCountAsInt}).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error updating error group count for admin in postgres"))
		}
		if util.IsHubspotEnabled() {
			if err := r.HubspotApi.UpdateContactProperty(ctx, admin.ID, []hubspot.Property{{
				Name:     "number_of_highlight_error_groups_viewed",
				Property: "number_of_highlight_error_groups_viewed",
				Value:    totalErrorGroupCountAsInt,
			}}, r.DB); err != nil {
				zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
				zerolog.ErrorStackMarshaler = pkgerrors.MarshalStack

				zlog.Error().
					Stack().
					Err(err).
					Int("admin_id", admin.ID).
					Int("value", totalErrorGroupCountAsInt).
					Msg("error updating error group count for admin in hubspot")
			}
			log.WithContext(ctx).Infof("succesfully added to total error group count for admin [%v], who just viewed error group [%v]", admin.ID, eg.ID)
		}
	})

	newErrorGroup := &model.ErrorGroup{}
	updatedFields := &model.ErrorGroup{
		Viewed: viewed,
	}
	if err := r.DB.Where(&model.ErrorGroup{Model: model.Model{ID: eg.ID}}).First(&newErrorGroup).Updates(updatedFields).Error; err != nil {
		return nil, e.Wrap(err, "error writing error as viewed")
	}

	if err := r.OpenSearch.Update(opensearch.IndexErrorsCombined, eg.ID, map[string]interface{}{"viewed": viewed}); err != nil {
		return nil, e.Wrap(err, "error updating error in opensearch")
	}

	newAdminView := struct {
		ID int `json:"id"`
	}{
		ID: admin.ID,
	}

	if err := r.OpenSearch.AppendToField(opensearch.IndexErrorsCombined, newErrorGroup.ID, "viewed_by_admins", []interface{}{
		newAdminView}); err != nil {
		return nil, e.Wrap(err, "error updating error gorups's admin viewed by in opensearch")
	}

	if err := r.DB.Model(&eg).Association("ViewedByAdmins").Append(admin); err != nil {
		return nil, e.Wrap(err, "error adding admin to ViewedByAdmins")
	}

	return newErrorGroup, nil
}

// MarkSessionAsViewed is the resolver for the markSessionAsViewed field.
func (r *mutationResolver) MarkSessionAsViewed(ctx context.Context, secureID string, viewed *bool) (*model.Session, error) {
	s, err := r.canAdminModifySession(ctx, secureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "admin not logged in")
	}

	// Update the the number of sessions viewed for the current admin.
	r.PrivateWorkerPool.SubmitRecover(func() {
		// Check if this admin has already viewed
		if _, err := r.isAdminInProject(ctx, s.ProjectID); err != nil {
			log.WithContext(ctx).Infof("not adding session count to admin in hubspot; this is probably a demo project, with id [%v]", s.ProjectID)
			return
		}
		var currentSessionCount int64
		if err := r.DB.Raw(`
			select count(*)
			from session_admins_views
			where session_id = ? and admin_id = ?
	`, s.ID, admin.ID).Scan(&currentSessionCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying count of session views from admin"))
			return
		} else if currentSessionCount > 0 {
			log.WithContext(ctx).Info("not updating hubspot session count; admin has already viewed this session")
			return
		}

		var totalSessionCount int64
		if err := r.DB.Raw(`
			select count(*)
			from session_admins_views
			where admin_id = ?
	`, admin.ID).Scan(&totalSessionCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying total count of session views from admin"))
			return
		}
		totalSessionCountAsInt := int(totalSessionCount) + 1

		if err := r.DB.Where(admin).Updates(&model.Admin{NumberOfSessionsViewed: &totalSessionCountAsInt}).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error updating session count for admin in postgres"))
		}
		if util.IsHubspotEnabled() {
			if err := r.HubspotApi.UpdateContactProperty(ctx, admin.ID, []hubspot.Property{{
				Name:     "number_of_highlight_sessions_viewed",
				Property: "number_of_highlight_sessions_viewed",
				Value:    totalSessionCountAsInt,
			}}, r.DB); err != nil {
				zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
				zerolog.ErrorStackMarshaler = pkgerrors.MarshalStack

				zlog.Error().
					Stack().
					Err(err).
					Int("admin_id", admin.ID).
					Int("value", totalSessionCountAsInt).
					Msg("error updating session count for admin in hubspot")
			}
			log.WithContext(ctx).Infof("succesfully added to total session count for admin [%v], who just viewed session [%v]", admin.ID, s.ID)
		}
	})

	newSession := &model.Session{}
	updatedFields := &model.Session{
		Viewed: viewed,
	}
	if err := r.DB.Where(&model.Session{Model: model.Model{ID: s.ID}}).First(&newSession).Updates(updatedFields).Error; err != nil {
		return nil, e.Wrap(err, "error writing session as viewed")
	}

	if err := r.OpenSearch.Update(opensearch.IndexSessions, s.ID, map[string]interface{}{"viewed": viewed}); err != nil {
		return nil, e.Wrap(err, "error updating session in opensearch")
	}

	newAdminView := struct {
		ID int `json:"id"`
	}{
		ID: admin.ID,
	}

	if err := r.OpenSearch.AppendToField(opensearch.IndexSessions, newSession.ID, "viewed_by_admins", []interface{}{
		newAdminView}); err != nil {
		return nil, e.Wrap(err, "error updating session's admin viewed by in opensearch")
	}

	if err := r.DB.Model(&s).Association("ViewedByAdmins").Append(admin); err != nil {
		return nil, e.Wrap(err, "error adding admin to ViewedByAdmins")
	}

	return newSession, nil
}

// MarkSessionAsStarred is the resolver for the markSessionAsStarred field.
func (r *mutationResolver) MarkSessionAsStarred(ctx context.Context, secureID string, starred *bool) (*model.Session, error) {
	s, err := r.canAdminModifySession(ctx, secureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	session := &model.Session{}
	if err := r.DB.Where(&model.Session{Model: model.Model{ID: s.ID}}).First(&session).Updates(&model.Session{
		Starred: starred,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error writing session as starred")
	}

	if err := r.OpenSearch.Update(opensearch.IndexSessions, s.ID, map[string]interface{}{"starred": starred}); err != nil {
		return nil, e.Wrap(err, "error updating session in opensearch")
	}

	return session, nil
}

// UpdateErrorGroupState is the resolver for the updateErrorGroupState field.
func (r *mutationResolver) UpdateErrorGroupState(ctx context.Context, secureID string, state string, snoozedUntil *time.Time) (*model.ErrorGroup, error) {
	errGroup, err := r.canAdminModifyErrorGroup(ctx, secureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}

	errorGroup := &model.ErrorGroup{}
	if err := r.DB.Where(&model.ErrorGroup{Model: model.Model{ID: errGroup.ID}}).First(&errorGroup).Updates(map[string]interface{}{
		"State":        state,
		"SnoozedUntil": snoozedUntil,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error writing errorGroup state")
	}

	if err := r.OpenSearch.UpdateSynchronous(opensearch.IndexErrorsCombined, errorGroup.ID, map[string]interface{}{
		"state":         state,
		"snoozed_until": snoozedUntil,
	}); err != nil {
		return nil, e.Wrap(err, "error updating error group state in OpenSearch")
	}

	return errorGroup, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id int) (*bool, error) {
	_, err := r.isAdminInProject(ctx, id)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}
	if err := r.DB.Model(&model.Project{}).Delete("id = ?", id).Error; err != nil {
		return nil, e.Wrap(err, "error deleting project")
	}
	return &model.T, nil
}

// SendAdminWorkspaceInvite is the resolver for the sendAdminWorkspaceInvite field.
func (r *mutationResolver) SendAdminWorkspaceInvite(ctx context.Context, workspaceID int, email string, baseURL string, role string) (*string, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error querying admin")
	}

	existingInviteLink := &model.WorkspaceInviteLink{}
	if err := r.DB.Where(&model.WorkspaceInviteLink{WorkspaceID: &workspaceID, InviteeEmail: &email}).First(existingInviteLink).Error; err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			existingInviteLink = nil
		} else {
			return nil, e.Wrap(err, "error querying workspace invite link for admin")
		}
	}

	// If there's an existing and expired invite link for the user then delete it.
	if existingInviteLink != nil && r.IsInviteLinkExpired(existingInviteLink) {
		if err := r.DB.Delete(existingInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "error deleting expired invite link")
		}
		existingInviteLink = nil
	}

	// Delete the existing invite if the roles are different.
	if existingInviteLink != nil && existingInviteLink.InviteeRole != nil && *existingInviteLink.InviteeRole != role {
		if err := r.DB.Delete(existingInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "error deleting different role invite link")
		}
		existingInviteLink = nil
	}

	if existingInviteLink == nil {
		existingInviteLink = r.CreateInviteLink(workspaceID, &email, role, false)

		if err := r.DB.Create(existingInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "error creating new invite link")
		}
	}

	inviteLink := baseURL + "/w/" + strconv.Itoa(workspaceID) + "/invite/" + *existingInviteLink.Secret
	return r.SendAdminInviteImpl(*admin.Name, *workspace.Name, inviteLink, email)
}

// AddAdminToWorkspace is the resolver for the addAdminToWorkspace field.
func (r *mutationResolver) AddAdminToWorkspace(ctx context.Context, workspaceID int, inviteID string) (*int, error) {
	adminID, err := r.addAdminMembership(ctx, workspaceID, inviteID)
	if err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "failed to add admin to workspace"))
		return adminID, err
	}
	r.PrivateWorkerPool.SubmitRecover(func() {
		if err := r.HubspotApi.CreateContactCompanyAssociation(ctx, *adminID, workspaceID, r.DB); err != nil {
			log.WithContext(ctx).Error(e.Wrapf(
				err,
				"error creating association between hubspot records with admin ID [%v] and workspace ID [%v]",
				*adminID,
				workspaceID,
			))
		}
	})

	return adminID, nil
}

// JoinWorkspace is the resolver for the joinWorkspace field.
func (r *mutationResolver) JoinWorkspace(ctx context.Context, workspaceID int) (*int, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		return nil, e.Wrap(err, "error getting custom verified admin email domain")
	}
	workspace := &model.Workspace{Model: model.Model{ID: workspaceID}}
	if err := r.DB.Model(&workspace).Where("jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))", domain).First(workspace).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}
	if err := r.DB.Model(&workspace).Association("Admins").Append(admin); err != nil {
		return nil, e.Wrap(err, "error adding admin to association")
	}
	return &workspace.ID, nil
}

// UpdateAllowedEmailOrigins is the resolver for the updateAllowedEmailOrigins field.
func (r *mutationResolver) UpdateAllowedEmailOrigins(ctx context.Context, workspaceID int, allowedAutoJoinEmailOrigins string) (*int, error) {
	_, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "current admin is not in workspace")
	}

	err = r.validateAdminRole(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving admin user")
	}

	if !json.Valid([]byte(allowedAutoJoinEmailOrigins)) {
		return nil, e.Wrap(err, "allowedAutoJoinEmailOrigins is not valid JSON")
	}

	if err := r.DB.Model(&model.Workspace{Model: model.Model{ID: workspaceID}}).Updates(&model.Workspace{
		AllowedAutoJoinEmailOrigins: &allowedAutoJoinEmailOrigins}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace")
	}

	return &workspaceID, nil
}

// ChangeAdminRole is the resolver for the changeAdminRole field.
func (r *mutationResolver) ChangeAdminRole(ctx context.Context, workspaceID int, adminID int, newRole string) (bool, error) {
	_, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, e.Wrap(err, "current admin is not in workspace")
	}

	if err := r.validateAdminRole(ctx, workspaceID); err != nil {
		return false, e.Wrap(err, "A non-Admin role Admin tried changing an admin role.")
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return false, e.Wrap(err, "error retrieving user")
	}

	if admin.ID == adminID {
		return false, e.New("A admin tried changing their own role.")
	}

	if err := r.DB.Model(&model.WorkspaceAdmin{AdminID: adminID, WorkspaceID: workspaceID}).Update("Role", newRole).Error; err != nil {
		return false, e.Wrap(err, "error updating workspace_admin role")
	}

	return true, nil
}

// DeleteAdminFromProject is the resolver for the deleteAdminFromProject field.
func (r *mutationResolver) DeleteAdminFromProject(ctx context.Context, projectID int, adminID int) (*int, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "current admin is not in project")
	}

	return r.DeleteAdminAssociation(ctx, project, adminID)
}

// DeleteAdminFromWorkspace is the resolver for the deleteAdminFromWorkspace field.
func (r *mutationResolver) DeleteAdminFromWorkspace(ctx context.Context, workspaceID int, adminID int) (*int, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "current admin is not in workspace")
	}

	deletedAdminId, err := r.DeleteAdminAssociation(ctx, workspace, adminID)
	if err != nil {
		return nil, e.Wrap(err, "error deleting admin association")
	}

	return deletedAdminId, nil
}

// CreateSegment is the resolver for the createSegment field.
func (r *mutationResolver) CreateSegment(ctx context.Context, projectID int, name string, params modelInputs.SearchParamsInput) (*model.Segment, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}
	modelParams := InputToParams(&params)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, e.Wrap(err, "error unmarshaling search params")
	}
	paramString := string(paramBytes)

	// check if such a segment exists
	var count int64
	if err := r.DB.Model(&model.Segment{}).Where("project_id = ? AND name = ?", projectID, name).Count(&count).Error; err != nil {
		return nil, e.Wrap(err, "error checking if segment exists")
	}
	if count > 0 {
		return nil, e.New("segment with this name already exists")
	}

	segment := &model.Segment{
		Name:      &name,
		Params:    &paramString,
		ProjectID: projectID,
	}
	if err := r.DB.Create(segment).Error; err != nil {
		return nil, e.Wrap(err, "error creating segment")
	}
	return segment, nil
}

// EmailSignup is the resolver for the emailSignup field.
func (r *mutationResolver) EmailSignup(ctx context.Context, email string) (string, error) {
	short, long, err := apolloio.Enrich(email)
	if err != nil {
		log.WithContext(ctx).Errorf("error enriching email: %v", err)
		return email, nil
	}

	model.DB.Create(&model.EmailSignup{
		Email:               email,
		ApolloData:          *long,
		ApolloDataShortened: *short,
	})

	r.PrivateWorkerPool.SubmitRecover(func() {
		if contact, err := apolloio.CreateContact(email); err != nil {
			log.WithContext(ctx).Errorf("error creating apollo contact: %v", err)
		} else {
			sequenceID := "60fb134ce97fa1014c1cc141" // represents the "Landing Page Signups" sequence.
			if err := apolloio.AddToSequence(contact.ID, sequenceID); err != nil {
				log.WithContext(ctx).Errorf("error adding to apollo sequence: %v", err)
			}
		}
	})

	return email, nil
}

// EditSegment is the resolver for the editSegment field.
func (r *mutationResolver) EditSegment(ctx context.Context, id int, projectID int, params modelInputs.SearchParamsInput, name string) (*bool, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}
	modelParams := InputToParams(&params)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, e.Wrap(err, "error unmarshaling search params")
	}
	paramString := string(paramBytes)

	// check if such a segment exists
	var count int64
	if err := r.DB.Model(&model.Segment{}).Where("project_id = ? AND name = ?", projectID, name).Count(&count).Error; err != nil {
		return nil, e.Wrap(err, "error checking if segment exists")
	}
	if count > 0 {
		return nil, e.New("segment with this name already exists")
	}

	if err := r.DB.Model(&model.Segment{Model: model.Model{ID: id}}).Updates(&model.Segment{
		Params: &paramString,
		Name:   &name,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error writing new recording settings")
	}

	return &model.T, nil
}

// DeleteSegment is the resolver for the deleteSegment field.
func (r *mutationResolver) DeleteSegment(ctx context.Context, segmentID int) (*bool, error) {
	_, err := r.isAdminSegmentOwner(ctx, segmentID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not segment owner")
	}
	if err := r.DB.Delete(&model.Segment{Model: model.Model{ID: segmentID}}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting segment")
	}
	return &model.T, nil
}

// CreateErrorSegment is the resolver for the createErrorSegment field.
func (r *mutationResolver) CreateErrorSegment(ctx context.Context, projectID int, name string, params modelInputs.ErrorSearchParamsInput) (*model.ErrorSegment, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}
	modelParams := ErrorInputToParams(&params)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, e.Wrap(err, "error unmarshaling search params")
	}
	paramString := string(paramBytes)

	// check if such a segment exists
	var count int64
	if err := r.DB.Model(&model.ErrorSegment{}).Where("project_id = ? AND name = ?", projectID, name).Count(&count).Error; err != nil {
		return nil, e.Wrap(err, "error checking if segment exists")
	}
	if count > 0 {
		return nil, e.New("segment with this name already exists")
	}

	segment := &model.ErrorSegment{
		Name:      &name,
		Params:    &paramString,
		ProjectID: projectID,
	}
	if err := r.DB.Create(segment).Error; err != nil {
		return nil, e.Wrap(err, "error creating segment")
	}
	return segment, nil
}

// EditErrorSegment is the resolver for the editErrorSegment field.
func (r *mutationResolver) EditErrorSegment(ctx context.Context, id int, projectID int, params modelInputs.ErrorSearchParamsInput, name string) (*bool, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}
	modelParams := ErrorInputToParams(&params)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, e.Wrap(err, "error unmarshaling search params")
	}
	paramString := string(paramBytes)

	var count int64
	if err := r.DB.Model(&model.ErrorSegment{}).Where("project_id = ? AND name = ?", projectID, name).Count(&count).Error; err != nil {
		return nil, e.Wrap(err, "error checking if segment exists")
	}
	if count > 0 {
		return nil, e.New("segment with this name already exists")
	}

	if err := r.DB.Model(&model.ErrorSegment{Model: model.Model{ID: id}}).Updates(&model.ErrorSegment{
		Params: &paramString,
		Name:   &name,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error writing new recording settings")
	}
	return &model.T, nil
}

// DeleteErrorSegment is the resolver for the deleteErrorSegment field.
func (r *mutationResolver) DeleteErrorSegment(ctx context.Context, segmentID int) (*bool, error) {
	_, err := r.isAdminErrorSegmentOwner(ctx, segmentID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not error segment owner")
	}
	if err := r.DB.Delete(&model.ErrorSegment{Model: model.Model{ID: segmentID}}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting segment")
	}
	return &model.T, nil
}

// CreateOrUpdateStripeSubscription is the resolver for the createOrUpdateStripeSubscription field.
func (r *mutationResolver) CreateOrUpdateStripeSubscription(ctx context.Context, workspaceID int, planType modelInputs.PlanType, interval modelInputs.SubscriptionInterval, retentionPeriod modelInputs.RetentionPeriod) (*string, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	if err := r.validateAdminRole(ctx, workspaceID); err != nil {
		return nil, e.Wrap(err, "must have ADMIN role to create/update stripe subscription")
	}

	// For older projects, if there's no customer ID, we create a StripeCustomer obj.
	if workspace.StripeCustomerID == nil {
		params := &stripe.CustomerParams{}
		c, err := r.StripeClient.Customers.New(params)
		if err != nil {
			log.WithContext(ctx).Error(err, "error creating stripe customer")
		}
		if err := r.DB.Model(&workspace).Updates(&model.Workspace{
			StripeCustomerID: &c.ID,
		}).Error; err != nil {
			return nil, e.Wrap(err, "error updating org fields")
		}
		workspace.StripeCustomerID = &c.ID
	}

	params := &stripe.CustomerParams{}
	params.AddExpand("subscriptions")

	c, err := r.StripeClient.Customers.Get(*workspace.StripeCustomerID, params)
	if err != nil {
		return nil, e.Wrap(err, "STRIPE_INTEGRATION_ERROR cannot update stripe subscription - couldn't retrieve stripe customer data")
	}

	// If there are multiple subscriptions, it's ambiguous which one should be updated, so throw an error
	if len(c.Subscriptions.Data) > 1 {
		return nil, e.New("STRIPE_INTEGRATION_ERROR cannot update stripe subscription - customer has multiple subscriptions")
	}

	subscriptions := c.Subscriptions.Data
	pricing.FillProducts(r.StripeClient, subscriptions)

	pricingInterval := pricing.SubscriptionIntervalMonthly
	if planType != modelInputs.PlanTypeFree && interval == modelInputs.SubscriptionIntervalAnnual {
		pricingInterval = pricing.SubscriptionIntervalAnnual
	}

	// default to unlimited members pricing
	prices, err := pricing.GetStripePrices(r.StripeClient, planType, pricingInterval, true, &retentionPeriod)
	if err != nil {
		return nil, e.Wrap(err, "STRIPE_INTEGRATION_ERROR cannot update stripe subscription - failed to get Stripe prices")
	}

	newBasePrice := prices[pricing.ProductTypeBase]

	// If there's an existing subscription, update it
	if len(subscriptions) == 1 {
		subscription := subscriptions[0]
		if len(subscription.Items.Data) != 1 {
			return nil, e.New("STRIPE_INTEGRATION_ERROR cannot update stripe subscription - subscription has multiple products")
		}

		subscriptionItem := subscription.Items.Data[0]
		productType, _, _, _, _ := pricing.GetProductMetadata(subscriptionItem.Price)
		if productType == nil {
			return nil, e.New(fmt.Sprintf("STRIPE_INTEGRATION_ERROR cannot update stripe subscription - nil product from sub %s price %s", subscription.ID, subscriptionItem.Price.ID))
		}
		if *productType != pricing.ProductTypeBase {
			return nil, e.New(fmt.Sprintf("STRIPE_INTEGRATION_ERROR cannot update stripe subscription - expecting base product from sub %s price %s: %s", subscription.ID, subscriptionItem.Price.ID, *productType))
		}

		subscriptionParams := &stripe.SubscriptionParams{
			CancelAtPeriodEnd: stripe.Bool(false),
			ProrationBehavior: stripe.String(string(stripe.SubscriptionProrationBehaviorCreateProrations)),
			Items: []*stripe.SubscriptionItemsParams{
				{
					ID:   &subscriptionItem.ID,
					Plan: &newBasePrice.ID,
				},
			},
		}

		_, err := r.StripeClient.Subscriptions.Update(subscription.ID, subscriptionParams)
		if err != nil {
			return nil, e.Wrap(err, "couldn't update subscription")
		}
		ret := ""
		return &ret, nil
	}

	// If there's no existing subscription, we create a checkout.
	checkoutSessionParams := &stripe.CheckoutSessionParams{
		SuccessURL: stripe.String(os.Getenv("FRONTEND_URI") + "/w/" + strconv.Itoa(workspaceID) + "/upgrade-plan/success"),
		CancelURL:  stripe.String(os.Getenv("FRONTEND_URI") + "/w/" + strconv.Itoa(workspaceID) + "/upgrade-plan/checkoutCanceled"),
		PaymentMethodTypes: stripe.StringSlice([]string{
			"card",
		}),
		Customer: workspace.StripeCustomerID,
		SubscriptionData: &stripe.CheckoutSessionSubscriptionDataParams{
			Items: []*stripe.CheckoutSessionSubscriptionDataItemsParams{
				{Plan: &newBasePrice.ID},
			},
		},
		Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
	}
	checkoutSessionParams.AddExtra("allow_promotion_codes", "true")

	stripeSession, err := r.StripeClient.CheckoutSessions.New(checkoutSessionParams)
	if err != nil {
		return nil, e.Wrap(err, "error creating CheckoutSession in stripe")
	}

	return &stripeSession.ID, nil
}

// UpdateBillingDetails is the resolver for the updateBillingDetails field.
func (r *mutationResolver) UpdateBillingDetails(ctx context.Context, workspaceID int) (*bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	if err := r.validateAdminRole(ctx, workspaceID); err != nil {
		return nil, e.Wrap(err, "must have ADMIN role to update billing details")
	}

	if err := r.updateBillingDetails(ctx, *workspace.StripeCustomerID); err != nil {
		return nil, e.Wrap(err, "error updating billing details")
	}

	return &model.T, nil
}

// CreateSessionComment is the resolver for the createSessionComment field.
func (r *mutationResolver) CreateSessionComment(ctx context.Context, projectID int, sessionSecureID string, sessionTimestamp int, text string, textForEmail string, xCoordinate float64, yCoordinate float64, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, sessionURL string, time float64, authorName string, sessionImage *string, issueTitle *string, issueDescription *string, issueTeamID *string, integrations []*modelInputs.IntegrationType, tags []*modelInputs.SessionCommentTagInput, additionalContext *string) (*model.SessionComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	// All viewers can leave a comment, including guests
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin cannot leave a comment")
	}

	var project model.Project
	if err := r.DB.Where(&model.Project{Model: model.Model{ID: projectID}}).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	sessionImageStr := ""
	if sessionImage != nil {
		sessionImageStr = *sessionImage
	}

	if sessionTimestamp >= math.MaxInt32 {
		log.WithContext(ctx).Warnf("attempted to create session with invalid timestamp %d", sessionTimestamp)
		sessionTimestamp = 0
	}
	sessionComment := &model.SessionComment{
		Admins:          admins,
		ProjectID:       projectID,
		AdminId:         admin.Model.ID,
		SessionId:       session.ID,
		SessionSecureId: session.SecureID,
		SessionImage:    sessionImageStr,
		Timestamp:       sessionTimestamp,
		Text:            text,
		XCoordinate:     xCoordinate,
		YCoordinate:     yCoordinate,
	}
	createSessionCommentSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.createSessionComment",
		tracer.ResourceName("db.createSessionComment"), tracer.Tag("project_id", projectID))
	if err := r.DB.Create(sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating session comment")
	}
	createSessionCommentSpan.Finish()

	if err := r.OpenSearch.UpdateSynchronous(opensearch.IndexSessions, session.ID, map[string]interface{}{"has_comments": true}); err != nil {
		return nil, e.Wrap(err, "error updating session in opensearch")
	}

	// Create associations between tags and comments.
	if len(tags) > 0 {
		// Create the tag if it's a new tag
		newTags := []*model.SessionCommentTag{}
		existingTags := []*model.SessionCommentTag{}
		sessionComments := []model.SessionComment{*sessionComment}

		for _, tag := range tags {
			if tag.ID == nil {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID:       projectID,
					Name:            tag.Name,
					SessionComments: sessionComments,
				}
				newTags = append(newTags, &newSessionCommentTag)
			} else {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID: projectID,
					Name:      tag.Name,
					Model: model.Model{
						ID: *tag.ID,
					},
					SessionComments: sessionComments,
				}
				existingTags = append(existingTags, &newSessionCommentTag)
			}
		}

		if len(newTags) > 0 {
			if err := r.DB.Create(&newTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to create new session tags", err)
			}
		}

		if len(existingTags) > 0 {
			if err := r.DB.Save(&existingTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to update existing session tags", err)
			}
		}
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)
	muteLink := fmt.Sprintf("%v?commentId=%v&ts=%v&muted=1", sessionURL, sessionComment.ID, time)

	r.PrivateWorkerPool.SubmitRecover(func() {
		c := context.Background()
		chunkIdx, chunkTs := r.GetSessionChunk(ctx, session.ID, sessionTimestamp)
		log.WithContext(ctx).Infof("got chunk %d ts %d for session %d ts %d", chunkIdx, chunkTs, session.ID, sessionTimestamp)
		imageBytes, err := r.getSessionScreenshot(c, projectID, session.ID, chunkTs, chunkIdx)
		if err != nil {
			log.WithContext(ctx).Errorf("failed to render screenshot for %d %d %d %s", projectID, session.ID, sessionTimestamp, err)
		} else {
			sessionImageStr = base64.StdEncoding.EncodeToString(imageBytes)
			sessionImage = &sessionImageStr
			if err := r.DB.Model(&model.SessionComment{}).Where(
				&model.SessionComment{Model: model.Model{ID: sessionComment.ID}},
			).Updates(
				model.SessionComment{
					SessionImage: sessionImageStr,
				},
			).Error; err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, fmt.Sprintf("failed to update image for comment %d", sessionComment.ID)))
			}
		}
		if len(taggedAdmins) > 0 && !isGuest {
			r.sendCommentPrimaryNotification(
				c,
				admin,
				*admin.Name,
				taggedAdmins,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				muteLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
				&Email.SessionCommentMentionsAsmId,
			)
		}
		if len(taggedSlackUsers) > 0 && !isGuest {
			r.sendCommentMentionNotification(
				c,
				admin,
				taggedSlackUsers,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
			)
		}
	})

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}
		desc := *issueDescription
		desc += "\n\nSee the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/sessions/%s", os.Getenv("REACT_APP_FRONTEND_URI"), projectID, sessionComment.SessionSecureId)

		if *s == modelInputs.IntegrationTypeLinear &&
			workspace.LinearAccessToken != nil &&
			*workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				textForEmail,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp &&
			workspace.ClickupAccessToken != nil &&
			*workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				*issueTitle,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.SessionCommentID = sessionComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return sessionComment, nil
}

// CreateIssueForSessionComment is the resolver for the createIssueForSessionComment field.
func (r *mutationResolver) CreateIssueForSessionComment(ctx context.Context, projectID int, sessionURL string, sessionCommentID int, authorName string, textForAttachment string, time float64, issueTitle *string, issueDescription *string, issueTeamID *string, integrations []*modelInputs.IntegrationType) (*model.SessionComment, error) {
	var project model.Project
	if err := r.DB.Where("id = ?", projectID).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	sessionComment := &model.SessionComment{}
	if err := r.DB.Preload("Attachments").Where(&model.SessionComment{Model: model.Model{ID: sessionCommentID}}).Find(sessionComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}

		desc := *issueDescription
		desc += "\n\nSee the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/sessions/%s", os.Getenv("REACT_APP_FRONTEND_URI"), projectID, sessionComment.SessionSecureId)

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(workspace, attachment, *issueTitle, *issueDescription, sessionComment.Text, authorName, viewLink, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(workspace, attachment, *issueTitle, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, *issueTitle, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	return sessionComment, nil
}

// DeleteSessionComment is the resolver for the deleteSessionComment field.
func (r *mutationResolver) DeleteSessionComment(ctx context.Context, id int) (*bool, error) {
	var sessionComment model.SessionComment
	if err := r.DB.Where(model.SessionComment{Model: model.Model{ID: id}}).First(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	session, err := r.canAdminModifySession(ctx, sessionComment.SessionSecureId)

	if err != nil {
		return nil, e.Wrap(err, "admin is not session owner")
	}

	if err := r.DB.Delete(&model.SessionComment{Model: model.Model{ID: id}}).Error; err != nil {
		return nil, e.Wrap(err, "error session comment")
	}

	if err := r.DB.Where(&model.ExternalAttachment{SessionCommentID: id}).Delete(&model.ExternalAttachment{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment attachments")
	}

	if err := r.DB.Where(&model.CommentReply{SessionCommentID: id}).Delete(&model.CommentReply{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment replies")
	}

	if err := r.DB.Where(&model.CommentFollower{SessionCommentID: id}).Delete(&model.CommentFollower{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment followers")
	}

	var commentCount int64
	if err := r.DB.Where(&model.SessionComment{SessionSecureId: sessionComment.SessionSecureId}).Count(&commentCount).Error; err != nil {
		return nil, e.Wrap(err, "error counting session comments")
	}

	if commentCount == 0 {
		if err := r.OpenSearch.UpdateSynchronous(
			opensearch.IndexSessions,
			session.ID,
			map[string]interface{}{"has_comments": false},
		); err != nil {
			return nil, e.Wrap(err, "error updating session in opensearch")
		}

	}

	return &model.T, nil
}

// MuteSessionCommentThread is the resolver for the muteSessionCommentThread field.
func (r *mutationResolver) MuteSessionCommentThread(ctx context.Context, id int, hasMuted *bool) (*bool, error) {
	var sessionComment model.SessionComment
	if err := r.DB.Where(model.SessionComment{Model: model.Model{ID: id}}).First(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	_, err := r.canAdminModifySession(ctx, sessionComment.SessionSecureId)
	if err != nil {
		return nil, e.Wrap(err, "admin is not session owner")
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "admin not logged in")
	}

	var commentFollower model.CommentFollower
	if err := r.DB.Where(&model.CommentFollower{SessionCommentID: id, AdminId: admin.ID}).First(&commentFollower).Updates(
		&model.CommentFollower{
			HasMuted: hasMuted,
		}).Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// ReplyToSessionComment is the resolver for the replyToSessionComment field.
func (r *mutationResolver) ReplyToSessionComment(ctx context.Context, commentID int, text string, textForEmail string, sessionURL string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput) (*model.CommentReply, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)
	if isGuest {
		return nil, e.New("must be logged in to add a comment reply")
	}

	var sessionComment model.SessionComment
	if err := r.DB.Preload("Followers").Preload("Threads").Where(model.SessionComment{Model: model.Model{ID: commentID}}).First(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	// All viewers can leave a comment reply, including guests
	_, err := r.canAdminViewSession(ctx, sessionComment.SessionSecureId)
	if err != nil {
		return nil, e.Wrap(err, "admin cannot leave a comment reply")
	}

	var project model.Project
	if err := r.DB.Where(&model.Project{Model: model.Model{ID: sessionComment.ProjectID}}).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	commentReply := &model.CommentReply{
		SessionCommentID: sessionComment.ID,
		Admins:           admins,
		AdminId:          admin.ID,
		Text:             text,
	}
	createSessionCommentReplySpan, _ := tracer.StartSpanFromContext(ctx, "resolver.createSessionCommentReply",
		tracer.ResourceName("db.createSessionCommentReply"), tracer.Tag("project_id", sessionComment.ProjectID))
	if err := r.DB.Create(commentReply).Error; err != nil {
		return nil, e.Wrap(err, "error creating session comment reply")
	}
	createSessionCommentReplySpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", sessionURL, sessionComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", sessionURL, sessionComment.ID)

	if len(taggedAdmins) > 0 {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			*admin.Name,
			taggedAdmins,
			workspace,
			project.ID,
			&sessionComment.ID,
			nil,
			textForEmail,
			viewLink,
			muteLink,
			&sessionComment.SessionImage,
			"replied to",
			"session",
			nil,
			&Email.SessionCommentMentionsAsmId,
		)
	}
	if len(sessionComment.Followers) > 0 {
		var threadIDs []int
		for _, thread := range sessionComment.Threads {
			threadIDs = append(threadIDs, thread.ID)
		}
		r.sendFollowedCommentNotification(
			ctx,
			admin,
			sessionComment.Followers,
			workspace,
			project.ID,
			threadIDs,
			textForEmail,
			viewLink,
			muteLink,
			&sessionComment.SessionImage,
			"replied to",
			"session",
			&Email.SessionCommentMentionsAsmId,
		)
	}

	existingAdminIDs, existingSlackChannelIDs := r.getCommentFollowers(ctx, sessionComment.Followers)
	taggedAdmins = append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedAdmins, taggedSlackUsers, existingAdminIDs, existingSlackChannelIDs)
	for _, f := range newFollowers {
		f.SessionCommentID = commentID
	}

	if len(newFollowers) > 0 {
		if err := r.DB.Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session reply followers", err)
		}
	}

	return commentReply, nil
}

// CreateErrorComment is the resolver for the createErrorComment field.
func (r *mutationResolver) CreateErrorComment(ctx context.Context, projectID int, errorGroupSecureID string, text string, textForEmail string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, errorURL string, authorName string, issueTitle *string, issueDescription *string, issueTeamID *string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to view error group")
	}

	var project model.Project
	if err := r.DB.Where(&model.Project{Model: model.Model{ID: projectID}}).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := []model.Admin{}
	for _, a := range taggedAdmins {
		admins = append(admins,
			model.Admin{
				Model: model.Model{ID: a.ID},
			},
		)
	}

	errorComment := &model.ErrorComment{
		Admins:        admins,
		ProjectID:     projectID,
		AdminId:       admin.Model.ID,
		ErrorId:       errorGroup.ID,
		ErrorSecureId: errorGroup.SecureID,
		Text:          text,
	}

	createErrorCommentSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.createErrorComment",
		tracer.ResourceName("db.createErrorComment"), tracer.Tag("project_id", projectID))

	if err := r.DB.Create(errorComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating error comment")
	}

	createErrorCommentSpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", errorURL, errorComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", errorURL, errorComment.ID)

	if len(taggedAdmins) > 0 && !isGuest {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			authorName,
			taggedAdmins,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"tagged",
			"error",
			nil,
			&Email.ErrorCommentMentionsAsmId,
		)
	}
	if len(taggedSlackUsers) > 0 && !isGuest {
		r.sendCommentMentionNotification(
			ctx,
			admin,
			taggedSlackUsers,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			nil,
			"tagged",
			"error",
			nil,
		)
	}

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		desc := *issueDescription
		desc += "\n\nSee the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/errors/%s", os.Getenv("REACT_APP_FRONTEND_URI"), projectID, errorComment.ErrorSecureId)

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				textForEmail,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, *issueTitle, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.ErrorCommentID = errorComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return errorComment, nil
}

// RemoveErrorIssue is the resolver for the removeErrorIssue field.
func (r *mutationResolver) RemoveErrorIssue(ctx context.Context, errorIssueID int) (*bool, error) {
	var errorCommentID int
	if err := r.DB.
		Model(&model.ExternalAttachment{}).
		Select("error_comment_id").
		Where("id=?", errorIssueID).
		First(&errorCommentID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error issues")
	}

	var errorGroupSecureID string
	if err := r.DB.
		Model(&model.ErrorComment{}).
		Select("error_secure_id").
		Where("id=?", errorCommentID).
		First(&errorGroupSecureID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}

	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}

	var externalAttachment model.ExternalAttachment
	if err := r.DB.
		Model(&model.ExternalAttachment{}).
		Where("id=?", errorIssueID).
		First(&externalAttachment).
		Updates(
			&model.ExternalAttachment{
				Removed: true,
			}).
		Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// MuteErrorCommentThread is the resolver for the muteErrorCommentThread field.
func (r *mutationResolver) MuteErrorCommentThread(ctx context.Context, id int, hasMuted *bool) (*bool, error) {
	var errorGroupSecureID string
	if err := r.DB.
		Model(&model.ErrorComment{}).
		Select("error_secure_id").
		Where("id=?", id).
		First(&errorGroupSecureID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}
	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "admin not logged in")
	}

	var commentFollower model.CommentFollower
	if err := r.DB.Where(&model.CommentFollower{ErrorCommentID: id, AdminId: admin.ID}).
		First(&commentFollower).
		Updates(
			&model.CommentFollower{
				HasMuted: hasMuted,
			}).
		Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// CreateIssueForErrorComment is the resolver for the createIssueForErrorComment field.
func (r *mutationResolver) CreateIssueForErrorComment(ctx context.Context, projectID int, errorURL string, errorCommentID int, authorName string, textForAttachment string, issueTitle *string, issueDescription *string, issueTeamID *string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	var project model.Project
	if err := r.DB.Where(&model.Project{Model: model.Model{ID: projectID}}).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	errorComment := &model.ErrorComment{}
	if err := r.DB.Preload("Attachments").Where(&model.ErrorComment{Model: model.Model{ID: errorCommentID}}).Find(errorComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v", errorURL)

	if issueDescription == nil {
		return nil, e.New("issue description cannot be nil")
	}

	desc := *issueDescription
	desc += "\n\nSee the error page on Highlight:\n"
	desc += fmt.Sprintf("%s/%d/errors/%s", os.Getenv("REACT_APP_FRONTEND_URI"), projectID, errorComment.ErrorSecureId)

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				errorComment.Text,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				workspace,
				attachment,
				*issueTitle,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, *issueTitle, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	return errorComment, nil
}

// DeleteErrorComment is the resolver for the deleteErrorComment field.
func (r *mutationResolver) DeleteErrorComment(ctx context.Context, id int) (*bool, error) {
	var errorGroupSecureID string
	if err := r.DB.Table("error_comments").Select("error_secure_id").Where("id=?", id).Scan(&errorGroupSecureID).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}
	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}
	if err := r.DB.Delete(&model.ErrorComment{Model: model.Model{ID: id}}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting error_comment")
	}
	if err := r.DB.Where(&model.ExternalAttachment{ErrorCommentID: id}).Delete(&model.ExternalAttachment{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment attachments")
	}
	return &model.T, nil
}

// ReplyToErrorComment is the resolver for the replyToErrorComment field.
func (r *mutationResolver) ReplyToErrorComment(ctx context.Context, commentID int, text string, textForEmail string, errorURL string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput) (*model.CommentReply, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)
	if isGuest {
		return nil, e.New("must be logged in to add a comment reply")
	}

	var errorComment model.ErrorComment
	if err := r.DB.Preload("Threads").Preload("Followers").Where(model.ErrorComment{Model: model.Model{ID: commentID}}).First(&errorComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comment")
	}

	_, err := r.canAdminViewErrorGroup(ctx, errorComment.ErrorSecureId, false)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to view error group")
	}

	var project model.Project
	if err := r.DB.Where(&model.Project{Model: model.Model{ID: errorComment.ProjectID}}).First(&project).Error; err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	commentReply := &model.CommentReply{
		ErrorCommentID: errorComment.ID,
		Admins:         admins,
		AdminId:        admin.ID,
		Text:           text,
	}
	createErrorCommentReplySpan, _ := tracer.StartSpanFromContext(ctx, "resolver.createErrorCommentReply",
		tracer.ResourceName("db.createErrorCommentReply"), tracer.Tag("project_id", errorComment.ProjectID))
	if err := r.DB.Create(commentReply).Error; err != nil {
		return nil, e.Wrap(err, "error creating error comment reply")
	}
	createErrorCommentReplySpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", errorURL, errorComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", errorURL, errorComment.ID)

	if len(taggedAdmins) > 0 && !isGuest {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			*admin.Name,
			taggedAdmins,
			workspace,
			project.ID, nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"replied to",
			"error",
			nil,
			&Email.ErrorCommentMentionsAsmId,
		)
	}
	if len(errorComment.Followers) > 0 && !isGuest {
		var threadIDs []int
		for _, thread := range errorComment.Threads {
			threadIDs = append(threadIDs, thread.ID)
		}
		r.sendFollowedCommentNotification(
			ctx,
			admin,
			errorComment.Followers,
			workspace,
			project.ID,
			threadIDs,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"replied to",
			"error",
			&Email.ErrorCommentMentionsAsmId,
		)
	}

	existingAdminIDs, existingSlackChannelIDs := r.getCommentFollowers(ctx, errorComment.Followers)
	taggedAdmins = append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedAdmins, taggedSlackUsers, existingAdminIDs, existingSlackChannelIDs)
	for _, f := range newFollowers {
		f.ErrorCommentID = commentID
	}

	if len(newFollowers) > 0 {
		if err := r.DB.Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new error reply followers", err)
		}
	}

	return commentReply, nil
}

// AddIntegrationToProject is the resolver for the addIntegrationToProject field.
func (r *mutationResolver) AddIntegrationToProject(ctx context.Context, integrationType *modelInputs.IntegrationType, projectID int, code string) (bool, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return false, e.Wrap(err, "admin is not in project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeLinear {
		if err := r.AddLinearToWorkspace(workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeSlack {
		if err := r.AddSlackToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeFront {
		if err := r.AddFrontToProject(ctx, project, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeVercel {
		if err := r.AddVercelToWorkspace(workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeDiscord {
		if err := r.AddDiscordToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeClickUp {
		// TODO - see if we can remove this code path
		if err := r.AddClickUpToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else {
		return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
	}

	return true, nil
}

// RemoveIntegrationFromProject is the resolver for the removeIntegrationFromProject field.
func (r *mutationResolver) RemoveIntegrationFromProject(ctx context.Context, integrationType *modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return false, e.Wrap(err, "admin is not in project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeLinear {
		if err := r.RemoveLinearFromWorkspace(workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeSlack {
		if err := r.RemoveSlackFromWorkspace(workspace, projectID); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeZapier {
		if err := r.RemoveZapierFromWorkspace(project); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeFront {
		if err := r.RemoveFrontFromProject(project); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeVercel {
		if err := r.RemoveVercelFromWorkspace(workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeDiscord {
		if err := r.RemoveDiscordFromWorkspace(workspace); err != nil {
			return false, err
		}
	} else {
		return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
	}

	return true, nil
}

// AddIntegrationToWorkspace is the resolver for the addIntegrationToWorkspace field.
func (r *mutationResolver) AddIntegrationToWorkspace(ctx context.Context, integrationType *modelInputs.IntegrationType, workspaceID int, code string) (bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeClickUp {
		if err := r.AddClickUpToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeHeight {
		if err := r.AddHeightToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}

	} else {
		return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
	}

	return true, nil
}

// RemoveIntegrationFromWorkspace is the resolver for the removeIntegrationFromWorkspace field.
func (r *mutationResolver) RemoveIntegrationFromWorkspace(ctx context.Context, integrationType modelInputs.IntegrationType, workspaceID int) (bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if integrationType == modelInputs.IntegrationTypeClickUp {
		if err := r.RemoveClickUpFromWorkspace(workspace); err != nil {
			return false, err
		}
	} else {
		if err := r.RemoveIntegrationFromWorkspaceAndProjects(workspace, integrationType); err != nil {
			return false, err
		}

	}

	return true, nil
}

// SyncSlackIntegration is the resolver for the syncSlackIntegration field.
func (r *mutationResolver) SyncSlackIntegration(ctx context.Context, projectID int) (*modelInputs.SlackSyncResponse, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	response := modelInputs.SlackSyncResponse{
		Success:               true,
		NewChannelsAddedCount: 0,
	}
	if err != nil {
		return &response, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return &response, err
	}
	slackChannels, newChannelsCount, err := r.GetSlackChannelsFromSlack(ctx, workspace.ID)

	if err != nil {
		return &response, err
	}

	channelBytes, err := json.Marshal(slackChannels)
	if err != nil {
		return &response, e.Wrap(err, "error marshaling slack channels")
	}
	channelString := string(channelBytes)
	if err := r.DB.Model(&workspace).Updates(&model.Workspace{
		SlackChannels: &channelString,
	}).Error; err != nil {
		return &response, e.Wrap(err, "error updating workspace slack channels")
	}

	response.NewChannelsAddedCount = newChannelsCount

	return &response, nil
}

// CreateMetricMonitor is the resolver for the createMetricMonitor field.
func (r *mutationResolver) CreateMetricMonitor(ctx context.Context, projectID int, name string, aggregator modelInputs.MetricAggregator, periodMinutes *int, threshold float64, units *string, metricToMonitor string, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, filters []*modelInputs.MetricTagFilterInput) (*model.MetricMonitor, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
	if err != nil {
		return nil, err
	}

	emailsString, err := r.MarshalAlertEmails(emails)
	if err != nil {
		return nil, err
	}

	var mmFilters []*model.DashboardMetricFilter
	for _, f := range filters {
		mmFilters = append(mmFilters, &model.DashboardMetricFilter{
			Tag:   f.Tag,
			Op:    f.Op,
			Value: f.Value,
		})
	}

	newMetricMonitor := &model.MetricMonitor{
		ProjectID:         projectID,
		Name:              name,
		Aggregator:        aggregator,
		PeriodMinutes:     periodMinutes,
		Threshold:         threshold,
		Units:             units,
		MetricToMonitor:   metricToMonitor,
		ChannelsToNotify:  channelsString,
		EmailsToNotify:    emailsString,
		LastAdminToEditID: admin.ID,
		Filters:           mmFilters,
		AlertIntegrations: model.AlertIntegrations{
			DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
			WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
		},
	}

	if err := r.DB.Create(newMetricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error creating a new error alert")
	}
	if err := newMetricMonitor.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageForMetricMonitorInput{Workspace: workspace, Admin: admin, MonitorID: &newMetricMonitor.ID, Project: project, OperationName: "created", OperationDescription: "Monitor alerts will be sent here", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return newMetricMonitor, nil
}

// UpdateMetricMonitor is the resolver for the updateMetricMonitor field.
func (r *mutationResolver) UpdateMetricMonitor(ctx context.Context, metricMonitorID int, projectID int, name *string, aggregator *modelInputs.MetricAggregator, periodMinutes *int, threshold *float64, units *string, metricToMonitor *string, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, disabled *bool, filters []*modelInputs.MetricTagFilterInput) (*model.MetricMonitor, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	metricMonitor := &model.MetricMonitor{}
	if err := r.DB.Where(&model.MetricMonitor{Model: model.Model{ID: metricMonitorID}, ProjectID: projectID}).Find(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitor")
	}

	var createdFilterIDs []int
	for _, f := range filters {
		var created struct{ ID int }
		if err := r.DB.Where(&model.DashboardMetricFilter{
			MetricMonitorID: metricMonitor.ID,
			Tag:             f.Tag,
		}).Clauses(clause.Returning{}, clause.OnConflict{
			OnConstraint: model.DASHBOARD_METRIC_FILTERS_UNIQ,
			DoNothing:    true,
		}).Create(&model.DashboardMetricFilter{
			MetricMonitorID: metricMonitor.ID,
			Tag:             f.Tag,
			Op:              f.Op,
			Value:           f.Value,
		}).Scan(&created).Error; err != nil {
			return nil, e.Wrap(err, "failed to create metric monitor filter")
		}
		createdFilterIDs = append(createdFilterIDs, created.ID)
	}
	r.DB.Exec(`DELETE FROM dashboard_metric_filters WHERE metric_monitor_id = ? AND id NOT IN ?`, metricMonitor.ID, createdFilterIDs)

	if slackChannels != nil {
		channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
		if err != nil {
			return nil, e.Wrap(err, "error marshalling slack channels")
		}
		metricMonitor.ChannelsToNotify = channelsString
	}

	metricMonitor.AlertIntegrations = model.AlertIntegrations{
		DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
		WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
	}

	if emails != nil {
		emailsString, err := r.MarshalAlertEmails(emails)
		if err != nil {
			return nil, err
		}
		metricMonitor.EmailsToNotify = emailsString
	}

	if name != nil {
		metricMonitor.Name = *name
	}
	if aggregator != nil {
		metricMonitor.Aggregator = *aggregator
	}
	metricMonitor.PeriodMinutes = periodMinutes
	if threshold != nil {
		metricMonitor.Threshold = *threshold
	}
	metricMonitor.Units = units
	if metricToMonitor != nil {
		metricMonitor.MetricToMonitor = *metricToMonitor
	}

	metricMonitor.LastAdminToEditID = admin.ID

	if disabled != nil {
		metricMonitor.Disabled = disabled
	}

	if err := r.DB.Save(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error updating metric monitor")
	}

	if err := metricMonitor.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageForMetricMonitorInput{Workspace: workspace, Admin: admin, MonitorID: &metricMonitorID, Project: project, OperationName: "updated", OperationDescription: "Monitor alerts will now be sent to this channel.", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return metricMonitor, nil
}

// CreateErrorAlert is the resolver for the createErrorAlert field.
func (r *mutationResolver) CreateErrorAlert(ctx context.Context, projectID int, name string, countThreshold int, thresholdWindow int, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, environments []*string, regexGroups []*string, frequency int) (*model.ErrorAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	envString, err := r.MarshalEnvironments(environments)
	if err != nil {
		return nil, err
	}

	channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
	if err != nil {
		return nil, err
	}

	regexGroupsBytes, err := json.Marshal(regexGroups)
	if err != nil {
		return nil, e.Wrap(err, "error marshalling regex groups")
	}
	regexGroupsString := string(regexGroupsBytes)

	emailsString, err := r.MarshalAlertEmails(emails)
	if err != nil {
		return nil, err
	}

	newAlert := &model.ErrorAlert{
		Alert: model.Alert{
			ProjectID:            projectID,
			OrganizationID:       projectID,
			ExcludedEnvironments: envString,
			CountThreshold:       countThreshold,
			ThresholdWindow:      &thresholdWindow,
			Type:                 &model.AlertType.ERROR,
			ChannelsToNotify:     channelsString,
			EmailsToNotify:       emailsString,
			Name:                 &name,
			LastAdminToEditID:    admin.ID,
			Frequency:            frequency,
		},
		RegexGroups: &regexGroupsString,
		AlertIntegrations: model.AlertIntegrations{
			DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
			WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
		},
	}

	if err := r.DB.Create(newAlert).Error; err != nil {
		return nil, e.Wrap(err, "error creating a new error alert")
	}
	if err := newAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &newAlert.ID, Project: project, OperationName: "created", OperationDescription: "Alerts will now be sent to this channel.", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return newAlert, nil
}

// UpdateErrorAlert is the resolver for the updateErrorAlert field.
func (r *mutationResolver) UpdateErrorAlert(ctx context.Context, projectID int, name *string, errorAlertID int, countThreshold *int, thresholdWindow *int, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, environments []*string, regexGroups []*string, frequency *int, disabled *bool) (*model.ErrorAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	projectAlert := &model.ErrorAlert{}
	if err := r.DB.Where(&model.ErrorAlert{Model: model.Model{ID: errorAlertID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error querying error alert")
	}

	if environments != nil {
		envString, err := r.MarshalEnvironments(environments)
		if err != nil {
			return nil, err
		}

		projectAlert.ExcludedEnvironments = envString
	}

	if slackChannels != nil {
		channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
		if err != nil {
			return nil, err
		}
		regexGroupsBytes, err := json.Marshal(regexGroups)
		if err != nil {
			return nil, e.Wrap(err, "error marshalling regex groups")
		}
		regexGroupsString := string(regexGroupsBytes)

		projectAlert.RegexGroups = &regexGroupsString
		projectAlert.ChannelsToNotify = channelsString
		projectAlert.RegexGroups = &regexGroupsString
	}

	if emails != nil {
		emailsString, err := r.MarshalAlertEmails(emails)
		if err != nil {
			return nil, err
		}

		projectAlert.EmailsToNotify = emailsString
	}

	if countThreshold != nil {
		projectAlert.CountThreshold = *countThreshold
	}
	if thresholdWindow != nil {
		projectAlert.ThresholdWindow = thresholdWindow
	}
	if name != nil {
		projectAlert.Name = name
	}

	projectAlert.LastAdminToEditID = admin.ID

	if frequency != nil {
		projectAlert.Frequency = *frequency
	}
	if disabled != nil {
		projectAlert.Disabled = disabled
	}

	projectAlert.AlertIntegrations = model.AlertIntegrations{
		DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
		WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
	}

	if err := r.DB.Model(&model.ErrorAlert{
		Model: model.Model{
			ID: errorAlertID,
		},
	}).Where("project_id = ?", projectID).Updates(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields")
	}

	if err := projectAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &errorAlertID, Project: project, OperationName: "updated", OperationDescription: "Alerts will now be sent to this channel.", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return projectAlert, nil
}

// DeleteErrorAlert is the resolver for the deleteErrorAlert field.
func (r *mutationResolver) DeleteErrorAlert(ctx context.Context, projectID int, errorAlertID int) (*model.ErrorAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	projectAlert := &model.ErrorAlert{}
	if err := r.DB.Where(&model.ErrorAlert{Model: model.Model{ID: errorAlertID}, Alert: model.Alert{ProjectID: projectID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "this error alert does not exist in this project.")
	}

	if err := r.DB.Delete(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete error alert")
	}

	if err := projectAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &errorAlertID, Project: project, OperationName: "deleted", OperationDescription: "Alerts will no longer be sent to this channel.", IncludeEditLink: false}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return projectAlert, nil
}

// DeleteMetricMonitor is the resolver for the deleteMetricMonitor field.
func (r *mutationResolver) DeleteMetricMonitor(ctx context.Context, projectID int, metricMonitorID int) (*model.MetricMonitor, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	metricMonitor := &model.MetricMonitor{}
	if err := r.DB.Where(&model.MetricMonitor{Model: model.Model{ID: metricMonitorID}, ProjectID: projectID}).Find(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "this metric monitor does not exist in this project.")
	}

	if err := r.DB.Delete(metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete metric monitor")
	}

	if err := metricMonitor.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageForMetricMonitorInput{Workspace: workspace, Admin: admin, MonitorID: &metricMonitorID, Project: project, OperationName: "deleted", OperationDescription: "Monitor alerts will no longer be sent to this channel.", IncludeEditLink: false}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return metricMonitor, nil
}

// UpdateSessionAlertIsDisabled is the resolver for the updateSessionAlertIsDisabled field.
func (r *mutationResolver) UpdateSessionAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	sessionAlert := &model.SessionAlert{
		Alert: model.Alert{
			Disabled: &disabled,
		},
	}

	if err := r.DB.Model(&model.SessionAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(sessionAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields for new session alert")
	}

	return sessionAlert, err
}

// UpdateErrorAlertIsDisabled is the resolver for the updateErrorAlertIsDisabled field.
func (r *mutationResolver) UpdateErrorAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.ErrorAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	errorAlert := &model.ErrorAlert{
		Alert: model.Alert{
			Disabled: &disabled,
		},
	}

	if err := r.DB.Model(&model.ErrorAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(errorAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating disabled field for error alert")
	}

	return errorAlert, err
}

// UpdateMetricMonitorIsDisabled is the resolver for the updateMetricMonitorIsDisabled field.
func (r *mutationResolver) UpdateMetricMonitorIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.MetricMonitor, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	metricMonitor := &model.MetricMonitor{
		Disabled: &disabled,
	}

	if err := r.DB.Model(&model.MetricMonitor{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error updating disabled field for metric monitor")
	}

	return metricMonitor, err
}

// UpdateSessionAlert is the resolver for the updateSessionAlert field.
func (r *mutationResolver) UpdateSessionAlert(ctx context.Context, id int, input modelInputs.SessionAlertInput) (*model.SessionAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	sessionAlert, err := alerts.BuildSessionAlert(project, workspace, admin, input)

	if err != nil {
		return nil, e.Wrap(err, "failed to build session feedback alert")
	}

	if err := r.DB.Model(&model.SessionAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", input.ProjectID).Updates(sessionAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating session alert")
	}

	if err := sessionAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &id, Project: project, OperationName: "updated", OperationDescription: "Alerts will now be sent to this channel.", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return sessionAlert, nil
}

// CreateSessionAlert is the resolver for the createSessionAlert field.
func (r *mutationResolver) CreateSessionAlert(ctx context.Context, input modelInputs.SessionAlertInput) (*model.SessionAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	sessionAlert, err := alerts.BuildSessionAlert(project, workspace, admin, input)

	if err != nil {
		return nil, e.Wrap(err, "failed to build session feedback alert")
	}

	if err := r.DB.Create(sessionAlert).Error; err != nil {
		return nil, e.Wrap(err, "error creating a new session feedback alert")
	}
	if err := sessionAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &sessionAlert.ID, Project: project, OperationName: "created", OperationDescription: "Alerts will now be sent to this channel.", IncludeEditLink: true}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return sessionAlert, nil
}

// DeleteSessionAlert is the resolver for the deleteSessionAlert field.
func (r *mutationResolver) DeleteSessionAlert(ctx context.Context, projectID int, sessionAlertID int) (*model.SessionAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	projectAlert := &model.SessionAlert{}
	if err := r.DB.Where(&model.ErrorAlert{Model: model.Model{ID: sessionAlertID}, Alert: model.Alert{ProjectID: projectID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "this session alert does not exist in this project.")
	}

	if err := r.DB.Delete(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete session alert")
	}

	if err := projectAlert.SendWelcomeSlackMessage(ctx, &model.SendWelcomeSlackMessageInput{Workspace: workspace, Admin: admin, AlertID: &sessionAlertID, Project: project, OperationName: "deleted", OperationDescription: "Alerts will no longer be sent to this channel.", IncludeEditLink: false}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return projectAlert, nil
}

// UpdateLogAlert is the resolver for the updateLogAlert field.
func (r *mutationResolver) UpdateLogAlert(ctx context.Context, id int, input modelInputs.LogAlertInput) (*model.LogAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	alert, err := alerts.BuildLogAlert(project, workspace, admin, input)
	if err != nil {
		return nil, e.Wrap(err, "failed to build log alert")
	}
	alert.ID = id

	if err := r.DB.Model(&model.LogAlert{Model: model.Model{ID: id}}).
		Where("project_id = ?", input.ProjectID).
		Save(alert).Error; err != nil {
		return nil, e.Wrap(err, "error updating log alert")
	}

	return alert, nil
}

// CreateLogAlert is the resolver for the createLogAlert field.
func (r *mutationResolver) CreateLogAlert(ctx context.Context, input modelInputs.LogAlertInput) (*model.LogAlert, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	alert, err := alerts.BuildLogAlert(project, workspace, admin, input)
	if err != nil {
		return nil, e.Wrap(err, "failed to build log alert")
	}

	if err := r.DB.Create(alert).Error; err != nil {
		return nil, e.Wrap(err, "error creating a new log alert")
	}

	return alert, nil
}

// DeleteLogAlert is the resolver for the deleteLogAlert field.
func (r *mutationResolver) DeleteLogAlert(ctx context.Context, projectID int, id int) (*model.LogAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	alert := &model.LogAlert{}
	if err := r.DB.Model(&model.LogAlert{Model: model.Model{ID: id}}).
		Where("project_id = ?", projectID).
		Find(&alert).Error; err != nil {
		return nil, e.Wrap(err, "this log alert does not exist in this project.")
	}

	if err := r.DB.Delete(alert).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete log alert")
	}

	return alert, nil
}

// UpdateLogAlertIsDisabled is the resolver for the updateLogAlertIsDisabled field.
func (r *mutationResolver) UpdateLogAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.LogAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in project")
	}

	alert := &model.LogAlert{
		Alert: model.Alert{
			Disabled: &disabled,
		},
	}

	if err := r.DB.Model(&model.LogAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(alert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields for new session alert")
	}

	return alert, err
}

// UpdateSessionIsPublic is the resolver for the updateSessionIsPublic field.
func (r *mutationResolver) UpdateSessionIsPublic(ctx context.Context, sessionSecureID string, isPublic bool) (*model.Session, error) {
	session, err := r.canAdminModifySession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	if err := r.DB.Model(session).Updates(&model.Session{
		IsPublic: &isPublic,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error updating session is_public")
	}

	if err := r.OpenSearch.Update(opensearch.IndexSessions, session.ID, map[string]interface{}{"is_public": isPublic}); err != nil {
		return nil, e.Wrap(err, "error updating session in opensearch")
	}

	return session, nil
}

// UpdateErrorGroupIsPublic is the resolver for the updateErrorGroupIsPublic field.
func (r *mutationResolver) UpdateErrorGroupIsPublic(ctx context.Context, errorGroupSecureID string, isPublic bool) (*model.ErrorGroup, error) {
	errorGroup, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}
	if err := r.DB.Model(errorGroup).Update("IsPublic", isPublic).Error; err != nil {
		return nil, e.Wrap(err, "error updating error group is_public")
	}
	if err := r.OpenSearch.Update(opensearch.IndexErrorsCombined, errorGroup.ID, map[string]interface{}{
		"IsPublic": isPublic,
	}); err != nil {
		return nil, e.Wrap(err, "error updating error group IsPublic in OpenSearch")
	}

	return errorGroup, nil
}

// UpdateAllowMeterOverage is the resolver for the updateAllowMeterOverage field.
func (r *mutationResolver) UpdateAllowMeterOverage(ctx context.Context, workspaceID int, allowMeterOverage bool) (*model.Workspace, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	err = r.validateAdminRole(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "must have ADMIN role to modify meter overage settings")
	}

	if err := r.DB.Model(&workspace).Updates(map[string]interface{}{
		"AllowMeterOverage": allowMeterOverage,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error updating AllowMeterOverage")
	}

	return workspace, nil
}

// SubmitRegistrationForm is the resolver for the submitRegistrationForm field.
func (r *mutationResolver) SubmitRegistrationForm(ctx context.Context, workspaceID int, teamSize string, role string, useCase string, heardAbout string, pun *string) (*bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	registrationData := &model.RegistrationData{
		WorkspaceID: workspaceID,
		TeamSize:    &teamSize,
		Role:        &role,
		UseCase:     &useCase,
		HeardAbout:  &heardAbout,
		Pun:         pun,
	}

	if err := r.DB.Create(registrationData).Error; err != nil {
		return nil, e.Wrap(err, "error creating registration")
	}

	if workspace.EligibleForTrialExtension {
		if err := r.DB.Model(workspace).Updates(map[string]interface{}{
			"EligibleForTrialExtension": false,
			"TrialEndDate":              workspace.TrialEndDate.Add(7 * 24 * time.Hour), // add 7 days to the current end date
		}).Error; err != nil {
			return nil, e.Wrap(err, "error clearing EligibleForTrialExtension flag")
		}
	}

	return &model.T, nil
}

// RequestAccess is the resolver for the requestAccess field.
func (r *mutationResolver) RequestAccess(ctx context.Context, projectID int) (*bool, error) {
	// RequestAccessMinimumDelay is the minimum time required between requests from an admin (across workspaces)
	const RequestAccessMinimumDelay = time.Minute * 10

	span, _ := tracer.StartSpanFromContext(ctx, "private-graph.RequestAccess", tracer.ResourceName("handler"), tracer.Tag("project_id", projectID))
	defer span.Finish()
	// sleep up to 10 ms to avoid leaking metadata about whether the project exists or not (how many queries deep we went).
	time.Sleep(time.Millisecond * time.Duration(10*rand.Float64()))

	// Any errors are logged but not returned to avoid leaking metadata
	// to the client (such as whether the project exists
	// or they have access to send an access request).
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "user is not logged in"))
		return &model.T, nil
	}

	var project model.Project
	if err := r.DB.Select("workspace_id").Where(&model.Project{Model: model.Model{ID: projectID}}).First(&project).Error; err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error querying project"))
		return &model.T, nil
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error querying workspace"))
		return &model.T, nil
	}

	request := &model.WorkspaceAccessRequest{
		AdminID:                admin.ID,
		LastRequestedWorkspace: workspace.ID,
	}

	query := r.DB.Where(model.WorkspaceAccessRequest{AdminID: admin.ID}).Clauses(clause.Returning{}, clause.OnConflict{
		Columns: []clause.Column{{Name: "admin_id"}},
		DoUpdates: clause.Assignments(map[string]interface{}{
			"updated_at":               time.Now(),
			"last_requested_workspace": workspace.ID,
		}),
		Where: clause.Where{
			Exprs: []clause.Expression{
				clause.Lt{
					Column: "workspace_access_requests.updated_at",
					Value:  time.Now().Add(-RequestAccessMinimumDelay),
				},
			},
		},
	}).Create(&request)
	if err := query.Error; err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error upserting access requests"))
		return &model.T, nil
	}

	// no rows updated, so user recently requested access. ignore the request
	if query.RowsAffected == 0 {
		return &model.T, nil
	}

	var workspaceAdmins []*model.Admin
	if err := r.DB.Order("created_at ASC").Model(workspace).Limit(2).Association("Admins").Find(&workspaceAdmins, "role=?", model.AdminRole.ADMIN); err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error getting admins for the workspace"))
		return &model.T, nil
	}

	for _, a := range workspaceAdmins {
		if a != nil {
			queryParams := url.Values{
				"autoinvite_email": {*admin.Email},
			}
			inviteLink := fmt.Sprintf("%s/w/%d/team?%s", os.Getenv("FRONTEND_URI"), workspace.ID, queryParams.Encode())
			if _, err := r.SendWorkspaceRequestEmail(*admin.Name, *admin.Email, *workspace.Name,
				*a.Name, *a.Email, inviteLink); err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "failed to send request access email"))
				return &model.T, nil
			}
		}
	}
	return &model.T, nil
}

// ModifyClearbitIntegration is the resolver for the modifyClearbitIntegration field.
func (r *mutationResolver) ModifyClearbitIntegration(ctx context.Context, workspaceID int, enabled bool) (*bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return &enabled, e.Wrap(err, "admin does not have access to this workspace")
	}
	if pricing.MustUpgradeForClearbit(workspace.PlanTier) {
		return nil, nil
	}
	workspace.ClearbitEnabled = enabled
	if err := r.DB.Model(workspace).Update("ClearbitEnabled", &enabled).Error; err != nil {
		return &enabled, e.Wrap(err, "failed to update workspace clearbit state")
	}
	return &enabled, nil
}

// UpsertDashboard is the resolver for the upsertDashboard field.
func (r *mutationResolver) UpsertDashboard(ctx context.Context, id *int, projectID int, name string, metrics []*modelInputs.DashboardMetricConfigInput, layout *string, isDefault *bool) (int, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return -1, err
	}

	if _, err := r.isAdminInProject(ctx, projectID); err != nil {
		return -1, err
	}

	var dashboard *model.Dashboard = &model.Dashboard{ProjectID: projectID}
	if id != nil {
		if err := r.DB.Preload("Metrics").Where(&model.Dashboard{Model: model.Model{ID: *id}}).FirstOrCreate(&dashboard).Error; err != nil {
			return -1, err
		}
	} else {
		if err := r.DB.Create(&dashboard).Error; err != nil {
			return -1, err
		}
	}

	for _, m := range dashboard.Metrics {
		if m != nil {
			if err := r.DB.Delete(&m).Error; err != nil {
				return -1, err
			}
		}
	}
	if err := r.DB.Model(&dashboard).Association("Metrics").Clear(); err != nil {
		return -1, e.Wrap(err, "failed to clear previous metrics")
	}

	for _, m := range metrics {
		var filters []*model.DashboardMetricFilter
		for _, f := range m.Filters {
			filters = append(filters, &model.DashboardMetricFilter{
				Tag:   f.Tag,
				Op:    f.Op,
				Value: f.Value,
			})
		}
		dashboardMetric := model.DashboardMetric{
			Name:                     m.Name,
			Description:              m.Description,
			ComponentType:            m.ComponentType,
			ChartType:                m.ChartType,
			Aggregator:               m.Aggregator,
			MaxGoodValue:             m.MaxGoodValue,
			MaxNeedsImprovementValue: m.MaxNeedsImprovementValue,
			PoorValue:                m.PoorValue,
			Units:                    m.Units,
			HelpArticle:              m.HelpArticle,
			MinValue:                 m.MinValue,
			MinPercentile:            m.MinPercentile,
			MaxValue:                 m.MaxValue,
			MaxPercentile:            m.MaxPercentile,
			Filters:                  filters,
			Groups:                   m.Groups,
		}
		if err := r.DB.Model(&dashboard).Association("Metrics").Append(&dashboardMetric); err != nil {
			return -1, e.Wrap(err, "error updating fields")
		}
	}

	// Update the existing record if it already exists
	dashboard.Name = name
	dashboard.LastAdminToEditID = &admin.ID
	dashboard.Layout = layout
	dashboard.IsDefault = isDefault
	if err := r.DB.Save(&dashboard).Error; err != nil {
		return dashboard.ID, err
	}

	return dashboard.ID, nil
}

// DeleteDashboard is the resolver for the deleteDashboard field.
func (r *mutationResolver) DeleteDashboard(ctx context.Context, id int) (bool, error) {
	var dashboard model.Dashboard
	if result := r.DB.First(&dashboard, id); result.Error != nil {
		return false, result.Error
	}

	if _, err := r.isAdminInProject(ctx, dashboard.ProjectID); err != nil {
		return false, err
	}

	if dashboard.IsDefault != nil && *dashboard.IsDefault {
		return false, e.New("cannot delete default dashboard")
	}

	if result := r.DB.Where("dashboard_id = ?", id).Delete(&model.DashboardMetric{}); result.Error != nil {
		return false, result.Error
	}

	if result := r.DB.Delete(&dashboard, id); result.Error != nil {
		return false, result.Error
	}

	return true, nil
}

// DeleteSessions is the resolver for the deleteSessions field.
func (r *mutationResolver) DeleteSessions(ctx context.Context, projectID int, query string, sessionCount int) (bool, error) {
	if util.IsDevOrTestEnv() {
		return false, nil
	}

	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return false, err
	}

	email := ""
	if admin.Email != nil {
		email = *admin.Email
	}

	firstName := ""
	if admin.FirstName != nil {
		firstName = *admin.FirstName
	}

	role, err := r.GetAdminRole(ctx, admin.ID, project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if role != model.AdminRole.ADMIN {
		return false, e.New("Must be admin role to delete sessions")
	}

	_, err = r.StepFunctions.DeleteSessionsByQuery(ctx, utils.QuerySessionsInput{
		ProjectId:    projectID,
		Email:        email,
		FirstName:    firstName,
		Query:        query,
		SessionCount: sessionCount,
		DryRun:       util.IsDevOrTestEnv(),
	})

	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateVercelProjectMappings is the resolver for the updateVercelProjectMappings field.
func (r *mutationResolver) UpdateVercelProjectMappings(ctx context.Context, projectID int, projectMappings []*modelInputs.VercelProjectMappingInput) (bool, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	workspaceId := project.WorkspaceID
	workspace, err := r.GetWorkspace(workspaceId)
	if err != nil {
		return false, err
	}

	if workspace.VercelAccessToken == nil {
		return false, e.New("workspace does not have an access token")
	}

	vercelProjects, err := vercel.GetProjects(*workspace.VercelAccessToken, workspace.VercelTeamID)
	if err != nil {
		return false, err
	}

	vercelProjectsById := map[string]*modelInputs.VercelProject{}
	for _, p := range vercelProjects {
		vercelProjectsById[p.ID] = p
	}

	configs := []*model.VercelIntegrationConfig{}
	for _, m := range projectMappings {
		var project *model.Project

		if m.NewProjectName != nil && *m.NewProjectName != "" {
			// for projects that don't exist
			n := *m.NewProjectName
			p, err := r.CreateProject(ctx, n, workspaceId)
			if err != nil {
				return false, e.Wrap(err, "cannot access Vercel project")
			}
			project = p
		} else {
			// for projects that already exist.
			p, err := r.isAdminInProject(ctx, *m.ProjectID)
			if err != nil {
				return false, err
			}
			project = p
		}

		if project.Secret == nil {
			continue
		}

		vercelProject, ok := vercelProjectsById[m.VercelProjectID]
		if !ok {
			return false, e.New("cannot access Vercel project")
		}

		var sourceMapEnvId *string
		var projectEnvId *string
		for _, e := range vercelProject.Env {
			if e.Key == vercel.SourcemapEnvKey {
				sourceMapEnvId = &e.ID
			}
			if e.Key == vercel.ProjectIdEnvVar {
				projectEnvId = &e.ID
			}
		}

		if err := vercel.SetEnvVariable(m.VercelProjectID, *project.Secret, *workspace.VercelAccessToken,
			workspace.VercelTeamID, sourceMapEnvId, vercel.SourcemapEnvKey); err != nil {
			return false, err
		}

		if err := vercel.SetEnvVariable(m.VercelProjectID, project.VerboseID(), *workspace.VercelAccessToken,
			workspace.VercelTeamID, projectEnvId, vercel.ProjectIdEnvVar); err != nil {
			return false, err
		}

		if err := vercel.CreateLogDrain(workspace.VercelTeamID, m.VercelProjectID, project.VerboseID(), "highlight-log-drain", *workspace.VercelAccessToken); err != nil {
			return false, err
		}

		configs = append(configs, &model.VercelIntegrationConfig{
			WorkspaceID:     workspaceId,
			VercelProjectID: m.VercelProjectID,
			ProjectID:       project.ID,
		})
	}

	if err := r.DB.Where("workspace_id = ?", workspaceId).Delete(&model.VercelIntegrationConfig{}).Error; err != nil {
		return false, err
	}

	if err := r.DB.Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateClickUpProjectMappings is the resolver for the updateClickUpProjectMappings field.
func (r *mutationResolver) UpdateClickUpProjectMappings(ctx context.Context, workspaceID int, projectMappings []*modelInputs.ClickUpProjectMappingInput) (bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if workspace.ClickupAccessToken == nil {
		return false, e.New("workspace does not have an access token")
	}

	configs := []*model.IntegrationProjectMapping{}
	for _, m := range projectMappings {
		configs = append(configs, &model.IntegrationProjectMapping{
			IntegrationType: modelInputs.IntegrationTypeClickUp,
			ProjectID:       m.ProjectID,
			ExternalID:      m.ClickupSpaceID,
		})
	}

	if err := r.DB.Exec(`
		DELETE FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, modelInputs.IntegrationTypeClickUp, workspaceID).Error; err != nil {
		return false, err
	}

	if len(projectMappings) == 0 {
		return true, nil
	}

	if err := r.DB.Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateIntegrationProjectMappings is the resolver for the updateIntegrationProjectMappings field.
func (r *mutationResolver) UpdateIntegrationProjectMappings(ctx context.Context, workspaceID int, integrationType modelInputs.IntegrationType, projectMappings []*modelInputs.IntegrationProjectMappingInput) (bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	workspaceMapping := &model.IntegrationWorkspaceMapping{}
	if err := r.DB.Where(&model.IntegrationWorkspaceMapping{
		WorkspaceID:     workspace.ID,
		IntegrationType: integrationType,
	}).First(&workspaceMapping).Error; err != nil {
		return false, e.Wrap(err, fmt.Sprintf("workspace does not have a %s integration", integrationType))
	}

	configs := []*model.IntegrationProjectMapping{}
	for _, m := range projectMappings {
		configs = append(configs, &model.IntegrationProjectMapping{
			IntegrationType: integrationType,
			ProjectID:       m.ProjectID,
			ExternalID:      m.ExternalID,
		})
	}

	if err := r.DB.Exec(`
		DELETE FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, integrationType, workspaceID).Error; err != nil {
		return false, err
	}

	if len(projectMappings) == 0 {
		return true, nil
	}

	if err := r.DB.Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateEmailOptOut is the resolver for the updateEmailOptOut field.
func (r *mutationResolver) UpdateEmailOptOut(ctx context.Context, token *string, adminID *int, category modelInputs.EmailOptOutCategory, isOptOut bool) (bool, error) {
	var adminIdDeref int
	if adminID != nil && token != nil {
		if !IsOptOutTokenValid(*adminID, *token) {
			return false, e.New("token is not valid or has expired")
		}
		adminIdDeref = *adminID
	} else {
		admin, err := r.getCurrentAdmin(ctx)
		if err != nil {
			return false, e.New("error querying current admin")
		}
		adminIdDeref = admin.ID
	}

	if isOptOut {
		if err := r.DB.Create(&model.EmailOptOut{
			AdminID:  adminIdDeref,
			Category: category,
		}).Error; err != nil {
			return false, err
		}
	} else {
		if err := r.DB.Where("admin_id = ? AND category = ?", adminIdDeref, category).
			Delete(&model.EmailOptOut{}).Error; err != nil {
			return false, err
		}
	}

	return true, nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*modelInputs.Account, error) {
	if !r.isWhitelistedAccount(ctx) {
		return nil, e.New("You don't have access to this data")
	}

	accounts := []*modelInputs.Account{}
	if err := r.DB.Raw(`
		SELECT w.id, w.name, w.plan_tier, w.unlimited_members, w.stripe_customer_id,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then count else 0 end), 0) as session_count_cur,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month' and sc.date < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then count else 0 end), 0) as session_count_prev,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '2 months' and sc.date < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month' then count else 0 end), 0) as session_count_prev_prev,
		(select count(*) from workspace_admins wa where wa.workspace_id = w.id) as member_count
		FROM workspaces w
		INNER JOIN projects p
		ON p.workspace_id = w.id
		LEFT OUTER JOIN daily_session_counts_view sc
		ON sc.project_id = p.id
		group by 1, 2
	`).Scan(&accounts).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving accounts for project")
	}

	viewCounts := []*modelInputs.Account{}
	if err := r.DB.Raw(`
		SELECT w.id,
		SUM(case when s.created_at >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then 1 else 0 end) as view_count_cur,
		SUM(case when s.created_at >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month'
			and s.created_at < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then 1 else 0 end) as view_count_prev
		FROM workspaces w
		INNER JOIN projects p
		ON p.workspace_id = w.id
		INNER JOIN sessions s
		ON s.project_id = p.id
		INNER JOIN session_admins_views sav
		ON sav.session_id = s.id
		group by 1`).Scan(&viewCounts).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving view counts for project")
	}
	viewsByWorkspace := lo.GroupBy(viewCounts, func(viewCount *modelInputs.Account) int {
		return viewCount.ID
	})
	for _, a := range accounts {
		views, ok := viewsByWorkspace[a.ID]
		if !ok || len(views) != 1 {
			continue
		}
		a.ViewCountCur = views[0].ViewCountCur
		a.ViewCountPrev = views[0].ViewCountPrev
	}

	subListParams := stripe.SubscriptionListParams{
		Status: string(stripe.SubscriptionStatusActive),
	}
	subListParams.AddExpand("data.customer")
	subListParams.Filters.AddFilter("limit", "", "100")
	var startingAfter *string
	var allSubs []*stripe.Subscription
	for {
		subListParams.StartingAfter = startingAfter
		subList := r.StripeClient.Subscriptions.List(&subListParams).SubscriptionList()
		allSubs = append(allSubs, subList.Data...)

		if !subList.HasMore {
			break
		}

		startingAfter = &subList.Data[len(subList.Data)-1].ID
	}
	subsByCustomer := lo.GroupBy(allSubs, func(sub *stripe.Subscription) string {
		return sub.Customer.ID
	})

	invoiceListParams := stripe.InvoiceListParams{
		Status: stripe.String(string(stripe.InvoiceStatusPaid)),
		CreatedRange: &stripe.RangeQueryParams{
			GreaterThan: time.Now().Add(-3 * 30 * 24 * time.Hour).Unix(),
		},
	}
	invoiceListParams.Filters.AddFilter("limit", "", "100")
	var allInvoices []*stripe.Invoice
	startingAfter = nil
	for {
		invoiceListParams.StartingAfter = startingAfter
		invoiceList := r.StripeClient.Invoices.List(&invoiceListParams).InvoiceList()
		allInvoices = append(allInvoices, invoiceList.Data...)

		if !invoiceList.HasMore {
			break
		}

		startingAfter = &invoiceList.Data[len(invoiceList.Data)-1].ID
	}
	invoicesByCustomer := lo.GroupBy(allInvoices, func(invoice *stripe.Invoice) string {
		return invoice.Customer.ID
	})

	for _, account := range accounts {
		subs, ok := subsByCustomer[account.StripeCustomerID]
		if ok {
			sort.Slice(subs, func(i, j int) bool {
				return subs[i].StartDate < subs[j].StartDate
			})
			start := time.Unix(subs[0].StartDate, 0)
			account.SubscriptionStart = &start
			account.Email = subs[0].Customer.Email
		}

		invoices, ok := invoicesByCustomer[account.StripeCustomerID]
		if ok {
			sort.Slice(invoices, func(i, j int) bool {
				return invoices[i].DueDate > invoices[j].DueDate
			})
			account.PaidPrev = int(invoices[0].AmountPaid)
			if len(invoices) > 1 {
				account.PaidPrevPrev = int(invoices[1].AmountPaid)
			}
		}

		planTier := modelInputs.PlanType(account.PlanTier)
		if account.SessionLimit == 0 {
			account.SessionLimit = pricing.TypeToSessionsLimit(planTier)
		}

		if account.MemberLimit != nil && *account.MemberLimit == 0 {
			account.MemberLimit = pricing.TypeToMemberLimit(planTier, account.UnlimitedMembers)
		}
	}

	return accounts, nil
}

// AccountDetails is the resolver for the account_details field.
func (r *queryResolver) AccountDetails(ctx context.Context, workspaceID int) (*modelInputs.AccountDetails, error) {
	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "error getting workspace info")
	}

	var queriedMonths = []struct {
		Sum   int
		Month string
	}{}
	if err := r.DB.Raw(`
	select SUM(count), to_char(date, 'yyyy-MM') as month
	from daily_session_counts_view
	where project_id in (select id from projects where projects.workspace_id = ?)
	group by month
	order by month
	`, workspaceID).Scan(&queriedMonths).Error; err != nil {
		return nil, e.Errorf("error retrieving months: %v", err)
	}

	var queriedDays = []struct {
		Sum int
		Day string
	}{}
	if err := r.DB.Raw(`
	select SUM(count), to_char(date, 'MON-DD-YYYY') as day
	from daily_session_counts_view
	where project_id in (select id from projects where projects.workspace_id = ?)
	group by date
	order by date
	`, workspaceID).Scan(&queriedDays).Error; err != nil {
		return nil, e.Errorf("error retrieving days: %v", err)
	}

	sessionCountsPerMonth := []*modelInputs.NamedCount{}
	sessionCountsPerDay := []*modelInputs.NamedCount{}
	for _, s := range queriedMonths {
		sessionCountsPerMonth = append(sessionCountsPerMonth, &modelInputs.NamedCount{Name: s.Month, Count: s.Sum})
	}
	for _, s := range queriedDays {
		sessionCountsPerDay = append(sessionCountsPerDay, &modelInputs.NamedCount{Name: s.Day, Count: s.Sum})
	}

	var stripeCustomerId string
	if workspace.StripeCustomerID != nil {
		stripeCustomerId = *workspace.StripeCustomerID
	}

	var members []*modelInputs.AccountDetailsMember
	if err := r.DB.Raw(`
	select a.id as id, max(a.name) as name, max(a.email) as email, max(s.created_at) as last_active
	from workspace_admins wa
	inner join admins a on wa.admin_id = a.id
	inner join sessions s on s.identifier = a.email
	where wa.workspace_id = ? and s.project_id = 1
	group by a.id
	`, workspaceID).Scan(&members).Error; err != nil {
		return nil, e.Errorf("error querying members: %v", err)
	}

	details := &modelInputs.AccountDetails{
		SessionCountPerMonth: sessionCountsPerMonth,
		SessionCountPerDay:   sessionCountsPerDay,
		Name:                 *workspace.Name,
		ID:                   workspace.ID,
		StripeCustomerID:     stripeCustomerId,
		Members:              members,
	}
	return details, nil
}

// Session is the resolver for the session field.
func (r *queryResolver) Session(ctx context.Context, secureID string) (*model.Session, error) {
	if util.IsDevEnv() && secureID == "repro" {
		sessionObj := &model.Session{}
		if err := r.DB.Preload("Fields").Where(&model.Session{Model: model.Model{ID: 0}}).First(&sessionObj).Error; err != nil {
			return nil, e.Wrap(err, "error reading from session")
		}
		return sessionObj, nil
	}

	s, err := r.canAdminViewSession(ctx, secureID)
	if s == nil || err != nil {
		return nil, nil
	}

	retentionDate, err := r.GetProjectRetentionDate(ctx, s.ProjectID)
	if err != nil {
		return nil, err
	}
	sessionObj := &model.Session{}
	if err := r.DB.Preload("Fields").Where(&model.Session{Model: model.Model{ID: s.ID}}).
		Where("created_at > ?", retentionDate).
		First(&sessionObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from session")
	}
	return sessionObj, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	if util.IsDevEnv() && sessionSecureID == "repro" {
		file, err := os.ReadFile("./tmp/events.json")
		if err != nil {
			return nil, e.Wrap(err, "Failed to read temp file")
		}
		var data []interface{}

		if err := json.Unmarshal([]byte(file), &data); err != nil {
			return nil, e.Wrap(err, "Failed to unmarshal data from file")
		}
		return data, nil
	}
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	events, err, _ := r.getEvents(ctx, session, model.EventsCursor{EventIndex: 0, EventObjectIndex: nil})
	return events, err
}

// SessionIntervals is the resolver for the session_intervals field.
func (r *queryResolver) SessionIntervals(ctx context.Context, sessionSecureID string) ([]*model.SessionInterval, error) {
	if !(util.IsDevEnv() && sessionSecureID == "repro") {
		_, err := r.canAdminViewSession(ctx, sessionSecureID)
		if err != nil {
			return nil, e.Wrap(err, "admin not session owner")
		}
	}

	var sessionIntervals []*model.SessionInterval
	if res := r.DB.Order("start_time ASC").Where(&model.SessionInterval{SessionSecureID: sessionSecureID}).Find(&sessionIntervals); res.Error != nil {
		return nil, e.Wrap(res.Error, "failed to get session intervals")
	}

	return sessionIntervals, nil
}

// TimelineIndicatorEvents is the resolver for the timeline_indicator_events field.
func (r *queryResolver) TimelineIndicatorEvents(ctx context.Context, sessionSecureID string) ([]*model.TimelineIndicatorEvent, error) {
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if !(util.IsDevEnv() && sessionSecureID == "repro") {
		if err != nil {
			return nil, e.Wrap(err, "admin not session owner")
		}
	}

	var timelineIndicatorEvents []*model.TimelineIndicatorEvent
	if session.AvoidPostgresStorage {
		timelineIndicatorEvents, err = r.StorageClient.ReadTimelineIndicatorEvents(ctx, session.ID, session.ProjectID)
		if err != nil {
			return nil, e.Wrap(err, "failed to get timeline indicator events from S3")
		}
	} else {
		if res := r.DB.Order("timestamp ASC").Where(&model.TimelineIndicatorEvent{SessionSecureID: sessionSecureID}).Find(&timelineIndicatorEvents); res.Error != nil {
			return nil, e.Wrap(res.Error, "failed to get timeline indicator events from Postgres")
		}
	}

	return timelineIndicatorEvents, nil
}

// RageClicks is the resolver for the rage_clicks field.
func (r *queryResolver) RageClicks(ctx context.Context, sessionSecureID string) ([]*model.RageClickEvent, error) {
	if !(util.IsDevEnv() && sessionSecureID == "repro") {
		_, err := r.canAdminViewSession(ctx, sessionSecureID)
		if err != nil {
			return nil, e.Wrap(err, "admin not session owner")
		}
	}

	var rageClicks []*model.RageClickEvent
	if res := r.DB.Where(&model.RageClickEvent{SessionSecureID: sessionSecureID}).Find(&rageClicks); res.Error != nil {
		return nil, e.Wrap(res.Error, "failed to get rage clicks")
	}

	return rageClicks, nil
}

// RageClicksForProject is the resolver for the rageClicksForProject field.
func (r *queryResolver) RageClicksForProject(ctx context.Context, projectID int, lookBackPeriod int) ([]*modelInputs.RageClickEventForProject, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	rageClicks := []*modelInputs.RageClickEventForProject{}

	rageClicksSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("db.RageClicksForProject"), tracer.Tag("project_id", projectID))
	if err := r.DB.Raw(`
	SELECT
		COALESCE(NULLIF(identifier, ''), CONCAT('#', fingerprint)) as identifier,
		rageClicks. *,
		user_properties
	FROM
		(
			SELECT
				DISTINCT session_secure_id,
				sum(total_clicks) as total_clicks
			FROM
				rage_click_events
			WHERE
				project_id = ?
				AND created_at >= NOW() - (? * INTERVAL '1 DAY')
			GROUP BY
				session_secure_id
		) AS rageClicks
		LEFT JOIN sessions s ON rageClicks.session_secure_id = s.secure_id
		WHERE s.excluded <> true
			AND session_secure_id IS NOT NULL
		ORDER BY total_clicks DESC
		LIMIT 100`,
		projectID, lookBackPeriod).Scan(&rageClicks).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving rage clicks for project")
	}
	rageClicksSpan.Finish()

	return rageClicks, nil
}

// ErrorGroupsOpensearch is the resolver for the error_groups_opensearch field.
func (r *queryResolver) ErrorGroupsOpensearch(ctx context.Context, projectID int, count int, query string, page *int) (*model.ErrorResults, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	results := []opensearch.OpenSearchError{}
	options := opensearch.SearchOptions{
		MaxResults:    ptr.Int(count),
		SortField:     ptr.String("updated_at"),
		SortOrder:     ptr.String("desc"),
		ReturnCount:   ptr.Bool(true),
		ExcludeFields: []string{"FieldGroup", "fields"}, // Excluding certain fields for performance
	}
	if page != nil {
		// page param is 1 indexed
		options.ResultsFrom = ptr.Int((*page - 1) * count)
	}
	errorGroupsOpensearchSearchSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("resolver.errorGroupsOpensearchSearchQuery"), tracer.Tag("project_id", projectID))
	q := FormatErrorGroupsQuery(query, GetRetentionDate(workspace.RetentionPeriod))
	resultCount, _, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexErrorsCombined}, projectID, q, options, &results)
	errorGroupsOpensearchSearchSpan.Finish()

	if err != nil {
		return nil, err
	}

	asErrorGroups := []*model.ErrorGroup{}
	for _, result := range results {
		asErrorGroups = append(asErrorGroups, result.ToErrorGroup())
	}

	errorFrequencyInfluxSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("resolver.errorFrequencyInflux"), tracer.Tag("project_id", projectID))

	err = r.SetErrorFrequencies(ctx, projectID, asErrorGroups, ErrorGroupLookbackDays)
	errorFrequencyInfluxSpan.Finish()

	if err != nil {
		return nil, err
	}

	return &model.ErrorResults{
		ErrorGroups: lo.Map(asErrorGroups, func(eg *model.ErrorGroup, idx int) model.ErrorGroup { return *eg }),
		TotalCount:  resultCount,
	}, nil
}

// ErrorsHistogram is the resolver for the errors_histogram field.
func (r *queryResolver) ErrorsHistogram(ctx context.Context, projectID int, query string, histogramOptions modelInputs.DateHistogramOptions) (*model.ErrorsHistogram, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	results := []opensearch.OpenSearchError{}
	options := opensearch.SearchOptions{
		MaxResults:        ptr.Int(0),
		SortField:         ptr.String("updated_at"),
		SortOrder:         ptr.String("desc"),
		ReturnCount:       ptr.Bool(false),
		ExcludeFields:     []string{"FieldGroup", "fields"}, // Excluding certain fields for performance
		ProjectIDOnParent: ptr.Bool(true),
		Aggregation:       GetDateHistogramAggregation(histogramOptions, "timestamp", nil),
	}

	q := FormatErrorInstancesQuery(query, GetRetentionDate(workspace.RetentionPeriod))
	_, aggs, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexErrorsCombined}, projectID, q, options, &results)
	if err != nil {
		return nil, err
	}

	bucketTimes, totalCounts := GetBucketTimesAndTotalCounts(ctx, aggs, histogramOptions)
	return &model.ErrorsHistogram{
		BucketTimes:  MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		ErrorObjects: MergeHistogramBucketCounts(totalCounts, histogramOptions.BucketSize.Multiple),
	}, nil
}

// ErrorGroup is the resolver for the error_group field.
func (r *queryResolver) ErrorGroup(ctx context.Context, secureID string) (*model.ErrorGroup, error) {
	eg, err := r.canAdminViewErrorGroup(ctx, secureID, true)
	if err != nil {
		return nil, err
	}
	retentionDate, err := r.GetProjectRetentionDate(ctx, eg.ProjectID)
	if err != nil {
		return nil, err
	}
	if eg.UpdatedAt.Before(retentionDate) {
		return nil, e.New("no new error instances after the workspace's retention date")
	}
	return eg, err
}

// ErrorObject is the resolver for the error_object field.
func (r *queryResolver) ErrorObject(ctx context.Context, id int) (*model.ErrorObject, error) {
	errorObject := &model.ErrorObject{}
	if err := r.DB.Where(&model.ErrorObject{Model: model.Model{ID: id}}).First(&errorObject).Error; err != nil {
		return nil, e.Wrap(err, "error reading error object")
	}
	return errorObject, nil
}

// ErrorObjectForLog is the resolver for the error_object_for_log field.
func (r *queryResolver) ErrorObjectForLog(ctx context.Context, logCursor string) (*model.ErrorObject, error) {
	errorObject := &model.ErrorObject{}
	if err := r.DB.Order("log_cursor").Model(&errorObject).Where(&model.ErrorObject{LogCursor: pointy.String(logCursor)}).Limit(1).Find(&errorObject).Error; err != nil || errorObject.ID == 0 {
		return nil, e.Wrapf(err, "no error found for log cursor %s", logCursor)
	}
	return errorObject, nil
}

// ErrorInstance is the resolver for the error_instance field.
func (r *queryResolver) ErrorInstance(ctx context.Context, errorGroupSecureID string, errorObjectID *int) (*model.ErrorInstance, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, true)
	if err != nil {
		return nil, e.Wrap(err, "not authorized to view error group")
	}

	retentionDate, err := r.GetProjectRetentionDate(ctx, errorGroup.ProjectID)
	if err != nil {
		return nil, err
	}

	errorObject := model.ErrorObject{}
	errorObjectQuery := r.DB.
		Model(&model.ErrorObject{}).
		Where("error_group_id = ?", errorGroup.ID).
		Where("created_at > ?", retentionDate).
		Order("id desc")

	if errorObjectID == nil {
		var sessionIds []int
		if err := r.DB.Model(&errorObject).
			Where(&model.ErrorObject{ErrorGroupID: errorGroup.ID}).
			Where("session_id is not null").
			Where("created_at > ?", retentionDate).
			Limit(100).
			Pluck("session_id", &sessionIds).
			Error; err != nil {
			return nil, e.Wrap(err, "error reading session ids")
		}

		var processedSessions []int
		// find all processed sessions
		if err := r.DB.Model(&model.Session{}).
			Where("id IN (?) AND processed = ? AND excluded = ?", sessionIds, true, false).
			Where("created_at > ?", retentionDate).
			Pluck("id", &processedSessions).
			Error; err != nil {
			return nil, e.Wrap(err, "error querying processed sessions")
		}

		if len(processedSessions) == 0 {
			if err := errorObjectQuery.Limit(1).Find(&errorObject).Error; err != nil {
				return nil, e.Wrap(err, "error reading error object for instance")
			}
		} else {
			// find the most recent object from the processed session
			if err := errorObjectQuery.
				Where("session_id IN ?", processedSessions).
				Limit(1).
				Find(&errorObject).
				Error; err != nil {
				return nil, e.Wrap(err, "error reading error object for instance")
			}
		}
	} else {
		if err := errorObjectQuery.
			Where(&model.ErrorObject{Model: model.Model{ID: *errorObjectID}}).
			Where("created_at > ?", retentionDate).
			Limit(1).
			Find(&errorObject).
			Error; err != nil {
			return nil, e.Wrap(err, "error reading error object for instance")
		}
	}
	var nextID int
	if err := r.DB.
		Model(&model.ErrorObject{}).
		Select("id").
		Where("error_group_id = ?", errorGroup.ID).
		Where("created_at > ?", retentionDate).
		Where("id > ?", errorObject.ID).
		Order("id asc").
		Limit(1).
		Pluck("id", &nextID).Error; err != nil {
		return nil, e.Wrap(err, "error reading next error object in group")
	}

	var previousID int
	if err := r.DB.
		Model(&model.ErrorObject{}).
		Select("id").
		Where("error_group_id = ?", errorGroup.ID).
		Where("id < ?", errorObject.ID).
		Where("created_at > ?", retentionDate).
		Order("id desc").
		Limit(1).
		Pluck("id", &previousID).Error; err != nil {
		return nil, e.Wrap(err, "error reading previous error object in group")
	}

	if errorObject.SessionID != nil {
		var session model.Session
		if err := r.DB.Model(&session).Where("id = ?", *errorObject.SessionID).Find(&session).Error; err != nil {
			return nil, e.Wrap(err, "error reading error group session")
		}
		if session.Excluded != nil && *session.Excluded {
			errorObject.SessionID = nil
		}
	}

	errorInstance := model.ErrorInstance{
		ErrorObject: errorObject,
		NextID:      &nextID,
		PreviousID:  &previousID,
	}

	return &errorInstance, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	if en := s.ObjectStorageEnabled; en != nil && *en {
		objectStorageSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
			tracer.ResourceName("db.objectStorageQuery"), tracer.Tag("project_id", s.ProjectID))
		defer objectStorageSpan.Finish()
		ret, err := r.StorageClient.ReadMessages(ctx, s.ID, s.ProjectID)
		if err != nil {
			return nil, e.Wrap(err, "error pulling messages from s3")
		}
		return ret, nil
	}
	messagesObj := []*model.MessagesObject{}
	if err := r.DB.Order("created_at desc").Where(&model.MessagesObject{SessionID: s.ID}).Find(&messagesObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from messages")
	}
	allEvents := make(map[string][]interface{})
	for _, messageObj := range messagesObj {
		subMessage := make(map[string][]interface{})
		if err := json.Unmarshal([]byte(messageObj.Messages), &subMessage); err != nil {
			return nil, e.Wrap(err, "error decoding message data")
		}
		allEvents["messages"] = append(subMessage["messages"], allEvents["messages"]...)
	}
	return allEvents["messages"], nil
}

// EnhancedUserDetails is the resolver for the enhanced_user_details field.
func (r *queryResolver) EnhancedUserDetails(ctx context.Context, sessionSecureID string) (*modelInputs.EnhancedUserDetailsResult, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	p, err := r.isAdminInProject(ctx, s.ProjectID)
	if err != nil {
		return nil, e.Wrap(err, "admin not project owner")
	}
	w, err := r.isAdminInWorkspace(ctx, p.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin not workspace owner")
	}
	if pricing.MustUpgradeForClearbit(w.PlanTier) {
		return nil, nil
	}
	// preload `Fields` children
	sessionObj := &model.Session{}
	// TODO: filter fields by type='user'.
	if err := r.DB.Preload("Fields").Where(&model.Session{Model: model.Model{ID: s.ID}}).First(&sessionObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from session")
	}
	details := &modelInputs.EnhancedUserDetailsResult{}
	details.Socials = []*modelInputs.SocialLink{}
	// We don't know what key is used for the user's email so we do a regex match
	// on all 'user' type fields.
	var email string
	for _, f := range sessionObj.Fields {
		if f.Type == "user" && regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`).MatchString(f.Value) {
			email = f.Value
		}
		if f.Type == "user" && f.Name == "email" {
			email = f.Value
		}
	}
	if len(email) > 0 {
		// Check if we already have this user's data in the db
		// If so, return it
		userDetailsModel := &model.EnhancedUserDetails{}
		p, co := clearbit.Person{}, clearbit.Company{}
		if err := r.DB.Where(&model.EnhancedUserDetails{Email: &email}).First(&userDetailsModel).Error; err != nil {
			if !w.ClearbitEnabled {
				return nil, nil
			}
			log.WithContext(ctx).Infof("retrieving api response for clearbit lookup")
			hlog.Incr("private-graph.enhancedDetails.miss", nil, 1)
			clearbitApiRequestSpan, ctx := tracer.StartSpanFromContext(ctx, "private-graph.EnhancedUserDetails",
				tracer.ResourceName("clearbit.api.request"),
				tracer.Tag("session_id", s.ID), tracer.Tag("workspace_id", w.ID), tracer.Tag("project_id", p.ID), tracer.Tag("plan_tier", w.PlanTier))
			pc, _, err := r.ClearbitClient.Person.FindCombined(clearbit.PersonFindParams{Email: email})
			clearbitApiRequestSpan.Finish()
			p, co = pc.Person, pc.Company
			if err != nil {
				log.WithContext(ctx).Errorf("error w/ clearbit request: %v", err)
			} else if len(p.ID) > 0 {
				// Store the data for this email in the DB.
				r.PrivateWorkerPool.SubmitRecover(func() {
					log.WithContext(ctx).Infof("caching response data in the db")
					modelToSave := &model.EnhancedUserDetails{}
					modelToSave.Email = &email
					if personBytes, err := json.Marshal(p); err == nil {
						sPersonBytes := string(personBytes)
						modelToSave.PersonJSON = &sPersonBytes
					} else {
						log.WithContext(ctx).Errorf("error marshaling clearbit person: %v", err)
					}
					if companyBytes, err := json.Marshal(co); err == nil {
						sCompanyBytes := string(companyBytes)
						modelToSave.CompanyJSON = &sCompanyBytes
					} else {
						log.WithContext(ctx).Errorf("error marshaling clearbit company: %v", err)
					}
					if err := r.DB.Create(modelToSave).Error; err != nil {
						log.WithContext(ctx).Errorf("error creating clearbit details model")
					}
				})
			}
		} else {
			log.WithContext(ctx).Infof("retrieving cache db entry of clearbit lookup")
			hlog.Incr("private-graph.enhancedDetails.hit", nil, 1)
			if userDetailsModel.PersonJSON != nil && userDetailsModel.CompanyJSON != nil {
				if err := json.Unmarshal([]byte(*userDetailsModel.PersonJSON), &p); err != nil {
					log.WithContext(ctx).Errorf("error unmarshaling person: %v", err)
				}
				if err := json.Unmarshal([]byte(*userDetailsModel.CompanyJSON), &co); err != nil {
					log.WithContext(ctx).Errorf("error unmarshaling company: %v", err)
				}
			}
		}
		if twitterHandle := p.Twitter.Handle; twitterHandle != "" {
			twitterLink := fmt.Sprintf("https://twitter.com/%v", twitterHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &twitterLink, Type: modelInputs.SocialTypeTwitter})
		}
		if fbHandle := p.Facebook.Handle; fbHandle != "" {
			fbLink := fmt.Sprintf("https://www.facebook.com/%v", fbHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &fbLink, Type: modelInputs.SocialTypeFacebook})
		}
		if gHandle := p.GitHub.Handle; gHandle != "" {
			ghLink := fmt.Sprintf("https://www.github.com/%v", gHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &ghLink, Type: modelInputs.SocialTypeGithub})
		}
		if liHandle := p.LinkedIn.Handle; liHandle != "" {
			fbLink := fmt.Sprintf("https://www.linkedin.com/%v", liHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &fbLink, Type: modelInputs.SocialTypeLinkedIn})
		}
		if personalSiteLink, companySiteLink := p.Site, co.Domain; personalSiteLink != "" || companySiteLink != "" {
			site := personalSiteLink
			if personalSiteLink == "" {
				site = companySiteLink
			}
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &site, Type: modelInputs.SocialTypeSite})
		}
		details.Avatar = &p.Avatar
		details.Name = &p.Name.FullName
		details.Bio = &p.Bio
		details.Email = &email
	}
	return details, nil
}

// Errors is the resolver for the errors field.
func (r *queryResolver) Errors(ctx context.Context, sessionSecureID string) ([]*model.ErrorObject, error) {
	if util.IsDevEnv() && sessionSecureID == "repro" {
		errors := []*model.ErrorObject{}
		return errors, nil
	}
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	eventsQuerySpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("db.errorObjectsQuery"), tracer.Tag("project_id", s.ProjectID))
	defer eventsQuerySpan.Finish()
	errorsObj := []*model.ErrorObject{}
	if err := r.DB.Order("created_at asc").Where(&model.ErrorObject{SessionID: &s.ID}).Find(&errorsObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from errors")
	}
	return errorsObj, nil
}

// Resources is the resolver for the resources field.
func (r *queryResolver) Resources(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}
	if en := s.ObjectStorageEnabled; en != nil && *en {
		objectStorageSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
			tracer.ResourceName("db.objectStorageQuery"), tracer.Tag("project_id", s.ProjectID))
		defer objectStorageSpan.Finish()
		ret, err := r.StorageClient.ReadResources(ctx, s.ID, s.ProjectID)
		if err != nil {
			return nil, e.Wrap(err, "error pulling resources from s3")
		}
		return ret, nil
	}
	resourcesObject := []*model.ResourcesObject{}
	if err := r.DB.Order("created_at desc").Where(&model.ResourcesObject{SessionID: s.ID}).Find(&resourcesObject).Error; err != nil {
		return nil, e.Wrap(err, "error reading from resources")
	}
	allResources := make(map[string][]interface{})
	for _, resourceObj := range resourcesObject {
		subResources := make(map[string][]interface{})
		if err := json.Unmarshal([]byte(resourceObj.Resources), &subResources); err != nil {
			return nil, e.Wrap(err, "error decoding resource data")
		}
		allResources["resources"] = append(subResources["resources"], allResources["resources"]...)
	}
	return allResources["resources"], nil
}

// WebVitals is the resolver for the web_vitals field.
func (r *queryResolver) WebVitals(ctx context.Context, sessionSecureID string) ([]*model.Metric, error) {
	webVitalNames := []string{
		"CLS", "FCP", "FID", "LCP", "TTFB",
	}
	webVitals := []*model.Metric{}
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return webVitals, nil
	}

	if err := r.DB.Raw(`
	WITH filtered_group_ids AS (
		SELECT id
		FROM metric_groups
		WHERE session_id = ?
		LIMIT 100000
	  )
	  SELECT metrics.*
	  FROM metrics
	  WHERE metrics.name in ?
	  AND metric_group_id in (SELECT * FROM filtered_group_ids)`, s.ID, webVitalNames).Find(&webVitals).Error; err != nil {
		log.WithContext(ctx).Error(err)
		return webVitals, nil
	}

	return webVitals, nil
}

// SessionComments is the resolver for the session_comments field.
func (r *queryResolver) SessionComments(ctx context.Context, sessionSecureID string) ([]*model.SessionComment, error) {
	if util.IsDevEnv() && sessionSecureID == "repro" {
		sessionComments := []*model.SessionComment{}
		return sessionComments, nil
	}
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin not session owner")
	}

	sessionComments := []*model.SessionComment{}

	if err := r.DB.Preload("Attachments").Preload("Replies").Where(model.SessionComment{SessionId: s.ID}).Order("timestamp asc").Find(&sessionComments).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comments for session")
	}
	return sessionComments, nil
}

// SessionCommentTagsForProject is the resolver for the session_comment_tags_for_project field.
func (r *queryResolver) SessionCommentTagsForProject(ctx context.Context, projectID int) ([]*model.SessionCommentTag, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in org for session comment tags")
	}

	var sessionCommentTags []*model.SessionCommentTag

	if err := r.DB.Where(&model.SessionCommentTag{ProjectID: projectID}).Find(&sessionCommentTags).Error; err != nil {
		return nil, e.Wrap(err, "error getting session comment tags")
	}

	return sessionCommentTags, nil
}

// SessionCommentsForAdmin is the resolver for the session_comments_for_admin field.
func (r *queryResolver) SessionCommentsForAdmin(ctx context.Context) ([]*model.SessionComment, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	var sessionComments []*model.SessionComment
	if err := r.DB.Model(admin).Association("SessionComments").Find(&sessionComments); err != nil {
		return nil, e.Wrap(err, "error getting session comments for")
	}

	return sessionComments, nil
}

// SessionCommentsForProject is the resolver for the session_comments_for_project field.
func (r *queryResolver) SessionCommentsForProject(ctx context.Context, projectID int) ([]*model.SessionComment, error) {
	var sessionComments []*model.SessionComment
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return sessionComments, nil
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	if err := r.DB.Model(model.SessionComment{}).Where("project_id = ? AND admin_id != ?", projectID, admin.ID).Find(&sessionComments).Error; err != nil {
		return sessionComments, e.Wrap(err, "error getting session comments for project")
	}

	return sessionComments, nil
}

// IsSessionPending is the resolver for the isSessionPending field.
func (r *queryResolver) IsSessionPending(ctx context.Context, sessionSecureID string) (*bool, error) {
	isPending, err := r.Redis.IsPendingSession(ctx, sessionSecureID)
	if err != nil {
		return pointy.Bool(false), e.Wrap(err, "error retrieving session")
	}
	return pointy.Bool(isPending), nil
}

// ErrorIssue is the resolver for the error_issue field.
func (r *queryResolver) ErrorIssue(ctx context.Context, errorGroupSecureID string) ([]*model.ExternalAttachment, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin not error owner")
	}

	errorIssues := []*model.ExternalAttachment{}

	if err := r.DB.Raw(`
  		SELECT *
  		FROM
			external_attachments
  		WHERE
			error_comment_id IN (
	  		SELECT
				id
	  		FROM
				error_comments
	  		WHERE
				error_id = ? AND removed <> true
			)
  		ORDER BY
			created_at DESC
		`,
		errorGroup.ID,
	).Scan(&errorIssues).Error; err != nil {
		return nil, e.Wrap(err, "error querying error issues for error_group")
	}

	return errorIssues, nil
}

// ErrorComments is the resolver for the error_comments field.
func (r *queryResolver) ErrorComments(ctx context.Context, errorGroupSecureID string) ([]*model.ErrorComment, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin not error owner")
	}

	errorComments := []*model.ErrorComment{}
	if err := r.DB.Preload("Attachments").Preload("Replies").Where(model.ErrorComment{ErrorId: errorGroup.ID}).Order("created_at asc").Find(&errorComments).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments for error_group")
	}
	return errorComments, nil
}

// ErrorCommentsForAdmin is the resolver for the error_comments_for_admin field.
func (r *queryResolver) ErrorCommentsForAdmin(ctx context.Context) ([]*model.ErrorComment, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	var errorComments []*model.ErrorComment
	if err := r.DB.Model(admin).Association("ErrorComments").Find(&errorComments); err != nil {
		return nil, e.Wrap(err, "error getting error comments for admin")
	}

	return errorComments, nil
}

// ErrorCommentsForProject is the resolver for the error_comments_for_project field.
func (r *queryResolver) ErrorCommentsForProject(ctx context.Context, projectID int) ([]*model.ErrorComment, error) {
	var errorComments []*model.ErrorComment
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return errorComments, nil
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	if err := r.DB.Model(model.ErrorComment{}).Where("project_id = ? AND admin_id != ?", projectID, admin.ID).Find(&errorComments).Error; err != nil {
		return errorComments, e.Wrap(err, "error getting error comments for project")
	}

	return errorComments, nil
}

// WorkspaceAdmins is the resolver for the workspace_admins field.
func (r *queryResolver) WorkspaceAdmins(ctx context.Context, workspaceID int) ([]*model.WorkspaceAdminRole, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	var admins []*model.Admin
	if err := r.DB.Order("created_at ASC").Model(workspace).Association("Admins").Find(&admins); err != nil {
		return nil, e.Wrap(err, "error getting admins for the workspace")
	}

	var roles []*model.WorkspaceAdminRole
	for _, admin := range admins {
		role, err := r.GetAdminRole(ctx, admin.ID, workspace.ID)
		if err != nil {
			return nil, e.Wrap(err, "failed to retrieve admin role")
		}
		roles = append(roles, &model.WorkspaceAdminRole{
			Admin: admin,
			Role:  role,
		})
	}

	return roles, nil
}

// WorkspaceAdminsByProjectID is the resolver for the workspace_admins_by_project_id field.
func (r *queryResolver) WorkspaceAdminsByProjectID(ctx context.Context, projectID int) ([]*model.WorkspaceAdminRole, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, nil
	}

	return r.WorkspaceAdmins(ctx, workspace.ID)
}

// IsIntegrated is the resolver for the isIntegrated field.
func (r *queryResolver) IsIntegrated(ctx context.Context, projectID int) (*bool, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, nil
	}

	firstSession := model.Session{}
	err := r.DB.Model(&model.Session{}).Where("project_id = ?", projectID).First(&firstSession).Error
	if e.Is(err, gorm.ErrRecordNotFound) {
		return &model.F, nil
	}
	if err != nil {
		return nil, e.Wrap(err, "error querying session for project")
	}

	return &model.T, nil
}

// IsBackendIntegrated is the resolver for the isBackendIntegrated field.
func (r *queryResolver) IsBackendIntegrated(ctx context.Context, projectID int) (*bool, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, nil
	}
	var count int64
	err := r.DB.Model(&model.Project{}).Where("id = ? AND backend_setup=true", projectID).Count(&count).Error
	if err != nil {
		return nil, e.Wrap(err, "error getting projects with backend flag")
	}
	if count > 0 {
		return &model.T, nil
	}
	return &model.F, nil
}

// ClientIntegration is the resolver for the clientIntegration field.
func (r *queryResolver) ClientIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:       false,
		ResourceType:     "Session",
		ResourceSecureID: nil,
	}
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return integration, nil
	}

	firstSession := model.Session{}
	err := r.DB.Model(&model.Session{}).Where("project_id = ?", projectID).First(&firstSession).Error
	if e.Is(err, gorm.ErrRecordNotFound) {
		return integration, nil
	}
	if err != nil {
		return integration, e.Wrap(err, "error querying session for project")
	}
	integration.Integrated = true
	integration.ResourceSecureID = &firstSession.SecureID
	integration.CreatedAt = &firstSession.CreatedAt

	return integration, nil
}

// ServerIntegration is the resolver for the serverIntegration field.
func (r *queryResolver) ServerIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:       false,
		ResourceType:     "ErrorGroup",
		ResourceSecureID: nil,
	}
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return integration, nil
	}

	firstErrorGroup := model.ErrorGroup{}
	err := r.DB.Model(&model.ErrorGroup{}).Where("project_id = ?", projectID).First(&firstErrorGroup).Error
	if e.Is(err, gorm.ErrRecordNotFound) {
		return integration, nil
	}
	if err != nil {
		return integration, e.Wrap(err, "error querying error group for project")
	}
	integration.Integrated = true
	integration.ResourceSecureID = &firstErrorGroup.SecureID
	integration.CreatedAt = &firstErrorGroup.CreatedAt

	return integration, nil
}

// LogsIntegration is the resolver for the logsIntegration field.
func (r *queryResolver) LogsIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:       true,
		ResourceType:     "Log",
		ResourceSecureID: nil,
	}
	_, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	setupEvent := model.SetupEvent{}
	err = r.DB.Model(&model.SetupEvent{}).Where("project_id = ? AND type = ?", projectID, model.MarkBackendSetupTypeLogs).First(&setupEvent).Error
	if err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			integration.Integrated = false
		} else {
			return nil, e.Wrap(err, "error querying setup event")
		}
	} else {
		integration.CreatedAt = &setupEvent.CreatedAt
	}

	return integration, nil
}

// UnprocessedSessionsCount is the resolver for the unprocessedSessionsCount field.
func (r *queryResolver) UnprocessedSessionsCount(ctx context.Context, projectID int) (*int64, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	// lookback based on DeleteCompletedSessions
	var count int64
	if err := r.DB.Raw(`
		SELECT COUNT(*)
		FROM sessions
		WHERE project_id = ?
		AND processed = false
		AND excluded = false
		AND created_at > NOW() - interval '4 hours 10 minutes'
	`, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving live users count")
	}

	return &count, nil
}

// LiveUsersCount is the resolver for the liveUsersCount field.
func (r *queryResolver) LiveUsersCount(ctx context.Context, projectID int) (*int64, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	if err := r.DB.Raw(`
		SELECT COUNT(DISTINCT(COALESCE(NULLIF(identifier, ''), CAST(fingerprint AS text))))
		FROM sessions
		WHERE project_id = ?
		AND processed = false
		AND excluded = false
		AND created_at > NOW() - interval '4 hours 10 minutes'
	`, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving live users count")
	}

	return &count, nil
}

// AdminHasCreatedComment is the resolver for the adminHasCreatedComment field.
func (r *queryResolver) AdminHasCreatedComment(ctx context.Context, adminID int) (*bool, error) {
	if err := r.DB.Model(&model.SessionComment{}).Where(&model.SessionComment{
		AdminId: adminID,
	}).First(&model.SessionComment{}).Error; err != nil {
		return &model.F, nil
	}

	return &model.T, nil
}

// ProjectHasViewedASession is the resolver for the projectHasViewedASession field.
func (r *queryResolver) ProjectHasViewedASession(ctx context.Context, projectID int) (*model.Session, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	session := model.Session{}
	if err := r.DB.Model(&session).Where("project_id = ?", projectID).Where(&model.Session{Viewed: &model.T, Excluded: &model.F}).First(&session).Error; err != nil {
		return &session, nil
	}
	return &session, nil
}

// DailySessionsCount is the resolver for the dailySessionsCount field.
func (r *queryResolver) DailySessionsCount(ctx context.Context, projectID int, dateRange modelInputs.DateRangeInput) ([]*model.DailySessionCount, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	dailySessions := []*model.DailySessionCount{}

	startDateUTC := time.Date(dateRange.StartDate.UTC().Year(), dateRange.StartDate.UTC().Month(), dateRange.StartDate.UTC().Day(), 0, 0, 0, 0, time.UTC)
	endDateUTC := time.Date(dateRange.EndDate.UTC().Year(), dateRange.EndDate.UTC().Month(), dateRange.EndDate.UTC().Day(), 0, 0, 0, 0, time.UTC)

	if err := r.DB.Raw("SELECT * FROM daily_session_counts_view WHERE date BETWEEN ? AND ? AND project_id = ?", startDateUTC, endDateUTC, projectID).Find(&dailySessions).Error; err != nil {
		return nil, e.Wrap(err, "error reading from daily sessions")
	}

	return dailySessions, nil
}

// DailyErrorsCount is the resolver for the dailyErrorsCount field.
func (r *queryResolver) DailyErrorsCount(ctx context.Context, projectID int, dateRange modelInputs.DateRangeInput) ([]*model.DailyErrorCount, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	dailyErrors := []*model.DailyErrorCount{}

	startDateUTC := time.Date(dateRange.StartDate.UTC().Year(), dateRange.StartDate.UTC().Month(), dateRange.StartDate.UTC().Day(), 0, 0, 0, 0, time.UTC)
	endDateUTC := time.Date(dateRange.EndDate.UTC().Year(), dateRange.EndDate.UTC().Month(), dateRange.EndDate.UTC().Day(), 0, 0, 0, 0, time.UTC)

	if err := r.DB.Raw("SELECT * FROM daily_error_counts_view WHERE date BETWEEN ? AND ? AND project_id = ?", startDateUTC, endDateUTC, projectID).Find(&dailyErrors).Error; err != nil {
		return nil, e.Wrap(err, "error reading from daily sessions")
	}

	return dailyErrors, nil
}

// DailyErrorFrequency is the resolver for the dailyErrorFrequency field.
func (r *queryResolver) DailyErrorFrequency(ctx context.Context, projectID int, errorGroupSecureID string, dateOffset int) ([]int64, error) {
	errGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to view error group")
	}

	if projectID == 0 {
		// Make error distribution random for demo org so it looks pretty
		rand.Seed(int64(errGroup.ID))
		var dists []int64
		for i := 0; i <= dateOffset; i++ {
			t := int64(rand.Intn(10) + 1)
			dists = append(dists, t)
		}
		return dists, nil
	}

	if err := r.SetErrorFrequencies(ctx, projectID, []*model.ErrorGroup{errGroup}, dateOffset); err != nil {
		return nil, e.Wrap(err, "error setting error frequencies")
	}
	return errGroup.ErrorFrequency, nil
}

// ErrorDistribution is the resolver for the errorDistribution field.
func (r *queryResolver) ErrorDistribution(ctx context.Context, projectID int, errorGroupSecureID string, property string) ([]*modelInputs.ErrorDistributionItem, error) {
	errGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to view error group")
	}

	if projectID == 0 {
		// Make error distribution random for demo org so it looks pretty
		rand.Seed(int64(errGroup.ID))
		dists := []*modelInputs.ErrorDistributionItem{}
		for i := 0; i <= 3; i++ {
			t := int64(rand.Intn(10) + 1)
			dists = append(dists, &modelInputs.ErrorDistributionItem{
				Name:  fmt.Sprintf("Property %d", i),
				Value: t,
			})
		}
		return dists, nil
	}

	errorDistribution := []*modelInputs.ErrorDistributionItem{}

	if err := r.DB.Raw(fmt.Sprintf(`
		SELECT %s as name, COUNT(*) as value FROM error_objects
		WHERE error_group_id=? AND project_id=?
		GROUP BY %s
		ORDER BY 2 DESC;
	`, property, property), errGroup.ID, projectID).Scan(&errorDistribution).Error; err != nil {
		return nil, e.Wrap(err, "error querying error distribution")
	}

	return errorDistribution, nil
}

// ErrorGroupFrequencies is the resolver for the errorGroupFrequencies field.
func (r *queryResolver) ErrorGroupFrequencies(ctx context.Context, projectID int, errorGroupSecureIds []string, params modelInputs.ErrorGroupFrequenciesParamsInput, metric *string) ([]*modelInputs.ErrorDistributionItem, error) {
	var errorGroupIDs []int
	for _, errorGroupSecureID := range errorGroupSecureIds {
		errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
		if err != nil {
			return nil, e.Wrap(err, "admin not error group owner")
		}
		errorGroupIDs = append(errorGroupIDs, errorGroup.ID)
	}
	if metric == nil {
		metric = pointy.String("")
	}
	return r.GetErrorGroupFrequencies(ctx, projectID, errorGroupIDs, params, *metric)
}

// ErrorGroupTags is the resolver for the errorGroupTags field.
func (r *queryResolver) ErrorGroupTags(ctx context.Context, errorGroupSecureID string) ([]*modelInputs.ErrorGroupTagAggregation, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID, false)
	if err != nil {
		return nil, e.Wrap(err, "admin not error group owner")
	}

	query := fmt.Sprintf(`
	{
		"size": 0,
		"query": {
			"has_parent": {
				"parent_type": "parent",
				"query": {
					"terms": {
						"_id": ["%d"]
					}
				}
			}
		},
		"aggs": {
			"browser": {
				"terms": {
					"field": "browser.keyword"
				}
			},
			"environment": {
				"terms": {
					"field": "environment.keyword"
				}
			},
			"os_name": {
				"terms": {
					"field": "os_name.keyword"
				}
			}
		}
	  }
	`, errorGroup.ID)

	res, err := r.OpenSearch.RawSearch(opensearch.IndexErrorsCombined, query)

	if err != nil {
		return nil, err
	}

	var aggregations highlightErrors.TagsAggregations
	if err := json.Unmarshal(res, &aggregations); err != nil {
		return nil, e.Wrap(err, "failed to unmarshal aggregations")
	}

	return highlightErrors.BuildAggregations(aggregations), nil
}

// Referrers is the resolver for the referrers field.
func (r *queryResolver) Referrers(ctx context.Context, projectID int, lookBackPeriod int) ([]*modelInputs.ReferrerTablePayload, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	referrers := []*modelInputs.ReferrerTablePayload{}

	if err := r.DB.Raw(fmt.Sprintf("SELECT DISTINCT(value) as host, COUNT(value), count(value) * 100.0 / (select count(*) from fields where name='referrer' and project_id=%d and created_at >= NOW() - INTERVAL '%d DAY') as percent FROM (SELECT SUBSTRING(value from '(?:.*://)?(?:www\\.)?([^/]*)') AS value FROM fields WHERE name='referrer' AND project_id=%d AND created_at >= NOW() - INTERVAL '%d DAY') t1 GROUP BY value ORDER BY count desc LIMIT 200", projectID, lookBackPeriod, projectID, lookBackPeriod)).Scan(&referrers).Error; err != nil {
		return nil, e.Wrap(err, "error getting referrers")
	}

	return referrers, nil
}

// NewUsersCount is the resolver for the newUsersCount field.
func (r *queryResolver) NewUsersCount(ctx context.Context, projectID int, lookBackPeriod int) (*modelInputs.NewUsersCount, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	if err := r.DB.Raw(fmt.Sprintf("SELECT COUNT(*) FROM sessions WHERE project_id=%d AND first_time=true AND created_at >= NOW() - INTERVAL '%d DAY'", projectID, lookBackPeriod)).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving count of first time users")
	}

	return &modelInputs.NewUsersCount{Count: count}, nil
}

// TopUsers is the resolver for the topUsers field.
func (r *queryResolver) TopUsers(ctx context.Context, projectID int, lookBackPeriod int) ([]*modelInputs.TopUsersPayload, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	var topUsersPayload = []*modelInputs.TopUsersPayload{}
	topUsersSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("db.topUsers"), tracer.Tag("project_id", projectID))
	if err := r.DB.Raw(`
	SELECT *
	FROM (
        SELECT
            DISTINCT ON(topUsers.identifier) topUsers.identifier,
            topUsers.id,
            total_active_time,
            active_time_percentage,
            s.user_properties
        FROM (
		SELECT
			identifier, (
				SELECT
					id
				FROM
					fields
				WHERE
					project_id = ?
					AND type = 'user'
					AND name = 'identifier'
					AND value = identifier
				LIMIT 1
			) AS id,
			SUM(active_length) as total_active_time,
			SUM(active_length) / (
				SELECT
					SUM(active_length)
				FROM
					sessions
				WHERE
					active_length IS NOT NULL
					AND project_id = ?
					AND identifier <> ''
					AND created_at >= NOW() - (? * INTERVAL '1 DAY')
					AND processed = true
					AND excluded <> true
			) AS active_time_percentage
		FROM (
			SELECT
				identifier,
				active_length,
				user_properties
			FROM
				sessions
			WHERE
				active_length IS NOT NULL
				AND project_id = ?
				AND identifier <> ''
				AND created_at >= NOW() - (? * INTERVAL '1 DAY')
				AND processed = true
				AND excluded <> true
		) q1
		GROUP BY identifier
		LIMIT 50
	) as topUsers
	INNER JOIN sessions s
	ON topUsers.identifier = s.identifier
	AND s.project_id = ?
    ) as q2
	ORDER BY total_active_time DESC`,
		projectID, projectID, lookBackPeriod, projectID, lookBackPeriod, projectID).Scan(&topUsersPayload).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving top users")
	}
	topUsersSpan.Finish()

	return topUsersPayload, nil
}

// AverageSessionLength is the resolver for the averageSessionLength field.
func (r *queryResolver) AverageSessionLength(ctx context.Context, projectID int, lookBackPeriod int) (*modelInputs.AverageSessionLength, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var length float64
	if err := r.DB.Raw(`
		SELECT
			COALESCE(avg(active_length), 0)
		FROM sessions
		WHERE project_id=?
			AND processed=true
			AND excluded <> true
			AND active_length IS NOT NULL
			AND created_at >= NOW() - (? * INTERVAL '1 DAY')
		`, projectID, lookBackPeriod).Scan(&length).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving average length for sessions")
	}

	return &modelInputs.AverageSessionLength{Length: length}, nil
}

// UserFingerprintCount is the resolver for the userFingerprintCount field.
func (r *queryResolver) UserFingerprintCount(ctx context.Context, projectID int, lookBackPeriod int) (*modelInputs.UserFingerprintCount, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	span, _ := tracer.StartSpanFromContext(ctx, "resolver.internal",
		tracer.ResourceName("db.userFingerprintCount"), tracer.Tag("project_id", projectID))
	if err := r.DB.Raw(`
		SELECT
			COUNT(DISTINCT fingerprint)
		FROM sessions
		WHERE identifier=''
			AND excluded <> true
			AND fingerprint IS NOT NULL
			AND created_at >= NOW() - (? * INTERVAL '1 DAY')
			AND project_id=?
			AND length >= 1000
		`, lookBackPeriod, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving user fingerprint count")
	}
	span.Finish()

	return &modelInputs.UserFingerprintCount{Count: count}, nil
}

// SessionsOpensearch is the resolver for the sessions_opensearch field.
func (r *queryResolver) SessionsOpensearch(ctx context.Context, projectID int, count int, query string, sortDesc bool, page *int) (*model.SessionResults, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	results := []model.Session{}

	sortOrder := "desc"
	if !sortDesc {
		sortOrder = "asc"
	}

	options := opensearch.SearchOptions{
		MaxResults:    ptr.Int(count),
		SortField:     ptr.String("created_at"),
		SortOrder:     ptr.String(sortOrder),
		ReturnCount:   ptr.Bool(true),
		ExcludeFields: []string{"fields", "field_group"}, // Excluding certain fields for performance
	}
	if page != nil {
		// page param is 1 indexed
		options.ResultsFrom = ptr.Int((*page - 1) * count)
	}

	q := FormatSessionsQuery(query, GetRetentionDate(workspace.RetentionPeriod))
	resultCount, _, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexSessions}, projectID, q, options, &results)
	if err != nil {
		return nil, err
	}

	return &model.SessionResults{
		Sessions:   results,
		TotalCount: resultCount,
	}, nil
}

// SessionsHistogram is the resolver for the sessions_histogram field.
func (r *queryResolver) SessionsHistogram(ctx context.Context, projectID int, query string, histogramOptions modelInputs.DateHistogramOptions) (*model.SessionsHistogram, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	results := []model.Session{}
	options := opensearch.SearchOptions{
		MaxResults:    ptr.Int(0),
		SortField:     ptr.String("created_at"),
		ReturnCount:   ptr.Bool(false),
		ExcludeFields: []string{"fields", "field_group"}, // Excluding certain fields for performance
		Aggregation: GetDateHistogramAggregation(histogramOptions, "created_at",
			&opensearch.TermsAggregation{
				Field:   "has_errors",
				Missing: ptr.String("false"),
			}),
	}
	q := FormatSessionsQuery(query, GetRetentionDate(workspace.RetentionPeriod))
	_, aggs, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexSessions}, projectID, q, options, &results)
	if err != nil {
		return nil, err
	}

	bucketTimes, totalCounts := GetBucketTimesAndTotalCounts(ctx, aggs, histogramOptions)
	noErrorsCounts, withErrorsCounts := []int64{}, []int64{}
	for _, dateBucket := range aggs {
		noErrors, withErrors := int64(0), int64(0)
		for _, errorsBucket := range dateBucket.SubAggregationResults {
			if errorsBucket.Key == "false" {
				noErrors = errorsBucket.DocCount
			} else if errorsBucket.Key == "true" {
				withErrors = errorsBucket.DocCount
			}
		}
		noErrorsCounts = append(noErrorsCounts, noErrors)
		withErrorsCounts = append(withErrorsCounts, withErrors)
	}

	return &model.SessionsHistogram{
		BucketTimes:           MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		SessionsWithoutErrors: MergeHistogramBucketCounts(noErrorsCounts, histogramOptions.BucketSize.Multiple),
		SessionsWithErrors:    MergeHistogramBucketCounts(withErrorsCounts, histogramOptions.BucketSize.Multiple),
		TotalSessions:         MergeHistogramBucketCounts(totalCounts, histogramOptions.BucketSize.Multiple),
	}, nil
}

// FieldTypes is the resolver for the field_types field.
func (r *queryResolver) FieldTypes(ctx context.Context, projectID int) ([]*model.Field, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	aggQuery := `{"bool": {
		"must": []
	}}`

	aggOptions := opensearch.SearchOptions{
		MaxResults: pointy.Int(0),
		Aggregation: &opensearch.TermsAggregation{
			Field:   "fields.Key.raw",
			Include: pointy.String("(session|track|user)_.*"),
			Size:    pointy.Int(500),
		},
	}

	ignored := []struct{}{}
	_, aggResults, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexSessions}, projectID, aggQuery, aggOptions, &ignored)
	if err != nil {
		return nil, err
	}

	keys := lo.Filter(
		lo.Map(aggResults, func(ar opensearch.AggregationResult, idx int) string { return ar.Key }),
		func(key string, idx int) bool { return len(key) > 0 })

	return lo.Map(keys, func(key string, idx int) *model.Field {
		typ, name, _ := strings.Cut(key, "_")
		return &model.Field{
			Type: typ,
			Name: name,
		}
	}), nil
}

// FieldsOpensearch is the resolver for the fields_opensearch field.
func (r *queryResolver) FieldsOpensearch(ctx context.Context, projectID int, count int, fieldType string, fieldName string, query string) ([]string, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	var q string
	if query == "" {
		q = fmt.Sprintf(`
		{"bool":{"must":[
			{"term":{"Type.keyword":"%s"}},
			{"term":{"Name.keyword":"%s"}}
		]}}`, fieldType, fieldName)
	} else {
		q = fmt.Sprintf(`
		{"bool":{"must":[
			{"term":{"Type.keyword":"%s"}},
			{"term":{"Name.keyword":"%s"}},
			{"multi_match": {
				"query": "%s",
				"type": "bool_prefix",
				"fields": [
					"Value",
					"Value._2gram",
					"Value._3gram"
				]
			}}
		]}}`, fieldType, fieldName, query)
	}

	results := []*model.Field{}
	options := opensearch.SearchOptions{
		MaxResults: ptr.Int(count),
	}
	_, _, err = r.OpenSearch.Search([]opensearch.Index{opensearch.IndexFields}, projectID, q, options, &results)
	if err != nil {
		return nil, err
	}

	// Get all unique values from the returned fields
	valueMap := map[string]bool{}
	for _, result := range results {
		valueMap[result.Value] = true
	}
	values := []string{}
	for value := range valueMap {
		values = append(values, value)
	}

	return values, nil
}

// ErrorFieldsOpensearch is the resolver for the error_fields_opensearch field.
func (r *queryResolver) ErrorFieldsOpensearch(ctx context.Context, projectID int, count int, fieldType string, fieldName string, query string) ([]string, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	var q string
	if query == "" {
		q = fmt.Sprintf(`
		{"bool":{"must":[
			{"term":{"Name.keyword":"%s"}}
		]}}`, fieldName)
	} else {
		q = fmt.Sprintf(`
		{"bool":{"must":[
			{"term":{"Name.keyword":"%s"}},
			{"multi_match": {
				"query": "%s",
				"type": "bool_prefix",
				"fields": [
					"Value",
					"Value._2gram",
					"Value._3gram"
				]
			}}
		]}}`, fieldName, query)
	}

	results := []*model.ErrorField{}
	options := opensearch.SearchOptions{
		MaxResults: ptr.Int(count),
	}
	_, _, err = r.OpenSearch.Search([]opensearch.Index{opensearch.IndexErrorFields}, projectID, q, options, &results)
	if err != nil {
		return nil, err
	}

	// Get all unique values from the returned fields
	valueMap := map[string]bool{}
	for _, result := range results {
		valueMap[result.Value] = true
	}
	values := []string{}
	for value := range valueMap {
		values = append(values, value)
	}

	return values, nil
}

// QuickFieldsOpensearch is the resolver for the quickFields_opensearch field.
func (r *queryResolver) QuickFieldsOpensearch(ctx context.Context, projectID int, count int, query string) ([]*model.Field, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	var q string
	if query == "" {
		q = `{"bool":{"must":[]}}`
	} else {
		q = fmt.Sprintf(`
		{"bool":{"must":[
			{"multi_match": {
				"query": "%s",
				"type": "bool_prefix",
				"fields": [
					"Value",
					"Value._2gram",
					"Value._3gram"
				]
			}}
		]}}`, query)
	}

	options := opensearch.SearchOptions{
		MaxResults: ptr.Int(count),
	}

	var g errgroup.Group
	results := []*model.Field{}
	errorResults := []*model.Field{}

	g.Go(func() error {
		_, _, err = r.OpenSearch.Search([]opensearch.Index{opensearch.IndexFields}, projectID, q, options, &results)
		if err != nil {
			return err
		}
		return nil
	})

	g.Go(func() error {
		_, _, err = r.OpenSearch.Search([]opensearch.Index{opensearch.IndexErrorFields}, projectID, q, options, &errorResults)
		if err != nil {
			return err
		}

		return nil
	})

	if err := g.Wait(); err != nil {
		return nil, e.Wrap(err, "error querying session or error fields")
	}

	for _, er := range errorResults {
		er.Type = "error-field"
		results = append(results, er)
	}

	return results, nil
}

// BillingDetailsForProject is the resolver for the billingDetailsForProject field.
func (r *queryResolver) BillingDetailsForProject(ctx context.Context, projectID int) (*modelInputs.BillingDetails, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	var g errgroup.Group
	var queriedSessionsOutOfQuota int64
	g.Go(func() error {
		queriedSessionsOutOfQuota, err = pricing.GetProjectQuotaOverflow(ctx, r.DB, projectID)
		if err != nil {
			return e.Wrap(err, "error from get quota overflow")
		}
		return nil
	})

	var billingDetails *modelInputs.BillingDetails
	g.Go(func() error {
		billingDetails, err = r.BillingDetails(ctx, project.WorkspaceID)
		if err != nil {
			return e.Wrap(err, "error from get quota")
		}
		return nil
	})

	// Waits for both goroutines to finish, then returns the first non-nil error (if any).
	if err := g.Wait(); err != nil {
		return nil, e.Wrap(err, "error querying session data for billing details")
	}

	billingDetails.SessionsOutOfQuota = queriedSessionsOutOfQuota
	return billingDetails, nil
}

// BillingDetails is the resolver for the billingDetails field.
func (r *queryResolver) BillingDetails(ctx context.Context, workspaceID int) (*modelInputs.BillingDetails, error) {
	workspace, err := r.isAdminInWorkspaceOrDemoWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	planType := modelInputs.PlanType(workspace.PlanTier)

	interval := modelInputs.SubscriptionIntervalMonthly
	if workspace.BillingPeriodStart != nil &&
		workspace.BillingPeriodEnd != nil &&
		workspace.BillingPeriodEnd.Sub(*workspace.BillingPeriodStart) >= time.Hour*24*32 {
		interval = modelInputs.SubscriptionIntervalAnnual
	}

	var g errgroup.Group
	var meter int64
	var membersMeter int64
	var errorsMeter int64

	g.Go(func() error {
		meter, err = pricing.GetWorkspaceSessionsMeter(r.DB, workspaceID)
		if err != nil {
			return e.Wrap(err, "error from get quota")
		}
		return nil
	})

	g.Go(func() error {
		membersMeter = pricing.GetWorkspaceMembersMeter(r.DB, workspaceID)
		if err != nil {
			return e.Wrap(err, "error querying members meter")
		}
		return nil
	})

	g.Go(func() error {
		errorsMeter, err = pricing.GetWorkspaceErrorsMeter(r.DB, workspaceID)
		if err != nil {
			return e.Wrap(err, "error querying errors meter")
		}
		return nil
	})

	// Waits for all goroutines to finish, then returns the first non-nil error (if any).
	if err := g.Wait(); err != nil {
		return nil, e.Wrap(err, "error querying session data for billing details")
	}

	sessionLimit := pricing.TypeToSessionsLimit(planType)
	// use monthly session limit if it exists
	if workspace.MonthlySessionLimit != nil {
		sessionLimit = *workspace.MonthlySessionLimit
	}

	membersLimit := pricing.TypeToMemberLimit(planType, workspace.UnlimitedMembers)
	if membersLimit != nil && workspace.MonthlyMembersLimit != nil {
		membersLimit = workspace.MonthlyMembersLimit
	}

	errorsLimit := pricing.TypeToErrorsLimit(planType)
	// use monthly session limit if it exists
	if workspace.MonthlyErrorsLimit != nil {
		errorsLimit = *workspace.MonthlyErrorsLimit
	}

	details := &modelInputs.BillingDetails{
		Plan: &modelInputs.Plan{
			Type:         modelInputs.PlanType(planType.String()),
			Quota:        sessionLimit,
			Interval:     interval,
			MembersLimit: membersLimit,
			ErrorsLimit:  errorsLimit,
		},
		Meter:        meter,
		MembersMeter: membersMeter,
		ErrorsMeter:  errorsMeter,
	}

	return details, nil
}

// FieldSuggestion is the resolver for the field_suggestion field.
func (r *queryResolver) FieldSuggestion(ctx context.Context, projectID int, name string, query string) ([]*model.Field, error) {
	fields := []*model.Field{}
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return fields, nil
	}
	res := r.DB.Where(&model.Field{Name: name}).
		Where("project_id = ?", projectID).
		Where("length(value) > ?", 0).
		Where("value ILIKE ?", "%"+query+"%").
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		log.WithContext(ctx).Error(err)
		return fields, nil
	}
	return fields, nil
}

// PropertySuggestion is the resolver for the property_suggestion field.
func (r *queryResolver) PropertySuggestion(ctx context.Context, projectID int, query string, typeArg string) ([]*model.Field, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	fields := []*model.Field{}
	res := r.DB.Where(&model.Field{Type: typeArg}).Where("project_id = ?", projectID).Where(r.DB.
		Where(r.DB.Where("length(value) > ?", 0).Where("value ILIKE ?", "%"+query+"%")).
		Or(r.DB.Where("length(name) > ?", 0).Where("name ILIKE ?", "%"+query+"%"))).
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying field suggestion")
	}
	return fields, nil
}

// ErrorFieldSuggestion is the resolver for the error_field_suggestion field.
func (r *queryResolver) ErrorFieldSuggestion(ctx context.Context, projectID int, name string, query string) ([]*model.ErrorField, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	fields := []*model.ErrorField{}
	res := r.DB.Where(&model.ErrorField{Name: name}).
		Where("length(value) > ?", 0).
		Where("value ILIKE ?", "%"+query+"%").
		Where("project_id = ?", projectID).
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying error field suggestion")
	}
	return fields, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}

	projects := []*model.Project{}
	if err := r.DB.Order("id ASC").Model(&model.Project{}).Where(`
		id IN (
			SELECT project_id
			FROM project_admins
			WHERE admin_id = ?
			UNION
			SELECT id
			FROM projects p
			INNER JOIN workspace_admins wa
			ON p.workspace_id = wa.workspace_id
			AND wa.admin_id = ?
		)
	`, admin.ID, admin.ID).Scan(&projects).Error; err != nil {
		return nil, e.Wrap(err, "error getting associated projects")
	}

	return projects, nil
}

// Workspaces is the resolver for the workspaces field.
func (r *queryResolver) Workspaces(ctx context.Context) ([]*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	workspaces := []*model.Workspace{}
	if err := r.DB.Order("id ASC").Model(&admin).Association("Workspaces").Find(&workspaces); err != nil {
		return nil, e.Wrap(err, "error getting associated workspaces")
	}

	return workspaces, nil
}

// WorkspacesCount is the resolver for the workspaces_count field.
func (r *queryResolver) WorkspacesCount(ctx context.Context) (int64, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return 0, e.Wrap(err, "error retrieving user")
	}

	var workspacesCount int64
	if err := r.DB.Table("workspace_admins").Where("admin_id=?", admin.ID).Count(&workspacesCount).Error; err != nil {
		return 0, e.Wrap(err, "error getting count of workspaces for admin")
	}

	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		log.WithContext(ctx).Error(err)
		return workspacesCount, nil
	}
	var joinableWorkspacesCount int64
	if err := r.DB.Raw(`
			SELECT COUNT(*)
			FROM workspaces
			WHERE id NOT IN (
					SELECT workspace_id
					FROM workspace_admins
					WHERE admin_id = ? )
				AND jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))
		`, admin.ID, domain).Scan(&joinableWorkspacesCount).Error; err != nil {
		return 0, e.Wrap(err, "error getting count of joinable workspaces for admin")
	}

	return joinableWorkspacesCount + workspacesCount, nil
}

// JoinableWorkspaces is the resolver for the joinable_workspaces field.
func (r *queryResolver) JoinableWorkspaces(ctx context.Context) ([]*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving user")
	}
	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		return nil, e.Wrap(err, "error getting custom verified admin email domain")
	}

	joinableWorkspaces := []*model.Workspace{}
	if err := r.DB.Model(&model.Workspace{}).
		Where(`id NOT IN (
			SELECT workspace_id
			FROM workspace_admins
			WHERE admin_id = ?
			)
			AND jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))`, admin.ID, domain).
		Order("workspaces.name").
		Preload("Projects").
		Find(&joinableWorkspaces).Error; err != nil {
		return nil, e.Wrap(err, "error getting joinable workspaces")
	}

	return joinableWorkspaces, nil
}

// ErrorAlerts is the resolver for the error_alerts field.
func (r *queryResolver) ErrorAlerts(ctx context.Context, projectID int) ([]*model.ErrorAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	alerts := []*model.ErrorAlert{}
	if err := r.DB.Order("created_at asc").Model(&model.ErrorAlert{}).Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying error alerts")
	}
	return alerts, nil
}

// SessionFeedbackAlerts is the resolver for the session_feedback_alerts field.
func (r *queryResolver) SessionFeedbackAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project on session feedback alerts")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Model(&model.SessionAlert{}).Where("project_id = ?", projectID).
		Where("type=?", model.AlertType.SESSION_FEEDBACK).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying session feedback alerts")
	}
	return alerts, nil
}

// NewUserAlerts is the resolver for the new_user_alerts field.
func (r *queryResolver) NewUserAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project on new user alerts")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Model(&model.SessionAlert{}).Where("project_id = ?", projectID).
		Where("type IS NULL OR type=?", model.AlertType.NEW_USER).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying new user alerts")
	}
	return alerts, nil
}

// TrackPropertiesAlerts is the resolver for the track_properties_alerts field.
func (r *queryResolver) TrackPropertiesAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Where(&model.SessionAlert{Alert: model.Alert{Type: &model.AlertType.TRACK_PROPERTIES}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying track properties alerts")
	}
	return alerts, nil
}

// UserPropertiesAlerts is the resolver for the user_properties_alerts field.
func (r *queryResolver) UserPropertiesAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Where(&model.SessionAlert{Alert: model.Alert{Type: &model.AlertType.USER_PROPERTIES}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying user properties alerts")
	}
	return alerts, nil
}

// NewSessionAlerts is the resolver for the new_session_alerts field.
func (r *queryResolver) NewSessionAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Where(&model.SessionAlert{Alert: model.Alert{Type: &model.AlertType.NEW_SESSION}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying new session alerts")
	}
	return alerts, nil
}

// RageClickAlerts is the resolver for the rage_click_alerts field.
func (r *queryResolver) RageClickAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project on rage click alert")
	}
	var alerts []*model.SessionAlert
	if err := r.DB.Model(&model.SessionAlert{}).Where("project_id = ?", projectID).
		Where("type=?", model.AlertType.RAGE_CLICK).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying rage click alert")
	}
	return alerts, nil
}

// LogAlerts is the resolver for the log_alerts field.
func (r *queryResolver) LogAlerts(ctx context.Context, projectID int) ([]*model.LogAlert, error) {
	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error validating admin in project")
	}
	var alerts []*model.LogAlert
	if err := r.DB.Model(&model.LogAlert{}).Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying log alerts")
	}
	return alerts, nil
}

// LogAlert is the resolver for the log_alert field.
func (r *queryResolver) LogAlert(ctx context.Context, id int) (*model.LogAlert, error) {
	var alert *model.LogAlert
	if err := r.DB.Model(&model.LogAlert{}).Where("id = ?", id).Find(&alert).Error; err != nil {
		return nil, e.Wrap(err, "error querying log alert")
	}
	_, err := r.isAdminInProjectOrDemoProject(ctx, alert.ProjectID)
	if err != nil {
		return nil, e.Wrap(err, "error validating admin in project")
	}
	return alert, nil
}

// ProjectSuggestion is the resolver for the projectSuggestion field.
func (r *queryResolver) ProjectSuggestion(ctx context.Context, query string) ([]*model.Project, error) {
	projects := []*model.Project{}
	if r.isWhitelistedAccount(ctx) {
		if err := r.DB.Model(&model.Project{}).Where("name ILIKE ?", "%"+query+"%").Find(&projects).Error; err != nil {
			return nil, e.Wrap(err, "error getting associated projects")
		}
	}
	return projects, nil
}

// WorkspaceSuggestion is the resolver for the workspaceSuggestion field.
func (r *queryResolver) WorkspaceSuggestion(ctx context.Context, query string) ([]*model.Workspace, error) {
	workspaces := []*model.Workspace{}
	if r.isWhitelistedAccount(ctx) {
		if err := r.DB.Model(&model.Workspace{}).Where("name ILIKE ?", "%"+query+"%").Find(&workspaces).Error; err != nil {
			return nil, e.Wrap(err, "error getting workspace suggestions")
		}
	}
	return workspaces, nil
}

// EnvironmentSuggestion is the resolver for the environment_suggestion field.
func (r *queryResolver) EnvironmentSuggestion(ctx context.Context, projectID int) ([]*model.Field, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	fields := []*model.Field{}
	res := r.DB.Where(&model.Field{Type: "session", Name: "environment"}).
		Where("project_id = ?", projectID).
		Where("length(value) > ?", 0).
		Distinct("value").
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying field suggestion")
	}
	return fields, nil
}

// AppVersionSuggestion is the resolver for the app_version_suggestion field.
func (r *queryResolver) AppVersionSuggestion(ctx context.Context, projectID int) ([]*string, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "error querying project")
	}
	appVersions := []*string{}

	if err := r.DB.Raw("SELECT DISTINCT app_version FROM sessions WHERE app_version IS NOT NULL AND project_id = ?", projectID).Find(&appVersions).Error; err != nil {
		return nil, e.Wrap(err, "error getting app version suggestions")
	}

	return appVersions, nil
}

// IdentifierSuggestion is the resolver for the identifier_suggestion field.
func (r *queryResolver) IdentifierSuggestion(ctx context.Context, projectID int, query string) ([]string, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	input := fmt.Sprintf(`{"wildcard": {"identifier.keyword": {"value": "*%s*", "case_insensitive": true}}}`, query)
	options := opensearch.SearchOptions{
		MaxResults: pointy.Int(0),
		Aggregation: &opensearch.TermsAggregation{
			Field: "identifier.keyword",
		},
	}

	results := []model.Session{}
	_, aggs, err := r.OpenSearch.Search([]opensearch.Index{opensearch.IndexSessions}, projectID, input, options, &results)
	if err != nil {
		return nil, e.Wrap(err, "error querying identifier aggregates")
	}

	// Only care about the keys, not the doc counts. Return all nonempty keys.
	return lo.Filter(
		lo.Map(aggs, func(ar opensearch.AggregationResult, idx int) string { return ar.Key }),
		func(key string, idx int) bool { return len(key) > 0 }), nil
}

// SlackChannelSuggestion is the resolver for the slack_channel_suggestion field.
func (r *queryResolver) SlackChannelSuggestion(ctx context.Context, projectID int) ([]*modelInputs.SanitizedSlackChannel, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error getting project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	chs, err := workspace.IntegratedSlackChannels()
	if err != nil {
		return nil, e.Wrap(err, "error retrieving existing channels")
	}
	ret := []*modelInputs.SanitizedSlackChannel{}
	for _, ch := range chs {
		channel := ch.WebhookChannel
		channelID := ch.WebhookChannelID
		ret = append(ret, &modelInputs.SanitizedSlackChannel{
			WebhookChannel:   &channel,
			WebhookChannelID: &channelID,
		})
	}
	return ret, nil
}

// DiscordChannelSuggestions is the resolver for the discord_channel_suggestions field.
func (r *queryResolver) DiscordChannelSuggestions(ctx context.Context, projectID int) ([]*model.DiscordChannel, error) {
	ret := []*model.DiscordChannel{}

	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return ret, e.Wrap(err, "error getting project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	guildId := workspace.DiscordGuildId

	if guildId == nil {
		return ret, e.Wrap(err, "discord not enabled for workspace")
	}

	bot, err := discord.NewDiscordBot(*guildId)

	if err != nil {
		return ret, err
	}

	channels, err := bot.GetChannels()

	if err != nil {
		return ret, err
	}

	for _, ch := range channels {
		ret = append(ret, &model.DiscordChannel{
			ID:   ch.ID,
			Name: ch.Name,
		})
	}

	return ret, nil
}

// GenerateZapierAccessToken is the resolver for the generate_zapier_access_token field.
func (r *queryResolver) GenerateZapierAccessToken(ctx context.Context, projectID int) (string, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return "", e.Wrap(err, "error querying project")
	}

	if project.ZapierAccessToken != nil {
		return "", e.New("zapier access token already exists, can't generate another jwt")
	}

	token, err := zapier.GenerateZapierAccessToken(project.ID)
	if err != nil {
		return "", e.Wrap(err, "error generating zapier access token")
	}

	return token, nil
}

// IsIntegratedWith is the resolver for the is_integrated_with field.
func (r *queryResolver) IsIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)

	if err != nil {
		return false, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if integrationType == modelInputs.IntegrationTypeLinear {
		return workspace.LinearAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeSlack {
		return workspace.SlackAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeZapier {
		return project.ZapierAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeFront {
		if project.FrontAccessToken == nil || project.FrontRefreshToken == nil || project.FrontTokenExpiresAt == nil {
			return false, nil
		}
		oauth, err := front.RefreshOAuth(ctx, &front.OAuthToken{
			AccessToken:  *project.FrontAccessToken,
			RefreshToken: *project.FrontRefreshToken,
			ExpiresAt:    project.FrontTokenExpiresAt.Unix(),
		})
		if err != nil {
			return false, e.Wrap(err, "failed to refresh oauth")
		}
		if err := r.saveFrontOAuth(project, oauth); err != nil {
			return false, e.Wrap(err, "failed to save oauth")
		}
		return project.FrontAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeVercel {
		// If there is an error accessing the Vercel projects, user needs to integrate again
		_, err := r.VercelProjects(ctx, projectID)
		if err != nil {
			return false, err
		}
		return workspace.VercelAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeDiscord {
		return workspace.DiscordGuildId != nil, nil
	}

	return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
}

// IsWorkspaceIntegratedWith is the resolver for the is_workspace_integrated_with field.
func (r *queryResolver) IsWorkspaceIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, workspaceID int) (bool, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, e.Wrap(err, "error querying workspace")
	}

	if integrationType == modelInputs.IntegrationTypeClickUp {
		return workspace.ClickupAccessToken != nil, nil
	} else {
		workspaceMapping := &model.IntegrationWorkspaceMapping{}
		if err := r.DB.Where(&model.IntegrationWorkspaceMapping{
			WorkspaceID:     workspace.ID,
			IntegrationType: integrationType,
		}).First(&workspaceMapping).Error; err != nil {
			return false, nil
		}

		if workspaceMapping == nil {
			return false, nil
		}
	}

	return true, nil
}

// IsProjectIntegratedWith is the resolver for the is_project_integrated_with field.
func (r *queryResolver) IsProjectIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)

	if err != nil {
		return false, e.Wrap(err, "error querying project")
	}

	if integrationType == modelInputs.IntegrationTypeClickUp {
		var projectMapping *model.IntegrationProjectMapping
		if err := r.DB.Where(&model.IntegrationProjectMapping{
			ProjectID:       project.ID,
			IntegrationType: integrationType,
		}).First(&projectMapping).Error; err != nil {
			return false, nil
		}

		if projectMapping == nil {
			return false, nil
		}

	}

	return r.IntegrationsClient.IsProjectIntegrated(ctx, project, integrationType)
}

// VercelProjects is the resolver for the vercel_projects field.
func (r *queryResolver) VercelProjects(ctx context.Context, projectID int) ([]*modelInputs.VercelProject, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	ret := []*modelInputs.VercelProject{}
	if err != nil {
		return ret, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	// Workspace does not have linear set up yet, don't have to treat this as an error
	if workspace.VercelAccessToken == nil {
		return ret, nil
	}

	res, err := vercel.GetProjects(*workspace.VercelAccessToken, workspace.VercelTeamID)
	if err != nil {
		return ret, e.Wrap(err, "error getting vercel teams")
	}

	return res, nil
}

// VercelProjectMappings is the resolver for the vercel_project_mappings field.
func (r *queryResolver) VercelProjectMappings(ctx context.Context, projectID int) ([]*modelInputs.VercelProjectMapping, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	rows := []*model.VercelIntegrationConfig{}
	if err := r.DB.Where("workspace_id = ?", project.WorkspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.VercelIntegrationConfig, idx int) *modelInputs.VercelProjectMapping {
		return &modelInputs.VercelProjectMapping{
			VercelProjectID: c.VercelProjectID,
			ProjectID:       c.ProjectID,
		}
	})

	return results, nil
}

// ClickupTeams is the resolver for the clickup_teams field.
func (r *queryResolver) ClickupTeams(ctx context.Context, workspaceID int) ([]*modelInputs.ClickUpTeam, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return []*modelInputs.ClickUpTeam{}, nil
	}

	teams, err := clickup.GetTeams(*workspace.ClickupAccessToken)
	if err != nil {
		return nil, err
	}

	for _, t := range teams {
		t.Spaces, err = clickup.GetSpaces(*workspace.ClickupAccessToken, t.ID)
		if err != nil {
			return nil, err
		}
	}

	return teams, nil
}

// ClickupProjectMappings is the resolver for the clickup_project_mappings field.
func (r *queryResolver) ClickupProjectMappings(ctx context.Context, workspaceID int) ([]*modelInputs.ClickUpProjectMapping, error) {
	_, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	rows := []*model.IntegrationProjectMapping{}
	if err := r.DB.Raw(`
		SELECT * FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, modelInputs.IntegrationTypeClickUp, workspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.IntegrationProjectMapping, idx int) *modelInputs.ClickUpProjectMapping {
		return &modelInputs.ClickUpProjectMapping{
			ProjectID:      c.ProjectID,
			ClickupSpaceID: c.ExternalID,
		}
	})

	return results, nil
}

// ClickupFolders is the resolver for the clickup_folders field.
func (r *queryResolver) ClickupFolders(ctx context.Context, projectID int) ([]*modelInputs.ClickUpFolder, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return nil, e.New("workspace does not have an access token")
	}

	var settings model.IntegrationProjectMapping
	if err := r.DB.Where(&model.IntegrationProjectMapping{
		ProjectID: projectID, IntegrationType: modelInputs.IntegrationTypeClickUp}).
		Find(&settings).Error; err != nil {
		return nil, err
	}

	if settings.ExternalID == "" {
		return nil, e.New("Project does not have an associated ClickUp space")
	}

	return clickup.GetFolders(*workspace.ClickupAccessToken, settings.ExternalID)
}

// ClickupFolderlessLists is the resolver for the clickup_folderless_lists field.
func (r *queryResolver) ClickupFolderlessLists(ctx context.Context, projectID int) ([]*modelInputs.ClickUpList, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return nil, e.New("workspace does not have an access token")
	}

	var settings model.IntegrationProjectMapping
	if err := r.DB.Where(&model.IntegrationProjectMapping{
		ProjectID: projectID, IntegrationType: modelInputs.IntegrationTypeClickUp}).
		Find(&settings).Error; err != nil {
		return nil, err
	}

	if settings.ExternalID == "" {
		return nil, e.New("Project does not have an associated ClickUp space")
	}

	return clickup.GetFolderlessLists(*workspace.ClickupAccessToken, settings.ExternalID)
}

// HeightLists is the resolver for the height_lists field.
func (r *queryResolver) HeightLists(ctx context.Context, projectID int) ([]*modelInputs.HeightList, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	accessToken, err := r.IntegrationsClient.GetWorkspaceAccessToken(ctx, workspace, modelInputs.IntegrationTypeHeight)

	if err != nil {
		return nil, err
	}

	lists, err := height.GetLists(*accessToken)

	return lists, err
}

// HeightWorkspaces is the resolver for the height_workspaces field.
func (r *queryResolver) HeightWorkspaces(ctx context.Context, workspaceID int) ([]*modelInputs.HeightWorkspace, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	accessToken, err := r.IntegrationsClient.GetWorkspaceAccessToken(ctx, workspace, modelInputs.IntegrationTypeHeight)

	if err != nil {
		return nil, err
	}

	if accessToken == nil {
		return []*modelInputs.HeightWorkspace{}, nil
	}

	workspaces, err := height.GetWorkspaces(*accessToken)

	return workspaces, err
}

// IntegrationProjectMappings is the resolver for the integration_project_mappings field.
func (r *queryResolver) IntegrationProjectMappings(ctx context.Context, workspaceID int, integrationType *modelInputs.IntegrationType) ([]*model.IntegrationProjectMapping, error) {
	_, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	rows := []*model.IntegrationProjectMapping{}
	if err := r.DB.Raw(`
		SELECT * FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, integrationType, workspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	return rows, nil
}

// LinearTeams is the resolver for the linear_teams field.
func (r *queryResolver) LinearTeams(ctx context.Context, projectID int) ([]*modelInputs.LinearTeam, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	ret := []*modelInputs.LinearTeam{}

	if err != nil {
		return ret, e.Wrap(err, "error querying project")
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	// Workspace does not have linear set up yet, don't have to treat this as an error
	if workspace.LinearAccessToken == nil {
		return ret, nil
	}

	res, err := r.GetLinearTeams(*workspace.LinearAccessToken)

	if err != nil {
		return ret, e.Wrap(err, "error getting linear teams")
	}

	teamResponse := res.Data.Teams.Nodes

	ret = lo.Map(teamResponse, func(team LinearTeam, _ int) *modelInputs.LinearTeam {
		return &modelInputs.LinearTeam{
			TeamID: team.ID,
			Name:   team.Name,
			Key:    team.Key,
		}
	})

	return ret, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id int) (*model.Project, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, id)
	if err != nil {
		return nil, nil
	}
	return project, nil
}

// Workspace is the resolver for the workspace field.
func (r *queryResolver) Workspace(ctx context.Context, id int) (*model.Workspace, error) {
	workspace, err := r.isAdminInWorkspace(ctx, id)
	if err != nil {
		return nil, nil
	}

	projects := []model.Project{}
	if err := r.DB.Order("name ASC").Model(&workspace).Association("Projects").Find(&projects); err != nil {
		return nil, e.Wrap(err, "error querying associated projects")
	}

	workspace.Projects = projects
	return workspace, nil
}

// WorkspaceForInviteLink is the resolver for the workspace_for_invite_link field.
func (r *queryResolver) WorkspaceForInviteLink(ctx context.Context, secret string) (*modelInputs.WorkspaceForInviteLink, error) {
	var workspaceInviteLink model.WorkspaceInviteLink
	if err := r.DB.Where(&model.WorkspaceInviteLink{Secret: &secret}).First(&workspaceInviteLink).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace invite link")
	}

	var workspace model.Workspace
	if err := r.DB.Model(&model.Workspace{}).Where("id = ?", *workspaceInviteLink.WorkspaceID).First(&workspace).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace for invite link")
	}

	var admin *model.Admin
	if workspaceInviteLink.InviteeEmail != nil {
		if err := r.DB.Model(&model.Admin{Email: workspaceInviteLink.InviteeEmail}).First(&admin).Error; err != nil {
			return nil, e.Wrap(err, "error querying admin for invitee_email")
		}
	}

	workspaceForInvite := &modelInputs.WorkspaceForInviteLink{
		ExpirationDate:  workspaceInviteLink.ExpirationDate,
		InviteeEmail:    workspaceInviteLink.InviteeEmail,
		Secret:          *workspaceInviteLink.Secret,
		WorkspaceID:     workspace.ID,
		WorkspaceName:   *workspace.Name,
		ExistingAccount: admin != nil,
	}

	return workspaceForInvite, nil
}

// WorkspaceInviteLinks is the resolver for the workspace_invite_links field.
func (r *queryResolver) WorkspaceInviteLinks(ctx context.Context, workspaceID int) (*model.WorkspaceInviteLink, error) {
	_, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	var workspaceInviteLink *model.WorkspaceInviteLink
	shouldCreateNewInviteLink := false

	if err := r.DB.Where(&model.WorkspaceInviteLink{WorkspaceID: &workspaceID, InviteeEmail: nil}).Where("invitee_email IS NULL").Order("created_at desc").First(&workspaceInviteLink).Error; err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			shouldCreateNewInviteLink = true
		} else {
			return nil, e.Wrap(err, "error querying workspace invite links")
		}
	}

	if r.IsInviteLinkExpired(workspaceInviteLink) && !shouldCreateNewInviteLink {
		shouldCreateNewInviteLink = true
		if err := r.DB.Delete(workspaceInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "error while deleting expired invite link for workspace")
		}
	}

	if workspaceInviteLink != nil && workspaceInviteLink.ExpirationDate != nil {
		// Create a new invite link if the current one expires within 7 days.
		daysRemainingForInvite := int(math.Abs(time.Now().UTC().Sub(*workspaceInviteLink.ExpirationDate).Hours() / 24))
		if daysRemainingForInvite <= 7 {
			shouldCreateNewInviteLink = true
		}

	}

	if shouldCreateNewInviteLink {
		workspaceInviteLink = r.CreateInviteLink(workspaceID, nil, model.AdminRole.ADMIN, true)

		if err := r.DB.Create(&workspaceInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "failed to create new invite link to replace expired one.")
		}
	}

	return workspaceInviteLink, nil
}

// WorkspaceForProject is the resolver for the workspace_for_project field.
func (r *queryResolver) WorkspaceForProject(ctx context.Context, projectID int) (*model.Workspace, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}

	// workspace secret should not be visible unless the admin has workspace access
	workspace.Secret = new(string)

	projects := []model.Project{}
	if err := r.DB.Order("name ASC").Model(&workspace).Association("Projects").Find(&projects); err != nil {
		return nil, e.Wrap(err, "error querying associated projects")
	}

	workspace.Projects = projects
	return workspace, nil
}

// Admin is the resolver for the admin field.
func (r *queryResolver) Admin(ctx context.Context) (*model.Admin, error) {
	admin := &model.Admin{UID: pointy.String(fmt.Sprintf("%v", ctx.Value(model.ContextKeys.UID)))}
	adminSpan, ctx := tracer.StartSpanFromContext(ctx, "resolver.getAdmin", tracer.ResourceName("db.admin"),
		tracer.Tag("admin_uid", admin.UID))

	if err := r.DB.Where(&model.Admin{UID: admin.UID}).First(&admin).Error; err != nil {
		if admin, err = r.createAdmin(ctx); err != nil {
			spanError := e.Wrap(err, "error creating user in postgres")
			adminSpan.Finish(tracer.WithError(spanError))
			return nil, spanError
		}
	}

	if admin.PhotoURL == nil || admin.Name == nil {
		firebaseSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.getAdmin", tracer.ResourceName("db.updateAdminFromFirebase"),
			tracer.Tag("admin_uid", *admin.UID))
		firebaseUser, err := AuthClient.GetUser(context.Background(), *admin.UID)
		if err != nil {
			spanError := e.Wrap(err, "error retrieving user from firebase api")
			adminSpan.Finish(tracer.WithError(spanError))
			firebaseSpan.Finish(tracer.WithError(spanError))
			return nil, spanError
		}
		if err := r.DB.Where(&model.Admin{UID: admin.UID}).Updates(&model.Admin{
			PhotoURL: &firebaseUser.PhotoURL,
			Name:     &firebaseUser.DisplayName,
			Phone:    &firebaseUser.PhoneNumber,
		}).Error; err != nil {
			spanError := e.Wrap(err, "error updating org fields")
			adminSpan.Finish(tracer.WithError(spanError))
			firebaseSpan.Finish(tracer.WithError(spanError))
			return nil, spanError
		}
		admin.PhotoURL = &firebaseUser.PhotoURL
		admin.Name = &firebaseUser.DisplayName
		admin.Phone = &firebaseUser.PhoneNumber
		firebaseSpan.Finish()
	}

	// Check email verification status
	if admin.EmailVerified != nil && !*admin.EmailVerified {
		firebaseSpan, _ := tracer.StartSpanFromContext(ctx, "resolver.getAdmin", tracer.ResourceName("db.updateAdminFromFirebaseForEmailVerification"),
			tracer.Tag("admin_uid", *admin.UID))
		firebaseUser, err := AuthClient.GetUser(context.Background(), *admin.UID)
		if err != nil {
			spanError := e.Wrap(err, "error retrieving user from firebase api for email verification")
			adminSpan.Finish(tracer.WithError(spanError))
			firebaseSpan.Finish(tracer.WithError(spanError))
			return nil, spanError
		}
		if err := r.DB.Where(&model.Admin{UID: admin.UID}).Updates(&model.Admin{
			EmailVerified: &firebaseUser.EmailVerified,
		}).Error; err != nil {
			spanError := e.Wrap(err, "error updating admin fields")
			adminSpan.Finish(tracer.WithError(spanError))
			firebaseSpan.Finish(tracer.WithError(spanError))
			return nil, spanError
		}
		admin.EmailVerified = &firebaseUser.EmailVerified
		firebaseSpan.Finish()
	}

	adminSpan.Finish()
	return admin, nil
}

// AdminRole is the resolver for the admin_role field.
func (r *queryResolver) AdminRole(ctx context.Context, workspaceID int) (*model.WorkspaceAdminRole, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if r.isWhitelistedAccount(ctx) {
		return &model.WorkspaceAdminRole{
			Admin: admin,
			Role:  model.AdminRole.ADMIN,
		}, nil
	}

	// ok to have empty string role, treated as unauthenticated user
	role, _ := r.GetAdminRole(ctx, admin.ID, workspaceID)
	return &model.WorkspaceAdminRole{
		Admin: admin,
		Role:  role,
	}, nil
}

// AdminRoleByProject is the resolver for the admin_role_by_project field.
func (r *queryResolver) AdminRoleByProject(ctx context.Context, projectID int) (*model.WorkspaceAdminRole, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if r.isWhitelistedAccount(ctx) {
		return &model.WorkspaceAdminRole{
			Admin: admin,
			Role:  model.AdminRole.ADMIN,
		}, nil
	}

	var role string
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err == nil {
		if workspace, err := r.GetWorkspace(project.WorkspaceID); err == nil {
			// ok to have empty string role, treated as unauthenticated user
			role, _ = r.GetAdminRole(ctx, admin.ID, workspace.ID)
		}
	}

	return &model.WorkspaceAdminRole{
		Admin: admin,
		Role:  role,
	}, nil
}

// Segments is the resolver for the segments field.
func (r *queryResolver) Segments(ctx context.Context, projectID int) ([]*model.Segment, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}
	// list of maps, where each map represents a field query.
	segments := []*model.Segment{}
	if err := r.DB.Model(model.Segment{}).Where("project_id = ?", projectID).Find(&segments).Error; err != nil {
		log.WithContext(ctx).Errorf("error querying segments from project: %v", err)
	}
	return segments, nil
}

// ErrorSegments is the resolver for the error_segments field.
func (r *queryResolver) ErrorSegments(ctx context.Context, projectID int) ([]*model.ErrorSegment, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in project")
	}
	// list of maps, where each map represents a field query.
	segments := []*model.ErrorSegment{}
	if err := r.DB.Model(model.ErrorSegment{}).Where("project_id = ?", projectID).Find(&segments).Error; err != nil {
		log.WithContext(ctx).Errorf("error querying segments from project: %v", err)
	}
	return segments, nil
}

// APIKeyToOrgID is the resolver for the api_key_to_org_id field.
func (r *queryResolver) APIKeyToOrgID(ctx context.Context, apiKey string) (*int, error) {
	var projectId int
	if err := r.DB.Table("projects").Select("id").Where("secret=?", apiKey).Scan(&projectId).Error; err != nil {
		return nil, e.Wrap(err, "error getting project id from api key")
	}
	return &projectId, nil
}

// GetSourceMapUploadUrls is the resolver for the get_source_map_upload_urls field.
func (r *queryResolver) GetSourceMapUploadUrls(ctx context.Context, apiKey string, paths []string) ([]string, error) {
	projectId, err := r.APIKeyToOrgID(ctx, apiKey)
	if err != nil {
		return nil, err
	}
	if projectId == nil {
		return nil, e.New("invalid API key - project id is nil")
	}

	// Assert all paths start with this prefix to block cross-project uploads
	pathPrefix := fmt.Sprintf("%d/", *projectId)

	urls := []string{}
	for _, path := range paths {
		if !strings.HasPrefix(path, pathPrefix) {
			return nil, e.New("invalid path - does not start with project prefix")
		}
		url, err := r.StorageClient.GetSourceMapUploadUrl(ctx, path)
		if err != nil {
			return nil, err
		}
		urls = append(urls, url)
	}

	return urls, nil
}

// CustomerPortalURL is the resolver for the customer_portal_url field.
func (r *queryResolver) CustomerPortalURL(ctx context.Context, workspaceID int) (string, error) {
	frontendUri := os.Getenv("FRONTEND_URI")

	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return "", e.Wrap(err, "admin does not have workspace access")
	}

	if err := r.validateAdminRole(ctx, workspaceID); err != nil {
		return "", e.Wrap(err, "must have ADMIN role to access the Stripe customer portal")
	}

	returnUrl := fmt.Sprintf("%s/w/%d/current-plan", frontendUri, workspaceID)

	params := &stripe.BillingPortalSessionParams{
		Customer:  workspace.StripeCustomerID,
		ReturnURL: &returnUrl,
	}

	portalSession, err := r.StripeClient.BillingPortalSessions.New(params)
	if err != nil {
		return "", e.Wrap(err, "error creating customer portal session")
	}

	return portalSession.URL, nil
}

// SubscriptionDetails is the resolver for the subscription_details field.
func (r *queryResolver) SubscriptionDetails(ctx context.Context, workspaceID int) (*modelInputs.SubscriptionDetails, error) {
	workspace, err := r.isAdminInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	if err := r.validateAdminRole(ctx, workspaceID); err != nil {
		return nil, nil
	}

	customerParams := &stripe.CustomerParams{}
	customerParams.AddExpand("subscriptions")
	c, err := r.StripeClient.Customers.Get(*workspace.StripeCustomerID, customerParams)
	if err != nil {
		return nil, e.Wrap(err, "error querying stripe customer")
	}

	if len(c.Subscriptions.Data) == 0 {
		return &modelInputs.SubscriptionDetails{}, nil
	}

	amount := c.Subscriptions.Data[0].Items.Data[0].Price.UnitAmount
	details := &modelInputs.SubscriptionDetails{BaseAmount: amount}

	discount := c.Subscriptions.Data[0].Discount
	if discount != nil && discount.Coupon != nil {
		details.DiscountAmount = discount.Coupon.AmountOff
		details.DiscountPercent = discount.Coupon.PercentOff
	}

	invoiceID := c.Subscriptions.Data[0].LatestInvoice.ID
	invoiceParams := &stripe.InvoiceParams{}
	customerParams.AddExpand("invoice_items")
	invoice, err := r.StripeClient.Invoices.Get(invoiceID, invoiceParams)
	if err != nil {
		return nil, e.Wrap(err, "error querying stripe invoice")
	}

	if invoice != nil {
		invoiceDue := time.Unix(invoice.Created, 0)
		status := string(invoice.Status)
		details.LastInvoice = &modelInputs.Invoice{
			Date:         &invoiceDue,
			AmountDue:    &invoice.AmountDue,
			AmountPaid:   &invoice.AmountPaid,
			AttemptCount: &invoice.AttemptCount,
			Status:       &status,
			URL:          &invoice.HostedInvoiceURL,
		}
	}

	return details, nil
}

// DashboardDefinitions is the resolver for the dashboard_definitions field.
func (r *queryResolver) DashboardDefinitions(ctx context.Context, projectID int) ([]*modelInputs.DashboardDefinition, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	var dashboards []*model.Dashboard
	if err := r.DB.Order("updated_at DESC").Preload("Metrics", func(db *gorm.DB) *gorm.DB {
		db = db.Order("id ASC")
		return db
	}).Preload("Metrics.Filters").Where(&model.Dashboard{ProjectID: projectID}).Find(&dashboards).Error; err != nil {
		return nil, err
	}

	var results []*modelInputs.DashboardDefinition
	for _, d := range dashboards {
		var metrics []*modelInputs.DashboardMetricConfig
		for _, metric := range d.Metrics {
			var filters []*modelInputs.MetricTagFilter
			for _, f := range metric.Filters {
				filters = append(filters, &modelInputs.MetricTagFilter{
					Tag:   f.Tag,
					Op:    f.Op,
					Value: f.Value,
				})
			}
			metrics = append(metrics, &modelInputs.DashboardMetricConfig{
				Name:                     metric.Name,
				Description:              metric.Description,
				ComponentType:            metric.ComponentType,
				ChartType:                metric.ChartType,
				Aggregator:               metric.Aggregator,
				MaxGoodValue:             metric.MaxGoodValue,
				MaxNeedsImprovementValue: metric.MaxNeedsImprovementValue,
				PoorValue:                metric.PoorValue,
				Units:                    metric.Units,
				HelpArticle:              metric.HelpArticle,
				MinValue:                 metric.MinValue,
				MinPercentile:            metric.MinPercentile,
				MaxValue:                 metric.MaxValue,
				MaxPercentile:            metric.MaxPercentile,
				Filters:                  filters,
				Groups:                   metric.Groups,
			})
		}
		results = append(results, &modelInputs.DashboardDefinition{
			ID:                d.ID,
			UpdatedAt:         d.UpdatedAt,
			ProjectID:         d.ProjectID,
			Name:              d.Name,
			Metrics:           metrics,
			LastAdminToEditID: d.LastAdminToEditID,
			Layout:            d.Layout,
			IsDefault:         d.IsDefault,
		})
	}
	return results, nil
}

// SuggestedMetrics is the resolver for the suggested_metrics field.
func (r *queryResolver) SuggestedMetrics(ctx context.Context, projectID int, prefix string) ([]string, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	filter := ""
	if len(prefix) > 0 {
		filter = fmt.Sprintf(`|> filter(fn: (r) => r["_field"] =~ /%s/)`, prefix)
	}
	query := fmt.Sprintf(`
		from(bucket: "%s")
		  |> range(start: -1d)
		  |> filter(fn: (r) => r["_measurement"] == "%s")
		  %s
		  |> group(columns: ["_field"])
		  |> distinct(column: "_field")
		  |> yield(name: "distinct")
	`, r.TDB.GetBucket(strconv.Itoa(projectID), timeseries.Metrics), timeseries.Metrics, filter)
	tdbQuerySpan, _ := tracer.StartSpanFromContext(ctx, "tdb.querySuggestedMetrics")
	tdbQuerySpan.SetTag("projectID", projectID)
	results, err := r.TDB.Query(ctx, query)
	tdbQuerySpan.Finish()
	if err != nil {
		return nil, err
	}

	return lo.Map(results, func(t *timeseries.Result, _ int) string {
		return t.Value.(string)
	}), nil
}

// MetricTags is the resolver for the metric_tags field.
func (r *queryResolver) MetricTags(ctx context.Context, projectID int, metricName string) ([]string, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	query := fmt.Sprintf(`
		import "influxdata/influxdb/schema"
		schema.tagKeys(bucket: "%s", predicate: (r) => r["_measurement"] == "%s" and r["_field"] == "%s")
	`, r.TDB.GetBucket(strconv.Itoa(projectID), timeseries.Metrics), timeseries.Metrics, metricName)
	tdbQuerySpan, _ := tracer.StartSpanFromContext(ctx, "tdb.queryMetricTags")
	tdbQuerySpan.SetTag("projectID", projectID)
	tdbQuerySpan.SetTag("metricName", metricName)
	results, err := r.TDB.Query(ctx, query)
	tdbQuerySpan.Finish()
	if err != nil {
		return nil, err
	}

	metrics, _ := r.SuggestedMetrics(ctx, projectID, "")

	return lo.Filter(lo.Map(results, func(t *timeseries.Result, _ int) string {
		return t.Value.(string)
	}), func(t string, _ int) bool {
		// filter out metrics from possible metric tags
		_, isMetric := lo.Find(metrics, func(m string) bool { return t == m })
		return !strings.HasPrefix(t, "_") && !isMetric
	}), nil
}

// MetricTagValues is the resolver for the metric_tag_values field.
func (r *queryResolver) MetricTagValues(ctx context.Context, projectID int, metricName string, tagName string) ([]string, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	query := fmt.Sprintf(`
		import "influxdata/influxdb/schema"
		schema.tagValues(bucket: "%s", tag: "%s", predicate: (r) => r["_measurement"] == "%s" and r["_field"] == "%s")
	`, r.TDB.GetBucket(strconv.Itoa(projectID), timeseries.Metrics), tagName, timeseries.Metrics, metricName)
	tdbQuerySpan, _ := tracer.StartSpanFromContext(ctx, "tdb.queryMetricTagValues")
	tdbQuerySpan.SetTag("projectID", projectID)
	tdbQuerySpan.SetTag("metricName", metricName)
	tdbQuerySpan.SetTag("tagName", tagName)
	results, err := r.TDB.Query(ctx, query)
	tdbQuerySpan.Finish()
	if err != nil {
		return nil, err
	}

	return lo.Map(results, func(t *timeseries.Result, _ int) string {
		return t.Value.(string)
	}), nil
}

// MetricsTimeline is the resolver for the metrics_timeline field.
func (r *queryResolver) MetricsTimeline(ctx context.Context, projectID int, metricName string, params modelInputs.DashboardParamsInput) ([]*modelInputs.DashboardPayload, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	return GetMetricTimeline(ctx, r.TDB, projectID, metricName, params)
}

// MetricsHistogram is the resolver for the metrics_histogram field.
func (r *queryResolver) MetricsHistogram(ctx context.Context, projectID int, metricName string, params modelInputs.HistogramParamsInput) (*modelInputs.HistogramPayload, error) {
	if _, err := r.isAdminInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	bucket, measurement := r.TDB.GetSampledMeasurement(r.TDB.GetBucket(strconv.Itoa(projectID), timeseries.Metrics), timeseries.Metrics, params.DateRange.EndDate.Sub(*params.DateRange.StartDate))
	div := CalculateMetricUnitConversion(MetricOriginalUnits(metricName), params.Units)
	tagFilters := GetTagFilters(ctx, params.Filters)
	if params.MinValue == nil || params.MaxValue == nil {
		minPercentile := 0.01
		if params.MinPercentile != nil {
			minPercentile = *params.MinPercentile
		}
		maxPercentile := 0.99
		if params.MaxPercentile != nil {
			maxPercentile = *params.MaxPercentile
		}
		query := fmt.Sprintf(`
	  do = (q) =>
		from(bucket: "%s")
		  |> range(start: %s, stop: %s)
		  |> filter(fn: (r) => r["_measurement"] == "%s")
		  |> filter(fn: (r) => r["_field"] == "%s")
		  %s|> group()
		  |> quantile(q:q, method: "estimate_tdigest", compression: 100.0)
		  |> map(fn: (r) => ({r with _value: r._value / %f}))
      union(tables: [
		do(q:%f),
		do(q:%f)
	  ])
		  |> sort()
  `, bucket, params.DateRange.StartDate.Format(time.RFC3339), params.DateRange.EndDate.Format(time.RFC3339), measurement, metricName, tagFilters, div, minPercentile, maxPercentile)
		histogramRangeQuerySpan, _ := tracer.StartSpanFromContext(ctx, "tdb.queryHistogram")
		histogramRangeQuerySpan.SetTag("projectID", projectID)
		histogramRangeQuerySpan.SetTag("metricName", metricName)
		results, err := r.TDB.Query(ctx, query)
		histogramRangeQuerySpan.Finish()
		if err != nil {
			return nil, err
		}
		if len(results) < 1 {
			return nil, nil
		}

		HistogramPercentileOffset := 0.1
		// offset min and max to include min and max values and pad the distribution a bit
		if params.MinValue == nil {
			f := results[0].Value.(float64) * (1 - HistogramPercentileOffset)
			params.MinValue = &f
		}
		if params.MaxValue == nil {
			f := results[1].Value.(float64) * (1 + HistogramPercentileOffset)
			params.MaxValue = &f
		}
	}
	histogramPayload := &modelInputs.HistogramPayload{
		Min: *params.MinValue,
		Max: *params.MaxValue,
	}

	numBuckets := 10
	if params.Buckets != nil {
		numBuckets = *params.Buckets
	}
	bucketSize := (histogramPayload.Max - histogramPayload.Min) / float64(numBuckets)
	if bucketSize == 0. {
		bucketSize = 1
	}

	query := fmt.Sprintf(`
		from(bucket: "%s")
		  |> range(start: %s, stop: %s)
		  |> filter(fn: (r) => r["_measurement"] == "%s")
		  |> filter(fn: (r) => r["_field"] == "%s")
          %s|> group()
		  |> histogram(bins: linearBins(start: %f, width: %f, count: %d, infinity: true))
          |> map(fn: (r) => ({r with le: r.le / %f}))
	`, bucket, params.DateRange.StartDate.Format(time.RFC3339), params.DateRange.EndDate.Format(time.RFC3339), measurement, metricName, tagFilters, histogramPayload.Min*div, bucketSize*div, numBuckets, div)
	histogramQuerySpan, _ := tracer.StartSpanFromContext(ctx, "tdb.queryHistogram")
	histogramQuerySpan.SetTag("projectID", projectID)
	histogramQuerySpan.SetTag("metricName", metricName)
	histogramQuerySpan.SetTag("buckets", params.Buckets)
	results, err := r.TDB.Query(ctx, query)
	histogramQuerySpan.Finish()
	if err != nil {
		return nil, err
	}

	var payloadBuckets []*modelInputs.HistogramBucket
	var previousCount = -1
	for i, r := range results {
		// the first bucket LE bound is actually the start value so use it to offset the histogram
		if previousCount == -1 {
			previousCount = int(r.Value.(float64))
			continue
		}
		le := r.Values["le"].(float64)
		b := &modelInputs.HistogramBucket{
			Bucket:     float64(i),
			RangeStart: le - bucketSize,
			RangeEnd:   le,
			Count:      int(r.Value.(float64)) - previousCount,
		}
		previousCount += b.Count
		if !math.IsInf(b.RangeStart, 1) {
			payloadBuckets = append(payloadBuckets, b)
		}
	}
	histogramPayload.Buckets = payloadBuckets
	return histogramPayload, nil
}

// NetworkHistogram is the resolver for the network_histogram field.
func (r *queryResolver) NetworkHistogram(ctx context.Context, projectID int, params modelInputs.NetworkHistogramParamsInput) (*modelInputs.CategoryHistogramPayload, error) {
	project, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	var extraFilters []string
	for _, domain := range project.BackendDomains {
		extraFilters = append(extraFilters, fmt.Sprintf(`r["%s"] =~ /%s/`, params.Attribute.String(), domain))
	}
	extraFiltersStr := ""
	if len(extraFilters) > 0 {
		extraFiltersStr = fmt.Sprintf(`|> filter(fn: (r) => %s)`, strings.Join(extraFilters, " or "))
	}
	days := 1
	if params.LookbackDays != nil {
		days = *params.LookbackDays
	}
	query := fmt.Sprintf(`
		from(bucket: "%s")
		  |> range(start: -%dd)
		  |> filter(fn: (r) => r["_measurement"] == "%s")
          %s
		  |> group(columns: ["%s"])
		  |> count()
          |> group()
		  |> sort(desc: true)
          |> limit(n: 10)
		  |> yield(name: "count")
	`, r.TDB.GetBucket(strconv.Itoa(projectID), timeseries.Metrics), days, timeseries.Metrics, extraFiltersStr, params.Attribute.String())
	networkHistogramSpan, _ := tracer.StartSpanFromContext(ctx, "tdb.queryTimeline")
	networkHistogramSpan.SetTag("projectID", projectID)
	networkHistogramSpan.SetTag("attribute", params.Attribute.String())
	networkHistogramSpan.SetTag("lookbackDays", params.LookbackDays)
	results, err := r.TDB.Query(ctx, query)
	networkHistogramSpan.Finish()
	if err != nil {
		return nil, err
	}

	var buckets []*modelInputs.CategoryHistogramBucket
	for _, r := range results {
		v, ok := r.Values[params.Attribute.String()].(string)
		if ok {
			buckets = append(buckets, &modelInputs.CategoryHistogramBucket{
				Category: v,
				Count:    int(r.Value.(int64)),
			})
		}
	}

	return &modelInputs.CategoryHistogramPayload{Buckets: buckets}, nil
}

// MetricMonitors is the resolver for the metric_monitors field.
func (r *queryResolver) MetricMonitors(ctx context.Context, projectID int, metricName *string) ([]*model.MetricMonitor, error) {
	metricMonitors := []*model.MetricMonitor{}

	_, err := r.isAdminInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return metricMonitors, nil
	}

	query := r.DB.Order("created_at asc").Model(&model.MetricMonitor{}).Where("project_id = ?", projectID)
	if metricName != nil && *metricName != "" {
		query = query.Where("metric_to_monitor = ?", *metricName)
	}
	if err := query.Find(&metricMonitors).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitors")
	}
	return metricMonitors, nil
}

// EventChunkURL is the resolver for the event_chunk_url field.
func (r *queryResolver) EventChunkURL(ctx context.Context, secureID string, index int) (string, error) {
	session, err := r.canAdminViewSession(ctx, secureID)
	if err != nil {
		return "", nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, session.ProjectID, session.ID, storage.SessionContentsCompressed, pointy.Int(index))
	if err != nil {
		return "", e.Wrap(err, "error getting direct download URL")
	}

	if str == nil {
		return "", e.Wrap(err, "nil direct download URL")
	}

	return *str, err
}

// EventChunks is the resolver for the event_chunks field.
func (r *queryResolver) EventChunks(ctx context.Context, secureID string) ([]*model.EventChunk, error) {
	session, err := r.canAdminViewSession(ctx, secureID)
	if err != nil {
		return nil, nil
	}

	chunks := []*model.EventChunk{}
	if err := r.DB.Order("chunk_index ASC").Model(&model.EventChunk{}).Where(&model.EventChunk{SessionID: session.ID}).
		Scan(&chunks).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving event chunks from DB")
	}

	return chunks, nil
}

// SourcemapFiles is the resolver for the sourcemap_files field.
func (r *queryResolver) SourcemapFiles(ctx context.Context, projectID int, version *string) ([]*modelInputs.S3File, error) {
	res, err := r.StorageClient.GetSourcemapFiles(ctx, projectID, version)
	var s3Files []*modelInputs.S3File

	if err != nil {
		return nil, e.Wrap(err, "error getting sourcemaps from s3")
	}

	for _, object := range res {
		s3File := modelInputs.S3File{Key: object.Key}
		s3Files = append(s3Files, &s3File)
	}

	return s3Files, nil
}

// SourcemapVersions is the resolver for the sourcemap_versions field.
func (r *queryResolver) SourcemapVersions(ctx context.Context, projectID int) ([]string, error) {
	res, err := r.StorageClient.GetSourcemapVersions(ctx, projectID)

	if err != nil {
		return nil, e.Wrap(err, "error getting sourcemaps from s3")
	}

	return res, nil
}

// OauthClientMetadata is the resolver for the oauth_client_metadata field.
func (r *queryResolver) OauthClientMetadata(ctx context.Context, clientID string) (*modelInputs.OAuthClient, error) {
	client := &model.OAuthClientStore{ID: clientID}
	if err := r.DB.Model(&client).Select("id", "created_at", "app_name").Where(&client).First(&client).Error; err != nil {
		return nil, e.Wrap(err, "error querying oauth client")
	}
	return &modelInputs.OAuthClient{
		ID:        client.ID,
		CreatedAt: client.CreatedAt,
		AppName:   client.AppName,
	}, nil
}

// EmailOptOuts is the resolver for the email_opt_outs field.
func (r *queryResolver) EmailOptOuts(ctx context.Context, token *string, adminID *int) ([]modelInputs.EmailOptOutCategory, error) {
	var adminIdDeref int
	if adminID != nil && token != nil {
		if !IsOptOutTokenValid(*adminID, *token) {
			return nil, e.New("token is not valid or has expired")
		}
		adminIdDeref = *adminID
	} else {
		admin, err := r.getCurrentAdmin(ctx)
		if err != nil {
			return nil, e.New("error querying current admin")
		}
		adminIdDeref = admin.ID
	}

	rows := []*model.EmailOptOut{}
	if err := r.DB.Where("admin_id = ?", adminIdDeref).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.EmailOptOut, idx int) modelInputs.EmailOptOutCategory {
		return c.Category
	})

	return results, nil
}

// Logs is the resolver for the logs field.
func (r *queryResolver) Logs(ctx context.Context, projectID int, params modelInputs.LogsParamsInput, after *string, before *string, at *string, direction modelInputs.LogDirection) (*modelInputs.LogsConnection, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	return r.ClickhouseClient.ReadLogs(ctx, project.ID, params, clickhouse.Pagination{
		After:     after,
		Before:    before,
		At:        at,
		Direction: direction,
	})
}

// LogsTotalCount is the resolver for the logs_total_count field.
func (r *queryResolver) LogsTotalCount(ctx context.Context, projectID int, params modelInputs.LogsParamsInput) (uint64, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return 0, e.Wrap(err, "error querying project")
	}

	return r.ClickhouseClient.ReadLogsTotalCount(ctx, project.ID, params)
}

// LogsHistogram is the resolver for the logs_histogram field.
func (r *queryResolver) LogsHistogram(ctx context.Context, projectID int, params modelInputs.LogsParamsInput) (*modelInputs.LogsHistogram, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	return r.ClickhouseClient.ReadLogsHistogram(ctx, project.ID, params, 48)
}

// LogsKeys is the resolver for the logs_keys field.
func (r *queryResolver) LogsKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput) ([]*modelInputs.LogKey, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	return r.ClickhouseClient.LogsKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate)
}

// LogsKeyValues is the resolver for the logs_key_values field.
func (r *queryResolver) LogsKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput) ([]string, error) {
	project, err := r.isAdminInProject(ctx, projectID)
	if err != nil {
		return nil, e.Wrap(err, "error querying project")
	}

	return r.ClickhouseClient.LogsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate)
}

// LogsErrorObjects is the resolver for the logs_error_objects field.
func (r *queryResolver) LogsErrorObjects(ctx context.Context, logCursors []string) ([]*model.ErrorObject, error) {
	ddS, _ := tracer.StartSpanFromContext(ctx, "resolver.LogsErrorObjects",
		tracer.ResourceName("DB.Query"), tracer.Tag("NumLogCursors", len(logCursors)))
	s, ctx := highlight.StartTrace(ctx, "LogsErrorObjects.DB.Query", attribute.Int("NumLogCursors", len(logCursors)))

	var errorObjects []*model.ErrorObject
	if err := r.DB.Model(&model.ErrorObject{}).Where("log_cursor IN ?", logCursors).Scan(&errorObjects).Error; err != nil {
		s.RecordError(err)
		highlight.EndTrace(s)
		ddS.Finish(tracer.WithError(err))
		return nil, e.Wrap(err, "failed to find errors for log cursors")
	}
	highlight.EndTrace(s)
	ddS.Finish()
	return errorObjects, nil
}

// Params is the resolver for the params field.
func (r *segmentResolver) Params(ctx context.Context, obj *model.Segment) (*model.SearchParams, error) {
	params := &model.SearchParams{}
	if obj.Params == nil {
		return params, nil
	}
	if err := json.Unmarshal([]byte(*obj.Params), params); err != nil {
		return nil, e.Wrapf(err, "error unmarshaling segment params")
	}
	return params, nil
}

// UserObject is the resolver for the user_object field.
func (r *sessionResolver) UserObject(ctx context.Context, obj *model.Session) (interface{}, error) {
	return obj.UserObject, nil
}

// DirectDownloadURL is the resolver for the direct_download_url field.
func (r *sessionResolver) DirectDownloadURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.DirectDownloadEnabled || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.SessionContentsCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting direct download URL")
	}

	return str, err
}

// ResourcesURL is the resolver for the resources_url field.
func (r *sessionResolver) ResourcesURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.AllObjectsCompressed || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.NetworkResourcesCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting resources URL")
	}

	return str, err
}

// MessagesURL is the resolver for the messages_url field.
func (r *sessionResolver) MessagesURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.AllObjectsCompressed || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.ConsoleMessagesCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting messages URL")
	}

	return str, err
}

// DeviceMemory is the resolver for the deviceMemory field.
func (r *sessionResolver) DeviceMemory(ctx context.Context, obj *model.Session) (*int, error) {
	var deviceMemory *int
	metric := &model.Metric{}

	if err := r.DB.Raw(`
	WITH filtered_group_ids AS (
		SELECT id
		FROM metric_groups
		WHERE session_id = ?
		LIMIT 100000
	  )
	  SELECT metrics.*
	  FROM metrics
	  WHERE metrics.name = ?
	  AND metric_group_id in (SELECT * FROM filtered_group_ids)`, obj.ID, "DeviceMemory").First(&metric).Error; err != nil {
		if !e.Is(err, gorm.ErrRecordNotFound) {
			log.WithContext(ctx).Error(err)
		}
	}

	if metric != nil {
		valueAsInt := int(metric.Value)
		deviceMemory = &valueAsInt
	}

	return deviceMemory, nil
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *sessionAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *sessionAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*model.DiscordChannel, error) {
	ret := obj.DiscordChannelsToNotify

	return ret, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *sessionAlertResolver) EmailsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetEmailsToNotify()
}

// ExcludedEnvironments is the resolver for the ExcludedEnvironments field.
func (r *sessionAlertResolver) ExcludedEnvironments(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetExcludedEnvironments()
}

// TrackProperties is the resolver for the TrackProperties field.
func (r *sessionAlertResolver) TrackProperties(ctx context.Context, obj *model.SessionAlert) ([]*model.TrackProperty, error) {
	return obj.GetTrackProperties()
}

// UserProperties is the resolver for the UserProperties field.
func (r *sessionAlertResolver) UserProperties(ctx context.Context, obj *model.SessionAlert) ([]*model.UserProperty, error) {
	return obj.GetUserProperties()
}

// ExcludeRules is the resolver for the ExcludeRules field.
func (r *sessionAlertResolver) ExcludeRules(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetExcludeRules()
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *sessionAlertResolver) DailyFrequency(ctx context.Context, obj *model.SessionAlert) ([]*int64, error) {
	return obj.GetDailyFrequency(r.DB, obj.ID)
}

// Author is the resolver for the author field.
func (r *sessionCommentResolver) Author(ctx context.Context, obj *model.SessionComment) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}

	// This case happens when the feedback is provided by feedback mechanism.
	if obj.Type == modelInputs.SessionCommentTypeFeedback.String() {
		name := "Anonymous"
		email := ""

		if obj.Metadata != nil {
			if val, ok := obj.Metadata["name"]; ok {
				switch val.(type) {
				case string:
					name = fmt.Sprintf("%v", val)
				}
			}
			if val, ok := obj.Metadata["email"]; ok {
				switch val.(type) {
				case string:
					email = fmt.Sprintf("%v", val)
				}
			}

		}

		feedbackAdmin := &modelInputs.SanitizedAdmin{
			ID:    -1,
			Name:  &name,
			Email: email,
		}
		return feedbackAdmin, nil
	}

	if err := r.DB.Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).First(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin for comment")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// Type is the resolver for the type field.
func (r *sessionCommentResolver) Type(ctx context.Context, obj *model.SessionComment) (modelInputs.SessionCommentType, error) {
	switch obj.Type {
	case model.SessionCommentTypes.ADMIN:
		return modelInputs.SessionCommentTypeAdmin, nil
	case model.SessionCommentTypes.FEEDBACK:
		return modelInputs.SessionCommentTypeFeedback, nil
	default:
		return modelInputs.SessionCommentTypeFeedback, e.New("invalid session comment type")
	}
}

// Metadata is the resolver for the metadata field.
func (r *sessionCommentResolver) Metadata(ctx context.Context, obj *model.SessionComment) (interface{}, error) {
	return obj.Metadata, nil
}

// Tags is the resolver for the tags field.
func (r *sessionCommentResolver) Tags(ctx context.Context, obj *model.SessionComment) ([]*string, error) {
	var (
		tags []sql.NullString
	)
	var tagsResponse []*string

	if err := r.DB.Raw(`
	SELECT
    array_agg(t.name)
FROM
    session_tags st
    JOIN session_comment_tags t ON t.id = st.session_comment_tag_id
WHERE
    st.session_comment_id = ?
GROUP BY
    st.session_comment_id`, obj.ID).Scan(&tags).Error; err != nil {
		log.WithContext(ctx).Error(err, "Failed to query for session comment tags")
	}

	for i := range tags {
		temp, _ := tags[i].Value()
		tagValue, _ := temp.(string)
		tagValue = strings.Replace(tagValue, "\"", "", -1)
		tagValue = strings.Replace(tagValue, "\"", "", -1)
		tagValue = strings.Replace(tagValue, "{", "[\"", 1)
		tagValue = strings.Replace(tagValue, "}", "\"]", 1)
		tagValue = strings.Replace(tagValue, ",", "\",\"", -1)

		tagsResponse = append(tagsResponse, &tagValue)
	}

	return tagsResponse, nil
}

// SessionPayloadAppended is the resolver for the session_payload_appended field.
func (r *subscriptionResolver) SessionPayloadAppended(ctx context.Context, sessionSecureID string, initialEventsCount int) (<-chan *model.SessionPayload, error) {
	ch := make(chan *model.SessionPayload)
	r.SubscriptionWorkerPool.SubmitRecover(func() {
		defer close(ch)
		log.WithContext(ctx).Infof("Polling for events on %s starting from index %d, number of waiting tasks %d",
			sessionSecureID,
			initialEventsCount,
			r.SubscriptionWorkerPool.WaitingQueueSize())

		cursor := model.EventsCursor{EventIndex: initialEventsCount, EventObjectIndex: nil}
		for {
			select {
			case <-ctx.Done():
				return
			default:
			}

			session, err := r.canAdminViewSession(ctx, sessionSecureID)
			if err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "error fetching session for subscription"))
				return
			}
			events, err, nextCursor := r.getEvents(ctx, session, cursor)
			if err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "error fetching events incrementally"))
				return
			}
			if len(events) != 0 {
				// TODO live updating for other event types
				ch <- &model.SessionPayload{
					Events:                  events,
					Errors:                  []model.ErrorObject{},
					RageClicks:              []model.RageClickEvent{},
					SessionComments:         []model.SessionComment{},
					LastUserInteractionTime: session.LastUserInteractionTime,
				}
			}
			cursor = *nextCursor

			time.Sleep(1 * time.Second)
		}
	})
	return ch, nil
}

// Data is the resolver for the data field.
func (r *timelineIndicatorEventResolver) Data(ctx context.Context, obj *model.TimelineIndicatorEvent) (interface{}, error) {
	return obj.Data, nil
}

// CommentReply returns generated.CommentReplyResolver implementation.
func (r *Resolver) CommentReply() generated.CommentReplyResolver { return &commentReplyResolver{r} }

// ErrorAlert returns generated.ErrorAlertResolver implementation.
func (r *Resolver) ErrorAlert() generated.ErrorAlertResolver { return &errorAlertResolver{r} }

// ErrorComment returns generated.ErrorCommentResolver implementation.
func (r *Resolver) ErrorComment() generated.ErrorCommentResolver { return &errorCommentResolver{r} }

// ErrorGroup returns generated.ErrorGroupResolver implementation.
func (r *Resolver) ErrorGroup() generated.ErrorGroupResolver { return &errorGroupResolver{r} }

// ErrorObject returns generated.ErrorObjectResolver implementation.
func (r *Resolver) ErrorObject() generated.ErrorObjectResolver { return &errorObjectResolver{r} }

// ErrorSegment returns generated.ErrorSegmentResolver implementation.
func (r *Resolver) ErrorSegment() generated.ErrorSegmentResolver { return &errorSegmentResolver{r} }

// LogAlert returns generated.LogAlertResolver implementation.
func (r *Resolver) LogAlert() generated.LogAlertResolver { return &logAlertResolver{r} }

// MetricMonitor returns generated.MetricMonitorResolver implementation.
func (r *Resolver) MetricMonitor() generated.MetricMonitorResolver { return &metricMonitorResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Segment returns generated.SegmentResolver implementation.
func (r *Resolver) Segment() generated.SegmentResolver { return &segmentResolver{r} }

// Session returns generated.SessionResolver implementation.
func (r *Resolver) Session() generated.SessionResolver { return &sessionResolver{r} }

// SessionAlert returns generated.SessionAlertResolver implementation.
func (r *Resolver) SessionAlert() generated.SessionAlertResolver { return &sessionAlertResolver{r} }

// SessionComment returns generated.SessionCommentResolver implementation.
func (r *Resolver) SessionComment() generated.SessionCommentResolver {
	return &sessionCommentResolver{r}
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// TimelineIndicatorEvent returns generated.TimelineIndicatorEventResolver implementation.
func (r *Resolver) TimelineIndicatorEvent() generated.TimelineIndicatorEventResolver {
	return &timelineIndicatorEventResolver{r}
}

type commentReplyResolver struct{ *Resolver }
type errorAlertResolver struct{ *Resolver }
type errorCommentResolver struct{ *Resolver }
type errorGroupResolver struct{ *Resolver }
type errorObjectResolver struct{ *Resolver }
type errorSegmentResolver struct{ *Resolver }
type logAlertResolver struct{ *Resolver }
type metricMonitorResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type segmentResolver struct{ *Resolver }
type sessionResolver struct{ *Resolver }
type sessionAlertResolver struct{ *Resolver }
type sessionCommentResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type timelineIndicatorEventResolver struct{ *Resolver }
