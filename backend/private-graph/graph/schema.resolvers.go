package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"math"
	"math/rand"
	"net/url"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/DmitriyVTitov/size"
	"github.com/PaesslerAG/jsonpath"
	mpeTypes "github.com/aws/aws-sdk-go-v2/service/marketplaceentitlementservice/types"
	"github.com/aws/aws-sdk-go-v2/service/marketplacemetering"
	"github.com/aws/smithy-go/ptr"
	"github.com/clearbit/clearbit-go/clearbit"
	"github.com/google/uuid"
	"github.com/highlight-run/highlight/backend/alerts"
	"github.com/highlight-run/highlight/backend/alerts/integrations/discord"
	microsoft_teams "github.com/highlight-run/highlight/backend/alerts/integrations/microsoft-teams"
	"github.com/highlight-run/highlight/backend/alerts/integrations/webhook"
	alertsV2 "github.com/highlight-run/highlight/backend/alerts/v2"
	destinationsV2 "github.com/highlight-run/highlight/backend/alerts/v2/destinations"
	"github.com/highlight-run/highlight/backend/apolloio"
	"github.com/highlight-run/highlight/backend/clickhouse"
	"github.com/highlight-run/highlight/backend/clickup"
	Email "github.com/highlight-run/highlight/backend/email"
	"github.com/highlight-run/highlight/backend/env"
	"github.com/highlight-run/highlight/backend/front"
	"github.com/highlight-run/highlight/backend/integrations/cloudflare"
	"github.com/highlight-run/highlight/backend/integrations/height"
	kafka_queue "github.com/highlight-run/highlight/backend/kafka-queue"
	delete_handlers "github.com/highlight-run/highlight/backend/lambda-functions/deleteSessions/handlers"
	"github.com/highlight-run/highlight/backend/lambda-functions/deleteSessions/utils"
	utils2 "github.com/highlight-run/highlight/backend/lambda-functions/sessionExport/utils"
	"github.com/highlight-run/highlight/backend/model"
	"github.com/highlight-run/highlight/backend/openai_client"
	"github.com/highlight-run/highlight/backend/phonehome"
	"github.com/highlight-run/highlight/backend/pricing"
	"github.com/highlight-run/highlight/backend/private-graph/graph/generated"
	modelInputs "github.com/highlight-run/highlight/backend/private-graph/graph/model"
	"github.com/highlight-run/highlight/backend/prompts"
	"github.com/highlight-run/highlight/backend/redis"
	"github.com/highlight-run/highlight/backend/storage"
	"github.com/highlight-run/highlight/backend/store"
	"github.com/highlight-run/highlight/backend/util"
	"github.com/highlight-run/highlight/backend/vercel"
	"github.com/highlight-run/highlight/backend/zapier"
	highlight "github.com/highlight/highlight/sdk/highlight-go"
	hmetric "github.com/highlight/highlight/sdk/highlight-go/metric"
	"github.com/lib/pq"
	"github.com/openlyinc/pointy"
	e "github.com/pkg/errors"
	"github.com/samber/lo"
	"github.com/sashabaranov/go-openai"
	log "github.com/sirupsen/logrus"
	stripe "github.com/stripe/stripe-go/v78"
	"go.opentelemetry.io/otel/attribute"
	semconv "go.opentelemetry.io/otel/semconv/v1.25.0"
	"golang.org/x/sync/errgroup"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// EnableBusinessDashboards is the resolver for the enable_business_dashboards field.
func (r *allWorkspaceSettingsResolver) EnableBusinessDashboards(ctx context.Context, obj *model.AllWorkspaceSettings) (bool, error) {
	w, err := r.isUserInWorkspaceReadOnly(ctx, obj.WorkspaceID)
	if err != nil {
		return false, err
	}

	var numDashboards int64
	if err := r.DB.Raw(`
		SELECT v.id
		FROM visualizations v
		INNER JOIN projects p ON p.id = v.project_id
		INNER JOIN workspaces w ON w.id = p.workspace_id
		WHERE w.id = ?;
	`, w.ID).Count(&numDashboards).Error; err != nil {
		return false, e.Wrap(err, "error querying workspace visualizations")
	}

	return obj.EnableUnlimitedDashboards || numDashboards < 2, nil
}

// EnableBusinessProjects is the resolver for the enable_business_projects field.
func (r *allWorkspaceSettingsResolver) EnableBusinessProjects(ctx context.Context, obj *model.AllWorkspaceSettings) (bool, error) {
	return obj.EnableUnlimitedProjects, nil
}

// EnableBusinessRetention is the resolver for the enable_business_retention field.
func (r *allWorkspaceSettingsResolver) EnableBusinessRetention(ctx context.Context, obj *model.AllWorkspaceSettings) (bool, error) {
	return obj.EnableUnlimitedRetention, nil
}

// EnableBusinessSeats is the resolver for the enable_business_seats field.
func (r *allWorkspaceSettingsResolver) EnableBusinessSeats(ctx context.Context, obj *model.AllWorkspaceSettings) (bool, error) {
	w, err := r.isUserInWorkspaceReadOnly(ctx, obj.WorkspaceID)
	if err != nil {
		return false, err
	}

	numAdmins := r.DB.Model(w).Association("Admins").Count()
	return obj.EnableUnlimitedSeats || numAdmins < 15, nil
}

// EnableIngestFiltering is the resolver for the enable_ingest_filtering field.
func (r *allWorkspaceSettingsResolver) EnableIngestFiltering(ctx context.Context, obj *model.AllWorkspaceSettings) (bool, error) {
	w, err := r.isUserInWorkspaceReadOnly(ctx, obj.WorkspaceID)
	if err != nil {
		return false, err
	}

	return w.PlanTier != modelInputs.PlanTypeFree.String(), nil
}

// Author is the resolver for the author field.
func (r *commentReplyResolver) Author(ctx context.Context, obj *model.CommentReply) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}
	if err := r.DB.WithContext(ctx).Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).Take(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin author for comment reply")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *errorAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *errorAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// MicrosoftTeamsChannelsToNotify is the resolver for the MicrosoftTeamsChannelsToNotify field.
func (r *errorAlertResolver) MicrosoftTeamsChannelsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*model.MicrosoftTeamsChannel, error) {
	return obj.MicrosoftTeamsChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the WebhookDestinations field.
func (r *errorAlertResolver) WebhookDestinations(ctx context.Context, obj *model.ErrorAlert) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *errorAlertResolver) EmailsToNotify(ctx context.Context, obj *model.ErrorAlert) ([]*string, error) {
	return obj.GetEmailsToNotify()
}

// RegexGroups is the resolver for the RegexGroups field.
func (r *errorAlertResolver) RegexGroups(ctx context.Context, obj *model.ErrorAlert) ([]*string, error) {
	return obj.GetRegexGroups()
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *errorAlertResolver) DailyFrequency(ctx context.Context, obj *model.ErrorAlert) ([]*int64, error) {
	return obj.GetDailyErrorEventFrequency(r.DB, obj.ID)
}

// Author is the resolver for the author field.
func (r *errorCommentResolver) Author(ctx context.Context, obj *model.ErrorComment) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}
	if err := r.DB.WithContext(ctx).Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).Take(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin for comment")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// Event is the resolver for the event field.
func (r *errorGroupResolver) Event(ctx context.Context, obj *model.ErrorGroup) ([]*string, error) {
	return util.JsonStringToStringArray(obj.Event), nil
}

// StructuredStackTrace is the resolver for the structured_stack_trace field.
func (r *errorGroupResolver) StructuredStackTrace(ctx context.Context, obj *model.ErrorGroup) ([]*modelInputs.ErrorTrace, error) {
	if (obj.MappedStackTrace == nil || *obj.MappedStackTrace == "") && obj.StackTrace == "" {
		return nil, nil
	}
	stackTraceString := obj.StackTrace
	if obj.MappedStackTrace != nil && *obj.MappedStackTrace != "" && *obj.MappedStackTrace != "null" {
		stackTraceString = *obj.MappedStackTrace
	}

	return r.UnmarshalStackTrace(stackTraceString)
}

// MetadataLog is the resolver for the metadata_log field.
func (r *errorGroupResolver) MetadataLog(ctx context.Context, obj *model.ErrorGroup) ([]*modelInputs.ErrorMetadata, error) {
	var metadataLogs []*modelInputs.ErrorMetadata
	r.DB.WithContext(ctx).Raw(`
		SELECT
			s.id AS session_id,
			s.secure_id AS session_secure_id,
			e.id AS error_id,
			e.timestamp,
			s.os_name AS os,
			s.browser_name AS browser,
			e.url AS visited_url,
			s.fingerprint AS fingerprint,
			s.identifier AS identifier,
			s.environment,
			s.user_properties,
			e.request_id,
			e.payload
		FROM
			sessions AS s
			INNER JOIN (
			SELECT
				DISTINCT ON (session_id) session_id,
				id,
				timestamp,
				url,
				payload,
				request_id
			FROM
				error_objects
			WHERE
				error_group_id = ?
				AND project_id = ?
			ORDER BY
				session_id DESC
			LIMIT
				20
			) AS e ON s.id = e.session_id
		WHERE
			s.excluded <> true
			AND s.project_id = ?
		ORDER BY
			s.updated_at DESC
		LIMIT
			20;
	`,
		obj.ID,
		obj.ProjectID,
		obj.ProjectID,
	).Scan(&metadataLogs)
	return metadataLogs, nil
}

// ErrorGroupSecureID is the resolver for the error_group_secure_id field.
func (r *errorObjectResolver) ErrorGroupSecureID(ctx context.Context, obj *model.ErrorObject) (string, error) {
	if obj != nil {
		var secureID string
		if err := r.DB.WithContext(ctx).Raw(`SELECT secure_id FROM error_groups WHERE id = ? LIMIT 1`,
			obj.ErrorGroupID).Scan(&secureID).Error; err != nil {
			return "", e.Wrapf(err, "Failed to retrieve secure_id for error group, id: %d", obj.ErrorGroupID)
		}
		return secureID, nil
	}
	return "", nil
}

// Event is the resolver for the event field.
func (r *errorObjectResolver) Event(ctx context.Context, obj *model.ErrorObject) ([]*string, error) {
	return util.JsonStringToStringArray(obj.Event), nil
}

// StructuredStackTrace is the resolver for the structured_stack_trace field.
func (r *errorObjectResolver) StructuredStackTrace(ctx context.Context, obj *model.ErrorObject) ([]*modelInputs.ErrorTrace, error) {
	if (obj.MappedStackTrace == nil || *obj.MappedStackTrace == "") && *obj.StackTrace == "" {
		return nil, nil
	}
	stackTraceString := *obj.StackTrace
	if obj.MappedStackTrace != nil && *obj.MappedStackTrace != "" && *obj.MappedStackTrace != "null" {
		stackTraceString = *obj.MappedStackTrace
	}

	return r.UnmarshalStackTrace(stackTraceString)
}

// Session is the resolver for the session field.
func (r *errorObjectResolver) Session(ctx context.Context, obj *model.ErrorObject) (*model.Session, error) {
	if obj.SessionID == nil {
		return nil, nil
	}
	return r.Store.GetSession(ctx, *obj.SessionID)
}

// FunnelSteps is the resolver for the funnelSteps field.
func (r *graphResolver) FunnelSteps(ctx context.Context, obj *model.Graph) (funnelSteps []*modelInputs.FunnelStep, err error) {
	if obj.FunnelSteps == nil {
		return nil, nil
	}
	err = json.Unmarshal([]byte(*obj.FunnelSteps), &funnelSteps)
	return
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *logAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.LogAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *logAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.LogAlert) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// MicrosoftTeamsChannelsToNotify is the resolver for the MicrosoftTeamsChannelsToNotify field.
func (r *logAlertResolver) MicrosoftTeamsChannelsToNotify(ctx context.Context, obj *model.LogAlert) ([]*model.MicrosoftTeamsChannel, error) {
	return obj.MicrosoftTeamsChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the WebhookDestinations field.
func (r *logAlertResolver) WebhookDestinations(ctx context.Context, obj *model.LogAlert) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *logAlertResolver) EmailsToNotify(ctx context.Context, obj *model.LogAlert) ([]string, error) {
	emails, err := obj.GetEmailsToNotify()
	if err != nil {
		return nil, err
	}
	return lo.Map(emails, func(email *string, idx int) string {
		return *email
	}), nil
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *logAlertResolver) DailyFrequency(ctx context.Context, obj *model.LogAlert) ([]*int64, error) {
	return obj.GetDailyLogEventFrequency(r.DB, obj.ID)
}

// Event is the resolver for the event field.
func (r *matchedErrorObjectResolver) Event(ctx context.Context, obj *model.MatchedErrorObject) ([]*string, error) {
	return util.JsonStringToStringArray(obj.Event), nil
}

// ChannelsToNotify is the resolver for the channels_to_notify field.
func (r *metricMonitorResolver) ChannelsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*modelInputs.SanitizedSlackChannel, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for channels to notify")
	}
	channelString := "[]"
	if obj.ChannelsToNotify != nil {
		channelString = *obj.ChannelsToNotify
	}
	var sanitizedChannels []*modelInputs.SanitizedSlackChannel
	if err := json.Unmarshal([]byte(channelString), &sanitizedChannels); err != nil {
		return nil, e.Wrap(err, "error unmarshalling sanitized slack channels for metric monitors")
	}
	return sanitizedChannels, nil
}

// DiscordChannelsToNotify is the resolver for the discord_channels_to_notify field.
func (r *metricMonitorResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*model.DiscordChannel, error) {
	return obj.DiscordChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the webhook_destinations field.
func (r *metricMonitorResolver) WebhookDestinations(ctx context.Context, obj *model.MetricMonitor) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the emails_to_notify field.
func (r *metricMonitorResolver) EmailsToNotify(ctx context.Context, obj *model.MetricMonitor) ([]*string, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for emails to notify")
	}
	emailString := "[]"
	if obj.EmailsToNotify != nil {
		emailString = *obj.EmailsToNotify
	}
	var emailsToNotify []*string
	if err := json.Unmarshal([]byte(emailString), &emailsToNotify); err != nil {
		return nil, e.Wrap(err, "error unmarshalling emails to notify for metric monitors")
	}
	return emailsToNotify, nil
}

// Filters is the resolver for the filters field.
func (r *metricMonitorResolver) Filters(ctx context.Context, obj *model.MetricMonitor) ([]*modelInputs.MetricTagFilter, error) {
	if obj == nil {
		return nil, e.New("empty metric monitor object for Slack or email notifications")
	}
	var filters []*model.DashboardMetricFilter
	if err := r.DB.WithContext(ctx).Where(&model.DashboardMetricFilter{MetricMonitorID: obj.ID}).Find(&filters).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitor filters")
	}
	return lo.Map(filters, func(t *model.DashboardMetricFilter, i int) *modelInputs.MetricTagFilter {
		return &modelInputs.MetricTagFilter{
			Tag:   t.Tag,
			Op:    t.Op,
			Value: t.Value,
		}
	}), nil
}

// UpdateAdminAndCreateWorkspace is the resolver for the updateAdminAndCreateWorkspace field.
func (r *mutationResolver) UpdateAdminAndCreateWorkspace(ctx context.Context, adminAndWorkspaceDetails modelInputs.AdminAndWorkspaceDetails) (*model.Project, error) {
	if err := r.Transaction(func(transactionR *mutationResolver) error {
		// Update admin details
		if _, err := transactionR.UpdateAdminAboutYouDetails(ctx, modelInputs.AdminAboutYouDetails{
			FirstName:               adminAndWorkspaceDetails.FirstName,
			LastName:                adminAndWorkspaceDetails.LastName,
			UserDefinedRole:         adminAndWorkspaceDetails.UserDefinedRole,
			UserDefinedPersona:      "",
			UserDefinedTeamSize:     adminAndWorkspaceDetails.UserDefinedTeamSize,
			HeardAbout:              adminAndWorkspaceDetails.HeardAbout,
			Referral:                adminAndWorkspaceDetails.Referral,
			PhoneHomeContactAllowed: adminAndWorkspaceDetails.PhoneHomeContactAllowed,
		}); err != nil {
			return e.Wrap(err, "error updating admin details")
		}

		// Create workspace
		workspace, err := transactionR.CreateWorkspace(ctx, adminAndWorkspaceDetails.WorkspaceName, adminAndWorkspaceDetails.PromoCode)
		if err != nil {
			return e.Wrap(err, "error creating workspace")
		}

		// Assign auto joinable domains for workspace
		if ptr.ToString(adminAndWorkspaceDetails.AllowedAutoJoinEmailOrigins) != "" {
			if _, err := transactionR.UpdateAllowedEmailOrigins(ctx, workspace.ID, *adminAndWorkspaceDetails.AllowedAutoJoinEmailOrigins); err != nil {
				return e.Wrap(err, "error assigning auto joinable email origins")
			}
		}

		// Create project
		projectName := fmt.Sprintf("%s App", adminAndWorkspaceDetails.WorkspaceName)
		if _, err := transactionR.CreateProject(ctx, projectName, workspace.ID); err != nil {
			return e.Wrap(err, "error creating project")
		}

		return nil
	}); err != nil {
		return nil, e.Wrap(err, "error during transaction")
	}

	projects, err := r.Query().Projects(ctx)
	if err != nil {
		return nil, e.Wrap(err, "error fetching new project")
	}

	return projects[0], nil
}

// UpdateAdminAboutYouDetails is the resolver for the updateAdminAboutYouDetails field.
func (r *mutationResolver) UpdateAdminAboutYouDetails(ctx context.Context, adminDetails modelInputs.AdminAboutYouDetails) (bool, error) {
	admin, err := r.getCurrentAdmin(ctx)

	if err != nil {
		return false, err
	}

	fullName := adminDetails.FirstName + " " + adminDetails.LastName
	admin.FirstName = &adminDetails.FirstName
	admin.LastName = &adminDetails.LastName
	admin.Name = &fullName
	admin.UserDefinedRole = &adminDetails.UserDefinedRole
	admin.UserDefinedTeamSize = &adminDetails.UserDefinedTeamSize
	admin.HeardAbout = &adminDetails.HeardAbout
	admin.PhoneHomeContactAllowed = &adminDetails.PhoneHomeContactAllowed
	admin.Referral = &adminDetails.Referral
	admin.UserDefinedPersona = &adminDetails.UserDefinedPersona
	admin.Phone = pointy.String("")
	admin.AboutYouDetailsFilled = &model.T

	phonehome.ReportAdminAboutYouDetails(ctx, admin)
	if err := r.DB.WithContext(ctx).Save(admin).Error; err != nil {
		return false, err
	}

	return true, nil
}

// CreateAdmin is the resolver for the createAdmin field.
func (r *mutationResolver) CreateAdmin(ctx context.Context) (*model.Admin, error) {
	return r.createAdmin(ctx)
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, name string, workspaceID int) (*model.Project, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	project := &model.Project{
		Name:         &name,
		BillingEmail: admin.Email,
		WorkspaceID:  workspace.ID,
	}

	if err := r.DB.WithContext(ctx).Create(project).Error; err != nil {
		return nil, e.Wrap(err, "error creating project")
	}

	return project, nil
}

// CreateWorkspace is the resolver for the createWorkspace field.
func (r *mutationResolver) CreateWorkspace(ctx context.Context, name string, promoCode *string) (*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	trialEnd := time.Now().Add(14 * 24 * time.Hour) // Trial expires 14 days from current day
	if promoCode != nil {
		trialDetails, ok := PromoCodes[strings.ToUpper(*promoCode)]
		if !ok {
			return nil, e.New("Could not create workspace: promo code is not valid.")
		}
		if time.Now().After(trialDetails.ValidUntil) {
			return nil, e.New("Could not create workspace: promo code has expired.")
		}

		trialEnd = time.Now().Add(time.Duration(trialDetails.TrialDays*24) * time.Hour)
	}

	workspace := &model.Workspace{
		Admins:                    []model.Admin{*admin},
		Name:                      &name,
		TrialEndDate:              &trialEnd,
		EligibleForTrialExtension: true, // Trial can be extended if user integrates + fills out form
		TrialExtensionEnabled:     false,
		PromoCode:                 promoCode,
	}

	if env.IsOnPrem() {
		// unlock self hosted usage
		workspace.PlanTier = modelInputs.PlanTypeEnterprise.String()
	}

	if err := r.DB.WithContext(ctx).Create(workspace).Error; err != nil {
		return nil, e.Wrap(err, "error creating workspace")
	}

	c := &stripe.Customer{}
	if !env.IsOnPrem() {
		params := &stripe.CustomerParams{
			Name:  &name,
			Email: admin.Email,
		}
		params.AddMetadata("Workspace ID", strconv.Itoa(workspace.ID))
		c, err = r.PricingClient.Customers.New(params)
		if err != nil {
			log.WithContext(ctx).Error(err, "error creating stripe customer")
		} else {
			if err := r.DB.WithContext(ctx).Model(&workspace).Updates(&model.Workspace{StripeCustomerID: &c.ID}).Error; err != nil {
				return nil, e.Wrap(err, "error updating workspace StripeCustomerID")
			}
		}
	}

	return workspace, nil
}

// EditProject is the resolver for the editProject field.
func (r *mutationResolver) EditProject(ctx context.Context, id int, name *string, billingEmail *string, excludedUsers pq.StringArray, errorFilters pq.StringArray, errorJSONPaths pq.StringArray, rageClickWindowSeconds *int, rageClickRadiusPixels *int, rageClickCount *int, filterChromeExtension *bool) (*model.Project, error) {
	project, err := r.isUserInProject(ctx, id)
	if err != nil {
		return nil, err
	}
	for _, expression := range excludedUsers {
		_, err := regexp.Compile(expression)
		if err != nil {
			return nil, e.Wrap(err, "The regular expression '"+expression+"' is not valid")
		}
	}

	for _, path := range errorJSONPaths {
		_, err := jsonpath.New(path)
		if err != nil {
			return nil, e.Wrap(err, "The JSON path '"+path+"'is not valid")
		}
	}

	updates := &model.Project{
		Name:                  name,
		BillingEmail:          billingEmail,
		ExcludedUsers:         excludedUsers,
		ErrorFilters:          errorFilters,
		ErrorJsonPaths:        errorJSONPaths,
		FilterChromeExtension: filterChromeExtension,
	}

	if rageClickWindowSeconds != nil {
		updates.RageClickWindowSeconds = *rageClickWindowSeconds
	}

	if rageClickRadiusPixels != nil {
		updates.RageClickRadiusPixels = *rageClickRadiusPixels
	}

	if rageClickCount != nil {
		updates.RageClickCount = *rageClickCount
	}

	if err := r.DB.WithContext(ctx).Model(project).Updates(updates).Error; err != nil {
		return nil, e.Wrap(err, "error updating project fields")
	}
	return project, nil
}

// EditProjectSettings is the resolver for the editProjectSettings field.
func (r *mutationResolver) EditProjectSettings(ctx context.Context, projectID int, name *string, billingEmail *string, excludedUsers pq.StringArray, errorFilters pq.StringArray, errorJSONPaths pq.StringArray, rageClickWindowSeconds *int, rageClickRadiusPixels *int, rageClickCount *int, filterChromeExtension *bool, filterSessionsWithoutError *bool, autoResolveStaleErrorsDayInterval *int, sampling *modelInputs.SamplingInput) (*modelInputs.AllProjectSettings, error) {
	project, err := r.EditProject(ctx, projectID, name, billingEmail, excludedUsers, errorFilters, errorJSONPaths, rageClickWindowSeconds, rageClickRadiusPixels, rageClickCount, filterChromeExtension)
	if err != nil {
		return nil, err
	}

	allProjectSettings := modelInputs.AllProjectSettings{
		ID:                     project.ID,
		Name:                   *project.Name,
		BillingEmail:           project.BillingEmail,
		ExcludedUsers:          project.ExcludedUsers,
		ErrorFilters:           project.ErrorFilters,
		ErrorJSONPaths:         project.ErrorJsonPaths,
		FilterChromeExtension:  project.FilterChromeExtension,
		RageClickWindowSeconds: &project.RageClickWindowSeconds,
		RageClickRadiusPixels:  &project.RageClickRadiusPixels,
		RageClickCount:         &project.RageClickCount,
	}

	projectFilterSettings, err := r.Store.UpdateProjectFilterSettings(ctx, project.ID, store.UpdateProjectFilterSettingsParams{
		FilterSessionsWithoutError:        filterSessionsWithoutError,
		AutoResolveStaleErrorsDayInterval: autoResolveStaleErrorsDayInterval,
		Sampling:                          sampling,
	})
	if err != nil {
		return nil, err
	}
	allProjectSettings.FilterSessionsWithoutError = projectFilterSettings.FilterSessionsWithoutError
	allProjectSettings.AutoResolveStaleErrorsDayInterval = projectFilterSettings.AutoResolveStaleErrorsDayInterval
	allProjectSettings.Sampling = &modelInputs.Sampling{
		SessionSamplingRate:    projectFilterSettings.SessionSamplingRate,
		ErrorSamplingRate:      projectFilterSettings.SessionSamplingRate,
		LogSamplingRate:        projectFilterSettings.SessionSamplingRate,
		TraceSamplingRate:      projectFilterSettings.SessionSamplingRate,
		SessionMinuteRateLimit: projectFilterSettings.SessionMinuteRateLimit,
		ErrorMinuteRateLimit:   projectFilterSettings.ErrorMinuteRateLimit,
		LogMinuteRateLimit:     projectFilterSettings.LogMinuteRateLimit,
		TraceMinuteRateLimit:   projectFilterSettings.TraceMinuteRateLimit,
		SessionExclusionQuery:  projectFilterSettings.SessionExclusionQuery,
		ErrorExclusionQuery:    projectFilterSettings.ErrorExclusionQuery,
		LogExclusionQuery:      projectFilterSettings.LogExclusionQuery,
		TraceExclusionQuery:    projectFilterSettings.TraceExclusionQuery,
	}

	return &allProjectSettings, nil
}

// EditWorkspace is the resolver for the editWorkspace field.
func (r *mutationResolver) EditWorkspace(ctx context.Context, id int, name *string) (*model.Workspace, error) {
	workspace, err := r.isUserInWorkspace(ctx, id)
	if err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}
	if err := r.DB.WithContext(ctx).Model(workspace).Updates(&model.Workspace{
		Name: name,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace fields")
	}
	return workspace, nil
}

// EditWorkspaceSettings is the resolver for the editWorkspaceSettings field.
func (r *mutationResolver) EditWorkspaceSettings(ctx context.Context, workspaceID int, aiApplication *bool, aiInsights *bool, aiQueryBuilder *bool) (*model.AllWorkspaceSettings, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspaceSettingsUpdates := map[string]interface{}{
		"AIApplication":  *aiApplication,
		"AIInsights":     *aiInsights,
		"AIQueryBuilder": *aiQueryBuilder,
	}

	return r.Store.UpdateAllWorkspaceSettings(ctx, workspaceID, workspaceSettingsUpdates)
}

// ExportSession is the resolver for the exportSession field.
func (r *mutationResolver) ExportSession(ctx context.Context, sessionSecureID string) (bool, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return false, err
	}

	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return false, err
	}

	cfg, err := r.Store.GetAllWorkspaceSettingsByProject(ctx, session.ProjectID)
	if !cfg.EnableSessionExport {
		return false, e.New("session export is not enabled")
	}

	export := model.SessionExport{
		SessionID:    session.ID,
		Type:         model.SessionExportFormatMP4,
		TargetEmails: []string{*admin.Email},
	}

	tx := r.DB.WithContext(ctx).Model(&export).Where(&model.SessionExport{
		SessionID: session.ID,
		Type:      model.SessionExportFormatMP4,
	}).Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "session_id"}, {Name: "type"}},
		DoUpdates: clause.AssignmentColumns([]string{"target_emails"}),
	}).FirstOrCreate(&export)
	if tx.Error != nil {
		log.WithContext(context.Background()).WithError(tx.Error).Error("failed to create session export record")
		return false, tx.Error
	}

	_, err = r.StepFunctions.SessionExport(ctx, utils2.SessionExportInput{
		Project:      session.ProjectID,
		Session:      session.ID,
		Format:       export.Type,
		TargetEmails: export.TargetEmails,
	})
	if err != nil {
		log.WithContext(context.Background()).WithError(err).Error("failed to export session video")
		return false, err
	}

	return true, nil
}

// MarkErrorGroupAsViewed is the resolver for the markErrorGroupAsViewed field.
func (r *mutationResolver) MarkErrorGroupAsViewed(ctx context.Context, errorSecureID string, viewed *bool) (*model.ErrorGroup, error) {
	eg, err := r.canAdminModifyErrorGroup(ctx, errorSecureID)
	if err != nil {
		return nil, err
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Update the the number of error groups viewed for the current admin.
	r.PrivateWorkerPool.SubmitRecover(func() {
		ctx := context.Background()
		// Check if this admin has already viewed
		if _, err := r.isUserInProject(ctx, eg.ProjectID); err != nil {
			log.WithContext(ctx).Infof("not adding error groups count to admin in hubspot; this is probably a demo project, with id [%v]", eg.ProjectID)
			return
		}
		var currentErrorGroupCount int64
		if err := r.DB.WithContext(ctx).Raw(`
			select count(*)
			from error_group_admins_views
			where error_group_id = ? and admin_id = ?
	`, eg.ID, admin.ID).Scan(&currentErrorGroupCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying count of error group views from admin"))
			return
		} else if currentErrorGroupCount > 0 {
			log.WithContext(ctx).Info("not updating hubspot error group count; admin has already viewed this error group")
			return
		}

		var totalErrorGroupCount int64
		if err := r.DB.WithContext(ctx).Raw(`
			select count(*)
			from error_group_admins_views
			where admin_id = ?
	`, admin.ID).Scan(&totalErrorGroupCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying total count of error group views from admin"))
			return
		}
		totalErrorGroupCountAsInt := int(totalErrorGroupCount) + 1

		if err := r.DB.WithContext(ctx).Where(admin).Updates(&model.Admin{NumberOfErrorGroupsViewed: &totalErrorGroupCountAsInt}).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error updating error group count for admin in postgres"))
		}
		phonehome.ReportUsageMetrics(ctx, phonehome.AdminUsage, admin.ID, []attribute.KeyValue{
			attribute.Int(phonehome.ErrorViewCount, totalErrorGroupCountAsInt),
		})
	})

	newErrorGroup := &model.ErrorGroup{}
	updatedFields := &model.ErrorGroup{
		Viewed: viewed,
	}
	if err := store.AssertRecordFound(r.DB.WithContext(ctx).Where(&model.ErrorGroup{Model: model.Model{ID: eg.ID}}).Model(&newErrorGroup).Clauses(clause.Returning{}).Updates(updatedFields)); err != nil {
		return nil, err
	}

	if err := r.DB.WithContext(ctx).Model(&eg).Association("ViewedByAdmins").Append(admin); err != nil {
		return nil, e.Wrap(err, "error adding admin to ViewedByAdmins")
	}

	return newErrorGroup, nil
}

// MarkSessionAsViewed is the resolver for the markSessionAsViewed field.
func (r *mutationResolver) MarkSessionAsViewed(ctx context.Context, secureID string, viewed *bool) (*model.Session, error) {
	s, err := r.canAdminModifySession(ctx, secureID)
	if err != nil {
		return nil, err
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Update the the number of sessions viewed for the current admin.
	r.PrivateWorkerPool.SubmitRecover(func() {
		ctx := context.Background()
		// Check if this admin has already viewed
		if _, err := r.isUserInProject(ctx, s.ProjectID); err != nil {
			log.WithContext(ctx).Infof("not adding session count to admin in hubspot; this is probably a demo project, with id [%v]", s.ProjectID)
			return
		}
		var currentSessionCount int64
		if err := r.DB.WithContext(ctx).Raw(`
			select count(*)
			from session_admins_views
			where session_id = ? and admin_id = ?
	`, s.ID, admin.ID).Scan(&currentSessionCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying count of session views from admin"))
			return
		} else if currentSessionCount > 0 {
			log.WithContext(ctx).Info("not updating hubspot session count; admin has already viewed this session")
			return
		}

		var totalSessionCount int64
		if err := r.DB.WithContext(ctx).Raw(`
			select count(*)
			from session_admins_views
			where admin_id = ?
	`, admin.ID).Scan(&totalSessionCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying total count of session views from admin"))
			return
		}
		totalSessionCountAsInt := int(totalSessionCount) + 1

		if err := r.DB.WithContext(ctx).Where(admin).Updates(&model.Admin{NumberOfSessionsViewed: &totalSessionCountAsInt}).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error updating session count for admin in postgres"))
		}
		phonehome.ReportUsageMetrics(ctx, phonehome.AdminUsage, admin.ID, []attribute.KeyValue{
			attribute.Int(phonehome.SessionViewCount, totalSessionCountAsInt),
		})
	})

	newSession := &model.Session{}
	updatedFields := &model.Session{
		Viewed: viewed,
	}
	if err := store.AssertRecordFound(r.DB.WithContext(ctx).Where(&model.Session{Model: model.Model{ID: s.ID}}).Model(&newSession).Clauses(clause.Returning{}).Updates(updatedFields)); err != nil {
		return nil, e.Wrap(err, "error writing session as viewed")
	}

	if err := r.DB.WithContext(ctx).Model(&s).Association("ViewedByAdmins").Append(admin); err != nil {
		return nil, e.Wrap(err, "error adding admin to ViewedByAdmins")
	}

	if err := r.DataSyncQueue.Submit(ctx, strconv.Itoa(s.ID), &kafka_queue.Message{Type: kafka_queue.SessionDataSync, SessionDataSync: &kafka_queue.SessionDataSyncArgs{SessionID: s.ID}}); err != nil {
		return nil, err
	}

	return newSession, nil
}

// UpdateErrorGroupState is the resolver for the updateErrorGroupState field.
func (r *mutationResolver) UpdateErrorGroupState(ctx context.Context, secureID string, state modelInputs.ErrorState, snoozedUntil *time.Time) (*model.ErrorGroup, error) {
	errorGroup, err := r.canAdminModifyErrorGroup(ctx, secureID)
	if err != nil {
		return nil, err
	}
	admin, err := r.getCurrentAdmin(ctx)

	return r.Store.UpdateErrorGroupStateByAdmin(ctx, *admin, store.UpdateErrorGroupParams{
		ID:           errorGroup.ID,
		State:        state,
		SnoozedUntil: snoozedUntil,
	})
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id int) (*bool, error) {
	project, err := r.isUserInProject(ctx, id)
	if err != nil {
		return nil, err
	}
	if err := r.validateAdminRole(ctx, project.WorkspaceID); err != nil {
		return nil, err
	}
	if err := r.DB.WithContext(ctx).Model(&model.Project{}).Delete("id = ?", id).Error; err != nil {
		return nil, e.Wrap(err, "error deleting project")
	}
	return &model.T, nil
}

// SendAdminWorkspaceInvite is the resolver for the sendAdminWorkspaceInvite field.
func (r *mutationResolver) SendAdminWorkspaceInvite(ctx context.Context, workspaceID int, email string, role string, projectIds []int) (*string, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if role != model.AdminRole.ADMIN && role != model.AdminRole.MEMBER {
		return nil, e.Errorf("invalid role %s", role)
	}

	// If the new invite is for an admin role, the inviter must be an admin
	if role == model.AdminRole.ADMIN {
		err := r.validateAdminRole(ctx, workspaceID)
		if err != nil {
			return nil, err
		}
	}

	// Check if an invite to the email address already exists
	var existingInvite model.WorkspaceInviteLink
	if err := r.DB.WithContext(ctx).Where("workspace_id = ? AND invitee_email ILIKE ?", workspaceID, email).First(&existingInvite).Error; err != gorm.ErrRecordNotFound {
		if err != nil {
			return nil, e.Wrap(err, "error checking for existing invite link")
		}
		return nil, e.Errorf("Looks like \"%s\" has already been invited to join this workspace.", email)
	}

	// Check if the email is already assigned to an admin in the workspace
	var existingAdmin model.Admin
	if err := r.DB.WithContext(ctx).Where("email ILIKE ?", email).First(&existingAdmin).Error; err != gorm.ErrRecordNotFound {
		if err != nil {
			return nil, e.Wrap(err, "error checking for existing admin")
		}
		var workspaceAdmin model.WorkspaceAdmin
		if err := r.DB.WithContext(ctx).Where("admin_id = ? AND workspace_id = ?", existingAdmin.ID, workspaceID).First(&workspaceAdmin).Error; err != gorm.ErrRecordNotFound {
			if err != nil {
				return nil, e.Wrap(err, "error checking for existing admin in workspace")
			}
			return nil, e.Errorf("Looks like \"%s\" is already an admin in this workspace.", email)
		}
	}

	inviteLink := r.CreateInviteLink(workspaceID, &email, role, false, projectIds)

	if err := r.DB.WithContext(ctx).Create(inviteLink).Error; err != nil {
		return nil, e.Wrap(err, "error creating new invite link")
	}

	baseURL := env.Config.FrontendUri

	inviteLinkUrl := baseURL + "/w/" + strconv.Itoa(workspaceID) + "/invite/" + *inviteLink.Secret
	return r.SendAdminInviteImpl(*admin.Name, *workspace.Name, inviteLinkUrl, email)
}

// AddAdminToWorkspace is the resolver for the addAdminToWorkspace field.
func (r *mutationResolver) AddAdminToWorkspace(ctx context.Context, workspaceID int, inviteID string) (*int, error) {
	return r.addAdminMembership(ctx, workspaceID, inviteID)
}

// DeleteInviteLinkFromWorkspace is the resolver for the deleteInviteLinkFromWorkspace field.
func (r *mutationResolver) DeleteInviteLinkFromWorkspace(ctx context.Context, workspaceID int, workspaceInviteLinkID int) (bool, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	result := r.DB.WithContext(ctx).Where("id = ?", workspaceInviteLinkID).Where("workspace_id = ?", workspaceID).Delete(&model.WorkspaceInviteLink{})
	if result.Error != nil {
		return false, e.Wrap(err, "error deleting workspace invite link")
	}

	return int(result.RowsAffected) > 0, nil
}

// JoinWorkspace is the resolver for the joinWorkspace field.
func (r *mutationResolver) JoinWorkspace(ctx context.Context, workspaceID int) (*int, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		return nil, e.Wrap(err, "error getting custom verified admin email domain")
	}
	// if more than one workspace has the auto join email origin, pick the first (oldest) one
	workspace := &model.Workspace{Model: model.Model{ID: workspaceID}}
	if err := r.DB.WithContext(ctx).Model(&workspace).Where("jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))", domain).First(workspace).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace")
	}

	if err := r.DB.WithContext(ctx).Create(&model.WorkspaceAdmin{AdminID: admin.ID, WorkspaceID: workspace.ID, Role: pointy.String("MEMBER")}).Error; err != nil {
		return nil, e.Wrap(err, "error adding admin to workspace")
	}

	return &workspace.ID, nil
}

// UpdateAllowedEmailOrigins is the resolver for the updateAllowedEmailOrigins field.
func (r *mutationResolver) UpdateAllowedEmailOrigins(ctx context.Context, workspaceID int, allowedAutoJoinEmailOrigins string) (*int, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	if !json.Valid([]byte(allowedAutoJoinEmailOrigins)) {
		return nil, e.Wrap(err, "allowedAutoJoinEmailOrigins is not valid JSON")
	}

	if err := r.DB.WithContext(ctx).Model(&model.Workspace{Model: model.Model{ID: workspaceID}}).Updates(&model.Workspace{
		AllowedAutoJoinEmailOrigins: &allowedAutoJoinEmailOrigins}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace")
	}

	return &workspaceID, nil
}

// ChangeAdminRole is the resolver for the changeAdminRole field.
func (r *mutationResolver) ChangeAdminRole(ctx context.Context, workspaceID int, adminID int, newRole string) (*model.WorkspaceAdminRole, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if admin.ID == adminID {
		return nil, e.New("User cannot change their own access.")
	}

	if newRole != model.AdminRole.ADMIN && newRole != model.AdminRole.MEMBER {
		return nil, e.Errorf("Invalid role %s", newRole)
	}

	wa := model.WorkspaceAdmin{AdminID: adminID, WorkspaceID: workspaceID}
	if err := r.DB.WithContext(ctx).Model(&wa).
		Clauses(clause.Returning{}).
		Updates(map[string]interface{}{"Role": newRole, "ProjectIds": nil}).Error; err != nil {
		return nil, e.Wrap(err, "Error updating workspace_admin role")
	}

	return &model.WorkspaceAdminRole{
		WorkspaceId: wa.WorkspaceID,
		Admin:       &model.Admin{Model: model.Model{ID: adminID}},
		Role:        *wa.Role,
		ProjectIds: lo.Map(wa.ProjectIds, func(in int32, _ int) int {
			return int(in)
		}),
	}, nil
}

// ChangeProjectMembership is the resolver for the changeProjectMembership field.
func (r *mutationResolver) ChangeProjectMembership(ctx context.Context, workspaceID int, adminID int, projectIds []int) (*model.WorkspaceAdminRole, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	settings, err := r.Store.GetAllWorkspaceSettings(ctx, workspaceID)
	if err != nil {
		return nil, err
	}
	if !settings.EnableProjectLevelAccess {
		return nil, e.New("Workspace does not have the project-level access feature.")
	}

	if admin.ID == adminID {
		return nil, e.New("User cannot change their own access.")
	}

	var newProjectIds pq.Int32Array = lo.Map(projectIds, func(in int, _ int) int32 {
		return int32(in)
	})

	if len(newProjectIds) == 0 {
		newProjectIds = nil
	}

	wa := model.WorkspaceAdmin{AdminID: adminID, WorkspaceID: workspaceID}
	if err := r.DB.WithContext(ctx).Model(&wa).
		Clauses(clause.Returning{}).Update("ProjectIds", newProjectIds).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace_admin role")
	}

	return &model.WorkspaceAdminRole{
		WorkspaceId: wa.WorkspaceID,
		Admin:       &model.Admin{Model: model.Model{ID: adminID}},
		Role:        *wa.Role,
		ProjectIds: lo.Map(wa.ProjectIds, func(in int32, _ int) int {
			return int(in)
		}),
	}, nil
}

// DeleteAdminFromWorkspace is the resolver for the deleteAdminFromWorkspace field.
func (r *mutationResolver) DeleteAdminFromWorkspace(ctx context.Context, workspaceID int, adminID int) (*int, error) {
	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "current admin is not in workspace")
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if admin.ID == adminID {
		return nil, e.New("Admin tried deleting their own association")
	}

	if err := r.DB.WithContext(ctx).Model(workspace).Association("Admins").Delete(model.Admin{Model: model.Model{ID: adminID}}); err != nil {
		return nil, e.Wrap(err, "error deleting admin association")
	}

	return &adminID, nil
}

// EmailSignup is the resolver for the emailSignup field.
func (r *mutationResolver) EmailSignup(ctx context.Context, email string) (string, error) {
	short, long, err := apolloio.Enrich(email)
	if err != nil {
		log.WithContext(ctx).Errorf("error enriching email: %v", err)
		return email, nil
	}

	model.DB.WithContext(ctx).Create(&model.EmailSignup{
		Email:               email,
		ApolloData:          *long,
		ApolloDataShortened: *short,
	})

	r.PrivateWorkerPool.SubmitRecover(func() {
		ctx := context.Background()
		if contact, err := apolloio.CreateContact(email); err != nil {
			log.WithContext(ctx).Errorf("error creating apollo contact: %v", err)
		} else {
			sequenceID := "60fb134ce97fa1014c1cc141" // represents the "Landing Page Signups" sequence.
			if err := apolloio.AddToSequence(contact.ID, sequenceID); err != nil {
				log.WithContext(ctx).Errorf("error adding to apollo sequence: %v", err)
			}
		}
	})

	return email, nil
}

// CreateSavedSegment is the resolver for the createSavedSegment field.
func (r *mutationResolver) CreateSavedSegment(ctx context.Context, projectID int, name string, entityType modelInputs.SavedSegmentEntityType, query string) (*model.SavedSegment, error) {
	if _, err := r.isUserInProject(ctx, projectID); err != nil {
		return nil, err
	}
	modelParams := SavedSegmentQueryToParams(query)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, err
	}
	paramString := string(paramBytes)

	// check if such a segment exists
	var count int64
	if err := r.DB.WithContext(ctx).Model(&model.SavedSegment{}).Where("project_id = ? AND name = ? AND entity_type = ?", projectID, name, entityType).Count(&count).Error; err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, e.New("saved segment with this name already exists")
	}

	savedSegment := &model.SavedSegment{
		ProjectID:  projectID,
		Name:       name,
		EntityType: entityType,
		Params:     paramString,
	}
	if err := r.DB.WithContext(ctx).Create(savedSegment).Error; err != nil {
		return nil, err
	}
	return savedSegment, nil
}

// EditSavedSegment is the resolver for the editSavedSegment field.
func (r *mutationResolver) EditSavedSegment(ctx context.Context, id int, projectID int, name string, entityType modelInputs.SavedSegmentEntityType, query string) (*bool, error) {
	if _, err := r.isUserInProject(ctx, projectID); err != nil {
		return nil, err
	}
	modelParams := SavedSegmentQueryToParams(query)
	// Convert to json to store in the db.
	paramBytes, err := json.Marshal(modelParams)
	if err != nil {
		return nil, err
	}
	paramString := string(paramBytes)

	var count int64
	if err := r.DB.WithContext(ctx).Model(&model.SavedSegment{}).Where("project_id = ? AND name = ? AND entity_type = ? AND id <> ?", projectID, name, entityType, id).Count(&count).Error; err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, e.New("saved segment with this name already exists")
	}

	if err := r.DB.WithContext(ctx).Model(&model.SavedSegment{}).Where("id = ?", id).Updates(&model.SavedSegment{
		Params: paramString,
		Name:   name,
	}).Error; err != nil {
		return nil, err
	}
	return &model.T, nil
}

// DeleteSavedSegment is the resolver for the deleteSavedSegment field.
func (r *mutationResolver) DeleteSavedSegment(ctx context.Context, segmentID int) (*bool, error) {
	_, err := r.isAdminSavedSegmentOwner(ctx, segmentID)
	if err != nil {
		return nil, err
	}
	if err := r.DB.Where("id = ?", segmentID).Delete(&model.SavedSegment{}).Error; err != nil {
		return nil, err
	}
	return &model.T, nil
}

// CreateOrUpdateStripeSubscription is the resolver for the createOrUpdateStripeSubscription field.
func (r *mutationResolver) CreateOrUpdateStripeSubscription(ctx context.Context, workspaceID int) (*string, error) {
	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	// For older projects, if there's no customer ID, we create a StripeCustomer obj.
	if workspace.StripeCustomerID == nil {
		params := &stripe.CustomerParams{}
		c, err := r.PricingClient.Customers.New(params)
		if err != nil {
			log.WithContext(ctx).Error(err, "error creating stripe customer")
		}
		if err := r.DB.WithContext(ctx).Model(&workspace).Updates(&model.Workspace{
			StripeCustomerID: &c.ID,
		}).Error; err != nil {
			return nil, e.Wrap(err, "error updating org fields")
		}
		workspace.StripeCustomerID = &c.ID
	}

	params := &stripe.CustomerParams{}
	params.AddExpand("subscriptions")

	c, err := r.PricingClient.Customers.Get(*workspace.StripeCustomerID, params)
	if err != nil {
		return nil, e.Wrap(err, "BILLING_ERROR cannot update stripe subscription - couldn't retrieve stripe customer data")
	}

	// If there are multiple subscriptions, it's ambiguous which one should be updated, so throw an error
	if len(c.Subscriptions.Data) > 1 {
		return nil, e.New("BILLING_ERROR cannot update stripe subscription - customer has multiple subscriptions")
	}

	subscriptions := c.Subscriptions.Data
	pricing.FillProducts(r.PricingClient, subscriptions)

	pricingInterval := model.PricingSubscriptionIntervalMonthly

	defaultRetention := modelInputs.RetentionPeriodThreeMonths

	// default to unlimited members pricing
	prices, err := pricing.GetStripePrices(r.PricingClient, workspace, modelInputs.PlanTypeGraduated, pricingInterval, true, &defaultRetention, &defaultRetention)
	if err != nil {
		return nil, e.Wrap(err, "BILLING_ERROR cannot update stripe subscription - failed to get Stripe prices")
	}

	newBasePrice := prices[model.PricingProductTypeBase]

	// If there's an existing subscription, update it
	if len(subscriptions) == 1 {
		subscription := subscriptions[0]
		if len(subscription.Items.Data) != 1 {
			return nil, e.New("BILLING_ERROR cannot update stripe subscription - subscription has multiple products")
		}

		subscriptionItem := subscription.Items.Data[0]
		productType, _, _, _, _ := pricing.GetProductMetadata(subscriptionItem.Price)
		if productType == nil {
			return nil, e.New(fmt.Sprintf("BILLING_ERROR cannot update stripe subscription - nil product from sub %s price %s", subscription.ID, subscriptionItem.Price.ID))
		}
		if *productType != model.PricingProductTypeBase {
			return nil, e.New(fmt.Sprintf("BILLING_ERROR cannot update stripe subscription - expecting base product from sub %s price %s: %s", subscription.ID, subscriptionItem.Price.ID, *productType))
		}

		subscriptionParams := &stripe.SubscriptionParams{
			CancelAtPeriodEnd: stripe.Bool(false),
			ProrationBehavior: stripe.String(string(stripe.SubscriptionSchedulePhaseProrationBehaviorCreateProrations)),
			Items: []*stripe.SubscriptionItemsParams{
				{
					ID:   &subscriptionItem.ID,
					Plan: &newBasePrice.ID,
				},
			},
		}

		_, err := r.PricingClient.Subscriptions.Update(subscription.ID, subscriptionParams)
		if err != nil {
			return nil, e.Wrap(err, "couldn't update subscription")
		}
		ret := ""
		return &ret, nil
	}

	// If there's no existing subscription, we create a checkout.
	checkoutSessionParams := &stripe.CheckoutSessionParams{
		SuccessURL: stripe.String(env.Config.FrontendUri + "/w/" + strconv.Itoa(workspaceID) + "/current-plan/success"),
		CancelURL:  stripe.String(env.Config.FrontendUri + "/w/" + strconv.Itoa(workspaceID) + "/current-plan/update-plan"),
		PaymentMethodTypes: stripe.StringSlice([]string{
			"card",
		}),
		Customer: workspace.StripeCustomerID,
		LineItems: []*stripe.CheckoutSessionLineItemParams{
			{
				Price:    &newBasePrice.ID,
				Quantity: stripe.Int64(1),
			},
		},
		Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
	}
	checkoutSessionParams.AddExtra("allow_promotion_codes", "true")

	stripeSession, err := r.PricingClient.CheckoutSessions.New(checkoutSessionParams)
	if err != nil {
		return nil, e.Wrap(err, "error creating CheckoutSession in stripe")
	}

	return &stripeSession.ID, nil
}

// HandleAWSMarketplace is the resolver for the handleAWSMarketplace field.
func (r *mutationResolver) HandleAWSMarketplace(ctx context.Context, workspaceID int, code string) (*bool, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	var customer marketplacemetering.ResolveCustomerOutput
	if err := r.Redis.Cache.Get(ctx, code, &customer); err != nil {
		return nil, e.Wrap(err, "unable to find customer via provided code")
	}

	entitlements, err := pricing.GetEntitlements(ctx, &customer)
	if err != nil {
		return nil, err
	}

	log.WithContext(ctx).
		WithField("workspaceID", workspaceID).
		WithField("code", code).
		WithField("entitlements", entitlements).
		Info("aws mp request entitlements")

	// create customer record with the current frontend workspace context
	if err := r.DB.WithContext(ctx).
		Where(&model.AWSMarketplaceCustomer{WorkspaceID: workspaceID}).
		Clauses(clause.OnConflict{
			Columns: []clause.Column{{Name: "workspace_id"}},
			DoUpdates: clause.AssignmentColumns([]string{
				"customer_identifier",
				"customer_aws_account_id",
				"product_code",
			}),
		}).
		Model(&model.AWSMarketplaceCustomer{}).
		Create(&model.AWSMarketplaceCustomer{
			WorkspaceID:          workspaceID,
			CustomerIdentifier:   customer.CustomerIdentifier,
			CustomerAWSAccountID: customer.CustomerAWSAccountId,
			ProductCode:          customer.ProductCode,
		}).Error; err != nil {
		return nil, err
	}

	products := map[string]*int{
		"sessions": nil,
		"errors":   nil,
		"logs":     nil,
		"traces":   nil,
	}
	multipliers := map[string]int{
		"sessions": 1_000,
		"errors":   1_000,
		"logs":     1_000_000,
		"traces":   1_000_000,
	}

	for key := range products {
		if v, ok := lo.Find(entitlements, func(item mpeTypes.Entitlement) bool {
			return pointy.StringValue(item.Dimension, "") == key
		}); ok {
			if v.Value.IntegerValue != nil {
				products[key] = pointy.Int(multipliers[key] * int(*v.Value.IntegerValue))
			}
		}
	}
	if err := r.DB.WithContext(ctx).
		Where(&model.Workspace{Model: model.Model{ID: workspaceID}}).
		Clauses(clause.OnConflict{
			Columns: []clause.Column{{Name: "id"}},
			DoUpdates: clause.AssignmentColumns([]string{
				"monthly_session_limit",
				"monthly_errors_limit",
				"monthly_logs_limit",
				"monthly_traces_limit",
			}),
		}).
		Model(&model.Workspace{}).
		Updates(&model.Workspace{
			MonthlySessionLimit: products["sessions"],
			MonthlyErrorsLimit:  products["errors"],
			MonthlyLogsLimit:    products["logs"],
			MonthlyTracesLimit:  products["traces"],
		}).Error; err != nil {
		return nil, err
	}

	err = r.updateAWSMPBillingDetails(ctx, workspaceID, &customer)
	if err != nil {
		return nil, err
	}

	// remove used code so that it cannot be associated with another workspace
	if err := r.Redis.Cache.Delete(ctx, code); err != nil {
		return nil, err
	}

	return pointy.Bool(true), nil
}

// UpdateBillingDetails is the resolver for the updateBillingDetails field.
func (r *mutationResolver) UpdateBillingDetails(ctx context.Context, workspaceID int) (*bool, error) {
	_, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	workspace, err := r.GetAWSMarketPlaceWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "failed to get workspace")
	}

	if workspace.AWSMarketplaceCustomer == nil {
		if err := r.updateStripeBillingDetails(ctx, *workspace.StripeCustomerID); err != nil {
			return nil, e.Wrap(err, "error updating billing details")
		}
	}

	return &model.T, nil
}

// SaveBillingPlan is the resolver for the saveBillingPlan field.
func (r *mutationResolver) SaveBillingPlan(ctx context.Context, workspaceID int, sessionsLimitCents *int, sessionsRetention modelInputs.RetentionPeriod, errorsLimitCents *int, errorsRetention modelInputs.RetentionPeriod, logsLimitCents *int, logsRetention modelInputs.RetentionPeriod, tracesLimitCents *int, tracesRetention modelInputs.RetentionPeriod) (*bool, error) {
	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	settings, err := r.Store.GetAllWorkspaceSettings(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	columns := []interface{}{"errors_retention_period", "retention_period"}
	if settings.EnableBillingLimits {
		columns = append(columns, "sessions_max_cents", "errors_max_cents", "logs_max_cents", "traces_max_cents")
	} else {
		// allow disabling products by setting a limit of 0, even when billing limits are disabled
		for column, value := range map[string]*int{
			"sessions_max_cents": sessionsLimitCents,
			"errors_max_cents":   errorsLimitCents,
			"logs_max_cents":     logsLimitCents,
			"traces_max_cents":   tracesLimitCents,
		} {
			if pointy.IntValue(value, 0) == 0 {
				columns = append(columns, column)
			}
		}
	}
	if err := r.DB.WithContext(ctx).Model(&workspace).
		Select(columns[0], columns[1:]...).
		Updates(&model.Workspace{
			SessionsMaxCents:      sessionsLimitCents,
			RetentionPeriod:       &sessionsRetention,
			ErrorsMaxCents:        errorsLimitCents,
			ErrorsRetentionPeriod: &errorsRetention,
			LogsMaxCents:          logsLimitCents,
			LogsRetentionPeriod:   &logsRetention,
			TracesMaxCents:        tracesLimitCents,
			TracesRetentionPeriod: &tracesRetention,
		}).Error; err != nil {
		return nil, e.Wrap(err, "error updating workspace")
	}

	return pointy.Bool(true), nil
}

// CreateSessionComment is the resolver for the createSessionComment field.
func (r *mutationResolver) CreateSessionComment(ctx context.Context, projectID int, sessionSecureID string, sessionTimestamp int, text string, textForEmail string, xCoordinate float64, yCoordinate float64, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, sessionURL string, time float64, authorName string, sessionImage *string, issueTitle *string, issueDescription *string, issueTeamID *string, issueTypeID *string, integrations []*modelInputs.IntegrationType, tags []*modelInputs.SessionCommentTagInput, additionalContext *string) (*model.SessionComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	// All viewers can leave a comment, including guests
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	sessionImageStr := ""
	if sessionImage != nil {
		sessionImageStr = *sessionImage
	}

	if sessionTimestamp >= math.MaxInt32 {
		log.WithContext(ctx).Warnf("attempted to create session with invalid timestamp %d", sessionTimestamp)
		sessionTimestamp = 0
	}
	sessionComment := &model.SessionComment{
		Admins:          admins,
		ProjectID:       projectID,
		AdminId:         admin.Model.ID,
		SessionId:       session.ID,
		SessionSecureId: session.SecureID,
		SessionImage:    sessionImageStr,
		Timestamp:       sessionTimestamp,
		Text:            text,
		XCoordinate:     xCoordinate,
		YCoordinate:     yCoordinate,
	}
	createSessionCommentSpan, _ := util.StartSpanFromContext(ctx, "db.createSessionComment",
		util.ResourceName("resolver.createSessionComment"), util.Tag("project_id", projectID))
	if err := r.DB.WithContext(ctx).Create(sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating session comment")
	}
	createSessionCommentSpan.Finish()

	if err := r.DB.WithContext(ctx).Model(&model.Session{Model: model.Model{ID: sessionComment.SessionId}}).
		Updates(&model.Session{HasComments: true}).Error; err != nil {
		return nil, e.Wrap(err, "error updating session")
	}

	if err := r.DataSyncQueue.Submit(ctx, strconv.Itoa(sessionComment.SessionId), &kafka_queue.Message{Type: kafka_queue.SessionDataSync, SessionDataSync: &kafka_queue.SessionDataSyncArgs{SessionID: sessionComment.SessionId}}); err != nil {
		log.WithContext(ctx).Errorf("error submitting session to data sync queue: %v", err)
	}

	// Create associations between tags and comments.
	if len(tags) > 0 {
		// Create the tag if it's a new tag
		newTags := []*model.SessionCommentTag{}
		existingTags := []*model.SessionCommentTag{}
		sessionComments := []model.SessionComment{*sessionComment}

		for _, tag := range tags {
			if tag.ID == nil {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID:       projectID,
					Name:            tag.Name,
					SessionComments: sessionComments,
				}
				newTags = append(newTags, &newSessionCommentTag)
			} else {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID: projectID,
					Name:      tag.Name,
					Model: model.Model{
						ID: *tag.ID,
					},
					SessionComments: sessionComments,
				}
				existingTags = append(existingTags, &newSessionCommentTag)
			}
		}

		if len(newTags) > 0 {
			if err := r.DB.WithContext(ctx).Create(&newTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to create new session tags", err)
			}
		}

		if len(existingTags) > 0 {
			if err := r.DB.Save(&existingTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to update existing session tags", err)
			}
		}
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)
	muteLink := fmt.Sprintf("%v?commentId=%v&ts=%v&muted=1", sessionURL, sessionComment.ID, time)

	r.PrivateWorkerPool.SubmitRecover(func() {
		ctx := context.Background()
		chunkIdx, chunkTs := r.GetSessionChunk(ctx, session.ID, sessionTimestamp)
		log.WithContext(ctx).Infof("got chunk %d ts %d for session %d ts %d", chunkIdx, chunkTs, session.ID, sessionTimestamp)
		format := model.SessionExportFormatPng
		resp, err := r.LambdaClient.GetSessionScreenshot(ctx, projectID, session.ID, pointy.Int(chunkTs), pointy.Int(chunkIdx), &format)
		if err != nil {
			log.WithContext(ctx).Errorf("failed to render screenshot for %d %d %d %s", projectID, session.ID, sessionTimestamp, err)
		} else {
			sessionImageStr = base64.StdEncoding.EncodeToString(resp.Image)
			sessionImage = &sessionImageStr
			if err := r.DB.WithContext(ctx).Model(&model.SessionComment{}).Where(
				&model.SessionComment{Model: model.Model{ID: sessionComment.ID}},
			).Updates(
				model.SessionComment{
					SessionImage: sessionImageStr,
				},
			).Error; err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, fmt.Sprintf("failed to update image for comment %d", sessionComment.ID)))
			}
		}
		if len(taggedAdmins) > 0 && !isGuest {
			r.sendCommentPrimaryNotification(
				ctx,
				admin,
				*admin.Name,
				taggedAdmins,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				muteLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
				&Email.SessionCommentMentionsAsmId,
			)
		}
		if len(taggedSlackUsers) > 0 && !isGuest {
			r.sendCommentMentionNotification(
				ctx,
				admin,
				taggedSlackUsers,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
			)
		}
	})

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}
		title, desc := r.Store.BuildIssueTitleAndDescription(*issueTitle, issueDescription)
		desc += "See the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/sessions/%s", env.Config.FrontendUri, projectID, sessionComment.SessionSecureId)

		if *s == modelInputs.IntegrationTypeLinear &&
			workspace.LinearAccessToken != nil &&
			*workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				ctx,
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				textForEmail,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp &&
			workspace.ClickupAccessToken != nil &&
			*workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitHub {
			if err := r.CreateGitHubTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				issueTeamID,
				tags,
			); err != nil {
				return nil, e.Wrap(err, "error creating GitHub task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeJira {
			if issueTeamID == nil || issueTypeID == nil {
				return nil, e.New("issue team and type are required")
			}

			if err := r.CreateJiraTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				*issueTeamID,
				*issueTypeID,
			); err != nil {
				return nil, e.Wrap(err, "error creating Jira task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitLab {
			if err := r.CreateGitlabTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				*issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating GitLab task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.SessionCommentID = sessionComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return sessionComment, nil
}

// CreateSessionCommentWithExistingIssue is the resolver for the createSessionCommentWithExistingIssue field.
func (r *mutationResolver) CreateSessionCommentWithExistingIssue(ctx context.Context, projectID int, sessionSecureID string, sessionTimestamp int, text string, textForEmail string, xCoordinate float64, yCoordinate float64, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, sessionURL string, time float64, authorName string, sessionImage *string, tags []*modelInputs.SessionCommentTagInput, integrations []*modelInputs.IntegrationType, issueTitle *string, issueURL string, issueID string, additionalContext *string) (*model.SessionComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	// All viewers can leave a comment, including guests
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	sessionImageStr := ""
	if sessionImage != nil {
		sessionImageStr = *sessionImage
	}

	if sessionTimestamp >= math.MaxInt32 {
		log.WithContext(ctx).Warnf("attempted to create session with invalid timestamp %d", sessionTimestamp)
		sessionTimestamp = 0
	}
	sessionComment := &model.SessionComment{
		Admins:          admins,
		ProjectID:       projectID,
		AdminId:         admin.Model.ID,
		SessionId:       session.ID,
		SessionSecureId: session.SecureID,
		SessionImage:    sessionImageStr,
		Timestamp:       sessionTimestamp,
		Text:            text,
		XCoordinate:     xCoordinate,
		YCoordinate:     yCoordinate,
	}
	createSessionCommentSpan, _ := util.StartSpanFromContext(ctx, "db.createSessionComment",
		util.ResourceName("resolver.createSessionComment"), util.Tag("project_id", projectID))
	if err := r.DB.WithContext(ctx).Create(sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating session comment")
	}
	createSessionCommentSpan.Finish()

	if err := r.DB.WithContext(ctx).Model(&model.Session{Model: model.Model{ID: sessionComment.SessionId}}).
		Updates(&model.Session{HasComments: true}).Error; err != nil {
		return nil, e.Wrap(err, "error updating session")
	}

	if err := r.DataSyncQueue.Submit(ctx, strconv.Itoa(sessionComment.SessionId), &kafka_queue.Message{Type: kafka_queue.SessionDataSync, SessionDataSync: &kafka_queue.SessionDataSyncArgs{SessionID: sessionComment.SessionId}}); err != nil {
		log.WithContext(ctx).Errorf("error submitting session to data sync queue: %v", err)
	}

	// Create associations between tags and comments.
	if len(tags) > 0 {
		// Create the tag if it's a new tag
		newTags := []*model.SessionCommentTag{}
		existingTags := []*model.SessionCommentTag{}
		sessionComments := []model.SessionComment{*sessionComment}

		for _, tag := range tags {
			if tag.ID == nil {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID:       projectID,
					Name:            tag.Name,
					SessionComments: sessionComments,
				}
				newTags = append(newTags, &newSessionCommentTag)
			} else {
				newSessionCommentTag := model.SessionCommentTag{
					ProjectID: projectID,
					Name:      tag.Name,
					Model: model.Model{
						ID: *tag.ID,
					},
					SessionComments: sessionComments,
				}
				existingTags = append(existingTags, &newSessionCommentTag)
			}
		}

		if len(newTags) > 0 {
			if err := r.DB.WithContext(ctx).Create(&newTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to create new session tags", err)
			}
		}

		if len(existingTags) > 0 {
			if err := r.DB.Save(&existingTags).Error; err != nil {
				log.WithContext(ctx).Error("Failed to update existing session tags", err)
			}
		}
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)
	muteLink := fmt.Sprintf("%v?commentId=%v&ts=%v&muted=1", sessionURL, sessionComment.ID, time)

	r.PrivateWorkerPool.SubmitRecover(func() {
		ctx := context.Background()
		chunkIdx, chunkTs := r.GetSessionChunk(ctx, session.ID, sessionTimestamp)
		log.WithContext(ctx).Infof("got chunk %d ts %d for session %d ts %d", chunkIdx, chunkTs, session.ID, sessionTimestamp)
		format := model.SessionExportFormatPng
		resp, err := r.LambdaClient.GetSessionScreenshot(ctx, projectID, session.ID, pointy.Int(chunkTs), pointy.Int(chunkIdx), &format)
		if err != nil {
			log.WithContext(ctx).Errorf("failed to render screenshot for %d %d %d %s", projectID, session.ID, sessionTimestamp, err)
		} else {
			sessionImageStr = base64.StdEncoding.EncodeToString(resp.Image)
			sessionImage = &sessionImageStr
			if err := r.DB.WithContext(ctx).Model(&model.SessionComment{}).Where(
				&model.SessionComment{Model: model.Model{ID: sessionComment.ID}},
			).Updates(
				model.SessionComment{
					SessionImage: sessionImageStr,
				},
			).Error; err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, fmt.Sprintf("failed to update image for comment %d", sessionComment.ID)))
			}
		}
		if len(taggedAdmins) > 0 && !isGuest {
			r.sendCommentPrimaryNotification(
				ctx,
				admin,
				*admin.Name,
				taggedAdmins,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				muteLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
				&Email.SessionCommentMentionsAsmId,
			)
		}
		if len(taggedSlackUsers) > 0 && !isGuest {
			r.sendCommentMentionNotification(
				ctx,
				admin,
				taggedSlackUsers,
				workspace,
				project.ID,
				&sessionComment.ID,
				nil,
				textForEmail,
				viewLink,
				sessionImage,
				"tagged",
				"session",
				additionalContext,
			)
		}
	})

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}
		title, _ := r.Store.BuildIssueTitleAndDescription(*issueTitle, ptr.String(""))

		if *s == modelInputs.IntegrationTypeLinear &&
			workspace.LinearAccessToken != nil &&
			*workspace.LinearAccessToken != "" {
			if err := r.CreateLinearAttachmentForExistingIssue(
				ctx,
				workspace,
				attachment,
				title,
				authorName,
				viewLink,
				issueID,
				issueURL,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear issue attachment")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else {
			if err := r.CreateIssueAttachment(ctx, attachment, title, issueURL); err != nil {
				return nil, e.Wrap(err, fmt.Sprintf("error creating %s task attachment", *s))
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.SessionCommentID = sessionComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return sessionComment, nil
}

// CreateIssueForSessionComment is the resolver for the createIssueForSessionComment field.
func (r *mutationResolver) CreateIssueForSessionComment(ctx context.Context, projectID int, sessionURL string, sessionCommentID int, authorName string, textForAttachment string, time float64, issueTitle *string, issueDescription *string, issueTeamID *string, issueTypeID *string, integrations []*modelInputs.IntegrationType) (*model.SessionComment, error) {
	var project model.Project
	if err := r.DB.WithContext(ctx).Where("id = ?", projectID).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	sessionComment := &model.SessionComment{}
	if err := r.DB.WithContext(ctx).Preload("Attachments").Where(&model.SessionComment{Model: model.Model{ID: sessionCommentID}}).Find(sessionComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}

		title, desc := r.Store.BuildIssueTitleAndDescription(*issueTitle, issueDescription)
		desc += "See the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/sessions/%s", env.Config.FrontendUri, projectID, sessionComment.SessionSecureId)

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(ctx, workspace, attachment, *issueTitle, *issueDescription, sessionComment.Text, authorName, viewLink, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitHub {
			if err := r.CreateGitHubTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID, nil); err != nil {
				return nil, e.Wrap(err, "error creating GitHub task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeJira {
			if issueTeamID == nil || issueTypeID == nil {
				return nil, e.New("issue team and type are required")
			}

			if err := r.CreateJiraTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID, *issueTypeID); err != nil {
				return nil, e.Wrap(err, "error creating Jira task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitLab {
			if err := r.CreateGitlabTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating GitLab task")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	return sessionComment, nil
}

// LinkIssueForSessionComment is the resolver for the linkIssueForSessionComment field.
func (r *mutationResolver) LinkIssueForSessionComment(ctx context.Context, projectID int, sessionURL string, sessionCommentID int, authorName string, textForAttachment string, time float64, issueTitle *string, issueURL string, issueID string, integrations []*modelInputs.IntegrationType) (*model.SessionComment, error) {
	var project model.Project
	if err := r.DB.WithContext(ctx).Where("id = ?", projectID).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	sessionComment := &model.SessionComment{}
	if err := r.DB.WithContext(ctx).Preload("Attachments").Where(&model.SessionComment{Model: model.Model{ID: sessionCommentID}}).Find(sessionComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v?commentId=%v&ts=%v", sessionURL, sessionComment.ID, time)

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType:  *s,
			SessionCommentID: sessionComment.ID,
		}

		title, _ := r.Store.BuildIssueTitleAndDescription(*issueTitle, ptr.String(""))

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearAttachmentForExistingIssue(ctx, workspace, attachment, sessionComment.Text, authorName, viewLink, issueID, issueURL); err != nil {
				return nil, e.Wrap(err, "error creating linear issue attachment")
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		} else {
			if err := r.CreateIssueAttachment(ctx, attachment, title, issueURL); err != nil {
				return nil, e.Wrap(err, fmt.Sprintf("error creating %s issue attachment", *s))
			}

			sessionComment.Attachments = append(sessionComment.Attachments, attachment)
		}
	}

	return sessionComment, nil
}

// DeleteSessionComment is the resolver for the deleteSessionComment field.
func (r *mutationResolver) DeleteSessionComment(ctx context.Context, id int) (*bool, error) {
	var sessionComment model.SessionComment
	if err := r.DB.WithContext(ctx).Where(model.SessionComment{Model: model.Model{ID: id}}).Take(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	_, err := r.canAdminModifySession(ctx, sessionComment.SessionSecureId)

	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&model.SessionComment{Model: model.Model{ID: id}}).Error; err != nil {
		return nil, e.Wrap(err, "error session comment")
	}

	if err := r.DB.WithContext(ctx).Where(&model.ExternalAttachment{SessionCommentID: id}).Delete(&model.ExternalAttachment{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment attachments")
	}

	if err := r.DB.WithContext(ctx).Where(&model.CommentReply{SessionCommentID: id}).Delete(&model.CommentReply{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment replies")
	}

	if err := r.DB.WithContext(ctx).Where(&model.CommentFollower{SessionCommentID: id}).Delete(&model.CommentFollower{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment followers")
	}

	var commentCount int64
	if err := r.DB.Table("session_comments").Where(&model.SessionComment{SessionSecureId: sessionComment.SessionSecureId}).Count(&commentCount).Error; err != nil {
		return nil, e.Wrap(err, "error counting session comments")
	}

	if commentCount == 0 {
		if err := r.DB.WithContext(ctx).Model(&model.Session{Model: model.Model{ID: sessionComment.SessionId}}).
			Select("HasComments").
			Updates(&model.Session{HasComments: false}).Error; err != nil {
			return nil, e.Wrap(err, "error updating session")
		}

		if err := r.DataSyncQueue.Submit(ctx, strconv.Itoa(sessionComment.SessionId), &kafka_queue.Message{Type: kafka_queue.SessionDataSync, SessionDataSync: &kafka_queue.SessionDataSyncArgs{SessionID: sessionComment.SessionId}}); err != nil {
			log.WithContext(ctx).Errorf("error submitting session to data sync queue: %v", err)
		}
	}

	return &model.T, nil
}

// MuteSessionCommentThread is the resolver for the muteSessionCommentThread field.
func (r *mutationResolver) MuteSessionCommentThread(ctx context.Context, id int, hasMuted *bool) (*bool, error) {
	var sessionComment model.SessionComment
	if err := r.DB.WithContext(ctx).Where(model.SessionComment{Model: model.Model{ID: id}}).Take(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	_, err := r.canAdminModifySession(ctx, sessionComment.SessionSecureId)
	if err != nil {
		return nil, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if err := r.DB.WithContext(ctx).Where(&model.CommentFollower{SessionCommentID: id, AdminId: admin.ID}).Updates(
		&model.CommentFollower{
			HasMuted: hasMuted,
		}).Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// ReplyToSessionComment is the resolver for the replyToSessionComment field.
func (r *mutationResolver) ReplyToSessionComment(ctx context.Context, commentID int, text string, textForEmail string, sessionURL string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput) (*model.CommentReply, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)
	if isGuest {
		return nil, e.New("must be logged in to add a comment reply")
	}

	var sessionComment model.SessionComment
	if err := r.DB.WithContext(ctx).Preload("Followers").Preload("Threads").Where(model.SessionComment{Model: model.Model{ID: commentID}}).Take(&sessionComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comment")
	}

	// All viewers can leave a comment reply, including guests
	_, err := r.canAdminViewSession(ctx, sessionComment.SessionSecureId)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: sessionComment.ProjectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	commentReply := &model.CommentReply{
		SessionCommentID: sessionComment.ID,
		Admins:           admins,
		AdminId:          admin.ID,
		Text:             text,
	}
	createSessionCommentReplySpan, _ := util.StartSpanFromContext(ctx, "db.createSessionCommentReply",
		util.ResourceName("resolver.createSessionCommentReply"), util.Tag("project_id", sessionComment.ProjectID))
	if err := r.DB.WithContext(ctx).Create(commentReply).Error; err != nil {
		return nil, e.Wrap(err, "error creating session comment reply")
	}
	createSessionCommentReplySpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", sessionURL, sessionComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", sessionURL, sessionComment.ID)

	if len(taggedAdmins) > 0 {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			*admin.Name,
			taggedAdmins,
			workspace,
			project.ID,
			&sessionComment.ID,
			nil,
			textForEmail,
			viewLink,
			muteLink,
			&sessionComment.SessionImage,
			"replied to",
			"session",
			nil,
			&Email.SessionCommentMentionsAsmId,
		)
	}
	if len(sessionComment.Followers) > 0 {
		var threadIDs []int
		for _, thread := range sessionComment.Threads {
			threadIDs = append(threadIDs, thread.ID)
		}
		r.sendFollowedCommentNotification(
			ctx,
			admin,
			sessionComment.Followers,
			workspace,
			project.ID,
			threadIDs,
			textForEmail,
			viewLink,
			muteLink,
			&sessionComment.SessionImage,
			"replied to",
			"session",
			&Email.SessionCommentMentionsAsmId,
		)
	}

	existingAdminIDs, existingSlackChannelIDs := r.getCommentFollowers(ctx, sessionComment.Followers)
	taggedAdmins = append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedAdmins, taggedSlackUsers, existingAdminIDs, existingSlackChannelIDs)
	for _, f := range newFollowers {
		f.SessionCommentID = commentID
	}

	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session reply followers", err)
		}
	}

	return commentReply, nil
}

// CreateErrorComment is the resolver for the createErrorComment field.
func (r *mutationResolver) CreateErrorComment(ctx context.Context, projectID int, errorGroupSecureID string, text string, textForEmail string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, errorURL string, authorName string, issueTitle *string, issueDescription *string, issueTeamID *string, issueTypeID *string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := []model.Admin{}
	for _, a := range taggedAdmins {
		admins = append(admins,
			model.Admin{
				Model: model.Model{ID: a.ID},
			},
		)
	}

	errorComment := &model.ErrorComment{
		Admins:        admins,
		ProjectID:     projectID,
		AdminId:       admin.Model.ID,
		ErrorId:       errorGroup.ID,
		ErrorSecureId: errorGroup.SecureID,
		Text:          text,
	}

	createErrorCommentSpan, _ := util.StartSpanFromContext(ctx, "db.createErrorComment",
		util.ResourceName("resolver.createErrorComment"), util.Tag("project_id", projectID))

	if err := r.DB.WithContext(ctx).Create(errorComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating error comment")
	}

	createErrorCommentSpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", errorURL, errorComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", errorURL, errorComment.ID)

	if len(taggedAdmins) > 0 && !isGuest {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			authorName,
			taggedAdmins,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"tagged",
			"error",
			nil,
			&Email.ErrorCommentMentionsAsmId,
		)
	}
	if len(taggedSlackUsers) > 0 && !isGuest {
		r.sendCommentMentionNotification(
			ctx,
			admin,
			taggedSlackUsers,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			nil,
			"tagged",
			"error",
			nil,
		)
	}

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		title, desc := r.Store.BuildIssueTitleAndDescription(*issueTitle, issueDescription)
		desc += "See the error page on Highlight:\n"
		desc += fmt.Sprintf("%s/%d/errors/%s", env.Config.FrontendUri, projectID, errorComment.ErrorSecureId)

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				ctx,
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				textForEmail,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitHub {
			if err := r.CreateGitHubTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID, nil); err != nil {
				return nil, e.Wrap(err, "error creating GitHub task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeJira {
			if issueTeamID == nil || issueTypeID == nil {
				return nil, e.New("issue team and type are required")
			}

			if err := r.CreateJiraTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID, *issueTypeID); err != nil {
				return nil, e.Wrap(err, "error creating Jira task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitLab {
			if err := r.CreateGitlabTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating GitLab task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.ErrorCommentID = errorComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return errorComment, nil
}

// CreateErrorCommentForExistingIssue is the resolver for the createErrorCommentForExistingIssue field.
func (r *mutationResolver) CreateErrorCommentForExistingIssue(ctx context.Context, projectID int, errorGroupSecureID string, text string, textForEmail string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput, errorURL string, authorName string, issueURL string, issueTitle string, issueID string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)

	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := []model.Admin{}
	for _, a := range taggedAdmins {
		admins = append(admins,
			model.Admin{
				Model: model.Model{ID: a.ID},
			},
		)
	}

	errorComment := &model.ErrorComment{
		Admins:        admins,
		ProjectID:     projectID,
		AdminId:       admin.Model.ID,
		ErrorId:       errorGroup.ID,
		ErrorSecureId: errorGroup.SecureID,
		Text:          text,
	}

	createErrorCommentSpan, _ := util.StartSpanFromContext(ctx, "db.createErrorComment",
		util.ResourceName("resolver.createErrorComment"), util.Tag("project_id", projectID))

	if err := r.DB.WithContext(ctx).Create(errorComment).Error; err != nil {
		return nil, e.Wrap(err, "error creating error comment")
	}

	createErrorCommentSpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", errorURL, errorComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", errorURL, errorComment.ID)

	if len(taggedAdmins) > 0 && !isGuest {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			authorName,
			taggedAdmins,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"tagged",
			"error",
			nil,
			&Email.ErrorCommentMentionsAsmId,
		)
	}
	if len(taggedSlackUsers) > 0 && !isGuest {
		r.sendCommentMentionNotification(
			ctx,
			admin,
			taggedSlackUsers,
			workspace,
			projectID,
			nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			nil,
			"tagged",
			"error",
			nil,
		)
	}

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		if *s == modelInputs.IntegrationTypeLinear {
			if err := r.CreateLinearAttachmentForExistingIssue(
				ctx,
				workspace,
				attachment,
				errorComment.Text,
				authorName,
				viewLink,
				issueID,  // supposed to be the issue ID itself - not some url - seems we need a rethink here?
				issueURL, //supposed to be the issue identifier - looks like a readable id
			); err != nil {
				return nil, e.Wrap(err, "error creating linear issue attachment")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else {
			if err := r.CreateIssueAttachment(ctx, attachment, issueTitle, issueURL); err != nil {
				return nil, e.Wrap(err, fmt.Sprintf("error creating %s issue attachment", *s))
			}
			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	taggedUsers := append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedUsers, taggedSlackUsers, nil, nil)
	for _, f := range newFollowers {
		f.ErrorCommentID = errorComment.ID
	}
	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new session comment followers", err)
		}
	}

	return errorComment, nil
}

// RemoveErrorIssue is the resolver for the removeErrorIssue field.
func (r *mutationResolver) RemoveErrorIssue(ctx context.Context, errorIssueID int) (*bool, error) {
	var errorCommentID int
	if err := r.DB.
		Model(&model.ExternalAttachment{}).
		Select("error_comment_id").
		Where("id=?", errorIssueID).
		First(&errorCommentID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error issues")
	}

	var errorGroupSecureID string
	if err := r.DB.
		Model(&model.ErrorComment{}).
		Select("error_secure_id").
		Where("id=?", errorCommentID).
		First(&errorGroupSecureID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}

	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}

	var externalAttachment model.ExternalAttachment
	if err := r.DB.
		Model(&model.ExternalAttachment{}).
		Where("id=?", errorIssueID).
		First(&externalAttachment).
		Updates(
			&model.ExternalAttachment{
				Removed: true,
			}).
		Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// MuteErrorCommentThread is the resolver for the muteErrorCommentThread field.
func (r *mutationResolver) MuteErrorCommentThread(ctx context.Context, id int, hasMuted *bool) (*bool, error) {
	var errorGroupSecureID string
	if err := r.DB.
		Model(&model.ErrorComment{}).
		Select("error_secure_id").
		Where("id=?", id).
		First(&errorGroupSecureID).
		Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}
	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	var commentFollower model.CommentFollower
	if err := r.DB.WithContext(ctx).Where(&model.CommentFollower{ErrorCommentID: id, AdminId: admin.ID}).
		First(&commentFollower).
		Updates(
			&model.CommentFollower{
				HasMuted: hasMuted,
			}).
		Error; err != nil {
		return nil, e.Wrap(err, "error changing the muted status")
	}

	return &model.T, nil
}

// CreateIssueForErrorComment is the resolver for the createIssueForErrorComment field.
func (r *mutationResolver) CreateIssueForErrorComment(ctx context.Context, projectID int, errorURL string, errorCommentID int, authorName string, textForAttachment string, issueTitle *string, issueDescription *string, issueTeamID *string, issueTypeID *string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	errorComment := &model.ErrorComment{}
	if err := r.DB.WithContext(ctx).Preload("Attachments").Where(&model.ErrorComment{Model: model.Model{ID: errorCommentID}}).Find(errorComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v", errorURL)

	if issueDescription == nil {
		return nil, e.New("issue description cannot be nil")
	}

	title, desc := r.Store.BuildIssueTitleAndDescription(*issueTitle, issueDescription)
	desc += "See the error page on Highlight:\n"
	desc += fmt.Sprintf("%s/%d/errors/%s", env.Config.FrontendUri, projectID, errorComment.ErrorSecureId)

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearIssueAndAttachment(
				ctx,
				workspace,
				attachment,
				*issueTitle,
				*issueDescription,
				errorComment.Text,
				authorName,
				viewLink,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear ticket or workspace")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeClickUp && workspace.ClickupAccessToken != nil && *workspace.ClickupAccessToken != "" {
			if err := r.CreateClickUpTaskAndAttachment(
				ctx,
				workspace,
				attachment,
				title,
				desc,
				issueTeamID,
			); err != nil {
				return nil, e.Wrap(err, "error creating ClickUp task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeHeight {
			if err := r.CreateHeightTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating Height task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitHub {
			if err := r.CreateGitHubTaskAndAttachment(ctx, workspace, attachment, title, desc, issueTeamID, nil); err != nil {
				return nil, e.Wrap(err, "error creating GitHub task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeJira {
			if issueTeamID == nil || issueTypeID == nil {
				return nil, e.New("issue team and type are required")
			}

			if err := r.CreateJiraTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID, *issueTypeID); err != nil {
				return nil, e.Wrap(err, "error creating Jira task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else if *s == modelInputs.IntegrationTypeGitLab {
			if err := r.CreateGitlabTaskAndAttachment(ctx, workspace, attachment, title, desc, *issueTeamID); err != nil {
				return nil, e.Wrap(err, "error creating GitLab task")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	return errorComment, nil
}

// LinkIssueForErrorComment is the resolver for the linkIssueForErrorComment field.
func (r *mutationResolver) LinkIssueForErrorComment(ctx context.Context, projectID int, errorURL string, errorCommentID int, authorName string, textForAttachment string, issueTitle *string, issueDescription *string, issueURL string, issueID string, integrations []*modelInputs.IntegrationType) (*model.ErrorComment, error) {
	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	errorComment := &model.ErrorComment{}
	if err := r.DB.WithContext(ctx).Preload("Attachments").Where(&model.ErrorComment{Model: model.Model{ID: errorCommentID}}).Find(errorComment).Error; err != nil {
		return nil, err
	}

	viewLink := fmt.Sprintf("%v", errorURL)

	if issueDescription == nil {
		return nil, e.New("issue description cannot be nil")
	}

	title, _ := r.Store.BuildIssueTitleAndDescription(*issueTitle, ptr.String(""))

	for _, s := range integrations {
		attachment := &model.ExternalAttachment{
			IntegrationType: *s,
			ErrorCommentID:  errorComment.ID,
		}

		if *s == modelInputs.IntegrationTypeLinear && workspace.LinearAccessToken != nil && *workspace.LinearAccessToken != "" {
			if err := r.CreateLinearAttachmentForExistingIssue(
				ctx,
				workspace,
				attachment,
				errorComment.Text,
				authorName,
				viewLink,
				issueID,
				issueURL,
			); err != nil {
				return nil, e.Wrap(err, "error creating linear issue attachment")
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		} else {
			if err := r.CreateIssueAttachment(ctx, attachment, title, issueURL); err != nil {
				return nil, e.Wrap(err, fmt.Sprintf("error creating %s task attachment", *s))
			}

			errorComment.Attachments = append(errorComment.Attachments, attachment)
		}
	}

	return errorComment, nil
}

// DeleteErrorComment is the resolver for the deleteErrorComment field.
func (r *mutationResolver) DeleteErrorComment(ctx context.Context, id int) (*bool, error) {
	var errorGroupSecureID string
	if err := r.DB.Table("error_comments").Select("error_secure_id").Where("id=?", id).Scan(&errorGroupSecureID).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments")
	}
	_, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}
	if err := r.DB.Delete(&model.ErrorComment{Model: model.Model{ID: id}}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting error_comment")
	}
	if err := r.DB.WithContext(ctx).Where(&model.ExternalAttachment{ErrorCommentID: id}).Delete(&model.ExternalAttachment{}).Error; err != nil {
		return nil, e.Wrap(err, "error deleting session comment attachments")
	}
	return &model.T, nil
}

// ReplyToErrorComment is the resolver for the replyToErrorComment field.
func (r *mutationResolver) ReplyToErrorComment(ctx context.Context, commentID int, text string, textForEmail string, errorURL string, taggedAdmins []*modelInputs.SanitizedAdminInput, taggedSlackUsers []*modelInputs.SanitizedSlackChannelInput) (*model.CommentReply, error) {
	admin, isGuest := r.getCurrentAdminOrGuest(ctx)
	if isGuest {
		return nil, e.New("must be logged in to add a comment reply")
	}

	var errorComment model.ErrorComment
	if err := r.DB.WithContext(ctx).Preload("Threads").Preload("Followers").Where(model.ErrorComment{Model: model.Model{ID: commentID}}).Take(&errorComment).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comment")
	}

	_, err := r.canAdminViewErrorGroup(ctx, errorComment.ErrorSecureId)
	if err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: errorComment.ProjectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins := r.getTaggedAdmins(taggedAdmins, isGuest)

	commentReply := &model.CommentReply{
		ErrorCommentID: errorComment.ID,
		Admins:         admins,
		AdminId:        admin.ID,
		Text:           text,
	}
	createErrorCommentReplySpan, _ := util.StartSpanFromContext(ctx, "db.createErrorCommentReply",
		util.ResourceName("resolver.createErrorCommentReply"), util.Tag("project_id", errorComment.ProjectID))
	if err := r.DB.WithContext(ctx).Create(commentReply).Error; err != nil {
		return nil, e.Wrap(err, "error creating error comment reply")
	}
	createErrorCommentReplySpan.Finish()

	viewLink := fmt.Sprintf("%v?commentId=%v", errorURL, errorComment.ID)
	muteLink := fmt.Sprintf("%v?commentId=%v&muted=1", errorURL, errorComment.ID)

	if len(taggedAdmins) > 0 && !isGuest {
		r.sendCommentPrimaryNotification(
			ctx,
			admin,
			*admin.Name,
			taggedAdmins,
			workspace,
			project.ID, nil,
			&errorComment.ID,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"replied to",
			"error",
			nil,
			&Email.ErrorCommentMentionsAsmId,
		)
	}
	if len(errorComment.Followers) > 0 && !isGuest {
		var threadIDs []int
		for _, thread := range errorComment.Threads {
			threadIDs = append(threadIDs, thread.ID)
		}
		r.sendFollowedCommentNotification(
			ctx,
			admin,
			errorComment.Followers,
			workspace,
			project.ID,
			threadIDs,
			textForEmail,
			viewLink,
			muteLink,
			nil,
			"replied to",
			"error",
			&Email.ErrorCommentMentionsAsmId,
		)
	}

	existingAdminIDs, existingSlackChannelIDs := r.getCommentFollowers(ctx, errorComment.Followers)
	taggedAdmins = append(taggedAdmins, &modelInputs.SanitizedAdminInput{
		ID:    admin.ID,
		Name:  admin.Name,
		Email: *admin.Email,
	})
	newFollowers := r.findNewFollowers(taggedAdmins, taggedSlackUsers, existingAdminIDs, existingSlackChannelIDs)
	for _, f := range newFollowers {
		f.ErrorCommentID = commentID
	}

	if len(newFollowers) > 0 {
		if err := r.DB.WithContext(ctx).Create(&newFollowers).Error; err != nil {
			log.WithContext(ctx).Error("Failed to create new error reply followers", err)
		}
	}

	return commentReply, nil
}

// AddIntegrationToProject is the resolver for the addIntegrationToProject field.
func (r *mutationResolver) AddIntegrationToProject(ctx context.Context, integrationType *modelInputs.IntegrationType, projectID int, code string) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeLinear {
		if err := r.AddLinearToWorkspace(workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeJira {
		if err := r.AddJiraToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeGitLab {
		if err := r.AddGitlabToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeSlack {
		if err := r.AddSlackToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeFront {
		if err := r.AddFrontToProject(ctx, project, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeVercel {
		if err := r.AddVercelToWorkspace(workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeDiscord {
		if err := r.AddDiscordToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeMicrosoftTeams {
		if err := r.AddMicrosoftTeamsToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeHeroku {
		if err := r.AddHerokuToProject(ctx, project, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeCloudflare {
		if err := r.AddCloudflareToWorkspace(ctx, project, code); err != nil {
			return false, err
		}
	} else {
		return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
	}

	return true, nil
}

// RemoveIntegrationFromProject is the resolver for the removeIntegrationFromProject field.
func (r *mutationResolver) RemoveIntegrationFromProject(ctx context.Context, integrationType *modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeLinear {
		if err := r.RemoveLinearFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeJira {
		if err := r.RemoveJiraFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeSlack {
		if err := r.RemoveSlackFromWorkspace(ctx, workspace, projectID); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeZapier {
		if err := r.RemoveZapierFromWorkspace(ctx, project); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeFront {
		if err := r.RemoveFrontFromProject(ctx, project); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeVercel {
		if err := r.RemoveVercelFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeDiscord {
		if err := r.RemoveDiscordFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeGitHub {
		if err := r.RemoveGitHubFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeMicrosoftTeams {
		if err := r.RemoveMicrosoftTeamsFromWorkspace(ctx, workspace, projectID); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeGitLab {
		if err := r.RemoveGitlabFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else {
		if err := r.RemoveIntegrationFromWorkspaceAndProjects(ctx, workspace, *integrationType); err != nil {
			return false, err
		}
	}

	return true, nil
}

// AddIntegrationToWorkspace is the resolver for the addIntegrationToWorkspace field.
func (r *mutationResolver) AddIntegrationToWorkspace(ctx context.Context, integrationType *modelInputs.IntegrationType, workspaceID int, code string) (bool, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if *integrationType == modelInputs.IntegrationTypeClickUp {
		if err := r.AddClickUpToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeHeight {
		if err := r.AddHeightToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeGitHub {
		if err := r.AddGitHubToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeJira {
		if err := r.AddJiraToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else if *integrationType == modelInputs.IntegrationTypeGitLab {
		if err := r.AddGitlabToWorkspace(ctx, workspace, code); err != nil {
			return false, err
		}
	} else {
		return false, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
	}

	return true, nil
}

// RemoveIntegrationFromWorkspace is the resolver for the removeIntegrationFromWorkspace field.
func (r *mutationResolver) RemoveIntegrationFromWorkspace(ctx context.Context, integrationType modelInputs.IntegrationType, workspaceID int) (bool, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if integrationType == modelInputs.IntegrationTypeClickUp {
		if err := r.RemoveClickUpFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if integrationType == modelInputs.IntegrationTypeGitHub {
		if err := r.RemoveGitHubFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if integrationType == modelInputs.IntegrationTypeJira {
		if err := r.RemoveJiraFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else if integrationType == modelInputs.IntegrationTypeGitLab {
		if err := r.RemoveGitlabFromWorkspace(ctx, workspace); err != nil {
			return false, err
		}
	} else {
		if err := r.RemoveIntegrationFromWorkspaceAndProjects(ctx, workspace, integrationType); err != nil {
			return false, err
		}
	}

	return true, nil
}

// SyncSlackIntegration is the resolver for the syncSlackIntegration field.
func (r *mutationResolver) SyncSlackIntegration(ctx context.Context, projectID int) (*modelInputs.SlackSyncResponse, error) {
	project, err := r.isUserInProject(ctx, projectID)
	response := modelInputs.SlackSyncResponse{
		Success:               true,
		NewChannelsAddedCount: 0,
	}
	if err != nil {
		return &response, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return &response, err
	}
	slackChannels, newChannelsCount, err := r.GetSlackChannelsFromSlack(ctx, workspace.ID)

	if err != nil {
		return &response, err
	}

	channelBytes, err := json.Marshal(slackChannels)
	if err != nil {
		return &response, e.Wrap(err, "error marshaling slack channels")
	}
	channelString := string(channelBytes)
	if err := r.DB.WithContext(ctx).Model(&workspace).Updates(&model.Workspace{
		SlackChannels: &channelString,
	}).Error; err != nil {
		return &response, e.Wrap(err, "error updating workspace slack channels")
	}

	response.NewChannelsAddedCount = newChannelsCount

	return &response, nil
}

// CreateMetricMonitor is the resolver for the createMetricMonitor field.
func (r *mutationResolver) CreateMetricMonitor(ctx context.Context, projectID int, name string, aggregator modelInputs.MetricAggregator, periodMinutes *int, threshold float64, units *string, metricToMonitor string, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, filters []*modelInputs.MetricTagFilterInput) (*model.MetricMonitor, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
	if err != nil {
		return nil, err
	}

	emailsString, err := r.MarshalAlertEmails(emails)
	if err != nil {
		return nil, err
	}

	var mmFilters []*model.DashboardMetricFilter
	for _, f := range filters {
		mmFilters = append(mmFilters, &model.DashboardMetricFilter{
			Tag:   f.Tag,
			Op:    f.Op,
			Value: f.Value,
		})
	}

	newMetricMonitor := &model.MetricMonitor{
		ProjectID:         projectID,
		Name:              name,
		Aggregator:        aggregator,
		PeriodMinutes:     periodMinutes,
		Threshold:         threshold,
		Units:             units,
		MetricToMonitor:   metricToMonitor,
		ChannelsToNotify:  channelsString,
		EmailsToNotify:    emailsString,
		LastAdminToEditID: admin.ID,
		Filters:           mmFilters,
		AlertIntegrations: model.AlertIntegrations{
			DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
			WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
		},
	}

	if err := r.DB.WithContext(ctx).Create(newMetricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error creating a new error alert")
	}
	if err := model.SendWelcomeSlackMessage(ctx, newMetricMonitor, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "created",
		OperationDescription: "Monitor alerts will be sent here",
		ID:                   newMetricMonitor.ID,
		Project:              project,
		IncludeEditLink:      true,
		URLSlug:              "alerts/monitors",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return newMetricMonitor, nil
}

// UpdateMetricMonitor is the resolver for the updateMetricMonitor field.
func (r *mutationResolver) UpdateMetricMonitor(ctx context.Context, metricMonitorID int, projectID int, name *string, aggregator *modelInputs.MetricAggregator, periodMinutes *int, threshold *float64, units *string, metricToMonitor *string, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, disabled *bool, filters []*modelInputs.MetricTagFilterInput) (*model.MetricMonitor, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	metricMonitor := &model.MetricMonitor{}
	if err := r.DB.WithContext(ctx).Where(&model.MetricMonitor{Model: model.Model{ID: metricMonitorID}, ProjectID: projectID}).Find(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitor")
	}

	var createdFilterIDs []int
	for _, f := range filters {
		var created struct{ ID int }
		if err := r.DB.WithContext(ctx).Where(&model.DashboardMetricFilter{
			MetricMonitorID: metricMonitor.ID,
			Tag:             f.Tag,
		}).Clauses(clause.Returning{}, clause.OnConflict{
			OnConstraint: model.DASHBOARD_METRIC_FILTERS_UNIQ,
			DoNothing:    true,
		}).Create(&model.DashboardMetricFilter{
			MetricMonitorID: metricMonitor.ID,
			Tag:             f.Tag,
			Op:              f.Op,
			Value:           f.Value,
		}).Scan(&created).Error; err != nil {
			return nil, e.Wrap(err, "failed to create metric monitor filter")
		}
		createdFilterIDs = append(createdFilterIDs, created.ID)
	}
	r.DB.Exec(`DELETE FROM dashboard_metric_filters WHERE metric_monitor_id = ? AND id NOT IN ?`, metricMonitor.ID, createdFilterIDs)

	if slackChannels != nil {
		channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
		if err != nil {
			return nil, e.Wrap(err, "error marshalling slack channels")
		}
		metricMonitor.ChannelsToNotify = channelsString
	}

	metricMonitor.AlertIntegrations = model.AlertIntegrations{
		DiscordChannelsToNotify: discord.GQLInputToGo(discordChannels),
		WebhookDestinations:     webhook.GQLInputToGo(webhookDestinations),
	}

	if emails != nil {
		emailsString, err := r.MarshalAlertEmails(emails)
		if err != nil {
			return nil, err
		}
		metricMonitor.EmailsToNotify = emailsString
	}

	if name != nil {
		metricMonitor.Name = *name
	}
	if aggregator != nil {
		metricMonitor.Aggregator = *aggregator
	}
	metricMonitor.PeriodMinutes = periodMinutes
	if threshold != nil {
		metricMonitor.Threshold = *threshold
	}
	metricMonitor.Units = units
	if metricToMonitor != nil {
		metricMonitor.MetricToMonitor = *metricToMonitor
	}

	metricMonitor.LastAdminToEditID = admin.ID

	if disabled != nil {
		metricMonitor.Disabled = disabled
	}

	if err := r.DB.Save(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error updating metric monitor")
	}

	if err := model.SendWelcomeSlackMessage(ctx, metricMonitor, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "updated",
		OperationDescription: "Monitor alerts will now be sent to this channel.",
		ID:                   metricMonitorID,
		Project:              project,
		IncludeEditLink:      true,
		URLSlug:              "alerts/monitors",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return metricMonitor, nil
}

// CreateAlert is the resolver for the createAlert field.
func (r *mutationResolver) CreateAlert(ctx context.Context, projectID int, name string, productType modelInputs.ProductType, functionType modelInputs.MetricAggregator, functionColumn *string, query *string, groupByKey *string, belowThreshold *bool, defaultArg *bool, thresholdValue *float64, thresholdWindow *int, thresholdCooldown *int, destinations []*modelInputs.AlertDestinationInput) (*model.Alert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	defaultValue := false
	if defaultArg != nil {
		defaultValue = *defaultArg
	}

	newAlert := &model.Alert{
		ProjectID:         projectID,
		MetricId:          uuid.New().String(),
		Name:              name,
		ProductType:       productType,
		FunctionType:      functionType,
		FunctionColumn:    functionColumn,
		Query:             query,
		GroupByKey:        groupByKey,
		Default:           defaultValue,
		BelowThreshold:    belowThreshold,
		ThresholdValue:    thresholdValue,
		ThresholdWindow:   thresholdWindow,
		ThresholdCooldown: thresholdCooldown,
		LastAdminToEditID: admin.ID,
	}

	createdAlert := &model.Alert{}
	if err := r.DB.WithContext(ctx).Clauses(clause.Returning{}).Create(newAlert).Scan(&createdAlert).Error; err != nil {
		return nil, err
	}

	alertDestinations := []*model.AlertDestination{}
	for _, d := range destinations {
		alertDestinations = append(alertDestinations, &model.AlertDestination{
			AlertID:         createdAlert.ID,
			DestinationType: d.DestinationType,
			TypeID:          d.TypeID,
			TypeName:        d.TypeName,
		})
	}

	if err := r.DB.WithContext(ctx).Create(alertDestinations).Error; err != nil {
		return nil, err
	}

	if len(alertDestinations) > 0 {
		notificationInput := destinationsV2.NotificationInput{
			NotificationType: destinationsV2.NotificationTypeAlertCreated,
			WorkspaceID:      project.WorkspaceID,
			AlertUpsertInput: &destinationsV2.AlertUpsertInput{
				Alert: createdAlert,
				Admin: admin,
			},
		}

		alertsV2.SendNotifications(ctx, r.DB, r.MailClient, r.LambdaClient, notificationInput, alertDestinations)
	}

	return newAlert, nil
}

// UpdateAlert is the resolver for the updateAlert field.
func (r *mutationResolver) UpdateAlert(ctx context.Context, projectID int, alertID int, name *string, productType *modelInputs.ProductType, functionType *modelInputs.MetricAggregator, functionColumn *string, query *string, groupByKey *string, belowThreshold *bool, thresholdValue *float64, thresholdWindow *int, thresholdCooldown *int, destinations []*modelInputs.AlertDestinationInput) (*model.Alert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	alertUpdates := map[string]interface{}{
		"MetricId":          uuid.New().String(),
		"LastAdminToEditID": admin.ID,
		"Name":              name,
		"ProductType":       productType,
		"FunctionType":      functionType,
		"FunctionColumn":    functionColumn,
		"Query":             query,
		"GroupByKey":        groupByKey,
		"BelowThreshold":    belowThreshold,
		"ThresholdValue":    thresholdValue,
		"ThresholdWindow":   thresholdWindow,
		"ThresholdCooldown": thresholdCooldown,
	}

	alert := &model.Alert{}
	updateErr := store.AssertRecordFound(r.DB.WithContext(ctx).Where(&model.Alert{Model: model.Model{ID: alertID}, ProjectID: project.ID}).Model(&alert).Clauses(clause.Returning{}).Updates(&alertUpdates))
	if updateErr != nil {
		return nil, updateErr
	}
	alertDestinations := []*model.AlertDestination{}
	if err := r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		if err := tx.Where(&model.AlertDestination{AlertID: alert.ID}).Delete(&model.AlertDestination{}).Error; err != nil {
			return err
		}

		for _, d := range destinations {
			alertDestinations = append(alertDestinations, &model.AlertDestination{
				AlertID:         alert.ID,
				DestinationType: d.DestinationType,
				TypeID:          d.TypeID,
				TypeName:        d.TypeName,
			})
		}

		if err := r.DB.WithContext(ctx).Create(alertDestinations).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	if len(alertDestinations) > 0 {
		notificationInput := destinationsV2.NotificationInput{
			NotificationType: destinationsV2.NotificationTypeAlertUpdated,
			WorkspaceID:      project.WorkspaceID,
			AlertUpsertInput: &destinationsV2.AlertUpsertInput{
				Alert: alert,
				Admin: admin,
			},
		}

		alertsV2.SendNotifications(ctx, r.DB, r.MailClient, r.LambdaClient, notificationInput, alertDestinations)
	}

	return alert, nil
}

// UpdateAlertDisabled is the resolver for the updateAlertDisabled field.
func (r *mutationResolver) UpdateAlertDisabled(ctx context.Context, projectID int, alertID int, disabled bool) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	if err := r.DB.WithContext(ctx).Model(
		&model.Alert{Model: model.Model{ID: alertID}, ProjectID: project.ID},
	).Updates(map[string]interface{}{"Disabled": disabled}).Error; err != nil {
		return false, err
	}

	return true, err
}

// DeleteAlert is the resolver for the deleteAlert field.
func (r *mutationResolver) DeleteAlert(ctx context.Context, projectID int, alertID int) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	if err := r.DB.Where(
		&model.Alert{Model: model.Model{ID: alertID}, ProjectID: project.ID},
	).Delete(&model.Alert{}).Error; err != nil {
		return false, err
	}

	// TODO(spenny): send deletion message to destinations?

	if err := r.DB.Where(
		&model.AlertDestination{AlertID: alertID},
	).Delete(&model.AlertDestination{}).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateErrorAlert is the resolver for the updateErrorAlert field.
func (r *mutationResolver) UpdateErrorAlert(ctx context.Context, projectID int, name *string, errorAlertID int, countThreshold *int, thresholdWindow *int, slackChannels []*modelInputs.SanitizedSlackChannelInput, discordChannels []*modelInputs.DiscordChannelInput, microsoftTeamsChannels []*modelInputs.MicrosoftTeamsChannelInput, webhookDestinations []*modelInputs.WebhookDestinationInput, emails []*string, query string, regexGroups []*string, frequency *int, disabled *bool) (*model.ErrorAlert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	projectAlert := &model.ErrorAlert{}
	if err := r.DB.WithContext(ctx).Where(&model.ErrorAlert{Model: model.Model{ID: errorAlertID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error querying error alert")
	}

	if slackChannels != nil {
		channelsString, err := r.MarshalSlackChannelsToSanitizedSlackChannels(slackChannels)
		if err != nil {
			return nil, err
		}

		projectAlert.ChannelsToNotify = channelsString
	}

	if regexGroups != nil {
		regexGroupsBytes, err := json.Marshal(regexGroups)
		if err != nil {
			return nil, e.Wrap(err, "error marshalling regex groups")
		}
		regexGroupsString := string(regexGroupsBytes)
		projectAlert.RegexGroups = &regexGroupsString
	}

	if emails != nil {
		emailsString, err := r.MarshalAlertEmails(emails)
		if err != nil {
			return nil, err
		}

		projectAlert.EmailsToNotify = emailsString
	}

	if countThreshold != nil {
		projectAlert.CountThreshold = *countThreshold
	}
	if thresholdWindow != nil {
		projectAlert.ThresholdWindow = thresholdWindow
	}
	if name != nil {
		projectAlert.Name = *name
	}

	projectAlert.LastAdminToEditID = admin.ID

	if frequency != nil {
		projectAlert.Frequency = *frequency
	}
	if disabled != nil {
		projectAlert.Disabled = disabled
	}

	projectAlert.Query = query

	projectAlert.AlertIntegrations = model.AlertIntegrations{
		DiscordChannelsToNotify:        discord.GQLInputToGo(discordChannels),
		MicrosoftTeamsChannelsToNotify: microsoft_teams.GQLInputToGo(microsoftTeamsChannels),
		WebhookDestinations:            webhook.GQLInputToGo(webhookDestinations),
	}

	if err := r.DB.WithContext(ctx).Model(&model.ErrorAlert{
		Model: model.Model{
			ID: errorAlertID,
		},
	}).Select("*").Where("project_id = ?", projectID).Updates(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields")
	}

	if err := model.SendWelcomeSlackMessage(ctx, projectAlert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "updated",
		OperationDescription: "Alerts will now be sent to this channel.",
		ID:                   errorAlertID,
		Project:              project,
		IncludeEditLink:      true,
		URLSlug:              "alerts/errors",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return projectAlert, nil
}

// DeleteErrorAlert is the resolver for the deleteErrorAlert field.
func (r *mutationResolver) DeleteErrorAlert(ctx context.Context, projectID int, errorAlertID int) (*model.ErrorAlert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	projectAlert := &model.ErrorAlert{}
	if err := r.DB.WithContext(ctx).Where(&model.ErrorAlert{Model: model.Model{ID: errorAlertID}, AlertDeprecated: model.AlertDeprecated{ProjectID: projectID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "this error alert does not exist in this project.")
	}

	if err := r.DB.Delete(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete error alert")
	}

	if err := model.SendWelcomeSlackMessage(ctx, projectAlert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "deleted",
		OperationDescription: "Alerts will no longer be sent to this channel.",
		ID:                   errorAlertID,
		Project:              project,
		IncludeEditLink:      false,
		URLSlug:              "alerts/errors",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return projectAlert, nil
}

// DeleteMetricMonitor is the resolver for the deleteMetricMonitor field.
func (r *mutationResolver) DeleteMetricMonitor(ctx context.Context, projectID int, metricMonitorID int) (*model.MetricMonitor, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	metricMonitor := &model.MetricMonitor{}
	if err := r.DB.WithContext(ctx).Where(&model.MetricMonitor{Model: model.Model{ID: metricMonitorID}, ProjectID: projectID}).Find(&metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "this metric monitor does not exist in this project.")
	}

	if err := r.DB.Delete(metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete metric monitor")
	}

	if err := model.SendWelcomeSlackMessage(ctx, metricMonitor, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "deleted",
		OperationDescription: "Monitor alerts will no longer be sent to this channel.",
		ID:                   metricMonitorID,
		Project:              project,
		IncludeEditLink:      false,
		URLSlug:              "alerts/monitors",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return metricMonitor, nil
}

// UpdateSessionAlertIsDisabled is the resolver for the updateSessionAlertIsDisabled field.
func (r *mutationResolver) UpdateSessionAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.SessionAlert, error) {
	_, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	sessionAlert := &model.SessionAlert{
		AlertDeprecated: model.AlertDeprecated{
			Disabled: &disabled,
		},
	}

	if err := r.DB.WithContext(ctx).Model(&model.SessionAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(sessionAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields for new session alert")
	}

	return sessionAlert, err
}

// UpdateErrorAlertIsDisabled is the resolver for the updateErrorAlertIsDisabled field.
func (r *mutationResolver) UpdateErrorAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.ErrorAlert, error) {
	_, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	errorAlert := &model.ErrorAlert{
		AlertDeprecated: model.AlertDeprecated{
			Disabled: &disabled,
		},
	}

	if err := r.DB.WithContext(ctx).Model(&model.ErrorAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(errorAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating disabled field for error alert")
	}

	return errorAlert, err
}

// UpdateMetricMonitorIsDisabled is the resolver for the updateMetricMonitorIsDisabled field.
func (r *mutationResolver) UpdateMetricMonitorIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.MetricMonitor, error) {
	_, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	metricMonitor := &model.MetricMonitor{
		Disabled: &disabled,
	}

	if err := r.DB.WithContext(ctx).Model(&model.MetricMonitor{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(metricMonitor).Error; err != nil {
		return nil, e.Wrap(err, "error updating disabled field for metric monitor")
	}

	return metricMonitor, err
}

// UpdateSessionAlert is the resolver for the updateSessionAlert field.
func (r *mutationResolver) UpdateSessionAlert(ctx context.Context, id int, input modelInputs.SessionAlertInput) (*model.SessionAlert, error) {
	project, err := r.isUserInProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	sessionAlert, err := alerts.BuildSessionAlert(project, workspace, admin, input)

	if err != nil {
		return nil, e.Wrap(err, "failed to build session feedback alert")
	}

	if err := r.DB.WithContext(ctx).Model(&model.SessionAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", input.ProjectID).Updates(sessionAlert).Error; err != nil {
		return nil, e.Wrap(err, "error updating session alert")
	}

	if err := model.SendWelcomeSlackMessage(ctx, sessionAlert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "updated",
		OperationDescription: "Alerts will now be sent to this channel.",
		ID:                   id,
		Project:              project,
		IncludeEditLink:      true,
		URLSlug:              "alerts/session",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}
	return sessionAlert, nil
}

// DeleteSessionAlert is the resolver for the deleteSessionAlert field.
func (r *mutationResolver) DeleteSessionAlert(ctx context.Context, projectID int, sessionAlertID int) (*model.SessionAlert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	projectAlert := &model.SessionAlert{}
	if err := r.DB.WithContext(ctx).Where(&model.ErrorAlert{Model: model.Model{ID: sessionAlertID}, AlertDeprecated: model.AlertDeprecated{ProjectID: projectID}}).Find(&projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "this session alert does not exist in this project.")
	}

	if err := r.DB.Delete(projectAlert).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete session alert")
	}

	if err := model.SendWelcomeSlackMessage(ctx, projectAlert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "deleted",
		OperationDescription: "Alerts will no longer be sent to this channel.",
		ID:                   sessionAlertID,
		Project:              project,
		IncludeEditLink:      false,
		URLSlug:              "alerts/session",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return projectAlert, nil
}

// UpdateLogAlert is the resolver for the updateLogAlert field.
func (r *mutationResolver) UpdateLogAlert(ctx context.Context, id int, input modelInputs.LogAlertInput) (*model.LogAlert, error) {
	project, err := r.isUserInProject(ctx, input.ProjectID)
	admin, _ := r.getCurrentAdmin(ctx)
	workspace, _ := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	alert, err := alerts.BuildLogAlert(project, workspace, admin, input)
	if err != nil {
		return nil, e.Wrap(err, "failed to build log alert")
	}

	if err := r.DB.WithContext(ctx).Model(&model.LogAlert{Model: model.Model{ID: id}}).
		Where("project_id = ?", input.ProjectID).
		Updates(alert).Error; err != nil {
		return nil, e.Wrap(err, "error updating log alert")
	}

	if err := model.SendWelcomeSlackMessage(ctx, alert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "updated",
		OperationDescription: "Log alerts will now be sent to this channel.",
		ID:                   id,
		Project:              project,
		IncludeEditLink:      true,
		URLSlug:              "alerts/logs",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	config := microsoft_teams.WelcomeMessageData{
		Workspace:     workspace,
		Admin:         admin,
		Project:       project,
		OperationName: "updated",
	}

	if err := microsoft_teams.SendLogAlertsWelcomeMessage(ctx, alert, &config); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return alert, nil
}

// DeleteLogAlert is the resolver for the deleteLogAlert field.
func (r *mutationResolver) DeleteLogAlert(ctx context.Context, projectID int, id int) (*model.LogAlert, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	alert := &model.LogAlert{}
	if err := r.DB.WithContext(ctx).Model(&model.LogAlert{}).
		Where("project_id = ?", projectID).
		Where("id = ?", id).
		Find(&alert).Error; err != nil {
		return nil, e.Wrap(err, "this log alert does not exist in this project.")
	}

	if err := r.DB.WithContext(ctx).Where("id = ?", id).Delete(&model.LogAlert{}).Error; err != nil {
		return nil, e.Wrap(err, "error trying to delete log alert")
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	if err := model.SendWelcomeSlackMessage(ctx, alert, &model.SendWelcomeSlackMessageInput{
		Workspace:            workspace,
		Admin:                admin,
		OperationName:        "deleted",
		OperationDescription: "Log alerts will no longer be sent to this channel.",
		ID:                   id,
		Project:              project,
		IncludeEditLink:      false,
		URLSlug:              "alerts/logs",
	}); err != nil {
		log.WithContext(ctx).Error(err)
	}

	return alert, nil
}

// UpdateLogAlertIsDisabled is the resolver for the updateLogAlertIsDisabled field.
func (r *mutationResolver) UpdateLogAlertIsDisabled(ctx context.Context, id int, projectID int, disabled bool) (*model.LogAlert, error) {
	_, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	alert := &model.LogAlert{
		AlertDeprecated: model.AlertDeprecated{
			Disabled: &disabled,
		},
	}

	if err := r.DB.WithContext(ctx).Model(&model.LogAlert{
		Model: model.Model{
			ID: id,
		},
	}).Where("project_id = ?", projectID).Updates(alert).Error; err != nil {
		return nil, e.Wrap(err, "error updating org fields for new session alert")
	}

	return alert, err
}

// UpdateSessionIsPublic is the resolver for the updateSessionIsPublic field.
func (r *mutationResolver) UpdateSessionIsPublic(ctx context.Context, sessionSecureID string, isPublic bool) (*model.Session, error) {
	session, err := r.canAdminModifySession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}
	settings, err := r.Store.GetAllWorkspaceSettingsByProject(ctx, session.ProjectID)
	if err != nil {
		return nil, err
	}
	if !settings.EnableUnlistedSharing {
		return nil, AuthorizationError
	}
	if err := r.DB.WithContext(ctx).
		Model(session).
		Select("IsPublic").
		Updates(&model.Session{IsPublic: isPublic}).Error; err != nil {
		return nil, e.Wrap(err, "error updating session is_public")
	}

	return session, nil
}

// UpdateErrorGroupIsPublic is the resolver for the updateErrorGroupIsPublic field.
func (r *mutationResolver) UpdateErrorGroupIsPublic(ctx context.Context, errorGroupSecureID string, isPublic bool) (*model.ErrorGroup, error) {
	errorGroup, err := r.canAdminModifyErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not authorized to modify error group")
	}
	if err := r.DB.WithContext(ctx).Model(errorGroup).Update("IsPublic", isPublic).Error; err != nil {
		return nil, e.Wrap(err, "error updating error group is_public")
	}

	return errorGroup, nil
}

// UpdateAllowMeterOverage is the resolver for the updateAllowMeterOverage field.
func (r *mutationResolver) UpdateAllowMeterOverage(ctx context.Context, workspaceID int, allowMeterOverage bool) (*model.Workspace, error) {
	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	if err := r.DB.WithContext(ctx).Model(&workspace).Updates(map[string]interface{}{
		"AllowMeterOverage": allowMeterOverage,
	}).Error; err != nil {
		return nil, e.Wrap(err, "error updating AllowMeterOverage")
	}

	return workspace, nil
}

// SubmitRegistrationForm is the resolver for the submitRegistrationForm field.
func (r *mutationResolver) SubmitRegistrationForm(ctx context.Context, workspaceID int, teamSize string, role string, useCase string, heardAbout string, pun *string) (*bool, error) {
	workspace, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "admin is not in workspace")
	}

	registrationData := &model.RegistrationData{
		WorkspaceID: workspaceID,
		TeamSize:    &teamSize,
		Role:        &role,
		UseCase:     &useCase,
		HeardAbout:  &heardAbout,
		Pun:         pun,
	}

	if err := r.DB.WithContext(ctx).Create(registrationData).Error; err != nil {
		return nil, e.Wrap(err, "error creating registration")
	}

	if workspace.EligibleForTrialExtension {
		if err := r.DB.WithContext(ctx).Model(workspace).Updates(map[string]interface{}{
			"EligibleForTrialExtension": false,
			"TrialEndDate":              workspace.TrialEndDate.Add(7 * 24 * time.Hour), // add 7 days to the current end date
		}).Error; err != nil {
			return nil, e.Wrap(err, "error clearing EligibleForTrialExtension flag")
		}
	}

	return &model.T, nil
}

// RequestAccess is the resolver for the requestAccess field.
func (r *mutationResolver) RequestAccess(ctx context.Context, projectID int) (*bool, error) {
	// RequestAccessMinimumDelay is the minimum time required between requests from an admin (across workspaces)
	const RequestAccessMinimumDelay = time.Minute * 10

	span, ctx := util.StartSpanFromContext(ctx, "private-graph.RequestAccess", util.ResourceName("handler"), util.Tag("project_id", projectID))
	defer span.Finish()
	// sleep up to 10 ms to avoid leaking metadata about whether the project exists or not (how many queries deep we went).
	time.Sleep(time.Millisecond * time.Duration(10*rand.Float64()))

	// Any errors are logged but not returned to avoid leaking metadata
	// to the client (such as whether the project exists
	// or they have access to send an access request).
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "user is not logged in"))
		return &model.T, nil
	}

	var project model.Project
	if err := r.DB.Select("workspace_id").Where(&model.Project{Model: model.Model{ID: projectID}}).Take(&project).Error; err != nil {
		log.WithContext(ctx).Error(err)
		return &model.T, nil
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error querying workspace"))
		return &model.T, nil
	}

	request := &model.WorkspaceAccessRequest{
		AdminID:                admin.ID,
		LastRequestedWorkspace: workspace.ID,
	}

	query := r.DB.WithContext(ctx).Where(model.WorkspaceAccessRequest{AdminID: admin.ID}).Clauses(clause.Returning{}, clause.OnConflict{
		Columns: []clause.Column{{Name: "admin_id"}},
		DoUpdates: clause.Assignments(map[string]interface{}{
			"updated_at":               time.Now(),
			"last_requested_workspace": workspace.ID,
		}),
		Where: clause.Where{
			Exprs: []clause.Expression{
				clause.Lt{
					Column: "workspace_access_requests.updated_at",
					Value:  time.Now().Add(-RequestAccessMinimumDelay),
				},
			},
		},
	}).Create(&request)
	if err := query.Error; err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error upserting access requests"))
		return &model.T, nil
	}

	// no rows updated, so user recently requested access. ignore the request
	if query.RowsAffected == 0 {
		return &model.T, nil
	}

	var workspaceAdmins []*model.Admin
	if err := r.DB.Order("created_at ASC").Model(workspace).Limit(2).Association("Admins").Find(&workspaceAdmins, "role=?", model.AdminRole.ADMIN); err != nil {
		log.WithContext(ctx).Error(e.Wrap(err, "error getting admins for the workspace"))
		return &model.T, nil
	}

	for _, a := range workspaceAdmins {
		if a != nil {
			queryParams := url.Values{
				"autoinvite_email": {*admin.Email},
			}
			inviteLink := fmt.Sprintf("%s/w/%d/team?%s", env.Config.FrontendUri, workspace.ID, queryParams.Encode())
			if _, err := r.SendWorkspaceRequestEmail(*admin.Name, *admin.Email, *workspace.Name,
				*a.Name, *a.Email, inviteLink); err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "failed to send request access email"))
				return &model.T, nil
			}
		}
	}
	return &model.T, nil
}

// ModifyClearbitIntegration is the resolver for the modifyClearbitIntegration field.
func (r *mutationResolver) ModifyClearbitIntegration(ctx context.Context, workspaceID int, enabled bool) (*bool, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return &enabled, e.Wrap(err, "admin does not have access to this workspace")
	}
	if pricing.MustUpgradeForClearbit(workspace.PlanTier) {
		return nil, nil
	}
	workspace.ClearbitEnabled = enabled
	if err := r.DB.WithContext(ctx).Model(workspace).Update("ClearbitEnabled", &enabled).Error; err != nil {
		return &enabled, e.Wrap(err, "failed to update workspace clearbit state")
	}
	return &enabled, nil
}

// UpsertDashboard is the resolver for the upsertDashboard field.
func (r *mutationResolver) UpsertDashboard(ctx context.Context, id *int, projectID int, name string, metrics []*modelInputs.DashboardMetricConfigInput, layout *string, isDefault *bool) (int, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return -1, err
	}

	if _, err := r.isUserInProject(ctx, projectID); err != nil {
		return -1, err
	}

	var dashboard *model.Dashboard = &model.Dashboard{ProjectID: projectID}
	if id != nil {
		if err := r.DB.WithContext(ctx).Preload("Metrics").Where(&model.Dashboard{Model: model.Model{ID: *id}}).FirstOrCreate(&dashboard).Error; err != nil {
			return -1, err
		}
	} else {
		if err := r.DB.WithContext(ctx).Create(&dashboard).Error; err != nil {
			return -1, err
		}
	}

	for _, m := range dashboard.Metrics {
		if m != nil {
			if err := r.DB.Delete(&m).Error; err != nil {
				return -1, err
			}
		}
	}
	if err := r.DB.WithContext(ctx).Model(&dashboard).Association("Metrics").Clear(); err != nil {
		return -1, e.Wrap(err, "failed to clear previous metrics")
	}

	for _, m := range metrics {
		var filters []*model.DashboardMetricFilter
		for _, f := range m.Filters {
			filters = append(filters, &model.DashboardMetricFilter{
				Tag:   f.Tag,
				Op:    f.Op,
				Value: f.Value,
			})
		}
		dashboardMetric := model.DashboardMetric{
			Name:                     m.Name,
			Description:              m.Description,
			ComponentType:            m.ComponentType,
			ChartType:                m.ChartType,
			Aggregator:               m.Aggregator,
			MaxGoodValue:             m.MaxGoodValue,
			MaxNeedsImprovementValue: m.MaxNeedsImprovementValue,
			PoorValue:                m.PoorValue,
			Units:                    m.Units,
			HelpArticle:              m.HelpArticle,
			MinValue:                 m.MinValue,
			MinPercentile:            m.MinPercentile,
			MaxValue:                 m.MaxValue,
			MaxPercentile:            m.MaxPercentile,
			Filters:                  filters,
			Groups:                   m.Groups,
		}
		if err := r.DB.WithContext(ctx).Model(&dashboard).Association("Metrics").Append(&dashboardMetric); err != nil {
			return -1, e.Wrap(err, "error updating fields")
		}
	}

	// Update the existing record if it already exists
	dashboard.Name = name
	dashboard.LastAdminToEditID = &admin.ID
	dashboard.Layout = layout
	dashboard.IsDefault = isDefault
	if err := r.DB.Save(&dashboard).Error; err != nil {
		return dashboard.ID, err
	}

	return dashboard.ID, nil
}

// DeleteDashboard is the resolver for the deleteDashboard field.
func (r *mutationResolver) DeleteDashboard(ctx context.Context, id int) (bool, error) {
	var dashboard model.Dashboard
	if result := r.DB.Take(&dashboard, id); result.Error != nil {
		return false, result.Error
	}

	if _, err := r.isUserInProject(ctx, dashboard.ProjectID); err != nil {
		return false, err
	}

	if dashboard.IsDefault != nil && *dashboard.IsDefault {
		return false, e.New("cannot delete default dashboard")
	}

	if result := r.DB.WithContext(ctx).Where("dashboard_id = ?", id).Delete(&model.DashboardMetric{}); result.Error != nil {
		return false, result.Error
	}

	if result := r.DB.Delete(&dashboard, id); result.Error != nil {
		return false, result.Error
	}

	return true, nil
}

// DeleteSessions is the resolver for the deleteSessions field.
func (r *mutationResolver) DeleteSessions(ctx context.Context, projectID int, params modelInputs.QueryInput, sessionCount int) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return false, err
	}

	settings, err := r.Store.GetAllWorkspaceSettingsByProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	if !settings.EnableDataDeletion {
		return false, e.New("data deletion is disabled for this workspace")
	}

	email := ""
	if admin.Email != nil {
		email = *admin.Email
	}

	firstName := ""
	if admin.FirstName != nil {
		firstName = *admin.FirstName
	}

	if err := r.validateAdminRole(ctx, project.WorkspaceID); err != nil {
		return false, err
	}

	if env.IsInDocker() {
		deleteHandlers := delete_handlers.InitHandlers(r.DB, r.ClickhouseClient, nil, r.StorageClient)
		deleteHandlers.DeleteSessions(ctx, projectID, params.DateRange.StartDate, params.DateRange.EndDate, params.Query)
	} else {
		_, err = r.StepFunctions.DeleteSessionsByQuery(ctx, utils.QuerySessionsInput{
			ProjectId:    projectID,
			Email:        email,
			FirstName:    firstName,
			Params:       params,
			SessionCount: sessionCount,
			DryRun:       env.IsDevOrTestEnv(),
		})
	}

	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateCloudflareProxy is the resolver for the createCloudflareProxy field.
func (r *mutationResolver) CreateCloudflareProxy(ctx context.Context, workspaceID int, proxySubdomain string) (string, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return "", err
	}

	workspaceMapping := &model.IntegrationWorkspaceMapping{}
	if err := r.DB.WithContext(ctx).Where(&model.IntegrationWorkspaceMapping{
		WorkspaceID:     workspace.ID,
		IntegrationType: modelInputs.IntegrationTypeCloudflare,
	}).Take(&workspaceMapping).Error; err != nil {
		return "", err
	}

	c, err := cloudflare.New(ctx, workspaceMapping.AccessToken)
	if err != nil {
		return "", err
	}
	proxy, err := c.CreateWorker(ctx, proxySubdomain)
	if err != nil {
		return "", err
	}

	updates := &model.Workspace{CloudflareProxy: ptr.String(proxy)}
	if err := r.DB.WithContext(ctx).Model(&workspace).Where(&workspace).Select("cloudflare_proxy").Updates(updates).Error; err != nil {
		return "", err
	}

	return proxy, nil
}

// UpdateVercelProjectMappings is the resolver for the updateVercelProjectMappings field.
func (r *mutationResolver) UpdateVercelProjectMappings(ctx context.Context, projectID int, projectMappings []*modelInputs.VercelProjectMappingInput) (bool, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	workspaceId := project.WorkspaceID
	workspace, err := r.GetWorkspace(workspaceId)
	if err != nil {
		return false, err
	}

	if workspace.VercelAccessToken == nil {
		return false, e.New("workspace does not have an access token")
	}

	vercelProjects, err := vercel.GetProjects(*workspace.VercelAccessToken, workspace.VercelTeamID)
	if err != nil {
		return false, err
	}

	vercelProjectsById := map[string]*modelInputs.VercelProject{}
	for _, p := range vercelProjects {
		vercelProjectsById[p.ID] = p
	}

	var configs []*model.VercelIntegrationConfig
	for _, m := range projectMappings {
		var project *model.Project

		if m.NewProjectName != nil && *m.NewProjectName != "" {
			// for projects that don't exist
			n := *m.NewProjectName
			p, err := r.CreateProject(ctx, n, workspaceId)
			if err != nil {
				return false, e.Wrap(err, "cannot access Vercel project")
			}
			project = p
		} else {
			// for projects that already exist.
			p, err := r.isUserInProject(ctx, *m.ProjectID)
			if err != nil {
				return false, err
			}
			project = p
		}

		if project.Secret == nil {
			continue
		}

		vercelProject, ok := vercelProjectsById[m.VercelProjectID]
		if !ok {
			return false, e.New("cannot access Vercel project")
		}

		var sourceMapEnvId *string
		var projectEnvId *string
		for _, e := range vercelProject.Env {
			if e.Key == vercel.SourcemapEnvKey {
				sourceMapEnvId = &e.ID
			}
			if e.Key == vercel.ProjectIdEnvVar {
				projectEnvId = &e.ID
			}
		}

		if err := vercel.SetEnvVariable(m.VercelProjectID, *project.Secret, *workspace.VercelAccessToken,
			workspace.VercelTeamID, sourceMapEnvId, vercel.SourcemapEnvKey); err != nil {
			return false, err
		}

		if err := vercel.SetEnvVariable(m.VercelProjectID, project.VerboseID(), *workspace.VercelAccessToken,
			workspace.VercelTeamID, projectEnvId, vercel.ProjectIdEnvVar); err != nil {
			return false, err
		}

		configs = append(configs, &model.VercelIntegrationConfig{
			WorkspaceID:     workspaceId,
			VercelProjectID: m.VercelProjectID,
			ProjectID:       project.ID,
		})
	}

	if err := vercel.RemoveLogDrains(ctx, workspace.VercelTeamID, *workspace.VercelAccessToken); err != nil {
		return false, err
	}

	// Group configs by Highlight project id, then create a log drain for each
	byHighlightProject := lo.GroupBy(configs, func(c *model.VercelIntegrationConfig) int {
		return c.ProjectID
	})
	for highlightProjectId, configs := range byHighlightProject {
		project := model.Project{
			Model: model.Model{
				ID: highlightProjectId,
			},
		}
		if err := vercel.CreateLogDrain(ctx, workspace.VercelTeamID, lo.Map(configs, func(t *model.VercelIntegrationConfig, i int) string {
			return t.VercelProjectID
		}), project.VerboseID(), "Highlight Log Drain", *workspace.VercelAccessToken); err != nil {
			return false, err
		}
	}

	if err := r.DB.WithContext(ctx).Where("workspace_id = ?", workspaceId).Delete(&model.VercelIntegrationConfig{}).Error; err != nil {
		return false, err
	}

	if err := r.DB.WithContext(ctx).Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateClickUpProjectMappings is the resolver for the updateClickUpProjectMappings field.
func (r *mutationResolver) UpdateClickUpProjectMappings(ctx context.Context, workspaceID int, projectMappings []*modelInputs.ClickUpProjectMappingInput) (bool, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	if workspace.ClickupAccessToken == nil {
		return false, e.New("workspace does not have an access token")
	}

	configs := []*model.IntegrationProjectMapping{}
	for _, m := range projectMappings {
		configs = append(configs, &model.IntegrationProjectMapping{
			IntegrationType: modelInputs.IntegrationTypeClickUp,
			ProjectID:       m.ProjectID,
			ExternalID:      m.ClickupSpaceID,
		})
	}

	if err := r.DB.Exec(`
		DELETE FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, modelInputs.IntegrationTypeClickUp, workspaceID).Error; err != nil {
		return false, err
	}

	if len(projectMappings) == 0 {
		return true, nil
	}

	if err := r.DB.WithContext(ctx).Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateIntegrationProjectMappings is the resolver for the updateIntegrationProjectMappings field.
func (r *mutationResolver) UpdateIntegrationProjectMappings(ctx context.Context, workspaceID int, integrationType modelInputs.IntegrationType, projectMappings []*modelInputs.IntegrationProjectMappingInput) (bool, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	workspaceMapping := &model.IntegrationWorkspaceMapping{}
	if err := r.DB.WithContext(ctx).Where(&model.IntegrationWorkspaceMapping{
		WorkspaceID:     workspace.ID,
		IntegrationType: integrationType,
	}).Take(&workspaceMapping).Error; err != nil {
		return false, e.Wrap(err, fmt.Sprintf("workspace does not have a %s integration", integrationType))
	}

	configs := []*model.IntegrationProjectMapping{}
	for _, m := range projectMappings {
		configs = append(configs, &model.IntegrationProjectMapping{
			IntegrationType: integrationType,
			ProjectID:       m.ProjectID,
			ExternalID:      m.ExternalID,
		})
	}

	if err := r.DB.Exec(`
		DELETE FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, integrationType, workspaceID).Error; err != nil {
		return false, err
	}

	if len(projectMappings) == 0 {
		return true, nil
	}

	if err := r.DB.WithContext(ctx).Create(configs).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateEmailOptOut is the resolver for the updateEmailOptOut field.
func (r *mutationResolver) UpdateEmailOptOut(ctx context.Context, token *string, adminID *int, category modelInputs.EmailOptOutCategory, isOptOut bool, projectID *int) (bool, error) {
	var adminIdDeref int
	if adminID != nil && token != nil {
		if !IsOptOutTokenValid(*adminID, *token) {
			return false, e.New("token is not valid or has expired")
		}
		adminIdDeref = *adminID
	} else {
		admin, err := r.getCurrentAdmin(ctx)
		if err != nil {
			return false, err
		}
		adminIdDeref = admin.ID
	}

	if isOptOut {
		if err := r.DB.WithContext(ctx).Create(&model.EmailOptOut{
			AdminID:   adminIdDeref,
			Category:  category,
			ProjectID: projectID,
		}).Error; err != nil {
			return false, err
		}
	} else {
		if err := r.DB.WithContext(ctx).Where("admin_id = ? AND category = ?", adminIdDeref, category).
			Delete(&model.EmailOptOut{}).Error; err != nil {
			return false, err
		}
	}

	return true, nil
}

// EditServiceGithubSettings is the resolver for the editServiceGithubSettings field.
func (r *mutationResolver) EditServiceGithubSettings(ctx context.Context, id int, projectID int, githubRepoPath *string, buildPrefix *string, githubPrefix *string) (*model.Service, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	serviceUpdates := map[string]interface{}{
		"ErrorDetails": make([]string, 0),
		"BuildPrefix":  buildPrefix,
		"GithubPrefix": githubPrefix,
	}
	if githubRepoPath != nil {
		serviceUpdates["GithubRepoPath"] = *githubRepoPath
		serviceUpdates["Status"] = "healthy"
	} else {
		serviceUpdates["GithubRepoPath"] = nil
		serviceUpdates["Status"] = "created"
	}

	service := &model.Service{}
	updateErr := store.AssertRecordFound(r.DB.WithContext(ctx).Where(&model.Service{Model: model.Model{ID: id}, ProjectID: project.ID}).Model(&service).Clauses(clause.Returning{}).Updates(&serviceUpdates))
	if updateErr != nil {
		return nil, updateErr
	}

	_ = r.Store.DeleteServiceCache(ctx, service.Name, service.ProjectID)
	_, _ = r.Redis.ResetServiceErrorCount(ctx, projectID)
	return service, nil
}

// CreateErrorTag is the resolver for the createErrorTag field.
func (r *mutationResolver) CreateErrorTag(ctx context.Context, title string, description string) (*model.ErrorTag, error) {
	return r.Resolver.CreateErrorTag(ctx, title, description)
}

// UpdateErrorTags is the resolver for the updateErrorTags field.
func (r *mutationResolver) UpdateErrorTags(ctx context.Context) (bool, error) {
	if err := r.Resolver.UpdateErrorTags(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// UpsertSlackChannel is the resolver for the upsertSlackChannel field.
func (r *mutationResolver) UpsertSlackChannel(ctx context.Context, projectID int, name string) (*modelInputs.SanitizedSlackChannel, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	channel, err := r.CreateSlackChannel(project.WorkspaceID, name)
	if err == nil {
		return &modelInputs.SanitizedSlackChannel{
			WebhookChannel:   &channel.WebhookChannel,
			WebhookChannelID: &channel.WebhookChannelID,
		}, nil
	}

	if err.Error() != "name_taken" {
		return nil, err
	}

	channels, _, err := r.GetSlackChannelsFromSlack(ctx, project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	ch, ok := lo.Find(*channels, func(channel model.SlackChannel) bool {
		return strings.EqualFold(channel.WebhookChannel, "#"+name)
	})
	if !ok {
		return nil, e.New("failed to find conflicting slack channel")
	}

	return &modelInputs.SanitizedSlackChannel{
		WebhookChannel:   &ch.WebhookChannel,
		WebhookChannelID: &ch.WebhookChannelID,
	}, nil
}

// UpsertDiscordChannel is the resolver for the upsertDiscordChannel field.
func (r *mutationResolver) UpsertDiscordChannel(ctx context.Context, projectID int, name string) (*model.DiscordChannel, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.Resolver.UpsertDiscordChannel(project.WorkspaceID, name)
}

// TestErrorEnhancement is the resolver for the testErrorEnhancement field.
func (r *mutationResolver) TestErrorEnhancement(ctx context.Context, errorObjectID int, githubRepoPath string, githubPrefix *string, buildPrefix *string, saveError *bool) (*model.ErrorObject, error) {
	errorObject := model.ErrorObject{}
	if err := r.DB.WithContext(ctx).Where(&model.ErrorObject{ID: errorObjectID}).
		Preload("ErrorGroup").
		Take(&errorObject).Error; err != nil {
		return nil, err
	}

	var project model.Project
	if err := r.DB.WithContext(ctx).Where(&model.Project{Model: model.Model{ID: errorObject.ProjectID}}).Take(&project).Error; err != nil {
		return nil, err
	}

	workspace, err := r.Store.GetWorkspace(ctx, project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	testService := &model.Service{
		Name:           errorObject.ServiceName,
		Status:         modelInputs.ServiceStatusHealthy,
		ProjectID:      project.ID,
		GithubRepoPath: &githubRepoPath,
		BuildPrefix:    buildPrefix,
		GithubPrefix:   githubPrefix,
	}

	mappedStackTrace, _, err := r.Store.EnhancedStackTrace(ctx, *errorObject.StackTrace, workspace, &project, &errorObject, testService)
	if err != nil {
		return nil, err
	}
	if mappedStackTrace != nil {
		errorObject.MappedStackTrace = mappedStackTrace
	}

	if saveError != nil && *saveError {
		if err := r.DB.Save(&errorObject).Error; err != nil {
			return nil, err
		}
	}

	return &errorObject, nil
}

// UpsertVisualization is the resolver for the upsertVisualization field.
func (r *mutationResolver) UpsertVisualization(ctx context.Context, visualization modelInputs.VisualizationInput) (int, error) {
	id := 0
	var viz model.Visualization
	if visualization.ID != nil {
		id = *visualization.ID

		if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", *visualization.ID).Find(&viz).Error; err != nil {
			return 0, err
		}

		if viz.ProjectID != visualization.ProjectID {
			return 0, errors.New("project id does not match saved project id")
		}
	}

	if _, err := r.isUserInProject(ctx, visualization.ProjectID); err != nil {
		return 0, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return 0, err
	}

	toSave := model.Visualization{
		Model:            model.Model{ID: id},
		ProjectID:        visualization.ProjectID,
		UpdatedByAdminId: &admin.ID,
		Name:             viz.Name,
		TimePreset:       viz.TimePreset,
		GraphIds:         viz.GraphIds,
		Variables:        viz.Variables,
	}

	if visualization.Variables != nil {
		bytes, err := json.Marshal(visualization.Variables)
		if err != nil {
			return 0, e.Wrapf(err, "error marshaling variables")
		}
		toSave.Variables = string(bytes)
	}

	if visualization.Name != nil {
		toSave.Name = *visualization.Name
	}

	if visualization.TimePreset != nil {
		toSave.TimePreset = visualization.TimePreset
	}

	if visualization.GraphIds != nil {
		toSave.GraphIds = lo.Map(visualization.GraphIds, func(i int, _ int) int32 {
			return int32(i)
		})
	}

	if err := r.DB.WithContext(ctx).Save(&toSave).Error; err != nil {
		return 0, err
	}

	return toSave.ID, nil
}

// DeleteVisualization is the resolver for the deleteVisualization field.
func (r *mutationResolver) DeleteVisualization(ctx context.Context, id int) (bool, error) {
	var viz model.Visualization
	if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", id).Find(&viz).Error; err != nil {
		return false, err
	}

	if _, err := r.isUserInProject(ctx, viz.ProjectID); err != nil {
		return false, err
	}

	if err := r.DB.WithContext(ctx).Model(&model.Visualization{}).Delete("id = ?", id).Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpsertGraph is the resolver for the upsertGraph field.
func (r *mutationResolver) UpsertGraph(ctx context.Context, graph modelInputs.GraphInput) (*model.Graph, error) {
	var viz model.Visualization
	if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", graph.VisualizationID).Take(&viz).Error; err != nil {
		return nil, err
	}

	_, err := r.isUserInProject(ctx, viz.ProjectID)
	if err != nil {
		return nil, err
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	id := 0
	if graph.ID != nil {
		id = *graph.ID
	}

	funnelStepsStr, err := json.Marshal(graph.FunnelSteps)
	if err != nil {
		return nil, err
	}

	toSave := model.Graph{
		Model: model.Model{
			ID: id,
		},
		VisualizationID:   graph.VisualizationID,
		Type:              graph.Type,
		Title:             graph.Title,
		ProductType:       graph.ProductType,
		Query:             graph.Query,
		Metric:            graph.Metric,
		FunctionType:      graph.FunctionType,
		GroupByKeys:       graph.GroupByKeys,
		BucketByKey:       graph.BucketByKey,
		BucketCount:       graph.BucketCount,
		BucketInterval:    graph.BucketInterval,
		Limit:             graph.Limit,
		LimitFunctionType: graph.LimitFunctionType,
		LimitMetric:       graph.LimitMetric,
		FunnelSteps:       ptr.String(string(funnelStepsStr)),
		Display:           graph.Display,
		NullHandling:      graph.NullHandling,
	}

	if err := r.DB.Transaction(func(tx *gorm.DB) error {
		if id == 0 {
			if err := tx.WithContext(ctx).Create(&toSave).Error; err != nil {
				return err
			}
		} else {
			if err := tx.WithContext(ctx).Select("*").Updates(&toSave).Error; err != nil {
				return err
			}
		}

		updates := map[string]interface{}{"UpdatedByAdminId": admin.ID}
		if graph.AfterGraphID != nil {
			var viz model.Visualization
			if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", graph.VisualizationID).Preload("Graphs").Find(&viz).Error; err != nil {
				return err
			}
			reorderGraphs(&viz)
			newGraphIds := pq.Int32Array{}
			for _, g := range viz.Graphs {
				if g.ID == toSave.ID {
					continue
				}
				newGraphIds = append(newGraphIds, int32(g.ID))
				if g.ID == *graph.AfterGraphID {
					newGraphIds = append(newGraphIds, int32(toSave.ID))
				}
			}
			updates["GraphIds"] = newGraphIds
		}

		if err := tx.WithContext(ctx).Model(&model.Visualization{}).Where("id = ?", graph.VisualizationID).
			Updates(updates).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &toSave, nil
}

// DeleteGraph is the resolver for the deleteGraph field.
func (r *mutationResolver) DeleteGraph(ctx context.Context, id int) (bool, error) {
	var viz model.Visualization
	if err := r.DB.WithContext(ctx).Model(&viz).Where("id = (select visualization_id from graphs where id = ?)", id).Find(&viz).Error; err != nil {
		return false, err
	}

	if _, err := r.isUserInProject(ctx, viz.ProjectID); err != nil {
		return false, err
	}

	if err := r.DB.WithContext(ctx).Model(&model.Graph{}).Delete("id = ?", id).Error; err != nil {
		return false, err
	}

	return true, nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*modelInputs.Account, error) {
	if !r.isWhitelistedAccount(ctx) {
		return nil, e.New("You don't have access to this data")
	}

	accounts := []*modelInputs.Account{}
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT w.id, w.name, w.plan_tier, w.unlimited_members, w.stripe_customer_id,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then count else 0 end), 0) as session_count_cur,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month' and sc.date < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then count else 0 end), 0) as session_count_prev,
		COALESCE(SUM(case when sc.date >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '2 months' and sc.date < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month' then count else 0 end), 0) as session_count_prev_prev,
		(select count(*) from workspace_admins wa where wa.workspace_id = w.id) as member_count
		FROM workspaces w
		INNER JOIN projects p
		ON p.workspace_id = w.id
		LEFT OUTER JOIN daily_session_counts_view sc
		ON sc.project_id = p.id
		group by 1, 2
	`).Scan(&accounts).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving accounts for project")
	}

	viewCounts := []*modelInputs.Account{}
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT w.id,
		SUM(case when s.created_at >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then 1 else 0 end) as view_count_cur,
		SUM(case when s.created_at >= COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) - interval '1 month'
			and s.created_at < COALESCE(w.billing_period_start, date_trunc('month', now(), 'UTC')) then 1 else 0 end) as view_count_prev
		FROM workspaces w
		INNER JOIN projects p
		ON p.workspace_id = w.id
		INNER JOIN sessions s
		ON s.project_id = p.id
		INNER JOIN session_admins_views sav
		ON sav.session_id = s.id
		group by 1`).Scan(&viewCounts).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving view counts for project")
	}
	viewsByWorkspace := lo.GroupBy(viewCounts, func(viewCount *modelInputs.Account) int {
		return viewCount.ID
	})
	for _, a := range accounts {
		views, ok := viewsByWorkspace[a.ID]
		if !ok || len(views) != 1 {
			continue
		}
		a.ViewCountCur = views[0].ViewCountCur
		a.ViewCountPrev = views[0].ViewCountPrev
	}

	subListParams := stripe.SubscriptionListParams{
		Status: stripe.String(string(stripe.SubscriptionStatusActive)),
	}
	subListParams.AddExpand("data.customer")
	subListParams.Filters.AddFilter("limit", "", "100")
	var startingAfter *string
	var allSubs []*stripe.Subscription
	for {
		subListParams.StartingAfter = startingAfter
		subList := r.PricingClient.Subscriptions.List(&subListParams).SubscriptionList()
		allSubs = append(allSubs, subList.Data...)

		if !subList.HasMore {
			break
		}

		startingAfter = &subList.Data[len(subList.Data)-1].ID
	}
	subsByCustomer := lo.GroupBy(allSubs, func(sub *stripe.Subscription) string {
		return sub.Customer.ID
	})

	invoiceListParams := stripe.InvoiceListParams{
		Status: stripe.String(string(stripe.InvoiceStatusPaid)),
		CreatedRange: &stripe.RangeQueryParams{
			GreaterThan: time.Now().Add(-3 * 30 * 24 * time.Hour).Unix(),
		},
	}
	invoiceListParams.Filters.AddFilter("limit", "", "100")
	var allInvoices []*stripe.Invoice
	startingAfter = nil
	for {
		invoiceListParams.StartingAfter = startingAfter
		invoiceList := r.PricingClient.Invoices.List(&invoiceListParams).InvoiceList()
		allInvoices = append(allInvoices, invoiceList.Data...)

		if !invoiceList.HasMore {
			break
		}

		startingAfter = &invoiceList.Data[len(invoiceList.Data)-1].ID
	}
	invoicesByCustomer := lo.GroupBy(allInvoices, func(invoice *stripe.Invoice) string {
		return invoice.Customer.ID
	})

	for _, account := range accounts {
		subs, ok := subsByCustomer[account.StripeCustomerID]
		if ok {
			sort.Slice(subs, func(i, j int) bool {
				return subs[i].StartDate < subs[j].StartDate
			})
			start := time.Unix(subs[0].StartDate, 0)
			account.SubscriptionStart = &start
			account.Email = subs[0].Customer.Email
		}

		invoices, ok := invoicesByCustomer[account.StripeCustomerID]
		if ok {
			sort.Slice(invoices, func(i, j int) bool {
				return invoices[i].DueDate > invoices[j].DueDate
			})
			account.PaidPrev = int(invoices[0].AmountPaid)
			if len(invoices) > 1 {
				account.PaidPrevPrev = int(invoices[1].AmountPaid)
			}
		}

		planTier := modelInputs.PlanType(account.PlanTier)
		if account.SessionLimit == 0 {
			account.SessionLimit = int(pricing.IncludedAmount(planTier, model.PricingProductTypeSessions))
		}

		if account.MemberLimit != nil && *account.MemberLimit == 0 {
			limit := pricing.TypeToMemberLimit(planTier, account.UnlimitedMembers)
			if limit == nil {
				account.MemberLimit = nil
			} else {
				account.MemberLimit = pointy.Int(int(*limit))
			}
		}
	}

	return accounts, nil
}

// AccountDetails is the resolver for the account_details field.
func (r *queryResolver) AccountDetails(ctx context.Context, workspaceID int) (*modelInputs.AccountDetails, error) {
	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, e.Wrap(err, "error getting workspace info")
	}

	var queriedMonths = []struct {
		Sum   int
		Month string
	}{}
	if err := r.DB.WithContext(ctx).Raw(`
	select SUM(count), to_char(date, 'yyyy-MM') as month
	from daily_session_counts_view
	where project_id in (select id from projects where projects.workspace_id = ?)
	group by month
	order by month
	`, workspaceID).Scan(&queriedMonths).Error; err != nil {
		return nil, e.Errorf("error retrieving months: %v", err)
	}

	var queriedDays = []struct {
		Sum int
		Day string
	}{}
	if err := r.DB.WithContext(ctx).Raw(`
	select SUM(count), to_char(date, 'MON-DD-YYYY') as day
	from daily_session_counts_view
	where project_id in (select id from projects where projects.workspace_id = ?)
	group by date
	order by date
	`, workspaceID).Scan(&queriedDays).Error; err != nil {
		return nil, e.Errorf("error retrieving days: %v", err)
	}

	sessionCountsPerMonth := []*modelInputs.NamedCount{}
	sessionCountsPerDay := []*modelInputs.NamedCount{}
	for _, s := range queriedMonths {
		sessionCountsPerMonth = append(sessionCountsPerMonth, &modelInputs.NamedCount{Name: s.Month, Count: s.Sum})
	}
	for _, s := range queriedDays {
		sessionCountsPerDay = append(sessionCountsPerDay, &modelInputs.NamedCount{Name: s.Day, Count: s.Sum})
	}

	var stripeCustomerId string
	if workspace.StripeCustomerID != nil {
		stripeCustomerId = *workspace.StripeCustomerID
	}

	var members []*modelInputs.AccountDetailsMember
	if err := r.DB.WithContext(ctx).Raw(`
	select a.id as id, max(a.name) as name, max(a.email) as email, max(s.created_at) as last_active
	from workspace_admins wa
	inner join admins a on wa.admin_id = a.id
	inner join sessions s on s.identifier = a.email
	where wa.workspace_id = ? and s.project_id = 1
	group by a.id
	`, workspaceID).Scan(&members).Error; err != nil {
		return nil, e.Errorf("error querying members: %v", err)
	}

	details := &modelInputs.AccountDetails{
		SessionCountPerMonth: sessionCountsPerMonth,
		SessionCountPerDay:   sessionCountsPerDay,
		Name:                 *workspace.Name,
		ID:                   workspace.ID,
		StripeCustomerID:     stripeCustomerId,
		Members:              members,
	}
	return details, nil
}

// Session is the resolver for the session field.
func (r *queryResolver) Session(ctx context.Context, secureID string) (*model.Session, error) {
	if env.IsDevEnv() && secureID == "repro" {
		sessionObj := &model.Session{}
		if err := r.DB.WithContext(ctx).Preload("Fields").Where(&model.Session{Model: model.Model{ID: 0}}).Take(&sessionObj).Error; err != nil {
			return nil, e.Wrap(err, "error reading from session")
		}
		return sessionObj, nil
	}

	s, err := r.canAdminViewSession(ctx, secureID)
	if s == nil || err != nil {
		return nil, err
	}

	retentionDate, err := r.GetProjectRetentionDate(s.ProjectID)
	if err != nil {
		return nil, err
	}
	sessionObj := &model.Session{}
	if err := r.DB.WithContext(ctx).Preload("Fields").Where(&model.Session{Model: model.Model{ID: s.ID}}).
		First(&sessionObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from session")
	}

	var excludedReason modelInputs.SessionExcludedReason
	if sessionObj.WithinBillingQuota != nil && !*sessionObj.WithinBillingQuota {
		excludedReason = modelInputs.SessionExcludedReasonBillingQuotaExceeded
		sessionObj.Excluded = true
		sessionObj.ExcludedReason = &excludedReason
	} else if sessionObj.CreatedAt.Before(retentionDate) {
		excludedReason = modelInputs.SessionExcludedReasonRetentionPeriodExceeded
		sessionObj.Excluded = true
		sessionObj.ExcludedReason = &excludedReason
	}

	return sessionObj, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	if env.IsDevEnv() && sessionSecureID == "repro" {
		file, err := os.ReadFile("./tmp/events.json")
		if err != nil {
			return nil, e.Wrap(err, "Failed to read temp file")
		}
		var data []interface{}

		if err := json.Unmarshal([]byte(file), &data); err != nil {
			return nil, e.Wrap(err, "Failed to unmarshal data from file")
		}
		return data, nil
	}
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}
	events, err, _ := r.getEvents(ctx, session, model.EventsCursor{EventIndex: 0, EventObjectIndex: nil})
	return events, err
}

// SessionIntervals is the resolver for the session_intervals field.
func (r *queryResolver) SessionIntervals(ctx context.Context, sessionSecureID string) ([]*model.SessionInterval, error) {
	if !(env.IsDevEnv() && sessionSecureID == "repro") {
		_, err := r.canAdminViewSession(ctx, sessionSecureID)
		if err != nil {
			return nil, err
		}
	}

	var sessionIntervals []*model.SessionInterval
	if res := r.DB.Order("start_time ASC").Where(&model.SessionInterval{SessionSecureID: sessionSecureID}).Find(&sessionIntervals); res.Error != nil {
		return nil, e.Wrap(res.Error, "failed to get session intervals")
	}

	return sessionIntervals, nil
}

// TimelineIndicatorEvents is the resolver for the timeline_indicator_events field.
func (r *queryResolver) TimelineIndicatorEvents(ctx context.Context, sessionSecureID string) ([]*model.TimelineIndicatorEvent, error) {
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if !(env.IsDevEnv() && sessionSecureID == "repro") {
		if err != nil {
			return nil, err
		}
	}

	var timelineIndicatorEvents []*model.TimelineIndicatorEvent
	timelineIndicatorEvents, err = r.StorageClient.ReadTimelineIndicatorEvents(ctx, session.ID, session.ProjectID)
	if err != nil {
		return nil, e.Wrap(err, "failed to get timeline indicator events from S3")
	}

	return timelineIndicatorEvents, nil
}

// WebsocketEvents is the resolver for the websocket_events field.
func (r *queryResolver) WebsocketEvents(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	session, err := r.canAdminViewSession(ctx, sessionSecureID)
	if !(env.IsDevEnv() && sessionSecureID == "repro") {
		if err != nil {
			return nil, err
		}
	}

	webSocketEvents, err := r.StorageClient.ReadWebSocketEvents(ctx, session.ID, session.ProjectID)
	if err != nil {
		return nil, e.Wrap(err, "failed to get websocket events from S3")
	}

	return webSocketEvents, nil
}

// RageClicks is the resolver for the rage_clicks field.
func (r *queryResolver) RageClicks(ctx context.Context, sessionSecureID string) ([]*model.RageClickEvent, error) {
	if !(env.IsDevEnv() && sessionSecureID == "repro") {
		_, err := r.canAdminViewSession(ctx, sessionSecureID)
		if err != nil {
			return nil, err
		}
	}

	var rageClicks []*model.RageClickEvent
	if res := r.DB.WithContext(ctx).Where(&model.RageClickEvent{SessionSecureID: sessionSecureID}).Find(&rageClicks); res.Error != nil {
		return nil, e.Wrap(res.Error, "failed to get rage clicks")
	}

	return rageClicks, nil
}

// RageClicksForProject is the resolver for the rageClicksForProject field.
func (r *queryResolver) RageClicksForProject(ctx context.Context, projectID int, lookbackDays float64) ([]*modelInputs.RageClickEventForProject, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	rageClicks := []*modelInputs.RageClickEventForProject{}

	rageClicksSpan, ctx := util.StartSpanFromContext(ctx, "db.RageClicksForProject",
		util.ResourceName("resolver.internal"), util.Tag("project_id", projectID))
	defer rageClicksSpan.Finish()
	if err := r.DB.WithContext(ctx).Raw(`
	SELECT
		COALESCE(NULLIF(identifier, ''), CONCAT('#', fingerprint)) as identifier,
		rageClicks. *,
		user_properties
	FROM
		(
			SELECT
				DISTINCT session_secure_id,
				sum(total_clicks) as total_clicks
			FROM
				rage_click_events
			WHERE
				project_id = ?
				AND created_at >= NOW() - (? * INTERVAL '1 DAY')
			GROUP BY
				session_secure_id
		) AS rageClicks
		LEFT JOIN sessions s ON rageClicks.session_secure_id = s.secure_id
		WHERE s.excluded <> true
			AND session_secure_id IS NOT NULL
		ORDER BY total_clicks DESC
		LIMIT 100`,
		projectID, lookbackDays).Scan(&rageClicks).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving rage clicks for project")
	}

	return rageClicks, nil
}

// ErrorGroupsClickhouse is the resolver for the error_groups_clickhouse field.
func (r *queryResolver) ErrorGroupsClickhouse(ctx context.Context, projectID int, count int, query modelInputs.ClickhouseQuery, page *int) (*model.ErrorResults, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	ids, total, err := r.ClickhouseClient.QueryErrorGroupIdsDeprecated(ctx, projectID, count, query, page)
	if err != nil {
		return nil, err
	}

	var results []*model.ErrorGroup
	if err := r.DB.WithContext(ctx).Model(&model.ErrorGroup{}).
		Joins("ErrorTag").
		Where("error_groups.id in ?", ids).
		Where("error_groups.project_id = ?", projectID).
		Order("error_groups.updated_at DESC").
		Find(&results).Error; err != nil {
		return nil, err
	}

	if len(results) > 0 {
		if err := r.SetErrorFrequenciesClickhouse(ctx, projectID, results, ErrorGroupLookbackDays); err != nil {
			return nil, err
		}
	}

	return &model.ErrorResults{
		ErrorGroups: lo.Map(results, func(eg *model.ErrorGroup, idx int) model.ErrorGroup { return *eg }),
		TotalCount:  total,
	}, nil
}

// ErrorGroups is the resolver for the error_groups field.
func (r *queryResolver) ErrorGroups(ctx context.Context, projectID int, count int, params modelInputs.QueryInput, page *int) (*model.ErrorResults, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	ids, total, err := r.ClickhouseClient.QueryErrorGroups(ctx, project.ID, count, params, page)
	if err != nil {
		return nil, err
	}

	var results []*model.ErrorGroup
	if err := r.DB.WithContext(ctx).Model(&model.ErrorGroup{}).
		Joins("ErrorTag").
		Where("error_groups.id in ?", ids).
		Where("error_groups.project_id = ?", project.ID).
		Find(&results).Error; err != nil {
		return nil, err
	}

	if len(results) > 0 {
		if err := r.loadErrorGroupFrequenciesClickhouse(ctx, project.ID, results); err != nil {
			return nil, err
		}
	}

	// Sort results by LastOccurrence, descending
	sort.Slice(results, func(i, j int) bool {
		var timeA, timeB time.Time
		if results[i].LastOccurrence != nil {
			timeA = *results[i].LastOccurrence
		}
		if results[j].LastOccurrence != nil {
			timeB = *results[j].LastOccurrence
		}
		return timeA.After(timeB)
	})

	return &model.ErrorResults{
		ErrorGroups: lo.Map(results, func(eg *model.ErrorGroup, idx int) model.ErrorGroup { return *eg }),
		TotalCount:  total,
	}, nil
}

// ErrorsHistogramClickhouse is the resolver for the errors_histogram_clickhouse field.
func (r *queryResolver) ErrorsHistogramClickhouse(ctx context.Context, projectID int, query modelInputs.ClickhouseQuery, histogramOptions modelInputs.DateHistogramOptions) (*model.ErrorsHistogram, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	bucketTimes, totals, err := r.ClickhouseClient.QueryErrorHistogramDeprecated(ctx, projectID, query, histogramOptions)
	if err != nil {
		return nil, err
	}

	if len(bucketTimes) > 0 {
		bucketTimes[0] = *histogramOptions.Bounds.StartDate // OpenSearch rounds the first bucket to a calendar interval by default
		bucketTimes = append(bucketTimes, *histogramOptions.Bounds.EndDate)
	}

	return &model.ErrorsHistogram{
		BucketTimes:  MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		ErrorObjects: MergeHistogramBucketCounts(totals, histogramOptions.BucketSize.Multiple),
	}, nil
}

// ErrorsHistogram is the resolver for the errors_histogram field.
func (r *queryResolver) ErrorsHistogram(ctx context.Context, projectID int, params modelInputs.QueryInput, histogramOptions modelInputs.DateHistogramOptions) (*model.ErrorsHistogram, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	bucketTimes, totals, err := r.ClickhouseClient.QueryErrorObjectsHistogram(ctx, project.ID, params, histogramOptions)
	if err != nil {
		return nil, err
	}

	if len(bucketTimes) > 0 {
		bucketTimes[0] = *histogramOptions.Bounds.StartDate // OpenSearch rounds the first bucket to a calendar interval by default
		bucketTimes = append(bucketTimes, *histogramOptions.Bounds.EndDate)
	}

	return &model.ErrorsHistogram{
		BucketTimes:  MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		ErrorObjects: MergeHistogramBucketCounts(totals, histogramOptions.BucketSize.Multiple),
	}, nil
}

// ErrorGroup is the resolver for the error_group field.
func (r *queryResolver) ErrorGroup(ctx context.Context, secureID string, useClickhouse *bool) (*model.ErrorGroup, error) {
	eg, err := r.canAdminViewErrorGroup(ctx, secureID)
	if err != nil {
		return nil, err
	}
	retentionDate, err := r.GetProjectRetentionDate(eg.ProjectID)
	if err != nil {
		return nil, err
	}
	if eg.UpdatedAt.Before(retentionDate) {
		return nil, e.New("no new error instances after the workspace's retention date")
	}
	if err := r.loadErrorGroupFrequenciesClickhouse(ctx, eg.ProjectID, []*model.ErrorGroup{eg}); err != nil {
		return nil, err
	}
	return eg, err
}

// ErrorObject is the resolver for the error_object field.
func (r *queryResolver) ErrorObject(ctx context.Context, id int) (*model.ErrorObject, error) {
	errorObject, err := r.canAdminViewErrorObject(ctx, id)
	if err != nil {
		return nil, err
	}
	return errorObject, nil
}

// ErrorObjects is the resolver for the error_objects field.
func (r *queryResolver) ErrorObjects(ctx context.Context, projectID *string, errorGroupSecureID *string, count int, params modelInputs.QueryInput, page *int) (*modelInputs.ErrorObjectResults, error) {
	if projectID == nil && errorGroupSecureID == nil {
		return nil, e.New("error_objects requires either projectID or errorGroupSecureID")
	}

	var projectIdDeref int
	if projectID != nil {
		var err error
		projectIdDeref, err = strconv.Atoi(*projectID)
		if err != nil {
			return nil, err
		}

		_, err = r.isUserInProjectOrDemoProject(ctx, projectIdDeref)
		if err != nil {
			return nil, err
		}
	}

	var errorGroupId *int
	if errorGroupSecureID != nil {
		errorGroup, err := r.canAdminViewErrorGroup(ctx, *errorGroupSecureID)
		if err != nil {
			return nil, err
		}

		projectIdDeref = errorGroup.ProjectID
		errorGroupId = &errorGroup.ID
	}

	ids, total, err := r.ClickhouseClient.QueryErrorObjects(ctx, projectIdDeref, errorGroupId, count, params, page)

	results, err := r.Store.ListErrorObjects(ctx, ids, total)
	return &results, err
}

// ErrorObjectForLog is the resolver for the error_object_for_log field.
func (r *queryResolver) ErrorObjectForLog(ctx context.Context, logCursor string) (*model.ErrorObject, error) {
	errorObject := &model.ErrorObject{}
	if err := r.DB.WithContext(ctx).Model(&errorObject).Where(&model.ErrorObject{LogCursor: pointy.String(logCursor)}).Take(&errorObject).Error; err != nil {
		return nil, e.New("no error found for log cursor " + logCursor)
	}
	errorObject, err := r.canAdminViewErrorObject(ctx, errorObject.ID)
	if err != nil {
		return nil, err
	}
	return errorObject, nil
}

// ErrorInstance is the resolver for the error_instance field.
func (r *queryResolver) ErrorInstance(ctx context.Context, errorGroupSecureID string, errorObjectID *int, params *modelInputs.QueryInput) (*model.ErrorInstance, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	retentionDate, err := r.GetProjectRetentionDate(errorGroup.ProjectID)
	if err != nil {
		return nil, err
	}

	errorObject := model.ErrorObject{}
	errorObjectQuery := r.DB.WithContext(ctx).Where(&model.ErrorObject{ErrorGroupID: errorGroup.ID})

	if errorObjectID != nil {
		if err := errorObjectQuery.Where(&model.ErrorObject{Model: model.Model{ID: *errorObjectID}}).Take(&errorObject).Error; err != nil {
			return nil, e.Wrap(err, "error reading error object for instance")
		}
	} else if params != nil {
		ids, _, err := r.ClickhouseClient.QueryErrorObjects(ctx, errorGroup.ProjectID, &errorGroup.ID, 1, *params, nil)
		if err != nil {
			return nil, err
		}
		if len(ids) != 0 {
			if err := r.DB.WithContext(ctx).Model(&errorObject).Where("id = ?", ids[0]).Take(&errorObject).Error; err != nil {
				return nil, err
			}
		}
	}

	if errorObject.ID == 0 {
		if err := errorObjectQuery.Last(&errorObject).Error; err != nil {
			return nil, e.Wrap(err, "error reading error object for instance")
		}
	}

	var nextID int
	if err := r.DB.
		Model(&model.ErrorObject{}).
		Select("id").
		Where("error_group_id = ?", errorGroup.ID).
		Where("created_at > ?", retentionDate).
		Where("id > ?", errorObject.ID).
		Order("id asc").
		Limit(1).
		Pluck("id", &nextID).Error; err != nil {
		return nil, e.Wrap(err, "error reading next error object in group")
	}

	var previousID int
	if err := r.DB.
		Model(&model.ErrorObject{}).
		Select("id").
		Where("error_group_id = ?", errorGroup.ID).
		Where("id < ?", errorObject.ID).
		Where("created_at > ?", retentionDate).
		Order("id desc").
		Limit(1).
		Pluck("id", &previousID).Error; err != nil {
		return nil, e.Wrap(err, "error reading previous error object in group")
	}

	errorInstance := model.ErrorInstance{ErrorObject: errorObject}
	if nextID != 0 {
		errorInstance.NextID = &nextID
	}
	if previousID != 0 {
		errorInstance.PreviousID = &previousID
	}

	return &errorInstance, nil
}

// EnhancedUserDetails is the resolver for the enhanced_user_details field.
func (r *queryResolver) EnhancedUserDetails(ctx context.Context, sessionSecureID string) (*modelInputs.EnhancedUserDetailsResult, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}
	p, err := r.isUserInProjectOrDemoProject(ctx, s.ProjectID)
	if err != nil {
		return nil, err
	}
	w, err := r.isUserInWorkspaceReadOnly(ctx, p.WorkspaceID)
	if err != nil {
		return nil, err
	}
	if pricing.MustUpgradeForClearbit(w.PlanTier) {
		return nil, nil
	}
	// preload `Fields` children
	sessionObj := &model.Session{}
	// TODO: filter fields by type='user'.
	if err := r.DB.WithContext(ctx).Preload("Fields").Where(&model.Session{Model: model.Model{ID: s.ID}}).Take(&sessionObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from session")
	}
	details := &modelInputs.EnhancedUserDetailsResult{}
	details.Socials = []*modelInputs.SocialLink{}
	// We don't know what key is used for the user's email so we do a regex match
	// on all 'user' type fields.
	var email string
	for _, f := range sessionObj.Fields {
		if f.Type == "user" && regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`).MatchString(f.Value) {
			email = f.Value
		}
		if f.Type == "user" && f.Name == "email" {
			email = f.Value
		}
	}
	if len(email) > 0 {
		// Check if we already have this user's data in the db
		// If so, return it
		userDetailsModel := &model.EnhancedUserDetails{}
		p, co := clearbit.Person{}, clearbit.Company{}
		if err := r.DB.WithContext(ctx).Where(&model.EnhancedUserDetails{Email: &email}).Take(&userDetailsModel).Error; err != nil {
			if !w.ClearbitEnabled {
				return nil, nil
			}
			log.WithContext(ctx).Infof("retrieving api response for clearbit lookup")
			hmetric.Incr(ctx, "private-graph.enhancedDetails.miss", nil, 1)
			clearbitApiRequestSpan, _ := util.StartSpanFromContext(ctx, "private-graph.EnhancedUserDetails",
				util.ResourceName("clearbit.api.request"),
				util.Tag("session_id", s.ID), util.Tag("workspace_id", w.ID), util.Tag("project_id", p.ID), util.Tag("plan_tier", w.PlanTier))
			pc, _, err := r.ClearbitClient.Person.FindCombined(clearbit.PersonFindParams{Email: email})
			clearbitApiRequestSpan.Finish()
			p, co = pc.Person, pc.Company
			if err != nil {
				log.WithContext(ctx).Errorf("error w/ clearbit request: %v", err)
			} else if len(p.ID) > 0 {
				// Store the data for this email in the DB.
				r.PrivateWorkerPool.SubmitRecover(func() {
					ctx := context.Background()
					log.WithContext(ctx).Infof("caching response data in the db")
					modelToSave := &model.EnhancedUserDetails{}
					modelToSave.Email = &email
					if personBytes, err := json.Marshal(p); err == nil {
						sPersonBytes := string(personBytes)
						modelToSave.PersonJSON = &sPersonBytes
					} else {
						log.WithContext(ctx).Errorf("error marshaling clearbit person: %v", err)
					}
					if companyBytes, err := json.Marshal(co); err == nil {
						sCompanyBytes := string(companyBytes)
						modelToSave.CompanyJSON = &sCompanyBytes
					} else {
						log.WithContext(ctx).Errorf("error marshaling clearbit company: %v", err)
					}
					if err := r.DB.WithContext(ctx).Create(modelToSave).Error; err != nil {
						log.WithContext(ctx).Errorf("error creating clearbit details model")
					}
				})
			}
		} else {
			log.WithContext(ctx).Infof("retrieving cache db entry of clearbit lookup")
			hmetric.Incr(ctx, "private-graph.enhancedDetails.hit", nil, 1)
			if userDetailsModel.PersonJSON != nil && userDetailsModel.CompanyJSON != nil {
				if err := json.Unmarshal([]byte(*userDetailsModel.PersonJSON), &p); err != nil {
					log.WithContext(ctx).Errorf("error unmarshaling person: %v", err)
				}
				if err := json.Unmarshal([]byte(*userDetailsModel.CompanyJSON), &co); err != nil {
					log.WithContext(ctx).Errorf("error unmarshaling company: %v", err)
				}
			}
		}
		if twitterHandle := p.Twitter.Handle; twitterHandle != "" {
			twitterLink := fmt.Sprintf("https://twitter.com/%v", twitterHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &twitterLink, Type: modelInputs.SocialTypeTwitter})
		}
		if fbHandle := p.Facebook.Handle; fbHandle != "" {
			fbLink := fmt.Sprintf("https://www.facebook.com/%v", fbHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &fbLink, Type: modelInputs.SocialTypeFacebook})
		}
		if gHandle := p.GitHub.Handle; gHandle != "" {
			ghLink := fmt.Sprintf("https://www.github.com/%v", gHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &ghLink, Type: modelInputs.SocialTypeGithub})
		}
		if liHandle := p.LinkedIn.Handle; liHandle != "" {
			fbLink := fmt.Sprintf("https://www.linkedin.com/%v", liHandle)
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &fbLink, Type: modelInputs.SocialTypeLinkedIn})
		}
		if personalSiteLink, companySiteLink := p.Site, co.Domain; personalSiteLink != "" || companySiteLink != "" {
			site := personalSiteLink
			if personalSiteLink == "" {
				site = companySiteLink
			}
			details.Socials = append(details.Socials, &modelInputs.SocialLink{Link: &site, Type: modelInputs.SocialTypeSite})
		}
		details.Avatar = &p.Avatar
		details.Name = &p.Name.FullName
		details.Bio = &p.Bio
		details.Email = &email
	}
	return details, nil
}

// Errors is the resolver for the errors field.
func (r *queryResolver) Errors(ctx context.Context, sessionSecureID string) ([]*model.ErrorObject, error) {
	if env.IsDevEnv() && sessionSecureID == "repro" {
		errors := []*model.ErrorObject{}
		return errors, nil
	}
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}
	eventsQuerySpan, ctx := util.StartSpanFromContext(ctx, "db.errorObjectsQuery",
		util.ResourceName("resolver.internal"), util.Tag("project_id", s.ProjectID))
	defer eventsQuerySpan.Finish()
	errorsObj := []*model.ErrorObject{}
	if err := r.DB.Order("created_at asc").Where(&model.ErrorObject{SessionID: &s.ID}).Find(&errorsObj).Error; err != nil {
		return nil, e.Wrap(err, "error reading from errors")
	}
	return errorsObj, nil
}

// Resources is the resolver for the resources field.
func (r *queryResolver) Resources(ctx context.Context, sessionSecureID string) ([]interface{}, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}

	s3Resources, err := r.StorageClient.GetRawData(ctx, s.ID, s.ProjectID, model.PayloadTypeResources)
	if err != nil {
		return nil, e.Wrap(err, "error retrieving events objects from S3")
	}

	resources, err := r.Redis.GetResources(ctx, s, s3Resources)
	if err != nil {
		return nil, e.Wrap(err, "error getting resources from redis")
	}

	resourceSize := size.Of(resources)
	log.WithContext(ctx).WithFields(
		log.Fields{
			"size":            resourceSize,
			"sessionSecureID": sessionSecureID,
		}).Info("[Resources] Fetched resources size")

	if resourceSize > MaxDownloadSize {
		return nil, fmt.Errorf("resource size (%v) exceeds max download size", resourceSize)
	}

	return resources, nil
}

// WebVitals is the resolver for the web_vitals field.
func (r *queryResolver) WebVitals(ctx context.Context, sessionSecureID string) ([]*model.Metric, error) {
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, nil
	}

	webVitalNames := []string{
		"CLS", "FCP", "FID", "LCP", "TTFB",
	}

	webVitals, err := r.ClickhouseClient.QuerySessionCustomMetrics(ctx, s.ProjectID, sessionSecureID, webVitalNames)
	if err != nil {
		return nil, err
	}

	return webVitals, nil
}

// SessionComments is the resolver for the session_comments field.
func (r *queryResolver) SessionComments(ctx context.Context, sessionSecureID string) ([]*model.SessionComment, error) {
	if env.IsDevEnv() && sessionSecureID == "repro" {
		sessionComments := []*model.SessionComment{}
		return sessionComments, nil
	}
	s, err := r.canAdminViewSession(ctx, sessionSecureID)
	if err != nil {
		return nil, err
	}

	sessionComments := []*model.SessionComment{}

	if err := r.DB.WithContext(ctx).Preload("Attachments").Preload("Replies").Where(model.SessionComment{SessionId: s.ID}).Order("timestamp asc").Find(&sessionComments).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comments for session")
	}
	return sessionComments, nil
}

// SessionCommentTagsForProject is the resolver for the session_comment_tags_for_project field.
func (r *queryResolver) SessionCommentTagsForProject(ctx context.Context, projectID int) ([]*model.SessionCommentTag, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, e.Wrap(err, "admin not found in org for session comment tags")
	}

	var sessionCommentTags []*model.SessionCommentTag

	if err := r.DB.WithContext(ctx).Where(&model.SessionCommentTag{ProjectID: projectID}).Find(&sessionCommentTags).Error; err != nil {
		return nil, e.Wrap(err, "error getting session comment tags")
	}

	return sessionCommentTags, nil
}

// SessionCommentsForAdmin is the resolver for the session_comments_for_admin field.
func (r *queryResolver) SessionCommentsForAdmin(ctx context.Context) ([]*model.SessionComment, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	var sessionComments []*model.SessionComment
	if err := r.DB.WithContext(ctx).Model(admin).Association("SessionComments").Find(&sessionComments); err != nil {
		return nil, e.Wrap(err, "error getting session comments for")
	}

	return sessionComments, nil
}

// SessionCommentsForProject is the resolver for the session_comments_for_project field.
func (r *queryResolver) SessionCommentsForProject(ctx context.Context, projectID int) ([]*model.SessionComment, error) {
	var sessionComments []*model.SessionComment
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return sessionComments, nil
	}
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.DB.WithContext(ctx).Model(model.SessionComment{}).Where("project_id = ? AND admin_id != ?", projectID, admin.ID).Find(&sessionComments).Error; err != nil {
		return sessionComments, e.Wrap(err, "error getting session comments for project")
	}

	return sessionComments, nil
}

// IsSessionPending is the resolver for the isSessionPending field.
func (r *queryResolver) IsSessionPending(ctx context.Context, sessionSecureID string) (*bool, error) {
	isPending, err := r.Redis.IsPendingSession(ctx, sessionSecureID)
	if err != nil {
		return pointy.Bool(false), e.Wrap(err, "error retrieving session")
	}
	return pointy.Bool(isPending), nil
}

// ErrorIssue is the resolver for the error_issue field.
func (r *queryResolver) ErrorIssue(ctx context.Context, errorGroupSecureID string) ([]*model.ExternalAttachment, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	errorIssues := []*model.ExternalAttachment{}

	if err := r.DB.WithContext(ctx).Raw(`
  		SELECT *
  		FROM
			external_attachments
  		WHERE
			error_comment_id IN (
	  		SELECT
				id
	  		FROM
				error_comments
	  		WHERE
				error_id = ? AND removed <> true
			)
  		ORDER BY
			created_at DESC
		`,
		errorGroup.ID,
	).Scan(&errorIssues).Error; err != nil {
		return nil, e.Wrap(err, "error querying error issues for error_group")
	}

	return errorIssues, nil
}

// ErrorComments is the resolver for the error_comments field.
func (r *queryResolver) ErrorComments(ctx context.Context, errorGroupSecureID string) ([]*model.ErrorComment, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	errorComments := []*model.ErrorComment{}
	if err := r.DB.WithContext(ctx).Preload("Attachments").Preload("Replies").Where(model.ErrorComment{ErrorId: errorGroup.ID}).Order("created_at asc").Find(&errorComments).Error; err != nil {
		return nil, e.Wrap(err, "error querying error comments for error_group")
	}
	return errorComments, nil
}

// ErrorCommentsForAdmin is the resolver for the error_comments_for_admin field.
func (r *queryResolver) ErrorCommentsForAdmin(ctx context.Context) ([]*model.ErrorComment, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	var errorComments []*model.ErrorComment
	if err := r.DB.WithContext(ctx).Model(admin).Association("ErrorComments").Find(&errorComments); err != nil {
		return nil, e.Wrap(err, "error getting error comments for admin")
	}

	return errorComments, nil
}

// ErrorCommentsForProject is the resolver for the error_comments_for_project field.
func (r *queryResolver) ErrorCommentsForProject(ctx context.Context, projectID int) ([]*model.ErrorComment, error) {
	var errorComments []*model.ErrorComment
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return errorComments, nil
	}

	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.DB.WithContext(ctx).Model(model.ErrorComment{}).Where("project_id = ? AND admin_id != ?", projectID, admin.ID).Find(&errorComments).Error; err != nil {
		return errorComments, e.Wrap(err, "error getting error comments for project")
	}

	return errorComments, nil
}

// WorkspaceAdmins is the resolver for the workspace_admins field.
func (r *queryResolver) WorkspaceAdmins(ctx context.Context, workspaceID int) ([]*model.WorkspaceAdminRole, error) {
	workspace, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	var admins []*model.Admin
	if err := r.DB.WithContext(ctx).Order("created_at ASC").Model(workspace).Association("Admins").Find(&admins); err != nil {
		return nil, e.Wrap(err, "error getting admins for the workspace")
	}

	var roles []*model.WorkspaceAdminRole
	for _, admin := range admins {
		role, projectIds, err := r.getAdminRole(ctx, admin.ID, workspace.ID)
		if err != nil {
			return nil, e.Wrap(err, "failed to retrieve admin role")
		}
		roles = append(roles, &model.WorkspaceAdminRole{
			WorkspaceId: workspace.ID,
			Admin:       admin,
			Role:        role,
			ProjectIds:  projectIds,
		})
	}

	return roles, nil
}

// WorkspaceAdminsByProjectID is the resolver for the workspace_admins_by_project_id field.
func (r *queryResolver) WorkspaceAdminsByProjectID(ctx context.Context, projectID int) ([]*model.WorkspaceAdminRole, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	admins, err := r.WorkspaceAdmins(ctx, workspace.ID)
	if err != nil {
		return nil, err
	}

	// Only return admins with project-level access
	return lo.Filter(admins, func(wa *model.WorkspaceAdminRole, _ int) bool {
		if len(wa.ProjectIds) == 0 {
			return true
		}
		for _, id := range wa.ProjectIds {
			if projectID == id {
				return true
			}
		}
		return false
	}), nil
}

// ClientIntegration is the resolver for the clientIntegration field.
func (r *queryResolver) ClientIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:   false,
		ResourceType: "Session",
	}
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return integration, nil
	}

	setupEvent := model.SetupEvent{}
	if err := r.DB.WithContext(ctx).Model(&model.SetupEvent{}).Where("project_id = ? AND type = ?", projectID, model.MarkBackendSetupTypeSession).Take(&setupEvent).Error; err != nil {
		if !e.Is(err, gorm.ErrRecordNotFound) {
			return nil, e.Wrap(err, "error querying logging setup event")
		}
	}

	if setupEvent.ID != 0 {
		integration.Integrated = true
		integration.CreatedAt = &setupEvent.CreatedAt
	}

	return integration, nil
}

// ServerIntegration is the resolver for the serverIntegration field.
func (r *queryResolver) ServerIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:   false,
		ResourceType: "ErrorGroup",
	}
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return integration, nil
	}

	setupEvent := model.SetupEvent{}
	if err := r.DB.WithContext(ctx).Model(&model.SetupEvent{}).Where("project_id = ? AND type = ?", projectID, model.MarkBackendSetupTypeError).Take(&setupEvent).Error; err != nil {
		if !e.Is(err, gorm.ErrRecordNotFound) {
			return nil, e.Wrap(err, "error querying error setup event")
		}
	}

	if setupEvent.ID != 0 {
		integration.Integrated = true
		integration.CreatedAt = &setupEvent.CreatedAt
	}

	return integration, nil
}

// LogsIntegration is the resolver for the logsIntegration field.
func (r *queryResolver) LogsIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:   false,
		ResourceType: "Log",
	}
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	setupEvent := model.SetupEvent{}
	err = r.DB.WithContext(ctx).Model(&model.SetupEvent{}).Where("project_id = ? AND type = ?", projectID, model.MarkBackendSetupTypeLogs).Take(&setupEvent).Error
	if err != nil {
		if !e.Is(err, gorm.ErrRecordNotFound) {
			return nil, e.Wrap(err, "error querying logging setup event")
		}
	}

	if setupEvent.ID != 0 {
		integration.Integrated = true
		integration.CreatedAt = &setupEvent.CreatedAt
	}

	return integration, nil
}

// TracesIntegration is the resolver for the tracesIntegration field.
func (r *queryResolver) TracesIntegration(ctx context.Context, projectID int) (*modelInputs.IntegrationStatus, error) {
	integration := &modelInputs.IntegrationStatus{
		Integrated:   false,
		ResourceType: "Trace",
	}
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	setupEvent := model.SetupEvent{}
	err = r.DB.WithContext(ctx).Model(&model.SetupEvent{}).Where("project_id = ? AND type = ?", projectID, model.MarkBackendSetupTypeTraces).Take(&setupEvent).Error
	if err != nil {
		if !e.Is(err, gorm.ErrRecordNotFound) {
			return nil, e.Wrap(err, "error querying logging setup event")
		}
	}

	if setupEvent.ID != 0 {
		integration.Integrated = true
		integration.CreatedAt = &setupEvent.CreatedAt
	}

	return integration, nil
}

// UnprocessedSessionsCount is the resolver for the unprocessedSessionsCount field.
func (r *queryResolver) UnprocessedSessionsCount(ctx context.Context, projectID int) (*int64, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	// lookback based on DeleteCompletedSessions
	var count int64
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT COUNT(*)
		FROM sessions
		WHERE project_id = ?
		AND processed = false
		AND excluded = false
		AND created_at > NOW() - interval '4 hours 10 minutes'
	`, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving live users count")
	}

	return &count, nil
}

// LiveUsersCount is the resolver for the liveUsersCount field.
func (r *queryResolver) LiveUsersCount(ctx context.Context, projectID int) (*int64, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT COUNT(DISTINCT(COALESCE(NULLIF(identifier, ''), CAST(fingerprint AS text))))
		FROM sessions
		WHERE project_id = ?
		AND processed = false
		AND excluded = false
		AND created_at > NOW() - interval '4 hours 10 minutes'
	`, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving live users count")
	}

	return &count, nil
}

// AdminHasCreatedComment is the resolver for the adminHasCreatedComment field.
func (r *queryResolver) AdminHasCreatedComment(ctx context.Context, adminID int) (*bool, error) {
	if err := r.DB.WithContext(ctx).Model(&model.SessionComment{}).Where(&model.SessionComment{
		AdminId: adminID,
	}).Take(&model.SessionComment{}).Error; err != nil {
		return &model.F, nil
	}

	return &model.T, nil
}

// ProjectHasViewedASession is the resolver for the projectHasViewedASession field.
func (r *queryResolver) ProjectHasViewedASession(ctx context.Context, projectID int) (*model.Session, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	session := model.Session{}
	if err := r.DB.WithContext(ctx).Model(&session).Where("project_id = ?", projectID).Where(&model.Session{Viewed: &model.T, Excluded: false}).Take(&session).Error; err != nil {
		return &session, nil
	}
	return &session, nil
}

// DailySessionsCount is the resolver for the dailySessionsCount field.
func (r *queryResolver) DailySessionsCount(ctx context.Context, projectID int, dateRange modelInputs.DateRangeInput) ([]*model.DailySessionCount, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	dailySessions := []*model.DailySessionCount{}

	startDateUTC := time.Date(dateRange.StartDate.UTC().Year(), dateRange.StartDate.UTC().Month(), dateRange.StartDate.UTC().Day(), 0, 0, 0, 0, time.UTC)
	endDateUTC := time.Date(dateRange.EndDate.UTC().Year(), dateRange.EndDate.UTC().Month(), dateRange.EndDate.UTC().Day(), 0, 0, 0, 0, time.UTC)

	if err := r.DB.WithContext(ctx).Raw("SELECT * FROM daily_session_counts_view WHERE date BETWEEN ? AND ? AND project_id = ?", startDateUTC, endDateUTC, projectID).Find(&dailySessions).Error; err != nil {
		return nil, e.Wrap(err, "error reading from daily sessions")
	}

	return dailySessions, nil
}

// DailyErrorsCount is the resolver for the dailyErrorsCount field.
func (r *queryResolver) DailyErrorsCount(ctx context.Context, projectID int, dateRange modelInputs.DateRangeInput) ([]*model.DailyErrorCount, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	dailyErrors := []*model.DailyErrorCount{}

	startDateUTC := time.Date(dateRange.StartDate.UTC().Year(), dateRange.StartDate.UTC().Month(), dateRange.StartDate.UTC().Day(), 0, 0, 0, 0, time.UTC)
	endDateUTC := time.Date(dateRange.EndDate.UTC().Year(), dateRange.EndDate.UTC().Month(), dateRange.EndDate.UTC().Day(), 0, 0, 0, 0, time.UTC)

	if err := r.DB.WithContext(ctx).Raw("SELECT * FROM daily_error_counts_view WHERE date BETWEEN ? AND ? AND project_id = ?", startDateUTC, endDateUTC, projectID).Find(&dailyErrors).Error; err != nil {
		return nil, e.Wrap(err, "error reading from daily sessions")
	}

	return dailyErrors, nil
}

// DailyErrorFrequency is the resolver for the dailyErrorFrequency field.
func (r *queryResolver) DailyErrorFrequency(ctx context.Context, projectID int, errorGroupSecureID string, dateOffset int) ([]int64, error) {
	errGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}
	if err := r.loadErrorGroupFrequenciesClickhouse(ctx, projectID, []*model.ErrorGroup{errGroup}); err != nil {
		return nil, err
	}

	if projectID == 0 {
		// Make error distribution random for demo org so it looks pretty
		rand.New(rand.NewSource(int64(errGroup.ID)))
		var dists []int64
		for i := 0; i <= dateOffset; i++ {
			t := int64(rand.Intn(10) + 1)
			dists = append(dists, t)
		}
		return dists, nil
	}

	return errGroup.ErrorFrequency, nil
}

// ErrorGroupFrequencies is the resolver for the errorGroupFrequencies field.
func (r *queryResolver) ErrorGroupFrequencies(ctx context.Context, projectID int, errorGroupSecureIds []string, params modelInputs.ErrorGroupFrequenciesParamsInput, metric *string, useClickhouse *bool) ([]*modelInputs.ErrorDistributionItem, error) {
	var errorGroupIDs []int
	for _, errorGroupSecureID := range errorGroupSecureIds {
		errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
		if err != nil {
			return nil, err
		}
		errorGroupIDs = append(errorGroupIDs, errorGroup.ID)
	}
	if metric == nil {
		metric = pointy.String("")
	}
	results, err := r.ClickhouseClient.QueryErrorGroupFrequencies(ctx, projectID, errorGroupIDs, params)
	if err != nil {
		return nil, err
	}
	return results, nil
}

// ErrorGroupTags is the resolver for the errorGroupTags field.
func (r *queryResolver) ErrorGroupTags(ctx context.Context, errorGroupSecureID string, useClickhouse *bool) ([]*modelInputs.ErrorGroupTagAggregation, error) {
	errorGroup, err := r.canAdminViewErrorGroup(ctx, errorGroupSecureID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.QueryErrorGroupTags(ctx, errorGroup.ProjectID, errorGroup.ID)
}

// Referrers is the resolver for the referrers field.
func (r *queryResolver) Referrers(ctx context.Context, projectID int, lookbackDays float64) ([]*modelInputs.ReferrerTablePayload, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	referrers := []*modelInputs.ReferrerTablePayload{}

	if err := r.DB.WithContext(ctx).Raw(`
SELECT DISTINCT(value)                                                               as host,
               COUNT(value),
               count(value) * 100.0 / (select count(*)
                                       from fields
                                       where name = 'referrer'
                                         and project_id = ?
                                         and created_at >= NOW() - (? * INTERVAL '1 DAY')) as percent
FROM (SELECT SUBSTRING(value from ?) AS value
      FROM fields
      WHERE name = 'referrer'
        AND project_id = ?
        AND created_at >= NOW() - (? * INTERVAL '1 DAY')) t1
GROUP BY value
ORDER BY count desc
LIMIT 200`, projectID, lookbackDays, `(?:.*://)?(?:www\.)?([^/]*)`, projectID, lookbackDays).Scan(&referrers).Error; err != nil {
		return nil, e.Wrap(err, "error getting referrers")
	}

	return referrers, nil
}

// NewUsersCount is the resolver for the newUsersCount field.
func (r *queryResolver) NewUsersCount(ctx context.Context, projectID int, lookbackDays float64) (*modelInputs.NewUsersCount, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	if err := r.DB.WithContext(ctx).Raw(`SELECT COUNT(*)
FROM sessions
WHERE project_id = ?
  AND first_time = true
  AND created_at >= NOW() - (? * INTERVAL '1 DAY')`, projectID, lookbackDays).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving count of first time users")
	}

	return &modelInputs.NewUsersCount{Count: count}, nil
}

// TopUsers is the resolver for the topUsers field.
func (r *queryResolver) TopUsers(ctx context.Context, projectID int, lookbackDays float64) ([]*modelInputs.TopUsersPayload, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	var topUsersPayload = []*modelInputs.TopUsersPayload{}
	topUsersSpan, ctx := util.StartSpanFromContext(ctx, "db.topUsers",
		util.ResourceName("resolver.internal"), util.Tag("project_id", projectID))
	defer topUsersSpan.Finish()
	if err := r.DB.WithContext(ctx).Raw(`
	SELECT *
	FROM (
        SELECT
            DISTINCT ON(topUsers.identifier) topUsers.identifier,
            topUsers.id,
            total_active_time,
            active_time_percentage,
            s.user_properties
        FROM (
		SELECT
			identifier, (
				SELECT
					id
				FROM
					fields
				WHERE
					project_id = ?
					AND type = 'user'
					AND name = 'identifier'
					AND value = identifier
				LIMIT 1
			) AS id,
			SUM(active_length) as total_active_time,
			SUM(active_length) / (
				SELECT
					SUM(active_length)
				FROM
					sessions
				WHERE
					active_length IS NOT NULL
					AND project_id = ?
					AND identifier <> ''
					AND created_at >= NOW() - (? * INTERVAL '1 DAY')
					AND processed = true
					AND excluded <> true
			) AS active_time_percentage
		FROM (
			SELECT
				identifier,
				active_length,
				user_properties
			FROM
				sessions
			WHERE
				active_length IS NOT NULL
				AND project_id = ?
				AND identifier <> ''
				AND created_at >= NOW() - (? * INTERVAL '1 DAY')
				AND processed = true
				AND excluded <> true
		) q1
		GROUP BY identifier
		LIMIT 50
	) as topUsers
	INNER JOIN sessions s
	ON topUsers.identifier = s.identifier
	AND s.project_id = ?
    ) as q2
	ORDER BY total_active_time DESC`,
		projectID, projectID, lookbackDays, projectID, lookbackDays, projectID).Scan(&topUsersPayload).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving top users")
	}
	topUsersSpan.Finish()

	return topUsersPayload, nil
}

// AverageSessionLength is the resolver for the averageSessionLength field.
func (r *queryResolver) AverageSessionLength(ctx context.Context, projectID int, lookbackDays float64) (*modelInputs.AverageSessionLength, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var length float64
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT
			COALESCE(avg(active_length), 0)
		FROM sessions
		WHERE project_id=?
			AND processed=true
			AND excluded <> true
			AND active_length IS NOT NULL
			AND created_at >= NOW() - (? * INTERVAL '1 DAY')
		`, projectID, lookbackDays).Scan(&length).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving average length for sessions")
	}

	return &modelInputs.AverageSessionLength{Length: length}, nil
}

// UserFingerprintCount is the resolver for the userFingerprintCount field.
func (r *queryResolver) UserFingerprintCount(ctx context.Context, projectID int, lookbackDays float64) (*modelInputs.UserFingerprintCount, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// If demo project, load stats for project_id 1
	if projectID == 0 {
		projectID = 1
	}

	var count int64
	span, ctx := util.StartSpanFromContext(ctx, "db.userFingerprintCount",
		util.ResourceName("resolver.internal"), util.Tag("project_id", projectID))
	defer span.Finish()
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT
			COUNT(DISTINCT fingerprint)
		FROM sessions
		WHERE identifier=''
			AND excluded <> true
			AND fingerprint IS NOT NULL
			AND created_at >= NOW() - (? * INTERVAL '1 DAY')
			AND project_id=?
			AND length >= 1000
		`, lookbackDays, projectID).Scan(&count).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving user fingerprint count")
	}

	return &modelInputs.UserFingerprintCount{Count: count}, nil
}

// SessionsClickhouse is the resolver for the sessions_clickhouse field.
func (r *queryResolver) SessionsClickhouse(ctx context.Context, projectID int, count int, query modelInputs.ClickhouseQuery, sortField *string, sortDesc bool, page *int) (*model.SessionResults, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	retentionDate := GetRetentionDate(workspace.RetentionPeriod)

	chSortStr := "CreatedAt DESC, ID DESC"
	pgSortStr := "created_at DESC"
	if !sortDesc {
		chSortStr = "CreatedAt ASC, ID ASC"
		pgSortStr = "created_at ASC"
	}

	// If there's no admin for the context, use `admin=nil`
	// (admin is used by the "viewed by me" filter)
	admin, err := r.getCurrentAdmin(ctx)
	if errors.Is(err, AuthenticationError) {
		admin = nil
	} else if err != nil {
		return nil, err
	}

	ids, total, ordered, err := r.ClickhouseClient.QuerySessionIdsDeprecated(ctx, admin, projectID, count, query, chSortStr, page, retentionDate)
	if err != nil {
		return nil, err
	}

	q := r.DB.WithContext(ctx).Model(&model.Session{}).
		Where("id in ?", ids).
		Where("project_id = ?", projectID)
	if !ordered {
		q = q.Order(pgSortStr)
	}

	var results []model.Session
	if err := q.Find(&results).Error; err != nil {
		return nil, err
	}

	if ordered {
		positions := make(map[int64]int)
		for idx, id := range ids {
			positions[id] = idx
		}
		sort.Slice(results, func(i, j int) bool {
			return positions[int64(results[i].ID)] < positions[int64(results[j].ID)]
		})
	}

	return &model.SessionResults{
		Sessions:   results,
		TotalCount: total,
	}, nil
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context, projectID int, count int, params modelInputs.QueryInput, sortField *string, sortDesc bool, page *int) (*model.SessionResults, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	retentionDate := GetRetentionDate(workspace.RetentionPeriod)

	chSortStr := "CreatedAt DESC, ID DESC"
	pgSortStr := "created_at DESC"
	if !sortDesc {
		chSortStr = "CreatedAt ASC, ID ASC"
		pgSortStr = "created_at ASC"
	}

	// If there's no admin for the context, use `admin=nil`
	// (admin is used by the "viewed by me" filter)
	admin, err := r.getCurrentAdmin(ctx)
	if errors.Is(err, AuthenticationError) {
		admin = nil
	} else if err != nil {
		return nil, err
	}

	ids, total, totalLength, totalActiveLength, ordered, err := r.ClickhouseClient.QuerySessionIds(ctx, admin, projectID, count, params, chSortStr, page, retentionDate)
	if err != nil {
		return nil, err
	}

	q := r.DB.WithContext(ctx).Model(&model.Session{}).
		Where("id in ?", ids).
		Where("project_id = ?", projectID)
	if !ordered {
		q = q.Order(pgSortStr)
	}

	var results []model.Session
	if err := q.Find(&results).Error; err != nil {
		return nil, err
	}

	if ordered {
		positions := make(map[int64]int)
		for idx, id := range ids {
			positions[id] = idx
		}
		sort.Slice(results, func(i, j int) bool {
			return positions[int64(results[i].ID)] < positions[int64(results[j].ID)]
		})
	}

	return &model.SessionResults{
		Sessions:          results,
		TotalCount:        total,
		TotalLength:       totalLength,
		TotalActiveLength: totalActiveLength,
	}, nil
}

// SessionsHistogramClickhouse is the resolver for the sessions_histogram_clickhouse field.
func (r *queryResolver) SessionsHistogramClickhouse(ctx context.Context, projectID int, query modelInputs.ClickhouseQuery, histogramOptions modelInputs.DateHistogramOptions) (*model.SessionsHistogram, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	retentionDate := GetRetentionDate(workspace.RetentionPeriod)

	// If there's no admin for the context, use `admin=nil`
	// (admin is used by the "viewed by me" filter)
	admin, err := r.getCurrentAdmin(ctx)
	if errors.Is(err, AuthenticationError) {
		admin = nil
	} else if err != nil {
		return nil, err
	}

	bucketTimes, totals, withErrors, withoutErrors, err := r.ClickhouseClient.QuerySessionHistogramDeprecated(ctx, admin, projectID, query, retentionDate, histogramOptions)
	if err != nil {
		return nil, err
	}

	if len(bucketTimes) > 0 {
		bucketTimes[0] = *histogramOptions.Bounds.StartDate // OpenSearch rounds the first bucket to a calendar interval by default
		bucketTimes = append(bucketTimes, *histogramOptions.Bounds.EndDate)
	}

	return &model.SessionsHistogram{
		BucketTimes:           MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		SessionsWithoutErrors: MergeHistogramBucketCounts(withoutErrors, histogramOptions.BucketSize.Multiple),
		SessionsWithErrors:    MergeHistogramBucketCounts(withErrors, histogramOptions.BucketSize.Multiple),
		TotalSessions:         MergeHistogramBucketCounts(totals, histogramOptions.BucketSize.Multiple),
	}, nil
}

// SessionsHistogram is the resolver for the sessions_histogram field.
func (r *queryResolver) SessionsHistogram(ctx context.Context, projectID int, params modelInputs.QueryInput, histogramOptions modelInputs.DateHistogramOptions) (*model.SessionsHistogram, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	retentionDate := GetRetentionDate(workspace.RetentionPeriod)

	// If there's no admin for the context, use `admin=nil`
	// (admin is used by the "viewed by me" filter)
	admin, err := r.getCurrentAdmin(ctx)
	if errors.Is(err, AuthenticationError) {
		admin = nil
	} else if err != nil {
		return nil, err
	}

	bucketTimes, totals, withErrors, withoutErrors, err := r.ClickhouseClient.QuerySessionHistogram(ctx, admin, projectID, params, retentionDate, histogramOptions)
	if err != nil {
		return nil, err
	}

	if len(bucketTimes) > 0 {
		bucketTimes[0] = *histogramOptions.Bounds.StartDate // OpenSearch rounds the first bucket to a calendar interval by default
		bucketTimes = append(bucketTimes, *histogramOptions.Bounds.EndDate)
	}

	return &model.SessionsHistogram{
		BucketTimes:           MergeHistogramBucketTimes(bucketTimes, histogramOptions.BucketSize.Multiple),
		SessionsWithoutErrors: MergeHistogramBucketCounts(withoutErrors, histogramOptions.BucketSize.Multiple),
		SessionsWithErrors:    MergeHistogramBucketCounts(withErrors, histogramOptions.BucketSize.Multiple),
		TotalSessions:         MergeHistogramBucketCounts(totals, histogramOptions.BucketSize.Multiple),
	}, nil
}

// SessionUsersReport is the resolver for the session_users_report field.
func (r *queryResolver) SessionUsersReport(ctx context.Context, projectID int, params modelInputs.QueryInput) ([]*modelInputs.SessionsReportRow, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	retentionDate := GetRetentionDate(workspace.RetentionPeriod)

	// If there's no admin for the context, use `admin=nil`
	// (admin is used by the "viewed by me" filter)
	admin, err := r.getCurrentAdmin(ctx)
	if errors.Is(err, AuthenticationError) {
		admin = nil
	} else if err != nil {
		return nil, err
	}

	sql, args, _, err := clickhouse.GetSessionsQueryImpl(admin, params, projectID, retentionDate, "ID", nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}

	q := fmt.Sprintf(`
select coalesce(
               nullif(arrayFilter((k, v) -> k = 'email', SessionAttributePairs)[1].2, ''),
               nullif(IP, ''),
               nullif(arrayFilter((k, v) -> k = 'device_id', SessionAttributePairs)[1].2, ''),
               Identifier
       )                                                                       as key,
       min(arrayFilter((k, v) -> k = 'email', SessionAttributePairs)[1].2)     as email,
       min(CreatedAt)                                                          as first_session,
       max(CreatedAt)                                                          as last_session,
       count(distinct ID)                                                      as num_sessions,
       count(distinct date_trunc('day', CreatedAt))                            as num_days_visited,
       count(distinct date_trunc('month', CreatedAt))                          as num_months_visited,
       avg(greatest(0, ActiveLength)) / 1000 / 60                              as avg_active_length_mins,
       max(greatest(0, ActiveLength)) / 1000 / 60                              as max_active_length_mins,
       sum(greatest(0, ActiveLength)) / 1000 / 60                              as total_active_length_mins,
       avg(greatest(0, Length)) / 1000 / 60                                    as avg_length_mins,
       max(greatest(0, Length)) / 1000 / 60                                    as max_length_mins,
       sum(greatest(0, Length)) / 1000 / 60                                    as total_length_mins,
       max(coalesce(nullif(City, ''), nullif(State, ''), nullif(Country, ''))) as location
from sessions_joined_vw final
WHERE ProjectID = %d
  AND NOT Excluded
  AND WithinBillingQuota
  AND ID in (%s)
group by 1 order by num_sessions desc;
`, project.ID, sql)
	rows, err := r.ClickhouseClient.GetConn().Query(ctx, q, args...)
	if err != nil {
		return nil, err
	}

	var results []*modelInputs.SessionsReportRow
	for rows.Next() {
		var result modelInputs.SessionsReportRow
		if err := rows.Scan(&result.Key, &result.Email, &result.FirstSession, &result.LastSession, &result.NumSessions, &result.NumDaysVisited, &result.NumMonthsVisited, &result.AvgActiveLengthMins, &result.MaxActiveLengthMins, &result.TotalActiveLengthMins, &result.AvgLengthMins, &result.MaxLengthMins, &result.TotalLengthMins, &result.Location); err != nil {
			return nil, err
		}
		results = append(results, &result)
	}

	return results, nil
}

// BillingDetailsForProject is the resolver for the billingDetailsForProject field.
func (r *queryResolver) BillingDetailsForProject(ctx context.Context, projectID int) (*modelInputs.BillingDetails, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.BillingDetails(ctx, project.WorkspaceID)
}

// BillingDetails is the resolver for the billingDetails field.
func (r *queryResolver) BillingDetails(ctx context.Context, workspaceID int) (*modelInputs.BillingDetails, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.Query().Workspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	awsMPWorkspace, err := r.GetAWSMarketPlaceWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	settings, err := r.Store.GetAllWorkspaceSettings(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	planType := modelInputs.PlanType(workspace.PlanTier)

	interval := modelInputs.SubscriptionIntervalMonthly
	if workspace.BillingPeriodStart != nil &&
		workspace.BillingPeriodEnd != nil &&
		workspace.BillingPeriodEnd.Sub(*workspace.BillingPeriodStart) >= time.Hour*24*32 {
		interval = modelInputs.SubscriptionIntervalAnnual
	}

	var g errgroup.Group
	var sessionsMeter int64
	var membersMeter int64
	var errorsMeter int64
	var logsMeter int64
	var tracesMeter int64
	var sessionsAvg float64
	var errorsAvg float64
	var logsAvg float64
	var tracesAvg float64

	g.Go(func() error {
		sessionsMeter, err = pricing.GetWorkspaceSessionsMeter(ctx, r.DB, r.ClickhouseClient, r.Redis, workspace)
		if err != nil {
			return e.Wrap(err, "error from get quota")
		}
		return nil
	})

	g.Go(func() error {
		membersMeter, err = r.Store.GetWorkspaceAdminCount(ctx, workspaceID)
		if err != nil {
			return e.Wrap(err, "error querying members meter")
		}
		return nil
	})

	g.Go(func() error {
		errorsMeter, err = pricing.GetWorkspaceErrorsMeter(ctx, r.DB, r.ClickhouseClient, r.Redis, workspace)
		if err != nil {
			return e.Wrap(err, "error querying errors meter")
		}
		return nil
	})

	g.Go(func() error {
		logsMeter, err = pricing.GetWorkspaceLogsMeter(ctx, r.DB, r.ClickhouseClient, r.Redis, workspace)
		if err != nil {
			return e.Wrap(err, "error querying logs meter")
		}
		return nil
	})

	g.Go(func() error {
		tracesMeter, err = pricing.GetWorkspaceTracesMeter(ctx, r.DB, r.ClickhouseClient, r.Redis, workspace)
		return err
	})

	g.Go(func() error {
		sessionsAvg, err = pricing.GetSessions7DayAverage(ctx, r.DB, r.ClickhouseClient, workspace)
		return err
	})

	g.Go(func() error {
		errorsAvg, err = pricing.GetErrors7DayAverage(ctx, r.DB, r.ClickhouseClient, workspace)
		return err
	})

	g.Go(func() error {
		logsAvg, err = pricing.GetLogs7DayAverage(ctx, r.DB, r.ClickhouseClient, workspace)
		return err
	})

	g.Go(func() error {
		tracesAvg, err = pricing.GetTraces7DayAverage(ctx, r.DB, r.ClickhouseClient, workspace)
		return err
	})

	// Waits for all goroutines to finish, then returns the first non-nil error (if any).
	if err := g.Wait(); err != nil {
		return nil, e.Wrap(err, "error querying session data for billing details")
	}

	sessionsIncluded := pricing.IncludedAmount(planType, model.PricingProductTypeSessions)
	// use monthly session limit if it exists
	if workspace.MonthlySessionLimit != nil {
		sessionsIncluded = int64(*workspace.MonthlySessionLimit)
	}

	membersLimit := pricing.TypeToMemberLimit(planType, workspace.UnlimitedMembers)
	if membersLimit != nil && workspace.MonthlyMembersLimit != nil {
		membersLimit = pointy.Int64(int64(*workspace.MonthlyMembersLimit))
	}

	errorsIncluded := pricing.IncludedAmount(planType, model.PricingProductTypeErrors)
	// use monthly session limit if it exists
	if workspace.MonthlyErrorsLimit != nil {
		errorsIncluded = int64(*workspace.MonthlyErrorsLimit)
	}

	logsIncluded := pricing.IncludedAmount(planType, model.PricingProductTypeLogs)
	// use monthly session limit if it exists
	if workspace.MonthlyLogsLimit != nil {
		logsIncluded = int64(*workspace.MonthlyLogsLimit)
	}

	tracesIncluded := pricing.IncludedAmount(planType, model.PricingProductTypeTraces)
	// use monthly traces limit if it exists
	if workspace.MonthlyTracesLimit != nil {
		tracesIncluded = int64(*workspace.MonthlyTracesLimit)
	}

	sessionsRetentionPeriod := modelInputs.RetentionPeriodSixMonths
	if workspace.RetentionPeriod != nil {
		sessionsRetentionPeriod = *workspace.RetentionPeriod
	}
	errorsRetentionPeriod := modelInputs.RetentionPeriodSixMonths
	if workspace.ErrorsRetentionPeriod != nil {
		errorsRetentionPeriod = *workspace.ErrorsRetentionPeriod
	}
	logsRetentionPeriod := modelInputs.RetentionPeriodThirtyDays
	if workspace.LogsRetentionPeriod != nil {
		logsRetentionPeriod = *workspace.LogsRetentionPeriod
	}
	tracesRetentionPeriod := modelInputs.RetentionPeriodThirtyDays
	if workspace.TracesRetentionPeriod != nil {
		tracesRetentionPeriod = *workspace.TracesRetentionPeriod
	}

	var sessionsLimit, errorsLimit, logsLimit, tracesLimit *int64
	var sessionsRate, errorsRate, logsRate, tracesRate float64
	if workspace.TrialEndDate == nil || workspace.TrialEndDate.Before(time.Now()) {
		sessionsLimit = pricing.GetLimitAmount(workspace.SessionsMaxCents, model.PricingProductTypeSessions, planType, sessionsRetentionPeriod)
		errorsLimit = pricing.GetLimitAmount(workspace.ErrorsMaxCents, model.PricingProductTypeErrors, planType, errorsRetentionPeriod)
		logsLimit = pricing.GetLimitAmount(workspace.LogsMaxCents, model.PricingProductTypeLogs, planType, logsRetentionPeriod)
		tracesLimit = pricing.GetLimitAmount(workspace.TracesMaxCents, model.PricingProductTypeTraces, planType, tracesRetentionPeriod)
		sessionsRate = pricing.ProductToBasePriceCents(model.PricingProductTypeSessions, planType, sessionsMeter)
		errorsRate = pricing.ProductToBasePriceCents(model.PricingProductTypeErrors, planType, errorsMeter)
		logsRate = pricing.ProductToBasePriceCents(model.PricingProductTypeLogs, planType, logsMeter)
		tracesRate = pricing.ProductToBasePriceCents(model.PricingProductTypeTraces, planType, tracesMeter)
	}

	details := &modelInputs.BillingDetails{
		Plan: &modelInputs.Plan{
			AwsMpSubscription:   &modelInputs.AWSMarketplaceSubscription{},
			Type:                modelInputs.PlanType(planType.String()),
			Interval:            interval,
			MembersLimit:        membersLimit,
			SessionsLimit:       sessionsIncluded,
			ErrorsLimit:         errorsIncluded,
			LogsLimit:           logsIncluded,
			TracesLimit:         tracesIncluded,
			SessionsRate:        sessionsRate,
			ErrorsRate:          errorsRate,
			LogsRate:            logsRate,
			TracesRate:          tracesRate,
			EnableBillingLimits: settings.EnableBillingLimits,
		},
		Meter:                sessionsMeter,
		MembersMeter:         membersMeter,
		ErrorsMeter:          errorsMeter,
		LogsMeter:            logsMeter,
		TracesMeter:          tracesMeter,
		SessionsDailyAverage: sessionsAvg,
		ErrorsDailyAverage:   errorsAvg,
		LogsDailyAverage:     logsAvg,
		TracesDailyAverage:   tracesAvg,
		SessionsBillingLimit: sessionsLimit,
		ErrorsBillingLimit:   errorsLimit,
		LogsBillingLimit:     logsLimit,
		TracesBillingLimit:   tracesLimit,
	}
	if awsMPWorkspace != nil && awsMPWorkspace.AWSMarketplaceCustomer != nil {
		details.Plan.AwsMpSubscription.CustomerIdentifier = pointy.StringValue(awsMPWorkspace.AWSMarketplaceCustomer.CustomerIdentifier, "")
		details.Plan.AwsMpSubscription.CustomerAwsAccountID = pointy.StringValue(awsMPWorkspace.AWSMarketplaceCustomer.CustomerAWSAccountID, "")
		details.Plan.AwsMpSubscription.ProductCode = pointy.StringValue(awsMPWorkspace.AWSMarketplaceCustomer.ProductCode, "")
	}

	return details, nil
}

// UsageHistory is the resolver for the usageHistory field.
func (r *queryResolver) UsageHistory(ctx context.Context, workspaceID int, productType modelInputs.ProductType, dateRange *modelInputs.DateRangeRequiredInput) (*modelInputs.UsageHistory, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	workspace, err := r.Query().Workspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	projectIds := lo.Map(workspace.Projects, func(p model.Project, _ int) int {
		return p.ID
	})

	var meter *modelInputs.MetricsBuckets
	switch productType {
	case modelInputs.ProductTypeSessions:
		meter, err = r.ClickhouseClient.ReadWorkspaceSessionCounts(ctx, projectIds, modelInputs.QueryInput{
			Query:     "completed=true AND excluded=false AND active_length > 1000",
			DateRange: dateRange,
		})
	case modelInputs.ProductTypeErrors:
		meter, err = r.ClickhouseClient.ReadWorkspaceErrorCounts(ctx, projectIds, modelInputs.QueryInput{
			Query:     "",
			DateRange: dateRange,
		})
	case modelInputs.ProductTypeLogs:
		meter, err = r.ClickhouseClient.ReadWorkspaceLogCounts(ctx, projectIds, modelInputs.QueryInput{
			Query:     "",
			DateRange: dateRange,
		})
	case modelInputs.ProductTypeTraces:
		meter, err = r.ClickhouseClient.ReadWorkspaceTraceCounts(ctx, projectIds, modelInputs.QueryInput{
			Query:     "",
			DateRange: dateRange,
		})
	case modelInputs.ProductTypeMetrics:
		meter, err = r.ClickhouseClient.ReadWorkspaceMetricCounts(ctx, projectIds, modelInputs.QueryInput{
			Query:     "",
			DateRange: dateRange,
		})
	default:
		return nil, errors.New(fmt.Sprintf("invalid product type: %v", productType))
	}

	if err != nil {
		return nil, err
	}

	return &modelInputs.UsageHistory{
		Usage: meter,
	}, nil
}

// FieldSuggestion is the resolver for the field_suggestion field.
func (r *queryResolver) FieldSuggestion(ctx context.Context, projectID int, name string, query string) ([]*model.Field, error) {
	fields := []*model.Field{}
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return fields, nil
	}
	res := r.DB.WithContext(ctx).Where(&model.Field{Name: name}).
		Where("project_id = ?", projectID).
		Where("length(value) > ?", 0).
		Where("value ILIKE ?", "%"+query+"%").
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		log.WithContext(ctx).Error(err)
		return fields, nil
	}
	return fields, nil
}

// PropertySuggestion is the resolver for the property_suggestion field.
func (r *queryResolver) PropertySuggestion(ctx context.Context, projectID int, query string, typeArg string) ([]*model.Field, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	fields := []*model.Field{}
	res := r.DB.WithContext(ctx).Where(&model.Field{Type: typeArg}).Where("project_id = ?", projectID).Where(r.DB.
		Where(r.DB.WithContext(ctx).Where("length(value) > ?", 0).Where("value ILIKE ?", "%"+query+"%")).
		Or(r.DB.WithContext(ctx).Where("length(name) > ?", 0).Where("name ILIKE ?", "%"+query+"%"))).
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying field suggestion")
	}
	return fields, nil
}

// ErrorFieldSuggestion is the resolver for the error_field_suggestion field.
func (r *queryResolver) ErrorFieldSuggestion(ctx context.Context, projectID int, name string, query string) ([]*model.ErrorField, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	fields := []*model.ErrorField{}
	res := r.DB.WithContext(ctx).Where(&model.ErrorField{Name: name}).
		Where("length(value) > ?", 0).
		Where("value ILIKE ?", "%"+query+"%").
		Where("project_id = ?", projectID).
		Limit(model.SUGGESTION_LIMIT_CONSTANT).
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying error field suggestion")
	}
	return fields, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	projects := []*model.Project{}
	if err := r.DB.WithContext(ctx).Order("id ASC").Model(&model.Project{}).Where(`
		id IN (
			SELECT id
			FROM projects p
			INNER JOIN workspace_admins wa
			ON p.workspace_id = wa.workspace_id
			AND wa.admin_id = ?
			AND (
				wa.project_ids IS NULL 
				OR p.id = ANY(wa.project_ids))
		)
	`, admin.ID).Scan(&projects).Error; err != nil {
		return nil, e.Wrap(err, "error getting associated projects")
	}

	workspaces, err := r.Workspaces(ctx)
	if err != nil {
		return nil, err
	}
	workspacesById := lo.KeyBy(workspaces, func(workspace *model.Workspace) int {
		return workspace.ID
	})

	for _, project := range projects {
		project.Workspace = workspacesById[project.WorkspaceID]
	}

	return projects, nil
}

// Workspaces is the resolver for the workspaces field.
func (r *queryResolver) Workspaces(ctx context.Context) ([]*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, nil
	}

	workspaces := []*model.Workspace{}
	if err := r.DB.Order("id ASC").Model(&admin).Association("Workspaces").Find(&workspaces); err != nil {
		return nil, e.Wrap(err, "error getting associated workspaces")
	}

	for _, w := range workspaces {
		r.SetDefaultRetention(w)
	}

	return workspaces, nil
}

// WorkspacesCount is the resolver for the workspaces_count field.
func (r *queryResolver) WorkspacesCount(ctx context.Context) (int64, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return 0, err
	}

	var workspacesCount int64
	if err := r.DB.WithContext(ctx).Table("workspace_admins").Where("admin_id=?", admin.ID).Count(&workspacesCount).Error; err != nil {
		return 0, e.Wrap(err, "error getting count of workspaces for admin")
	}

	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		log.WithContext(ctx).Error(err)
		return workspacesCount, nil
	}
	var joinableWorkspacesCount int64
	if err := r.DB.WithContext(ctx).Raw(`
			SELECT COUNT(*)
			FROM workspaces
			WHERE id NOT IN (
					SELECT workspace_id
					FROM workspace_admins
					WHERE admin_id = ? )
				AND jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))
		`, admin.ID, domain).Scan(&joinableWorkspacesCount).Error; err != nil {
		return 0, e.Wrap(err, "error getting count of joinable workspaces for admin")
	}

	return joinableWorkspacesCount + workspacesCount, nil
}

// JoinableWorkspaces is the resolver for the joinable_workspaces field.
func (r *queryResolver) JoinableWorkspaces(ctx context.Context) ([]*model.Workspace, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	var joinableWorkspaces []*model.Workspace
	domain, err := r.getCustomVerifiedAdminEmailDomain(admin)
	if err != nil {
		// cannot join workspaces with a public email
		return joinableWorkspaces, nil
	}

	if err := r.DB.WithContext(ctx).Model(&model.Workspace{}).
		Where(`id NOT IN (
			SELECT workspace_id
			FROM workspace_admins
			WHERE admin_id = ?
			)
			AND jsonb_exists(allowed_auto_join_email_origins::jsonb, LOWER(?))`, admin.ID, domain).
		Order("workspaces.name").
		Preload("Projects").
		Find(&joinableWorkspaces).Error; err != nil {
		return nil, e.Wrap(err, "error getting joinable workspaces")
	}

	return joinableWorkspaces, nil
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, projectID int) ([]*model.Alert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	alerts := []*model.Alert{}
	if err := r.DB.Order("created_at asc").Model(&model.Alert{}).Preload("Destinations").Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, err
	}
	return alerts, nil
}

// Alert is the resolver for the alert field.
func (r *queryResolver) Alert(ctx context.Context, id int) (*model.Alert, error) {
	var alert *model.Alert
	if err := r.DB.WithContext(ctx).Model(&model.Alert{}).Preload("Destinations").Where("id = ?", id).Find(&alert).Error; err != nil {
		return nil, err
	}

	_, err := r.isUserInProjectOrDemoProject(ctx, alert.ProjectID)
	if err != nil {
		return nil, err
	}

	return alert, nil
}

// AlertStateChanges is the resolver for the alert_state_changes field.
func (r *queryResolver) AlertStateChanges(ctx context.Context, alertID int) ([]*modelInputs.AlertStateChange, error) {
	// TODO(spenny): fetch alert state changes from clickhouse
	return []*modelInputs.AlertStateChange{}, nil
}

// ErrorAlerts is the resolver for the error_alerts field.
func (r *queryResolver) ErrorAlerts(ctx context.Context, projectID int) ([]*model.ErrorAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	alerts := []*model.ErrorAlert{}
	if err := r.DB.Order("created_at asc").Model(&model.ErrorAlert{}).Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying error alerts")
	}
	return alerts, nil
}

// NewUserAlerts is the resolver for the new_user_alerts field.
func (r *queryResolver) NewUserAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.SessionAlert
	if err := r.DB.WithContext(ctx).Model(&model.SessionAlert{}).Where("project_id = ?", projectID).
		Where("type IS NULL OR type=?", model.AlertType.NEW_USER).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying new user alerts")
	}
	return alerts, nil
}

// TrackPropertiesAlerts is the resolver for the track_properties_alerts field.
func (r *queryResolver) TrackPropertiesAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.SessionAlert
	if err := r.DB.WithContext(ctx).Where(&model.SessionAlert{AlertDeprecated: model.AlertDeprecated{Type: &model.AlertType.TRACK_PROPERTIES}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying track properties alerts")
	}
	return alerts, nil
}

// UserPropertiesAlerts is the resolver for the user_properties_alerts field.
func (r *queryResolver) UserPropertiesAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.SessionAlert
	if err := r.DB.WithContext(ctx).Where(&model.SessionAlert{AlertDeprecated: model.AlertDeprecated{Type: &model.AlertType.USER_PROPERTIES}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying user properties alerts")
	}
	return alerts, nil
}

// NewSessionAlerts is the resolver for the new_session_alerts field.
func (r *queryResolver) NewSessionAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.SessionAlert
	if err := r.DB.WithContext(ctx).Where(&model.SessionAlert{AlertDeprecated: model.AlertDeprecated{Type: &model.AlertType.NEW_SESSION}}).
		Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying new session alerts")
	}
	return alerts, nil
}

// RageClickAlerts is the resolver for the rage_click_alerts field.
func (r *queryResolver) RageClickAlerts(ctx context.Context, projectID int) ([]*model.SessionAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.SessionAlert
	if err := r.DB.WithContext(ctx).Model(&model.SessionAlert{}).Where("project_id = ?", projectID).
		Where("type=?", model.AlertType.RAGE_CLICK).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying rage click alert")
	}
	return alerts, nil
}

// LogAlerts is the resolver for the log_alerts field.
func (r *queryResolver) LogAlerts(ctx context.Context, projectID int) ([]*model.LogAlert, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	var alerts []*model.LogAlert
	if err := r.DB.WithContext(ctx).Model(&model.LogAlert{}).Where("project_id = ?", projectID).Find(&alerts).Error; err != nil {
		return nil, e.Wrap(err, "error querying log alerts")
	}
	return alerts, nil
}

// LogAlert is the resolver for the log_alert field.
func (r *queryResolver) LogAlert(ctx context.Context, id int) (*model.LogAlert, error) {
	var alert *model.LogAlert
	if err := r.DB.WithContext(ctx).Model(&model.LogAlert{}).Where("id = ?", id).Find(&alert).Error; err != nil {
		return nil, e.Wrap(err, "error querying log alert")
	}
	_, err := r.isUserInProjectOrDemoProject(ctx, alert.ProjectID)
	if err != nil {
		return nil, err
	}
	return alert, nil
}

// ProjectSuggestion is the resolver for the projectSuggestion field.
func (r *queryResolver) ProjectSuggestion(ctx context.Context, query string) ([]*model.Project, error) {
	projects := []*model.Project{}
	if r.isWhitelistedAccount(ctx) {
		if err := r.DB.WithContext(ctx).Model(&model.Project{}).Where("name ILIKE ?", "%"+query+"%").Find(&projects).Error; err != nil {
			return nil, e.Wrap(err, "error getting associated projects")
		}
	}
	return projects, nil
}

// EnvironmentSuggestion is the resolver for the environment_suggestion field.
func (r *queryResolver) EnvironmentSuggestion(ctx context.Context, projectID int) ([]*model.Field, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	fields := []*model.Field{}
	res := r.DB.WithContext(ctx).Where(&model.Field{Type: "session", Name: "environment"}).
		Where("project_id = ?", projectID).
		Where("length(value) > ?", 0).
		Distinct("value").
		Find(&fields)
	if err := res.Error; err != nil {
		return nil, e.Wrap(err, "error querying field suggestion")
	}
	return fields, nil
}

// IdentifierSuggestion is the resolver for the identifier_suggestion field.
func (r *queryResolver) IdentifierSuggestion(ctx context.Context, projectID int, query string) ([]string, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	// Suggest identifiers for sessions >= 1 month old
	return r.ClickhouseClient.QueryFieldValues(ctx, projectID, 50, "user", "identifier", query, time.Now().AddDate(0, -1, 0), time.Now())
}

// SlackChannelSuggestion is the resolver for the slack_channel_suggestion field.
func (r *queryResolver) SlackChannelSuggestion(ctx context.Context, projectID int) ([]*modelInputs.SanitizedSlackChannel, error) {
	// We intentionally don't allow access to this in demo to not leak our Slack channels.
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	chs, err := workspace.IntegratedSlackChannels()
	if err != nil {
		return nil, e.Wrap(err, "error retrieving existing channels")
	}
	ret := []*modelInputs.SanitizedSlackChannel{}
	for _, ch := range chs {
		channel := ch.WebhookChannel
		channelID := ch.WebhookChannelID
		ret = append(ret, &modelInputs.SanitizedSlackChannel{
			WebhookChannel:   &channel,
			WebhookChannelID: &channelID,
		})
	}
	return ret, nil
}

// MicrosoftTeamsChannelSuggestions is the resolver for the microsoft_teams_channel_suggestions field.
func (r *queryResolver) MicrosoftTeamsChannelSuggestions(ctx context.Context, projectID int) ([]*model.MicrosoftTeamsChannel, error) {
	ret := []*model.MicrosoftTeamsChannel{}

	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return ret, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	tenantId := workspace.MicrosoftTeamsTenantId

	if tenantId == nil {
		return ret, nil
	}

	channels, err := microsoft_teams.GetChannelSuggestions(workspace)

	if err != nil {
		return ret, nil
	}

	return channels, nil
}

// DiscordChannelSuggestions is the resolver for the discord_channel_suggestions field.
func (r *queryResolver) DiscordChannelSuggestions(ctx context.Context, projectID int) ([]*model.DiscordChannel, error) {
	ret := []*model.DiscordChannel{}

	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return ret, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	guildId := workspace.DiscordGuildId

	if guildId == nil {
		return ret, nil
	}

	bot, err := discord.NewDiscordBot(*guildId)

	if err != nil {
		return ret, err
	}

	channels, err := bot.GetChannels()

	if err != nil {
		return ret, err
	}

	for _, ch := range channels {
		ret = append(ret, &model.DiscordChannel{
			ID:   ch.ID,
			Name: ch.Name,
		})
	}

	return ret, nil
}

// GenerateZapierAccessToken is the resolver for the generate_zapier_access_token field.
func (r *queryResolver) GenerateZapierAccessToken(ctx context.Context, projectID int) (string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return "", err
	}

	if project.ZapierAccessToken != nil {
		return "", e.New("zapier access token already exists, can't generate another jwt")
	}

	token, err := zapier.GenerateZapierAccessToken(project.ID)
	if err != nil {
		return "", e.Wrap(err, "error generating zapier access token")
	}

	return token, nil
}

// SearchIssues is the resolver for the search_issues field.
func (r *queryResolver) SearchIssues(ctx context.Context, integrationType modelInputs.IntegrationType, projectID int, query string) ([]*modelInputs.IssuesSearchResult, error) {
	ret := []*modelInputs.IssuesSearchResult{}

	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return ret, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	if integrationType == modelInputs.IntegrationTypeJira {
		results, err := r.SearchJiraIssues(ctx, workspace, query)
		if err != nil {
			return ret, err
		}
		return results, nil
	}

	if integrationType == modelInputs.IntegrationTypeHeight {
		results, err := r.SearchHeightIssues(ctx, workspace, query)
		if err != nil {
			return ret, err
		}
		return results, nil
	}

	if integrationType == modelInputs.IntegrationTypeGitLab {
		results, err := r.SearchGitlabIssues(ctx, workspace, query)
		if err != nil {
			return ret, err
		}
		return results, nil
	}

	if integrationType == modelInputs.IntegrationTypeLinear {
		results, err := r.SearchLinearIssues(*workspace.LinearAccessToken, query)
		if err != nil {
			return ret, err
		}
		return results, nil
	}

	if integrationType == modelInputs.IntegrationTypeGitHub {
		results, err := r.SearchGitHubIssues(ctx, workspace, query)
		if err != nil {
			return ret, err
		}
		return results, nil
	}
	return ret, e.New(fmt.Sprintf("invalid integrationType: %s", integrationType))
}

// IsIntegratedWith is the resolver for the is_integrated_with field.
func (r *queryResolver) IsIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return false, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return false, err
	}

	if integrationType == modelInputs.IntegrationTypeLinear {
		return workspace.LinearAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeSlack {
		return workspace.SlackAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeZapier {
		return project.ZapierAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeMicrosoftTeams {
		return workspace.MicrosoftTeamsTenantId != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeFront {
		if project.FrontAccessToken == nil || project.FrontRefreshToken == nil || project.FrontTokenExpiresAt == nil {
			return false, nil
		}
		oauth, err := front.RefreshOAuth(ctx, &front.OAuthToken{
			AccessToken:  *project.FrontAccessToken,
			RefreshToken: *project.FrontRefreshToken,
			ExpiresAt:    project.FrontTokenExpiresAt.Unix(),
		})
		if err != nil {
			return false, e.Wrap(err, "failed to refresh oauth")
		}
		if err := r.saveFrontOAuth(project, oauth); err != nil {
			return false, e.Wrap(err, "failed to save oauth")
		}
		return project.FrontAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeVercel {
		// If there is an error accessing the Vercel projects, user needs to integrate again
		_, err := r.VercelProjects(ctx, projectID)
		if err != nil {
			return false, err
		}
		return workspace.VercelAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeDiscord {
		return workspace.DiscordGuildId != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeHeroku {
		projectMapping := &model.IntegrationProjectMapping{}
		if err := r.DB.WithContext(ctx).Where(&model.IntegrationProjectMapping{
			ProjectID:       projectID,
			IntegrationType: integrationType,
		}).Take(&projectMapping).Error; err != nil {
			return false, nil
		}
		return projectMapping != nil, nil
	} else {
		workspaceMapping := &model.IntegrationWorkspaceMapping{}
		if err := r.DB.WithContext(ctx).Where(&model.IntegrationWorkspaceMapping{
			WorkspaceID:     workspace.ID,
			IntegrationType: integrationType,
		}).First(&workspaceMapping).Error; err != nil {
			return false, err
		}
		if workspaceMapping.WorkspaceID == 0 {
			return true, nil
		}

		projectMapping := &model.IntegrationProjectMapping{}
		if err := r.DB.WithContext(ctx).Where(&model.IntegrationProjectMapping{
			ProjectID:       projectID,
			IntegrationType: integrationType,
		}).Take(&projectMapping).Error; err != nil {
			return false, nil
		}
		return projectMapping != nil, nil
	}
}

// IsWorkspaceIntegratedWith is the resolver for the is_workspace_integrated_with field.
func (r *queryResolver) IsWorkspaceIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, workspaceID int) (bool, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return false, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return false, err
	}

	if integrationType == modelInputs.IntegrationTypeClickUp {
		return workspace.ClickupAccessToken != nil, nil
	} else if integrationType == modelInputs.IntegrationTypeMicrosoftTeams {
		return workspace.MicrosoftTeamsTenantId != nil, nil
	} else {
		workspaceMapping := &model.IntegrationWorkspaceMapping{}
		if err := r.DB.WithContext(ctx).Where(&model.IntegrationWorkspaceMapping{
			WorkspaceID:     workspace.ID,
			IntegrationType: integrationType,
		}).Take(&workspaceMapping).Error; err != nil {
			return false, nil
		}

		if workspaceMapping == nil {
			return false, nil
		}
	}

	return true, nil
}

// IsProjectIntegratedWith is the resolver for the is_project_integrated_with field.
func (r *queryResolver) IsProjectIntegratedWith(ctx context.Context, integrationType modelInputs.IntegrationType, projectID int) (bool, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)

	if err != nil {
		return false, err
	}

	return r.IntegrationsClient.IsProjectIntegrated(ctx, project, integrationType)
}

// VercelProjects is the resolver for the vercel_projects field.
func (r *queryResolver) VercelProjects(ctx context.Context, projectID int) ([]*modelInputs.VercelProject, error) {
	project, err := r.isUserInProject(ctx, projectID)
	ret := []*modelInputs.VercelProject{}
	if err != nil {
		return ret, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	// Workspace does not have linear set up yet, don't have to treat this as an error
	if workspace.VercelAccessToken == nil {
		return ret, nil
	}

	res, err := vercel.GetProjects(*workspace.VercelAccessToken, workspace.VercelTeamID)
	if err != nil {
		return ret, e.Wrap(err, "error getting vercel teams")
	}

	return res, nil
}

// VercelProjectMappings is the resolver for the vercel_project_mappings field.
func (r *queryResolver) VercelProjectMappings(ctx context.Context, projectID int) ([]*modelInputs.VercelProjectMapping, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	rows := []*model.VercelIntegrationConfig{}
	if err := r.DB.WithContext(ctx).Where("workspace_id = ?", project.WorkspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.VercelIntegrationConfig, idx int) *modelInputs.VercelProjectMapping {
		return &modelInputs.VercelProjectMapping{
			VercelProjectID: c.VercelProjectID,
			ProjectID:       c.ProjectID,
		}
	})

	return results, nil
}

// ClickupTeams is the resolver for the clickup_teams field.
func (r *queryResolver) ClickupTeams(ctx context.Context, workspaceID int) ([]*modelInputs.ClickUpTeam, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return []*modelInputs.ClickUpTeam{}, nil
	}

	teams, err := clickup.GetTeams(*workspace.ClickupAccessToken)
	if err != nil {
		return nil, err
	}

	for _, t := range teams {
		t.Spaces, err = clickup.GetSpaces(*workspace.ClickupAccessToken, t.ID)
		if err != nil {
			return nil, err
		}
	}

	return teams, nil
}

// ClickupProjectMappings is the resolver for the clickup_project_mappings field.
func (r *queryResolver) ClickupProjectMappings(ctx context.Context, workspaceID int) ([]*modelInputs.ClickUpProjectMapping, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	rows := []*model.IntegrationProjectMapping{}
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT * FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, modelInputs.IntegrationTypeClickUp, workspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.IntegrationProjectMapping, idx int) *modelInputs.ClickUpProjectMapping {
		return &modelInputs.ClickUpProjectMapping{
			ProjectID:      c.ProjectID,
			ClickupSpaceID: c.ExternalID,
		}
	})

	return results, nil
}

// ClickupFolders is the resolver for the clickup_folders field.
func (r *queryResolver) ClickupFolders(ctx context.Context, projectID int) ([]*modelInputs.ClickUpFolder, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return nil, e.New("workspace does not have an access token")
	}

	var settings model.IntegrationProjectMapping
	if err := r.DB.WithContext(ctx).Where(&model.IntegrationProjectMapping{
		ProjectID: projectID, IntegrationType: modelInputs.IntegrationTypeClickUp}).
		Find(&settings).Error; err != nil {
		return nil, err
	}

	if settings.ExternalID == "" {
		return nil, e.New("Project does not have an associated ClickUp space")
	}

	return clickup.GetFolders(*workspace.ClickupAccessToken, settings.ExternalID)
}

// ClickupFolderlessLists is the resolver for the clickup_folderless_lists field.
func (r *queryResolver) ClickupFolderlessLists(ctx context.Context, projectID int) ([]*modelInputs.ClickUpList, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	if workspace.ClickupAccessToken == nil {
		return nil, e.New("workspace does not have an access token")
	}

	var settings model.IntegrationProjectMapping
	if err := r.DB.WithContext(ctx).Where(&model.IntegrationProjectMapping{
		ProjectID: projectID, IntegrationType: modelInputs.IntegrationTypeClickUp}).
		Find(&settings).Error; err != nil {
		return nil, err
	}

	if settings.ExternalID == "" {
		return nil, e.New("Project does not have an associated ClickUp space")
	}

	return clickup.GetFolderlessLists(*workspace.ClickupAccessToken, settings.ExternalID)
}

// HeightLists is the resolver for the height_lists field.
func (r *queryResolver) HeightLists(ctx context.Context, projectID int) ([]*modelInputs.HeightList, error) {
	project, err := r.isUserInProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return nil, err
	}

	accessToken, err := r.IntegrationsClient.GetWorkspaceAccessToken(ctx, workspace, modelInputs.IntegrationTypeHeight)

	if err != nil {
		return nil, err
	}

	lists, err := height.GetLists(*accessToken)

	return lists, err
}

// HeightWorkspaces is the resolver for the height_workspaces field.
func (r *queryResolver) HeightWorkspaces(ctx context.Context, workspaceID int) ([]*modelInputs.HeightWorkspace, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	accessToken, err := r.IntegrationsClient.GetWorkspaceAccessToken(ctx, workspace, modelInputs.IntegrationTypeHeight)

	if err != nil {
		return nil, err
	}

	if accessToken == nil {
		return []*modelInputs.HeightWorkspace{}, nil
	}

	workspaces, err := height.GetWorkspaces(*accessToken)

	return workspaces, err
}

// IntegrationProjectMappings is the resolver for the integration_project_mappings field.
func (r *queryResolver) IntegrationProjectMappings(ctx context.Context, workspaceID int, integrationType *modelInputs.IntegrationType) ([]*model.IntegrationProjectMapping, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	rows := []*model.IntegrationProjectMapping{}
	if err := r.DB.WithContext(ctx).Raw(`
		SELECT * FROM integration_project_mappings ipm
		WHERE ipm.integration_type = ?
		AND EXISTS (
			SELECT *
			FROM projects p
			WHERE p.workspace_id = ?
			AND ipm.project_id = p.id
		)
	`, integrationType, workspaceID).Find(&rows).Error; err != nil {
		return nil, err
	}

	return rows, nil
}

// LinearTeams is the resolver for the linear_teams field.
func (r *queryResolver) LinearTeams(ctx context.Context, projectID int) ([]*modelInputs.LinearTeam, error) {
	project, err := r.isUserInProject(ctx, projectID)
	ret := []*modelInputs.LinearTeam{}

	if err != nil {
		return ret, err
	}

	workspace, err := r.GetWorkspace(project.WorkspaceID)
	if err != nil {
		return ret, err
	}

	// Workspace does not have linear set up yet, don't have to treat this as an error
	if workspace.LinearAccessToken == nil {
		return ret, nil
	}

	res, err := r.GetLinearTeams(*workspace.LinearAccessToken)

	if err != nil {
		return ret, e.Wrap(err, "error getting linear teams")
	}

	teamResponse := res.Data.Teams.Nodes

	ret = lo.Map(teamResponse, func(team LinearTeam, _ int) *modelInputs.LinearTeam {
		return &modelInputs.LinearTeam{
			TeamID: team.ID,
			Name:   team.Name,
			Key:    team.Key,
		}
	})

	return ret, nil
}

// JiraProjects is the resolver for the jira_projects field.
func (r *queryResolver) JiraProjects(ctx context.Context, workspaceID int) ([]*modelInputs.JiraProject, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	return r.GetJiraProjects(ctx, workspace)
}

// GitlabProjects is the resolver for the gitlab_projects field.
func (r *queryResolver) GitlabProjects(ctx context.Context, workspaceID int) ([]*modelInputs.GitlabProject, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	return r.GetGitlabProjects(ctx, workspace)
}

// GithubRepos is the resolver for the github_repos field.
func (r *queryResolver) GithubRepos(ctx context.Context, workspaceID int) ([]*modelInputs.GitHubRepo, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	return r.GetGitHubRepos(ctx, workspace)
}

// GithubIssueLabels is the resolver for the github_issue_labels field.
func (r *queryResolver) GithubIssueLabels(ctx context.Context, workspaceID int, repository string) ([]string, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	workspace, err := r.GetWorkspace(workspaceID)
	if err != nil {
		return nil, err
	}

	return r.GetGitHubIssueLabels(ctx, workspace, repository)
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id int) (*model.Project, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, id)
	if err != nil {
		return nil, err
	}

	if r.isDemoProject(ctx, id) {
		workspace, err := r.GetWorkspace(project.WorkspaceID)
		if err != nil {
			return nil, e.Wrap(err, "error querying workspace")
		}

		threeMonth := modelInputs.RetentionPeriodThreeMonths
		return &model.Project{
			Model: project.Model,
			Name:  project.Name,
			Workspace: &model.Workspace{
				Model:                 workspace.Model,
				Name:                  workspace.Name,
				RetentionPeriod:       &threeMonth,
				ErrorsRetentionPeriod: &threeMonth,
				Projects: []model.Project{{
					Model: project.Model,
					Name:  project.Name,
				}},
			},
		}, nil
	}

	workspace, err := r.Workspace(ctx, project.WorkspaceID)
	if err != nil {
		return nil, err
	}
	project.Workspace = workspace

	return project, nil
}

// ProjectSettings is the resolver for the projectSettings field.
func (r *queryResolver) ProjectSettings(ctx context.Context, projectID int) (*modelInputs.AllProjectSettings, error) {
	project, err := r.Project(ctx, projectID)
	if err != nil {
		return nil, err
	}

	projectFilterSettings, err := r.Store.GetProjectFilterSettings(ctx, project.ID, redis.WithBypassCache(true))
	if err != nil {
		return nil, err
	}

	allProjectSettings := modelInputs.AllProjectSettings{
		ID:                                project.ID,
		Name:                              *project.Name,
		BillingEmail:                      project.BillingEmail,
		ExcludedUsers:                     project.ExcludedUsers,
		ErrorFilters:                      project.ErrorFilters,
		ErrorJSONPaths:                    project.ErrorJsonPaths,
		RageClickWindowSeconds:            &project.RageClickWindowSeconds,
		RageClickRadiusPixels:             &project.RageClickRadiusPixels,
		RageClickCount:                    &project.RageClickCount,
		FilterChromeExtension:             project.FilterChromeExtension,
		FilterSessionsWithoutError:        projectFilterSettings.FilterSessionsWithoutError,
		AutoResolveStaleErrorsDayInterval: projectFilterSettings.AutoResolveStaleErrorsDayInterval,
		Sampling: &modelInputs.Sampling{
			SessionSamplingRate:    projectFilterSettings.SessionSamplingRate,
			ErrorSamplingRate:      projectFilterSettings.ErrorSamplingRate,
			LogSamplingRate:        projectFilterSettings.LogSamplingRate,
			TraceSamplingRate:      projectFilterSettings.TraceSamplingRate,
			SessionMinuteRateLimit: projectFilterSettings.SessionMinuteRateLimit,
			ErrorMinuteRateLimit:   projectFilterSettings.ErrorMinuteRateLimit,
			LogMinuteRateLimit:     projectFilterSettings.LogMinuteRateLimit,
			TraceMinuteRateLimit:   projectFilterSettings.TraceMinuteRateLimit,
			SessionExclusionQuery:  projectFilterSettings.SessionExclusionQuery,
			ErrorExclusionQuery:    projectFilterSettings.ErrorExclusionQuery,
			LogExclusionQuery:      projectFilterSettings.LogExclusionQuery,
			TraceExclusionQuery:    projectFilterSettings.TraceExclusionQuery,
		},
	}

	return &allProjectSettings, nil
}

// Workspace is the resolver for the workspace field.
func (r *queryResolver) Workspace(ctx context.Context, id int) (*model.Workspace, error) {
	workspace, err := r.isUserInWorkspaceReadOnly(ctx, id)
	if err != nil {
		return nil, nil
	}

	projects, err := r.Projects(ctx)
	if err != nil {
		return nil, nil
	}

	r.SetDefaultRetention(workspace)

	if r.isWhitelistedAccount(ctx) {
		projects := []model.Project{}
		if err := r.DB.WithContext(ctx).Order("name ASC").Model(&workspace).Association("Projects").Find(&projects); err != nil {
			return nil, nil
		}
		workspace.Projects = projects
		return workspace, nil
	}

	workspace.Projects = lo.FilterMap(projects, func(p *model.Project, _ int) (model.Project, bool) {
		if p == nil {
			return model.Project{}, false
		}

		p.Workspace = workspace

		return *p, p.WorkspaceID == id
	})

	return workspace, nil
}

// WorkspaceForInviteLink is the resolver for the workspace_for_invite_link field.
func (r *queryResolver) WorkspaceForInviteLink(ctx context.Context, secret string) (*modelInputs.WorkspaceForInviteLink, error) {
	var workspaceInviteLink model.WorkspaceInviteLink
	if err := r.DB.WithContext(ctx).Where(&model.WorkspaceInviteLink{Secret: &secret}).Take(&workspaceInviteLink).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace invite link")
	}

	if r.IsInviteLinkExpired(&workspaceInviteLink) {
		return nil, e.New("invite link expired")
	}

	var workspace model.Workspace
	if err := r.DB.WithContext(ctx).Model(&model.Workspace{}).Where("id = ?", *workspaceInviteLink.WorkspaceID).Take(&workspace).Error; err != nil {
		return nil, e.Wrap(err, "error querying workspace for invite link")
	}

	var projectId int
	if err := r.DB.Model(&model.Project{}).Select("id").Where("workspace_id = ?", workspace.ID).Order("id ASC").First(&projectId).Error; err != nil {
		return nil, e.Wrap(err, "error querying associated project")
	}

	var admin *model.Admin
	if workspaceInviteLink.InviteeEmail != nil {
		if err := r.DB.WithContext(ctx).Model(&model.Admin{Email: workspaceInviteLink.InviteeEmail}).Take(&admin).Error; err != nil {
			return nil, e.Wrap(err, "error querying admin for invitee_email")
		}
	}

	workspaceForInvite := &modelInputs.WorkspaceForInviteLink{
		ExpirationDate:  workspaceInviteLink.ExpirationDate,
		InviteeEmail:    workspaceInviteLink.InviteeEmail,
		Secret:          *workspaceInviteLink.Secret,
		WorkspaceID:     workspace.ID,
		WorkspaceName:   *workspace.Name,
		ExistingAccount: admin != nil,
		ProjectID:       projectId,
	}

	return workspaceForInvite, nil
}

// WorkspaceInviteLinks is the resolver for the workspace_invite_links field.
func (r *queryResolver) WorkspaceInviteLinks(ctx context.Context, workspaceID int) (*model.WorkspaceInviteLink, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	var workspaceInviteLink *model.WorkspaceInviteLink
	shouldCreateNewInviteLink := false

	if err := r.DB.WithContext(ctx).Where(&model.WorkspaceInviteLink{WorkspaceID: &workspaceID, InviteeEmail: nil}).Where("invitee_email IS NULL").Order("created_at desc").Take(&workspaceInviteLink).Error; err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			shouldCreateNewInviteLink = true
		} else {
			return nil, e.Wrap(err, "error querying workspace invite links")
		}
	}

	if r.IsInviteLinkExpired(workspaceInviteLink) && !shouldCreateNewInviteLink {
		shouldCreateNewInviteLink = true
	}

	if workspaceInviteLink != nil && workspaceInviteLink.ExpirationDate != nil {
		// Create a new invite link if the current one expires within 7 days.
		daysRemainingForInvite := int(math.Abs(time.Now().UTC().Sub(*workspaceInviteLink.ExpirationDate).Hours() / 24))
		if daysRemainingForInvite <= 7 {
			shouldCreateNewInviteLink = true
		}

	}

	if shouldCreateNewInviteLink {
		workspaceInviteLink = r.CreateInviteLink(workspaceID, nil, model.AdminRole.MEMBER, true, nil)

		if err := r.DB.WithContext(ctx).Create(&workspaceInviteLink).Error; err != nil {
			return nil, e.Wrap(err, "failed to create new invite link to replace expired one.")
		}
	}

	return workspaceInviteLink, nil
}

// WorkspacePendingInvites is the resolver for the workspacePendingInvites field.
func (r *queryResolver) WorkspacePendingInvites(ctx context.Context, workspaceID int) ([]*model.WorkspaceInviteLink, error) {
	_, err := r.isUserInWorkspace(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}

	var pendingInvites []*model.WorkspaceInviteLink
	var queryErr = r.DB.
		Where(&model.WorkspaceInviteLink{WorkspaceID: &workspaceID}).
		Where("invitee_email IS NOT NULL").
		Order("created_at DESC").
		Find(&pendingInvites).
		Error

	if queryErr != nil {
		return nil, e.Wrap(queryErr, "error getting invite links for the workspace")
	}

	return pendingInvites, nil
}

// WorkspaceSettings is the resolver for the workspaceSettings field.
func (r *queryResolver) WorkspaceSettings(ctx context.Context, workspaceID int) (*model.AllWorkspaceSettings, error) {
	_, err := r.isUserInWorkspaceReadOnly(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	return r.Store.GetAllWorkspaceSettings(ctx, workspaceID)
}

// WorkspaceForProject is the resolver for the workspace_for_project field.
func (r *queryResolver) WorkspaceForProject(ctx context.Context, projectID int) (*model.Workspace, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	if r.isDemoProject(ctx, projectID) {
		workspace, err := r.GetWorkspace(project.WorkspaceID)
		if err != nil {
			return nil, e.Wrap(err, "error querying workspace")
		}

		threeMonth := modelInputs.RetentionPeriodThreeMonths
		return &model.Workspace{
			Model:                 workspace.Model,
			Name:                  workspace.Name,
			RetentionPeriod:       &threeMonth,
			ErrorsRetentionPeriod: &threeMonth,
			Projects: []model.Project{{
				Model: project.Model,
				Name:  project.Name,
			}},
		}, nil
	}

	return r.Workspace(ctx, project.WorkspaceID)
}

// Admin is the resolver for the admin field.
func (r *queryResolver) Admin(ctx context.Context) (*model.Admin, error) {
	uid := ctx.Value(model.ContextKeys.UID)
	if uid == nil {
		return nil, e.New("uid not found in context")
	}

	admin := &model.Admin{UID: pointy.String(fmt.Sprintf("%v", uid))}
	adminSpan, ctx := util.StartSpanFromContext(ctx, "resolver.getAdmin", util.ResourceName("db.admin"),
		util.Tag("admin_uid", admin.UID))

	if err := r.DB.WithContext(ctx).Where(&model.Admin{UID: admin.UID}).Take(&admin).Error; err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			// Sometimes users don't exist in our DB because they authenticated with
			// Google auth and never went through the sign up flow. In this case, we
			// create a new user in our DB.
			if admin, err = r.createAdmin(ctx); err != nil {
				spanError := e.Wrap(err, "error creating admin in postgres")
				adminSpan.Finish(spanError)
				return nil, spanError
			}
		} else {
			spanError := e.Wrap(err, "error retrieving admin from postgres")
			adminSpan.Finish(spanError)
			return nil, spanError
		}
	}

	// Check email verification status
	if admin.EmailVerified != nil && !*admin.EmailVerified {
		firebaseSpan, _ := util.StartSpanFromContext(ctx, "db.updateAdminFromFirebaseForEmailVerification", util.ResourceName("resolver.getAdmin"),
			util.Tag("admin_uid", *admin.UID))
		firebaseUser, err := AuthClient.GetUser(context.Background(), *admin.UID)
		if err != nil {
			spanError := e.Wrap(err, "error retrieving user from firebase api for email verification")
			adminSpan.Finish(spanError)
			firebaseSpan.Finish(spanError)
			return nil, spanError
		}
		if err := r.DB.WithContext(ctx).Where(&model.Admin{UID: admin.UID}).Updates(&model.Admin{
			EmailVerified: &firebaseUser.EmailVerified,
		}).Error; err != nil {
			spanError := e.Wrap(err, "error updating admin fields")
			adminSpan.Finish(spanError)
			firebaseSpan.Finish(spanError)
			return nil, spanError
		}
		admin.EmailVerified = &firebaseUser.EmailVerified
		firebaseSpan.Finish()
	}

	adminSpan.Finish()
	return admin, nil
}

// AdminRole is the resolver for the admin_role field.
func (r *queryResolver) AdminRole(ctx context.Context, workspaceID int) (*model.WorkspaceAdminRole, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if r.isWhitelistedAccount(ctx) {
		return &model.WorkspaceAdminRole{
			WorkspaceId: workspaceID,
			Admin:       admin,
			Role:        model.AdminRole.ADMIN,
			ProjectIds:  nil,
		}, nil
	}

	// ok to have empty string role, treated as unauthenticated user
	role, projectIds, _ := r.getAdminRole(ctx, admin.ID, workspaceID)
	return &model.WorkspaceAdminRole{
		WorkspaceId: workspaceID,
		Admin:       admin,
		Role:        role,
		ProjectIds:  projectIds,
	}, nil
}

// AdminRoleByProject is the resolver for the admin_role_by_project field.
func (r *queryResolver) AdminRoleByProject(ctx context.Context, projectID int) (*model.WorkspaceAdminRole, error) {
	admin, err := r.getCurrentAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if r.isWhitelistedAccount(ctx) {
		project, err := r.Query().Project(ctx, projectID)
		if err != nil {
			return nil, err
		}
		workspace, err := r.GetWorkspace(project.WorkspaceID)
		if err != nil {
			return nil, err
		}
		return &model.WorkspaceAdminRole{
			WorkspaceId: workspace.ID,
			Admin:       admin,
			Role:        model.AdminRole.ADMIN,
			ProjectIds:  nil,
		}, nil
	}

	var role string
	var projectIds []int
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err == nil {
		if workspace, err := r.GetWorkspace(project.WorkspaceID); err == nil {
			// ok to have empty string role, treated as unauthenticated user
			role, projectIds, _ = r.getAdminRole(ctx, admin.ID, workspace.ID)
		}
	}

	var workspaceId int
	if project != nil {
		workspaceId = project.WorkspaceID
	}

	return &model.WorkspaceAdminRole{
		WorkspaceId: workspaceId,
		Admin:       admin,
		Role:        role,
		ProjectIds:  projectIds,
	}, nil
}

// SavedSegments is the resolver for the saved_segments field.
func (r *queryResolver) SavedSegments(ctx context.Context, projectID int, entityType modelInputs.SavedSegmentEntityType) ([]*model.SavedSegment, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	// list of maps, where each map represents a field query.
	segments := []*model.SavedSegment{}
	if err := r.DB.WithContext(ctx).Model(model.SavedSegment{}).Where("project_id = ? AND entity_type = ?", projectID, entityType).Find(&segments).Error; err != nil {
		log.WithContext(ctx).Errorf("error querying saved segments from project: %v", err)
	}
	return segments, nil
}

// APIKeyToOrgID is the resolver for the api_key_to_org_id field.
func (r *queryResolver) APIKeyToOrgID(ctx context.Context, apiKey string) (*int, error) {
	var projectId int
	if err := r.DB.Table("projects").Select("id").Where("secret=?", apiKey).Scan(&projectId).Error; err != nil {
		return nil, e.Wrap(err, "error getting project id from api key")
	}
	return &projectId, nil
}

// GetSourceMapUploadUrls is the resolver for the get_source_map_upload_urls field.
func (r *queryResolver) GetSourceMapUploadUrls(ctx context.Context, apiKey string, paths []string) ([]string, error) {
	projectId, err := r.APIKeyToOrgID(ctx, apiKey)
	if err != nil {
		return nil, err
	}
	if projectId == nil {
		return nil, e.New("invalid API key - project id is nil")
	}

	// Assert all paths start with this prefix to block cross-project uploads
	pathPrefix := fmt.Sprintf("%d/", *projectId)

	urls := []string{}
	for _, path := range paths {
		if !strings.HasPrefix(path, pathPrefix) {
			return nil, e.New("invalid path - does not start with project prefix")
		}
		url, err := r.StorageClient.GetSourceMapUploadUrl(ctx, path)
		if err != nil {
			return nil, err
		}
		urls = append(urls, url)
	}

	return urls, nil
}

// CustomerPortalURL is the resolver for the customer_portal_url field.
func (r *queryResolver) CustomerPortalURL(ctx context.Context, workspaceID int) (string, error) {
	frontendUri := env.Config.FrontendUri

	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return "", err
	}

	returnUrl := fmt.Sprintf("%s/w/%d/current-plan", frontendUri, workspaceID)

	params := &stripe.BillingPortalSessionParams{
		Customer:  workspace.StripeCustomerID,
		ReturnURL: &returnUrl,
	}

	portalSession, err := r.PricingClient.BillingPortalSessions.New(params)
	if err != nil {
		return "", e.Wrap(err, "error creating customer portal session")
	}

	return portalSession.URL, nil
}

// SubscriptionDetails is the resolver for the subscription_details field.
func (r *queryResolver) SubscriptionDetails(ctx context.Context, workspaceID int) (*modelInputs.SubscriptionDetails, error) {
	span, _ := util.StartSpanFromContext(ctx, "SubscriptionDetails", util.Tag("workspaceID", workspaceID))
	defer span.Finish()

	workspace, err := r.isUserWorkspaceAdmin(ctx, workspaceID)
	if err != nil {
		return nil, nil
	}
	if workspace.StripeCustomerID == nil {
		return nil, e.New("workspace has no stripe customer ID")
	}

	return redis.CachedEval(ctx, r.Redis, redis.GetSubscriptionDetailsKey(workspaceID), time.Minute, time.Minute, func() (*modelInputs.SubscriptionDetails, error) {
		customerParams := &stripe.CustomerParams{}
		customerParams.AddExpand("subscriptions")
		c, err := r.PricingClient.Customers.Get(*workspace.StripeCustomerID, customerParams)
		if err != nil {
			return nil, e.Wrap(err, "error querying stripe customer")
		}

		if len(c.Subscriptions.Data) == 0 {
			return &modelInputs.SubscriptionDetails{}, nil
		}

		amount := c.Subscriptions.Data[0].Items.Data[0].Price.UnitAmount
		details := &modelInputs.SubscriptionDetails{BaseAmount: amount}

		discount := c.Subscriptions.Data[0].Discount
		if discount != nil && discount.Coupon != nil {
			details.Discount = &modelInputs.SubscriptionDiscount{
				Name:    discount.Coupon.Name,
				Percent: discount.Coupon.PercentOff,
				Amount:  discount.Coupon.AmountOff,
			}
			if discount.Coupon.Duration != stripe.CouponDurationForever {
				t := time.Unix(discount.Start, 0).AddDate(0, int(discount.Coupon.DurationInMonths), 0)
				details.Discount.Until = &t
			}
		}

		invoiceID := c.Subscriptions.Data[0].LatestInvoice.ID
		invoiceParams := &stripe.InvoiceParams{}
		customerParams.AddExpand("invoice_items")
		invoice, err := r.PricingClient.Invoices.Get(invoiceID, invoiceParams)
		if err != nil {
			return nil, e.Wrap(err, "error querying stripe invoice")
		}

		if invoice != nil {
			invoiceDue := time.Unix(invoice.Created, 0)
			status := string(invoice.Status)
			details.LastInvoice = &modelInputs.Invoice{
				Date:         &invoiceDue,
				AmountDue:    &invoice.AmountDue,
				AmountPaid:   &invoice.AmountPaid,
				AttemptCount: &invoice.AttemptCount,
				Status:       &status,
				URL:          &invoice.HostedInvoiceURL,
			}
			warningSent, err := r.Redis.GetCustomerBillingWarning(ctx, ptr.ToString(workspace.StripeCustomerID))
			if err != nil {
				return nil, err
			}
			details.BillingIssue = !warningSent.IsZero()
		}

		if details.BillingIngestBlocked, err = r.Redis.GetCustomerBillingInvalid(ctx, ptr.ToString(workspace.StripeCustomerID)); err != nil {
			return nil, err
		}

		return details, nil
	})
}

// DashboardDefinitions is the resolver for the dashboard_definitions field.
func (r *queryResolver) DashboardDefinitions(ctx context.Context, projectID int) ([]*modelInputs.DashboardDefinition, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	var dashboards []*model.Dashboard
	if err := r.DB.Order("updated_at DESC").Preload("Metrics", func(db *gorm.DB) *gorm.DB {
		db = db.Order("id ASC")
		return db
	}).Preload("Metrics.Filters").Where(&model.Dashboard{ProjectID: projectID}).Find(&dashboards).Error; err != nil {
		return nil, err
	}

	var results []*modelInputs.DashboardDefinition
	for _, d := range dashboards {
		var metrics []*modelInputs.DashboardMetricConfig
		for _, metric := range d.Metrics {
			var filters []*modelInputs.MetricTagFilter
			for _, f := range metric.Filters {
				filters = append(filters, &modelInputs.MetricTagFilter{
					Tag:   f.Tag,
					Op:    f.Op,
					Value: f.Value,
				})
			}
			metrics = append(metrics, &modelInputs.DashboardMetricConfig{
				Name:                     metric.Name,
				Description:              metric.Description,
				ComponentType:            metric.ComponentType,
				ChartType:                metric.ChartType,
				Aggregator:               metric.Aggregator,
				MaxGoodValue:             metric.MaxGoodValue,
				MaxNeedsImprovementValue: metric.MaxNeedsImprovementValue,
				PoorValue:                metric.PoorValue,
				Units:                    metric.Units,
				HelpArticle:              metric.HelpArticle,
				MinValue:                 metric.MinValue,
				MinPercentile:            metric.MinPercentile,
				MaxValue:                 metric.MaxValue,
				MaxPercentile:            metric.MaxPercentile,
				Filters:                  filters,
				Groups:                   metric.Groups,
			})
		}
		results = append(results, &modelInputs.DashboardDefinition{
			ID:                d.ID,
			UpdatedAt:         d.UpdatedAt,
			ProjectID:         d.ProjectID,
			Name:              d.Name,
			Metrics:           metrics,
			LastAdminToEditID: d.LastAdminToEditID,
			Layout:            d.Layout,
			IsDefault:         d.IsDefault,
		})
	}
	return results, nil
}

// MetricTags is the resolver for the metric_tags field.
func (r *queryResolver) MetricTags(ctx context.Context, projectID int, metricName string, query *string) ([]string, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	keys, err := r.ClickhouseClient.TracesKeys(ctx, projectID, time.Now().Add(-30*24*time.Hour), time.Now(), query, nil)
	if err != nil {
		return nil, err
	}

	return lo.Map(keys, func(item *modelInputs.QueryKey, index int) string {
		return item.Name
	}), nil
}

// MetricTagValues is the resolver for the metric_tag_values field.
func (r *queryResolver) MetricTagValues(ctx context.Context, projectID int, metricName string, tagName string) ([]string, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}

	return r.ClickhouseClient.TracesKeyValues(ctx, projectID, tagName, time.Now().Add(-30*24*time.Hour), time.Now(), nil, nil)
}

// MetricsTimeline is the resolver for the metrics_timeline field.
func (r *queryResolver) MetricsTimeline(ctx context.Context, projectID int, metricName string, params modelInputs.DashboardParamsInput) ([]*modelInputs.DashboardPayload, error) {
	if _, err := r.isUserInProjectOrDemoProject(ctx, projectID); err != nil {
		return nil, err
	}
	return GetMetricTimeline(ctx, r.ClickhouseClient, projectID, metricName, params)
}

// NetworkHistogram is the resolver for the network_histogram field.
func (r *queryResolver) NetworkHistogram(ctx context.Context, projectID int, params modelInputs.NetworkHistogramParamsInput) (*modelInputs.CategoryHistogramPayload, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	metrics, err := r.ClickhouseClient.ReadTracesMetrics(ctx, projectID, modelInputs.QueryInput{
		Query: strings.Join([]string{string(highlight.TraceTypeAttribute), string(highlight.TraceTypeNetworkRequest)}, ":"),
		DateRange: &modelInputs.DateRangeRequiredInput{
			StartDate: time.Now().Add(time.Duration(-params.LookbackDays) * 24 * time.Hour),
			EndDate:   time.Now(),
		},
	}, string(modelInputs.MetricColumnDuration), []modelInputs.MetricAggregator{modelInputs.MetricAggregatorCount}, []string{string(semconv.HTTPURLKey)}, pointy.Int(48), string(modelInputs.MetricBucketByTimestamp), nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}

	result := &modelInputs.CategoryHistogramPayload{
		Buckets: []*modelInputs.CategoryHistogramBucket{},
	}
	for url, groups := range lo.GroupBy(metrics.Buckets, func(item *modelInputs.MetricBucket) string {
		return item.Group[0]
	}) {
		count := 0

		for _, g := range groups {
			if g.MetricValue != nil {
				count += int(*g.MetricValue)
			}
		}
		result.Buckets = append(result.Buckets, &modelInputs.CategoryHistogramBucket{
			Category: url,
			Count:    int(count),
		})
	}
	if len(result.Buckets) > 0 {
		sort.Slice(result.Buckets, func(i, j int) bool {
			return result.Buckets[i].Count > result.Buckets[j].Count
		})
		result.Buckets = result.Buckets[0:lo.Min([]int{30, len(result.Buckets) - 1})]
	}

	return result, nil
}

// MetricMonitors is the resolver for the metric_monitors field.
func (r *queryResolver) MetricMonitors(ctx context.Context, projectID int, metricName *string) ([]*model.MetricMonitor, error) {
	metricMonitors := []*model.MetricMonitor{}

	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return metricMonitors, nil
	}

	query := r.DB.Order("created_at asc").Model(&model.MetricMonitor{}).Where("project_id = ?", projectID)
	if metricName != nil && *metricName != "" {
		query = query.Where("metric_to_monitor = ?", *metricName)
	}
	if err := query.Find(&metricMonitors).Error; err != nil {
		return nil, e.Wrap(err, "error querying metric monitors")
	}
	return metricMonitors, nil
}

// EventChunkURL is the resolver for the event_chunk_url field.
func (r *queryResolver) EventChunkURL(ctx context.Context, secureID string, index int) (string, error) {
	session, err := r.canAdminViewSession(ctx, secureID)
	if err != nil {
		return "", nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, session.ProjectID, session.ID, storage.SessionContentsCompressed, pointy.Int(index))
	if err != nil {
		return "", e.Wrap(err, "error getting direct download URL")
	}

	if str == nil {
		return "", e.Wrap(err, "nil direct download URL")
	}

	return *str, err
}

// EventChunks is the resolver for the event_chunks field.
func (r *queryResolver) EventChunks(ctx context.Context, secureID string) ([]*model.EventChunk, error) {
	session, err := r.canAdminViewSession(ctx, secureID)
	if err != nil {
		return nil, nil
	}

	chunks := []*model.EventChunk{}
	if err := r.DB.Order("chunk_index ASC").Model(&model.EventChunk{}).Where(&model.EventChunk{SessionID: session.ID}).
		Scan(&chunks).Error; err != nil {
		return nil, e.Wrap(err, "error retrieving event chunks from DB")
	}

	return chunks, nil
}

// SourcemapFiles is the resolver for the sourcemap_files field.
func (r *queryResolver) SourcemapFiles(ctx context.Context, projectID int, version *string) ([]*modelInputs.S3File, error) {
	res, err := r.StorageClient.GetSourcemapFiles(ctx, projectID, version)
	var s3Files []*modelInputs.S3File

	if err != nil {
		return nil, e.Wrap(err, "error getting sourcemaps from s3")
	}

	for _, object := range res {
		s3File := modelInputs.S3File{Key: object.Key}
		s3Files = append(s3Files, &s3File)
	}

	return s3Files, nil
}

// SourcemapVersions is the resolver for the sourcemap_versions field.
func (r *queryResolver) SourcemapVersions(ctx context.Context, projectID int) ([]string, error) {
	res, err := r.StorageClient.GetSourcemapVersions(ctx, projectID)

	if err != nil {
		return nil, e.Wrap(err, "error getting sourcemaps from s3")
	}

	return res, nil
}

// OauthClientMetadata is the resolver for the oauth_client_metadata field.
func (r *queryResolver) OauthClientMetadata(ctx context.Context, clientID string) (*modelInputs.OAuthClient, error) {
	if clientID == "" {
		return nil, e.New("oauth client query received empty client id")
	}
	client := &model.OAuthClientStore{ID: clientID}
	if err := r.DB.WithContext(ctx).Model(&client).Select("id", "created_at", "app_name").Where(&client).Take(&client).Error; err != nil {
		return nil, e.Wrap(err, "error querying oauth client")
	}
	return &modelInputs.OAuthClient{
		ID:        client.ID,
		CreatedAt: client.CreatedAt,
		AppName:   client.AppName,
	}, nil
}

// EmailOptOuts is the resolver for the email_opt_outs field.
func (r *queryResolver) EmailOptOuts(ctx context.Context, token *string, adminID *int) ([]modelInputs.EmailOptOutCategory, error) {
	var adminIdDeref int
	if adminID != nil && token != nil {
		if !IsOptOutTokenValid(*adminID, *token) {
			return nil, e.New("token is not valid or has expired")
		}
		adminIdDeref = *adminID
	} else {
		admin, err := r.getCurrentAdmin(ctx)
		if err != nil {
			return nil, err
		}
		adminIdDeref = admin.ID
	}

	rows := []*model.EmailOptOut{}
	if err := r.DB.WithContext(ctx).Where("admin_id = ?", adminIdDeref).Find(&rows).Error; err != nil {
		return nil, err
	}

	results := lo.Map(rows, func(c *model.EmailOptOut, idx int) modelInputs.EmailOptOutCategory {
		return c.Category
	})

	return results, nil
}

// AiQuerySuggestion is the resolver for the ai_query_suggestion field.
func (r *queryResolver) AiQuerySuggestion(ctx context.Context, timeZone string, projectID int, productType modelInputs.ProductType, query string) (*modelInputs.QueryOutput, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	// create a list of key:value strings
	keyVals := []string{}
	keys := []string{}
	// switch on the product type to get the keys and values
	switch productType {
	case modelInputs.ProductTypeTraces:
		keys = append(keys, lo.Keys(clickhouse.TracesTableConfig.KeysToColumns)...)
	case modelInputs.ProductTypeLogs:
		keys = append(keys, lo.Keys(clickhouse.LogsTableConfig.KeysToColumns)...)
	case modelInputs.ProductTypeSessions:
		keys = append(keys, lo.Keys(clickhouse.SessionsTableConfig.KeysToColumns)...)
	case modelInputs.ProductTypeErrors:
		keys = append(keys, lo.Keys(clickhouse.ErrorGroupsTableConfig.KeysToColumns)...)
	}

	loc, err := time.LoadLocation(timeZone)
	if err != nil {
		loc, err = time.LoadLocation("America/Los_Angeles")
		if err != nil {
			return nil, e.Errorf("error loading location twice: %v", err)
		}
	}
	var sevenDaysAgo time.Time = time.Now().Add(-7 * 24 * time.Hour)
	for _, key := range keys {
		if key == "HighlightType" {
			continue
		}
		count := 10
		vals, err := r.KeyValues(
			ctx,
			&productType,
			projectID,
			key,
			modelInputs.DateRangeRequiredInput{
				StartDate: sevenDaysAgo,
				EndDate:   time.Now(),
			},
			nil,
			&count,
			nil,
		)
		if err != nil {
			return nil, err
		}
		for _, val := range vals {
			keyVals = append(keyVals, fmt.Sprintf("%s:%s", key, val))
		}
	}

	now := time.Now().In(loc).Format(time.RFC3339)

	var searchSpecificDoc string
	switch productType {
	case modelInputs.ProductTypeTraces:
		searchSpecificDoc = prompts.TraceSearch
	case modelInputs.ProductTypeLogs:
		searchSpecificDoc = prompts.LogSearch
	case modelInputs.ProductTypeSessions:
		searchSpecificDoc = prompts.SessionSearch
	case modelInputs.ProductTypeErrors:
		searchSpecificDoc = prompts.ErrorSearch
	}

	log.WithContext(ctx).Infof("search generic doc: %s", prompts.SearchSyntaxDocs)
	log.WithContext(ctx).Infof("search specific doc: %s", searchSpecificDoc)

	systemPrompt := fmt.Sprintf(`
You are a simple system used by an observability product in which, 
given a %s query in english, you output a structured query that the system 
can use to parse (which ultimately queries an internal database).

The input query will be a string which describes what the user wants in plain English.	

## Output Overview:

The output query should be in a json format with two keys: "query" and "date_range". 

Below are descriptions of the keys:
"query": A string that represents the query that the system should use to query the internal database, which must use the key-value pairs provided below. See below for the syntax rules of the language.
"date_range.start_date": A datetime string that represents the start date of the date range for the query.  If the date range is not specified, this key should be empty.
"date_range.end_date": A datetime string that represents the end date of the date range for the query. If the date range is not specified, this key should be empty.

## Rules for 'date_range' key:
Use today's date/time in the user's time zone for any relative times provided: %s

## Rules for 'query' key:
In terms of the keys and values you can use in the 'query' field, try not to use a key-value pairs that don't exist. If the user asks to search for a log that has a specific string in it, use the "*text*" option.

%s

And here are the key/values that you can use for each respective key. You are limited to these keys, but can be creative with the values:

%s

### Documentation for query syntax:

The 'query' syntax documentation is as follows:
%s

And specifically, for the %s product, you can refer to the following documentation:
%s
`, productType, now, openai_client.IrrelevantQueryFunctionalityIndicator, strings.Join(keyVals, ", "), prompts.SearchSyntaxDocs, productType, searchSpecificDoc)

	yesterday := time.Now().In(loc).AddDate(0, 0, -1)
	yesterdayAt2PM := time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 14, 0, 0, 0, yesterday.Location()).Format(time.RFC3339)
	sevenDaysBack := time.Now().Add(-7 * 24 * time.Hour).In(loc).Format(time.RFC3339)

	examples := []struct {
		request  string
		response string
	}{
		{
			request:  "Show me all the 500 errors in the last 7 days",
			response: fmt.Sprintf(`{"query":"status_code=500","date_range":{"start_date":"%s","end_date":""}}`, sevenDaysBack),
		},
		{
			request:  "Filter out debug logs",
			response: `{"query":"level!=debug","date_range":{"start_date":"","end_date":""}}`,
		},
		{
			request:  "Show me all the error logs from last week to yesterday at 2pm",
			response: fmt.Sprintf(`{"query":"level=error","date_range":{"start_date":"%s","end_date":"%s"}}`, sevenDaysBack, yesterdayAt2PM),
		},
		{
			request:  "All the traces from the private graph or public graph service",
			response: `{"query":"service_name=private-graph OR service_name=public-graph","date_range":{"start_date":"","end_date":""}}`,
		},
		{
			request:  "Give me all the logs where the environment is production and the session is not null",
			response: `{"query":"environment=production AND secure_session_id EXISTS","date_range":{"start_date":"","end_date":""}}`,
		},
		{
			request:  "logs that have 'panic' in the message",
			response: `{"query":"message=*panic*","date_range":{"start_date":"","end_date":""}}`,
		},
		{
			request:  "logs with a number in the trace_id",
			response: `{"query":"trace_id=/.*\d.*/","date_range":{"start_date":"","end_date":""}}`,
		},
		{
			request:  openai_client.IrrelevantQuery,
			response: `{"query":"","date_range":{"start_date":"","end_date":""}}`,
		},
	}

	messages := []openai.ChatCompletionMessage{
		{
			Role:    openai.ChatMessageRoleSystem,
			Content: systemPrompt,
		},
	}

	for _, example := range examples {
		messages = append(messages, openai.ChatCompletionMessage{
			Role:    openai.ChatMessageRoleUser,
			Content: example.request,
		})

		messages = append(messages, openai.ChatCompletionMessage{
			Role:    openai.ChatMessageRoleAssistant,
			Content: example.response,
		})
	}

	messages = append(messages, openai.ChatCompletionMessage{
		Role:    openai.ChatMessageRoleUser,
		Content: query,
	})

	resp, err := r.OpenAiClient.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model: openai.GPT3Dot5Turbo,
			ResponseFormat: &openai.ChatCompletionResponseFormat{
				Type: openai.ChatCompletionResponseFormatTypeJSONObject,
			},
			Messages: messages,
		},
	)

	if err != nil {
		log.WithContext(ctx).Error(err, "ChatCompletion error")
		return nil, err
	}

	if resp.Choices[0].Message.Content == "" {
		log.WithContext(ctx).Error(err, "Empty openai response")
		return nil, e.New("Empty openai response")
	}

	log.WithContext(ctx).
		WithFields(
			log.Fields{
				"request":  query,
				"response": resp.Choices[0].Message.Content,
			},
		).
		Info("AI query suggestion generated.")

	// Define the structs inline
	var toSaveString struct {
		Query     string `json:"query"`
		DateRange struct {
			StartDate string `json:"start_date,omitempty"`
			EndDate   string `json:"end_date,omitempty"`
		} `json:"date_range"`
	}

	err = json.Unmarshal([]byte(resp.Choices[0].Message.Content), &toSaveString)
	if err != nil {
		return nil, e.Errorf("error unmarshalling response from openai: %v", err)
	}

	toSave := modelInputs.QueryOutput{}
	toSave.DateRange = &modelInputs.DateRangeRequiredOutput{}
	toSave.Query = toSaveString.Query
	startDate, err := time.Parse(time.RFC3339, toSaveString.DateRange.StartDate)
	if err != nil {
		toSave.DateRange.StartDate = nil
	} else {
		toSave.DateRange.StartDate = &startDate
	}
	endDate, err := time.Parse(time.RFC3339, toSaveString.DateRange.EndDate)
	if err != nil {
		toSave.DateRange.EndDate = nil
	} else {
		toSave.DateRange.EndDate = &endDate
	}

	if toSave.Query == "" && toSave.DateRange.StartDate == nil && toSave.DateRange.EndDate == nil {
		return nil, openai_client.MalformedPromptError
	}

	return &toSave, nil
}

// Logs is the resolver for the logs field.
func (r *queryResolver) Logs(ctx context.Context, projectID int, params modelInputs.QueryInput, after *string, before *string, at *string, direction modelInputs.SortDirection, limit *int) (*modelInputs.LogConnection, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Update the the number of logs viewed for the current admin.
	r.PrivateWorkerPool.SubmitRecover(func() {
		// If the user is not authenticated (e.g. demo page), return
		admin, err := r.getCurrentAdmin(ctx)
		if err != nil {
			return
		}

		ctx := context.Background()
		var totalLogCount int64
		if err := r.DB.WithContext(ctx).Raw(`
			select count(*)
			from log_admins_views
			where admin_id = ?
	`, admin.ID).Scan(&totalLogCount).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error querying total count of log views from admin"))
			return
		}
		totalLogCountAsInt := int(totalLogCount) + 1

		if err := r.DB.WithContext(ctx).Where(admin).Updates(&model.Admin{NumberOfLogsViewed: &totalLogCountAsInt}).Error; err != nil {
			log.WithContext(ctx).Error(e.Wrap(err, "error updating log count for admin in postgres"))
		}
		phonehome.ReportUsageMetrics(ctx, phonehome.AdminUsage, admin.ID, []attribute.KeyValue{
			attribute.Int(phonehome.LogViewCount, totalLogCountAsInt),
		})

		if err := r.DB.WithContext(ctx).Model(&model.LogAdminsView{}).Create(&model.LogAdminsView{
			AdminID: admin.ID,
		}).Error; err != nil {
			log.WithContext(ctx).
				WithError(err).
				WithField("admin_id", admin.ID).
				WithField("value", totalLogCountAsInt).
				Error("error saving log view for admin in hubspot")
		}
	})

	return r.ClickhouseClient.ReadLogs(ctx, project.ID, params, clickhouse.Pagination{
		After:     after,
		Before:    before,
		At:        at,
		Direction: direction,
		Limit:     limit,
	})
}

// LogsHistogram is the resolver for the logs_histogram field.
func (r *queryResolver) LogsHistogram(ctx context.Context, projectID int, params modelInputs.QueryInput) (*modelInputs.LogsHistogram, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadLogsHistogram(ctx, project.ID, params, 48)
}

// LogsMetrics is the resolver for the logs_metrics field.
func (r *queryResolver) LogsMetrics(ctx context.Context, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadLogsMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketBy, bucketWindow, limit, limitAggregator, limitColumn)
}

// LogsKeys is the resolver for the logs_keys field.
func (r *queryResolver) LogsKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType) ([]*modelInputs.QueryKey, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.LogsKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg)
}

// LogsKeyValues is the resolver for the logs_key_values field.
func (r *queryResolver) LogsKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}
	return r.ClickhouseClient.LogsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
}

// LogsErrorObjects is the resolver for the logs_error_objects field.
func (r *queryResolver) LogsErrorObjects(ctx context.Context, logCursors []string) ([]*model.ErrorObject, error) {
	span, ctx := util.StartSpanFromContext(ctx, "LogsErrorObjects.DB.Query", util.Tag("NumLogCursors", len(logCursors)))
	defer span.Finish()

	var errorObjects []*model.ErrorObject
	if err := r.DB.WithContext(ctx).Model(&model.ErrorObject{}).Where("log_cursor IN ?", logCursors).Scan(&errorObjects).Error; err != nil {
		span.Finish(err)
		return nil, e.Wrap(err, "failed to find errors for log cursors")
	}
	return errorObjects, nil
}

// ExistingLogsTraces is the resolver for the existing_logs_traces field.
func (r *queryResolver) ExistingLogsTraces(ctx context.Context, projectID int, traceIds []string, dateRange modelInputs.DateRangeRequiredInput) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ExistingTraceIds(ctx, project.ID, traceIds, dateRange.StartDate, dateRange.EndDate)
}

// ErrorResolutionSuggestion is the resolver for the error_resolution_suggestion field.
func (r *queryResolver) ErrorResolutionSuggestion(ctx context.Context, errorObjectID int) (string, error) {
	errorObject := &model.ErrorObject{}
	if err := r.DB.WithContext(ctx).Model(&model.ErrorObject{}).Where("id = ?", errorObjectID).Find(&errorObject).Error; err != nil {
		return "", e.Wrap(err, "failed to find error object")
	}

	systemPrompt := fmt.Sprint(`
	You are a software engineer working on a web application and are trying to
	debug an error in your code. Provide some general background on the issue and
	then step-by-step instructions on fixing it. If possible, attempt to include
	code samples. Don't state anything obvious like "read the error".
	`)

	var stackTrace *string
	if errorObject.MappedStackTrace != nil {
		stackTrace = errorObject.MappedStackTrace
	} else {
		stackTrace = errorObject.StackTrace
	}

	const MAX_AI_STACKTRACE_LENGTH = 5000
	if stackTrace != nil && len(*stackTrace) > MAX_AI_STACKTRACE_LENGTH {
		stackTrace = ptr.String((*stackTrace)[:MAX_AI_STACKTRACE_LENGTH])
	}

	userPrompt := fmt.Sprintf(`
	Here is some information about the error.

	Title: %s
	Here's the stack trace information: %v
	`, errorObject.Event, *stackTrace)

	resp, err := r.OpenAiClient.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model:       openai.GPT3Dot5Turbo,
			Temperature: 0.7,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: systemPrompt,
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: userPrompt,
				},
			},
		},
	)

	if err != nil {
		log.WithContext(ctx).Error(err, "ChatCompletion error")
		return "", err
	}

	log.WithContext(ctx).
		WithField("error_object_id", errorObjectID).
		WithField("system_prompt", systemPrompt).
		WithField("user_prompt", userPrompt).
		WithField("response", resp.Choices[0].Message.Content).
		Info("AI suggestion generated.")

	return resp.Choices[0].Message.Content, nil
}

// SessionInsight is the resolver for the session_insight field.
func (r *queryResolver) SessionInsight(ctx context.Context, secureID string) (*model.SessionInsight, error) {
	session, err := r.canAdminViewSession(ctx, secureID)
	if err != nil {
		return nil, nil
	}

	var insight *model.SessionInsight

	if err := r.DB.WithContext(ctx).Model(&insight).Where(&model.SessionInsight{SessionID: session.ID}).Take(&insight).Error; err != nil {
		if e.Is(err, gorm.ErrRecordNotFound) {
			log.WithContext(ctx).Error(err, "SessionInsight: No record found")
			insight, err = r.getSessionInsight(ctx, session)
			if err != nil {
				log.WithContext(ctx).Error(err, "SessionInsight: Error getting insight")
			}
		} else {
			return nil, err
		}
	}

	return insight, nil
}

// SessionExports is the resolver for the session_exports field.
func (r *queryResolver) SessionExports(ctx context.Context, projectID int) ([]*modelInputs.SessionExportWithSession, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	var sessionExports []*modelInputs.SessionExportWithSession
	if err := r.DB.
		WithContext(ctx).
		Table("session_exports").
		Joins("INNER JOIN sessions s ON s.id = session_exports.session_id").
		Where(`s.project_id = ?`, projectID).
		Order("session_exports.id DESC").
		Scan(&sessionExports).Error; err != nil {
		return nil, err
	}
	return sessionExports, nil
}

// SystemConfiguration is the resolver for the system_configuration field.
func (r *queryResolver) SystemConfiguration(ctx context.Context) (*model.SystemConfiguration, error) {
	return r.Store.GetSystemConfiguration(ctx)
}

// Services is the resolver for the services field.
func (r *queryResolver) Services(ctx context.Context, projectID int, after *string, before *string, query *string) (*modelInputs.ServiceConnection, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	services := []*model.Service{}
	if err := r.DB.WithContext(ctx).Order("name ASC").Model(&model.Service{}).Where(&model.Service{ProjectID: project.ID}).Scan(&services).Error; err != nil {
		return nil, err
	}

	connection, err := r.Store.ListServices(ctx, *project, store.ListServicesParams{
		After:  after,
		Before: before,
		Query:  query,
	})

	return &connection, err
}

// ServiceByName is the resolver for the serviceByName field.
func (r *queryResolver) ServiceByName(ctx context.Context, projectID int, name string) (*model.Service, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.Store.FindService(ctx, projectID, name)
}

// ErrorTags is the resolver for the error_tags field.
func (r *queryResolver) ErrorTags(ctx context.Context) ([]*model.ErrorTag, error) {
	return r.GetErrorTags()
}

// MatchErrorTag is the resolver for the match_error_tag field.
func (r *queryResolver) MatchErrorTag(ctx context.Context, query string) ([]*modelInputs.MatchedErrorTag, error) {
	return r.Resolver.MatchErrorTag(ctx, query)
}

// Trace is the resolver for the trace field.
func (r *queryResolver) Trace(ctx context.Context, projectID int, traceID string, timestamp time.Time, sessionSecureID *string) (*modelInputs.TracePayload, error) {
	if _, err := r.canAdminViewSession(ctx, pointy.StringValue(sessionSecureID, "")); err != nil {
		_, err = r.isUserInProjectOrDemoProject(ctx, projectID)
		if err != nil {
			return nil, err
		}
	}

	trace, err := r.ClickhouseClient.ReadTrace(ctx, projectID, traceID, timestamp)
	if err != nil {
		return nil, err
	}

	var errors = []*modelInputs.TraceError{}
	err = r.DB.WithContext(ctx).Model(&model.ErrorObject{}).
		Joins("JOIN error_groups ON error_objects.error_group_id = error_groups.id").
		Where("error_objects.trace_id = ? AND error_objects.project_id = ?", traceID, projectID).
		Order("error_objects.timestamp DESC").
		Select("error_objects.*, error_groups.secure_id as error_group_secure_id").
		Find(&errors).Error
	if err != nil {
		return nil, err
	}

	traceStartTime := time.Now()
	for _, span := range trace {
		if span.Timestamp.Before(traceStartTime) {
			traceStartTime = span.Timestamp
		}
	}

	// Assigning this on the server since we can't parse timestamp to a date with
	// nanosecond precision in JavaScript.
	for _, span := range trace {
		span.StartTime = int(span.Timestamp.UnixNano() - traceStartTime.UnixNano())
	}

	return &modelInputs.TracePayload{
		Trace:  trace,
		Errors: errors,
	}, nil
}

// Traces is the resolver for the traces field.
func (r *queryResolver) Traces(ctx context.Context, projectID int, params modelInputs.QueryInput, after *string, before *string, at *string, direction modelInputs.SortDirection, limit *int) (*modelInputs.TraceConnection, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadTraces(ctx, project.ID, params, clickhouse.Pagination{
		After:     after,
		Before:    before,
		At:        at,
		Direction: direction,
		Limit:     limit,
	})
}

// TracesMetrics is the resolver for the traces_metrics field.
func (r *queryResolver) TracesMetrics(ctx context.Context, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy *string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	bucketByDeref := string(modelInputs.MetricBucketByTimestamp)
	if bucketBy != nil {
		bucketByDeref = *bucketBy
	}

	return r.ClickhouseClient.ReadTracesMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketByDeref, bucketWindow, limit, limitAggregator, limitColumn)
}

// TracesKeys is the resolver for the traces_keys field.
func (r *queryResolver) TracesKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType) ([]*modelInputs.QueryKey, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.TracesKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg)
}

// TracesKeyValues is the resolver for the traces_key_values field.
func (r *queryResolver) TracesKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.TracesKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
}

// ErrorsKeys is the resolver for the errors_keys field.
func (r *queryResolver) ErrorsKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType) ([]*modelInputs.QueryKey, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	if typeArg != nil && *typeArg != modelInputs.KeyTypeString {
		return []*modelInputs.QueryKey{}, nil
	} else {
		return lo.FilterMap(modelInputs.AllReservedErrorsJoinedKey, func(k modelInputs.ReservedErrorsJoinedKey, _ int) (*modelInputs.QueryKey, bool) {
			// Skip this key if filtered out by the query
			if query != nil && !strings.Contains(strings.ToLower(string(k)), strings.ToLower(*query)) {
				return nil, false
			}

			return &modelInputs.QueryKey{Name: string(k), Type: modelInputs.KeyTypeString}, true
		}), nil
	}
}

// ErrorsKeyValues is the resolver for the errors_key_values field.
func (r *queryResolver) ErrorsKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ErrorsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
}

// ErrorsMetrics is the resolver for the errors_metrics field.
func (r *queryResolver) ErrorsMetrics(ctx context.Context, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadErrorsMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketBy, bucketWindow, limit, limitAggregator, limitColumn)
}

// SessionsKeys is the resolver for the sessions_keys field.
func (r *queryResolver) SessionsKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType) ([]*modelInputs.QueryKey, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.SessionsKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg)
}

// SessionsKeyValues is the resolver for the sessions_key_values field.
func (r *queryResolver) SessionsKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.SessionsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
}

// SessionsMetrics is the resolver for the sessions_metrics field.
func (r *queryResolver) SessionsMetrics(ctx context.Context, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadSessionsMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketBy, bucketWindow, limit, limitAggregator, limitColumn)
}

// EventsKeys is the resolver for the events_keys field.
func (r *queryResolver) EventsKeys(ctx context.Context, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType, event *string) ([]*modelInputs.QueryKey, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.EventsKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg, event)
}

// EventsKeyValues is the resolver for the events_key_values field.
func (r *queryResolver) EventsKeyValues(ctx context.Context, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int, event *string) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.EventsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count, event)
}

// EventsMetrics is the resolver for the events_metrics field.
func (r *queryResolver) EventsMetrics(ctx context.Context, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	return r.ClickhouseClient.ReadEventsMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketBy, bucketWindow, limit, limitAggregator, limitColumn)
}

// Metrics is the resolver for the metrics field.
func (r *queryResolver) Metrics(ctx context.Context, productType modelInputs.ProductType, projectID int, params modelInputs.QueryInput, column string, metricTypes []modelInputs.MetricAggregator, groupBy []string, bucketBy string, bucketCount *int, bucketWindow *int, limit *int, limitAggregator *modelInputs.MetricAggregator, limitColumn *string) (*modelInputs.MetricsBuckets, error) {
	switch productType {
	case modelInputs.ProductTypeMetrics:
		project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
		if err != nil {
			return nil, err
		}
		return r.ClickhouseClient.ReadEventMetrics(ctx, project.ID, params, column, metricTypes, groupBy, bucketCount, bucketBy, bucketWindow, limit, limitAggregator, limitColumn)
	case modelInputs.ProductTypeTraces:
		return r.TracesMetrics(ctx, projectID, params, column, metricTypes, groupBy, &bucketBy, bucketCount, bucketWindow, limit, limitAggregator, limitColumn)
	case modelInputs.ProductTypeLogs:
		return r.LogsMetrics(ctx, projectID, params, column, metricTypes, groupBy, bucketBy, bucketCount, bucketWindow, limit, limitAggregator, limitColumn)
	case modelInputs.ProductTypeSessions:
		return r.SessionsMetrics(ctx, projectID, params, column, metricTypes, groupBy, bucketBy, bucketCount, bucketWindow, limit, limitAggregator, limitColumn)
	case modelInputs.ProductTypeErrors:
		return r.ErrorsMetrics(ctx, projectID, params, column, metricTypes, groupBy, bucketBy, bucketCount, bucketWindow, limit, limitAggregator, limitColumn)
	case modelInputs.ProductTypeEvents:
		return r.EventsMetrics(ctx, projectID, params, column, metricTypes, groupBy, bucketBy, bucketCount, bucketWindow, limit, limitAggregator, limitColumn)
	default:
		return nil, e.Errorf("invalid product type %s", productType)
	}
}

// Keys is the resolver for the keys field.
func (r *queryResolver) Keys(ctx context.Context, productType *modelInputs.ProductType, projectID int, dateRange modelInputs.DateRangeRequiredInput, query *string, typeArg *modelInputs.KeyType, event *string) ([]*modelInputs.QueryKey, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	if productType == nil {
		return r.ClickhouseClient.AllKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg)
	}

	switch *productType {
	case modelInputs.ProductTypeMetrics:
		return r.ClickhouseClient.MetricsKeys(ctx, project.ID, dateRange.StartDate, dateRange.EndDate, query, typeArg)
	case modelInputs.ProductTypeTraces:
		return r.TracesKeys(ctx, projectID, dateRange, query, typeArg)
	case modelInputs.ProductTypeLogs:
		return r.LogsKeys(ctx, projectID, dateRange, query, typeArg)
	case modelInputs.ProductTypeSessions:
		return r.SessionsKeys(ctx, projectID, dateRange, query, typeArg)
	case modelInputs.ProductTypeErrors:
		return r.ErrorsKeys(ctx, projectID, dateRange, query, typeArg)
	case modelInputs.ProductTypeEvents:
		return r.EventsKeys(ctx, projectID, dateRange, query, typeArg, event)
	default:
		return nil, e.Errorf("invalid product type %s", productType)
	}
}

// KeyValues is the resolver for the key_values field.
func (r *queryResolver) KeyValues(ctx context.Context, productType *modelInputs.ProductType, projectID int, keyName string, dateRange modelInputs.DateRangeRequiredInput, query *string, count *int, event *string) ([]string, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	if productType == nil {
		return r.ClickhouseClient.AllKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
	}

	switch *productType {
	case modelInputs.ProductTypeMetrics:
		return r.ClickhouseClient.MetricsKeyValues(ctx, project.ID, keyName, dateRange.StartDate, dateRange.EndDate, query, count)
	case modelInputs.ProductTypeTraces:
		return r.TracesKeyValues(ctx, projectID, keyName, dateRange, query, count)
	case modelInputs.ProductTypeLogs:
		return r.LogsKeyValues(ctx, projectID, keyName, dateRange, query, count)
	case modelInputs.ProductTypeSessions:
		return r.SessionsKeyValues(ctx, projectID, keyName, dateRange, query, count)
	case modelInputs.ProductTypeErrors:
		return r.ErrorsKeyValues(ctx, projectID, keyName, dateRange, query, count)
	case modelInputs.ProductTypeEvents:
		return r.EventsKeyValues(ctx, projectID, keyName, dateRange, query, count, event)
	default:
		return nil, e.Errorf("invalid product type %s", productType)
	}
}

// Visualization is the resolver for the visualization field.
func (r *queryResolver) Visualization(ctx context.Context, id int) (*model.Visualization, error) {
	var viz model.Visualization
	if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", id).Preload("Graphs").Preload("UpdatedByAdmin").Find(&viz).Error; err != nil {
		return nil, err
	}

	reorderGraphs(&viz)

	_, err := r.isUserInProjectOrDemoProject(ctx, viz.ProjectID)
	if err != nil {
		return nil, err
	}

	return &viz, nil
}

// Visualizations is the resolver for the visualizations field.
func (r *queryResolver) Visualizations(ctx context.Context, projectID int, input string, count int, offset int) (*model.VisualizationsResponse, error) {
	_, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Escape any % or _, surround the input with %
	searchStr := fmt.Sprintf("%%%s%%", strings.ReplaceAll(strings.ReplaceAll(input, "%", "\\%"), "_", "\\_"))

	type vizWithCount struct {
		model.Visualization
		Count int
	}

	var viz []vizWithCount
	if err := r.DB.WithContext(ctx).Model(&model.Visualization{}).Preload("Graphs").Preload("UpdatedByAdmin").
		Where("project_id = ?", projectID).Where("name ILIKE ?", searchStr).
		Order("updated_at DESC").Select("*, COUNT(*) OVER () as count").Limit(count).Offset(offset).Find(&viz).Error; err != nil {
		return nil, err
	}

	results := []model.Visualization{}
	for _, v := range viz {
		reorderGraphs(&v.Visualization)
		results = append(results, v.Visualization)
	}

	totalCount := 0
	if len(viz) > 0 {
		totalCount = viz[0].Count
	}

	// If no dashboards have been created for this project, create a default dashboard.
	if input == "" && totalCount == 0 {
		return r.CreateDefaultDashboard(ctx, projectID)
	}

	return &model.VisualizationsResponse{
		Count:   totalCount,
		Results: results,
	}, nil
}

// Graph is the resolver for the graph field.
func (r *queryResolver) Graph(ctx context.Context, id int) (*model.Graph, error) {
	var graph model.Graph
	if err := r.DB.WithContext(ctx).Model(&graph).Where("id = ?", id).Find(&graph).Error; err != nil {
		return nil, err
	}

	var viz model.Visualization
	if err := r.DB.WithContext(ctx).Model(&viz).Where("id = ?", graph.VisualizationID).Find(&viz).Error; err != nil {
		return nil, err
	}

	_, err := r.isUserInProjectOrDemoProject(ctx, viz.ProjectID)
	if err != nil {
		return nil, err
	}

	return &graph, nil
}

// LogLines is the resolver for the log_lines field.
func (r *queryResolver) LogLines(ctx context.Context, productType modelInputs.ProductType, projectID int, params modelInputs.QueryInput) ([]*modelInputs.LogLine, error) {
	project, err := r.isUserInProjectOrDemoProject(ctx, projectID)
	if err != nil {
		return nil, err
	}

	switch productType {
	case modelInputs.ProductTypeMetrics:
		return r.ClickhouseClient.MetricsLogLines(ctx, project.ID, params)
	case modelInputs.ProductTypeTraces:
		return r.ClickhouseClient.TracesLogLines(ctx, project.ID, params)
	case modelInputs.ProductTypeLogs:
		return r.ClickhouseClient.LogsLogLines(ctx, project.ID, params)
	case modelInputs.ProductTypeSessions:
		return r.ClickhouseClient.SessionsLogLines(ctx, project.ID, params)
	case modelInputs.ProductTypeErrors:
		return r.ClickhouseClient.ErrorsLogLines(ctx, project.ID, params)
	case modelInputs.ProductTypeEvents:
		return r.ClickhouseClient.EventsLogLines(ctx, project.ID, params)
	default:
		return nil, e.Errorf("invalid product type %s", productType)
	}
}

// Params is the resolver for the params field.
func (r *savedSegmentResolver) Params(ctx context.Context, obj *model.SavedSegment) (*model.SearchParams, error) {
	params := &model.SearchParams{}
	if err := json.Unmarshal([]byte(obj.Params), params); err != nil {
		return nil, e.Wrapf(err, "error unmarshaling saved segment params")
	}
	return params, nil
}

// ErrorDetails is the resolver for the errorDetails field.
func (r *serviceResolver) ErrorDetails(ctx context.Context, obj *model.Service) ([]string, error) {
	return obj.ErrorDetails, nil
}

// UserObject is the resolver for the user_object field.
func (r *sessionResolver) UserObject(ctx context.Context, obj *model.Session) (interface{}, error) {
	return obj.UserObject, nil
}

// DirectDownloadURL is the resolver for the direct_download_url field.
func (r *sessionResolver) DirectDownloadURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.DirectDownloadEnabled || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.SessionContentsCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting direct download URL")
	}

	return str, err
}

// ResourcesURL is the resolver for the resources_url field.
func (r *sessionResolver) ResourcesURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.AllObjectsCompressed || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.NetworkResourcesCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting resources URL")
	}

	return str, err
}

// WebSocketEventsURL is the resolver for the web_socket_events_url field.
func (r *sessionResolver) WebSocketEventsURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.AllObjectsCompressed || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.WebSocketEventsCompressed, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting web socket events URL")
	}

	return str, err
}

// TimelineIndicatorsURL is the resolver for the timeline_indicators_url field.
func (r *sessionResolver) TimelineIndicatorsURL(ctx context.Context, obj *model.Session) (*string, error) {
	// Direct download only supported for clients that accept Brotli content encoding
	if !obj.AllObjectsCompressed || !r.isBrotliAccepted(ctx) {
		return nil, nil
	}

	str, err := r.StorageClient.GetDirectDownloadURL(ctx, obj.ProjectID, obj.ID, storage.TimelineIndicatorEvents, nil)
	if err != nil {
		return nil, e.Wrap(err, "error getting timeline indicators URL")
	}

	return str, err
}

// DeviceMemory is the resolver for the deviceMemory field.
func (r *sessionResolver) DeviceMemory(ctx context.Context, obj *model.Session) (*int, error) {
	metrics, err := r.ClickhouseClient.QuerySessionCustomMetrics(ctx, obj.ProjectID, obj.SecureID, []string{
		"DeviceMemory",
	})
	if err != nil {
		return nil, err
	}

	if len(metrics) == 0 {
		return nil, nil
	}

	deviceMemory := int(metrics[0].Value)
	return &deviceMemory, nil
}

// SessionFeedback is the resolver for the session_feedback field.
func (r *sessionResolver) SessionFeedback(ctx context.Context, obj *model.Session) ([]*model.SessionComment, error) {
	if env.IsDevEnv() && obj.SecureID == "repro" {
		sessionFeedback := []*model.SessionComment{}
		return sessionFeedback, nil
	}
	s, err := r.canAdminViewSession(ctx, obj.SecureID)
	if err != nil {
		return nil, err
	}
	sessionFeedback := []*model.SessionComment{}

	if err := r.DB.WithContext(ctx).Where(model.SessionComment{SessionId: s.ID, Type: model.SessionCommentTypes.FEEDBACK}).Order("timestamp asc").Find(&sessionFeedback).Error; err != nil {
		return nil, e.Wrap(err, "error querying session comments for session")
	}
	return sessionFeedback, nil
}

// ChannelsToNotify is the resolver for the ChannelsToNotify field.
func (r *sessionAlertResolver) ChannelsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*modelInputs.SanitizedSlackChannel, error) {
	return obj.GetChannelsToNotify()
}

// DiscordChannelsToNotify is the resolver for the DiscordChannelsToNotify field.
func (r *sessionAlertResolver) DiscordChannelsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*model.DiscordChannel, error) {
	ret := obj.DiscordChannelsToNotify

	return ret, nil
}

// MicrosoftTeamsChannelsToNotify is the resolver for the MicrosoftTeamsChannelsToNotify field.
func (r *sessionAlertResolver) MicrosoftTeamsChannelsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*model.MicrosoftTeamsChannel, error) {
	return obj.MicrosoftTeamsChannelsToNotify, nil
}

// WebhookDestinations is the resolver for the WebhookDestinations field.
func (r *sessionAlertResolver) WebhookDestinations(ctx context.Context, obj *model.SessionAlert) ([]*model.WebhookDestination, error) {
	return obj.WebhookDestinations, nil
}

// EmailsToNotify is the resolver for the EmailsToNotify field.
func (r *sessionAlertResolver) EmailsToNotify(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetEmailsToNotify()
}

// ExcludedEnvironments is the resolver for the ExcludedEnvironments field.
func (r *sessionAlertResolver) ExcludedEnvironments(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetExcludedEnvironments()
}

// TrackProperties is the resolver for the TrackProperties field.
func (r *sessionAlertResolver) TrackProperties(ctx context.Context, obj *model.SessionAlert) ([]*model.TrackProperty, error) {
	return obj.GetTrackProperties()
}

// UserProperties is the resolver for the UserProperties field.
func (r *sessionAlertResolver) UserProperties(ctx context.Context, obj *model.SessionAlert) ([]*model.UserProperty, error) {
	return obj.GetUserProperties()
}

// ExcludeRules is the resolver for the ExcludeRules field.
func (r *sessionAlertResolver) ExcludeRules(ctx context.Context, obj *model.SessionAlert) ([]*string, error) {
	return obj.GetExcludeRules()
}

// DailyFrequency is the resolver for the DailyFrequency field.
func (r *sessionAlertResolver) DailyFrequency(ctx context.Context, obj *model.SessionAlert) ([]*int64, error) {
	return obj.GetDailySessionEventFrequency(r.DB, obj.ID)
}

// Author is the resolver for the author field.
func (r *sessionCommentResolver) Author(ctx context.Context, obj *model.SessionComment) (*modelInputs.SanitizedAdmin, error) {
	admin := &model.Admin{}

	// This case happens when the feedback is provided by feedback mechanism.
	if obj.Type == modelInputs.SessionCommentTypeFeedback.String() {
		name := "Anonymous"
		email := ""

		if obj.Metadata != nil {
			if val, ok := obj.Metadata["name"]; ok {
				switch val.(type) {
				case string:
					name = fmt.Sprintf("%v", val)
				}
			}
			if val, ok := obj.Metadata["email"]; ok {
				switch val.(type) {
				case string:
					email = fmt.Sprintf("%v", val)
				}
			}

		}

		feedbackAdmin := &modelInputs.SanitizedAdmin{
			ID:    -1,
			Name:  &name,
			Email: email,
		}
		return feedbackAdmin, nil
	}

	if err := r.DB.WithContext(ctx).Where(&model.Admin{Model: model.Model{ID: obj.AdminId}}).Take(&admin).Error; err != nil {
		return nil, e.Wrap(err, "Error finding admin for comment")
	}

	return r.formatSanitizedAuthor(admin), nil
}

// Type is the resolver for the type field.
func (r *sessionCommentResolver) Type(ctx context.Context, obj *model.SessionComment) (modelInputs.SessionCommentType, error) {
	switch obj.Type {
	case model.SessionCommentTypes.ADMIN:
		return modelInputs.SessionCommentTypeAdmin, nil
	case model.SessionCommentTypes.FEEDBACK:
		return modelInputs.SessionCommentTypeFeedback, nil
	default:
		return modelInputs.SessionCommentTypeFeedback, e.New("invalid session comment type")
	}
}

// Metadata is the resolver for the metadata field.
func (r *sessionCommentResolver) Metadata(ctx context.Context, obj *model.SessionComment) (interface{}, error) {
	return obj.Metadata, nil
}

// Tags is the resolver for the tags field.
func (r *sessionCommentResolver) Tags(ctx context.Context, obj *model.SessionComment) ([]*string, error) {
	var (
		tags []sql.NullString
	)
	var tagsResponse []*string

	if err := r.DB.WithContext(ctx).Raw(`
	SELECT
    array_agg(t.name)
FROM
    session_tags st
    JOIN session_comment_tags t ON t.id = st.session_comment_tag_id
WHERE
    st.session_comment_id = ?
GROUP BY
    st.session_comment_id`, obj.ID).Scan(&tags).Error; err != nil {
		log.WithContext(ctx).Error(err, "Failed to query for session comment tags")
	}

	for i := range tags {
		temp, _ := tags[i].Value()
		tagValue, _ := temp.(string)
		tagValue = strings.Replace(tagValue, "\"", "", -1)
		tagValue = strings.Replace(tagValue, "\"", "", -1)
		tagValue = strings.Replace(tagValue, "{", "[\"", 1)
		tagValue = strings.Replace(tagValue, "}", "\"]", 1)
		tagValue = strings.Replace(tagValue, ",", "\",\"", -1)

		tagsResponse = append(tagsResponse, &tagValue)
	}

	return tagsResponse, nil
}

// SessionPayloadAppended is the resolver for the session_payload_appended field.
func (r *subscriptionResolver) SessionPayloadAppended(ctx context.Context, sessionSecureID string, initialEventsCount int) (<-chan *model.SessionPayload, error) {
	ch := make(chan *model.SessionPayload)
	r.SubscriptionWorkerPool.SubmitRecover(func() {
		defer close(ch)
		log.WithContext(ctx).Infof("Polling for events on %s starting from index %d, number of waiting tasks %d",
			sessionSecureID,
			initialEventsCount,
			r.SubscriptionWorkerPool.WaitingQueueSize())

		cursor := model.EventsCursor{EventIndex: initialEventsCount, EventObjectIndex: nil}
		for {
			select {
			case <-ctx.Done():
				return
			default:
			}

			session, err := r.canAdminViewSession(ctx, sessionSecureID)
			if err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "error fetching session for subscription"))
				return
			}
			// Use context.Background() here as the original ctx seems to
			// be cancelled after 30 seconds, which cancels the redis query.
			events, err, nextCursor := r.getEvents(context.Background(), session, cursor)
			if err != nil {
				log.WithContext(ctx).Error(e.Wrap(err, "error fetching events incrementally"))
				return
			}
			if len(events) != 0 {
				// TODO live updating for other event types
				ch <- &model.SessionPayload{
					Events:                  events,
					Errors:                  []model.ErrorObject{},
					RageClicks:              []model.RageClickEvent{},
					SessionComments:         []model.SessionComment{},
					LastUserInteractionTime: session.LastUserInteractionTime,
				}
			}
			cursor = *nextCursor

			time.Sleep(1 * time.Second)
		}
	})
	return ch, nil
}

// Data is the resolver for the data field.
func (r *timelineIndicatorEventResolver) Data(ctx context.Context, obj *model.TimelineIndicatorEvent) (interface{}, error) {
	return obj.Data, nil
}

// UpdatedByAdmin is the resolver for the updatedByAdmin field.
func (r *visualizationResolver) UpdatedByAdmin(ctx context.Context, obj *model.Visualization) (*modelInputs.SanitizedAdmin, error) {
	if obj.UpdatedByAdmin == nil {
		return nil, nil
	}

	email := ""
	if obj.UpdatedByAdmin.Email != nil {
		email = *obj.UpdatedByAdmin.Email
	}

	return &modelInputs.SanitizedAdmin{
		ID:       obj.UpdatedByAdmin.ID,
		Name:     obj.UpdatedByAdmin.Name,
		Email:    email,
		PhotoURL: obj.UpdatedByAdmin.PhotoURL,
	}, nil
}

// Variables is the resolver for the variables field.
func (r *visualizationResolver) Variables(ctx context.Context, obj *model.Visualization) ([]*modelInputs.Variable, error) {
	if obj.Variables == "" {
		return []*modelInputs.Variable{}, nil
	}
	type VariablesUnmarshaled struct {
		Key            string                     `json:"key"`
		DefaultValue   string                     `json:"defaultValue"`
		DefaultValues  []string                   `json:"defaultValues"`
		SuggestionType modelInputs.SuggestionType `json:"suggestionType"`
		Field          *string                    `json:"field,omitempty"`
	}
	unmarshalled := &[]*VariablesUnmarshaled{}
	if err := json.Unmarshal([]byte(obj.Variables), unmarshalled); err != nil {
		return nil, e.Wrapf(err, "error unmarshaling variables")
	}

	variables := []*modelInputs.Variable{}
	for _, v := range *unmarshalled {
		if v.DefaultValue != "" && len(v.DefaultValues) == 0 {
			v.DefaultValues = []string{v.DefaultValue}
		}
		variables = append(variables, &modelInputs.Variable{
			Key:            v.Key,
			DefaultValues:  v.DefaultValues,
			SuggestionType: v.SuggestionType,
			Field:          v.Field,
		})
	}

	return variables, nil
}

// AllWorkspaceSettings returns generated.AllWorkspaceSettingsResolver implementation.
func (r *Resolver) AllWorkspaceSettings() generated.AllWorkspaceSettingsResolver {
	return &allWorkspaceSettingsResolver{r}
}

// CommentReply returns generated.CommentReplyResolver implementation.
func (r *Resolver) CommentReply() generated.CommentReplyResolver { return &commentReplyResolver{r} }

// ErrorAlert returns generated.ErrorAlertResolver implementation.
func (r *Resolver) ErrorAlert() generated.ErrorAlertResolver { return &errorAlertResolver{r} }

// ErrorComment returns generated.ErrorCommentResolver implementation.
func (r *Resolver) ErrorComment() generated.ErrorCommentResolver { return &errorCommentResolver{r} }

// ErrorGroup returns generated.ErrorGroupResolver implementation.
func (r *Resolver) ErrorGroup() generated.ErrorGroupResolver { return &errorGroupResolver{r} }

// ErrorObject returns generated.ErrorObjectResolver implementation.
func (r *Resolver) ErrorObject() generated.ErrorObjectResolver { return &errorObjectResolver{r} }

// Graph returns generated.GraphResolver implementation.
func (r *Resolver) Graph() generated.GraphResolver { return &graphResolver{r} }

// LogAlert returns generated.LogAlertResolver implementation.
func (r *Resolver) LogAlert() generated.LogAlertResolver { return &logAlertResolver{r} }

// MatchedErrorObject returns generated.MatchedErrorObjectResolver implementation.
func (r *Resolver) MatchedErrorObject() generated.MatchedErrorObjectResolver {
	return &matchedErrorObjectResolver{r}
}

// MetricMonitor returns generated.MetricMonitorResolver implementation.
func (r *Resolver) MetricMonitor() generated.MetricMonitorResolver { return &metricMonitorResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// SavedSegment returns generated.SavedSegmentResolver implementation.
func (r *Resolver) SavedSegment() generated.SavedSegmentResolver { return &savedSegmentResolver{r} }

// Service returns generated.ServiceResolver implementation.
func (r *Resolver) Service() generated.ServiceResolver { return &serviceResolver{r} }

// Session returns generated.SessionResolver implementation.
func (r *Resolver) Session() generated.SessionResolver { return &sessionResolver{r} }

// SessionAlert returns generated.SessionAlertResolver implementation.
func (r *Resolver) SessionAlert() generated.SessionAlertResolver { return &sessionAlertResolver{r} }

// SessionComment returns generated.SessionCommentResolver implementation.
func (r *Resolver) SessionComment() generated.SessionCommentResolver {
	return &sessionCommentResolver{r}
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// TimelineIndicatorEvent returns generated.TimelineIndicatorEventResolver implementation.
func (r *Resolver) TimelineIndicatorEvent() generated.TimelineIndicatorEventResolver {
	return &timelineIndicatorEventResolver{r}
}

// Visualization returns generated.VisualizationResolver implementation.
func (r *Resolver) Visualization() generated.VisualizationResolver { return &visualizationResolver{r} }

type allWorkspaceSettingsResolver struct{ *Resolver }
type commentReplyResolver struct{ *Resolver }
type errorAlertResolver struct{ *Resolver }
type errorCommentResolver struct{ *Resolver }
type errorGroupResolver struct{ *Resolver }
type errorObjectResolver struct{ *Resolver }
type graphResolver struct{ *Resolver }
type logAlertResolver struct{ *Resolver }
type matchedErrorObjectResolver struct{ *Resolver }
type metricMonitorResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type savedSegmentResolver struct{ *Resolver }
type serviceResolver struct{ *Resolver }
type sessionResolver struct{ *Resolver }
type sessionAlertResolver struct{ *Resolver }
type sessionCommentResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type timelineIndicatorEventResolver struct{ *Resolver }
type visualizationResolver struct{ *Resolver }
