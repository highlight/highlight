(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd) define([], factory);
    else if (typeof exports === 'object') exports['highlightLib'] = factory();
    else root['highlightLib'] = factory();
})(self, function () {
    return /******/ (() => {
        // webpackBootstrap
        /******/ var __webpack_modules__ = {
            /***/ './node_modules/@highlight-run/rrweb/dist/index.js':
                /*!*********************************************************!*\
  !*** ./node_modules/@highlight-run/rrweb/dist/index.js ***!
  \*********************************************************/
                /***/ (module) => {
                    (function webpackUniversalModuleDefinition(root, factory) {
                        if (true) module.exports = factory();
                        else {
                        }
                    })(self, function () {
                        return /******/ (() => {
                            // webpackBootstrap
                            /******/ 'use strict';
                            /******/ var __webpack_modules__ = {
                                /***/ './node_modules/@xstate/fsm/es/index.js':
                                    /*!**********************************************!*\
  !*** ./node_modules/@xstate/fsm/es/index.js ***!
  \**********************************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        __webpack_exports__,
                                        __nested_webpack_require_736__
                                    ) => {
                                        __nested_webpack_require_736__.r(
                                            __webpack_exports__
                                        );
                                        /* harmony export */ __nested_webpack_require_736__.d(
                                            __webpack_exports__,
                                            {
                                                /* harmony export */ InterpreterStatus: () =>
                                                    /* binding */ n,
                                                /* harmony export */ assign: () =>
                                                    /* binding */ o,
                                                /* harmony export */ createMachine: () =>
                                                    /* binding */ s,
                                                /* harmony export */ interpret: () =>
                                                    /* binding */ v,
                                                /* harmony export */
                                            }
                                        );
                                        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
                                        function t(t, n) {
                                            var e =
                                                'function' == typeof Symbol &&
                                                t[Symbol.iterator];
                                            if (!e) return t;
                                            var r,
                                                o,
                                                i = e.call(t),
                                                a = [];
                                            try {
                                                for (
                                                    ;
                                                    (void 0 === n || n-- > 0) &&
                                                    !(r = i.next()).done;

                                                )
                                                    a.push(r.value);
                                            } catch (t) {
                                                o = { error: t };
                                            } finally {
                                                try {
                                                    r &&
                                                        !r.done &&
                                                        (e = i.return) &&
                                                        e.call(i);
                                                } finally {
                                                    if (o) throw o.error;
                                                }
                                            }
                                            return a;
                                        }
                                        var n;
                                        !(function (t) {
                                            (t[(t.NotStarted = 0)] =
                                                'NotStarted'),
                                                (t[(t.Running = 1)] =
                                                    'Running'),
                                                (t[(t.Stopped = 2)] =
                                                    'Stopped');
                                        })(n || (n = {}));
                                        var e = { type: 'xstate.init' };
                                        function r(t) {
                                            return void 0 === t
                                                ? []
                                                : [].concat(t);
                                        }
                                        function o(t) {
                                            return {
                                                type: 'xstate.assign',
                                                assignment: t,
                                            };
                                        }
                                        function i(t, n) {
                                            return 'string' ==
                                                typeof (t =
                                                    'string' == typeof t &&
                                                    n &&
                                                    n[t]
                                                        ? n[t]
                                                        : t)
                                                ? { type: t }
                                                : 'function' == typeof t
                                                ? { type: t.name, exec: t }
                                                : t;
                                        }
                                        function a(t) {
                                            return function (n) {
                                                return t === n;
                                            };
                                        }
                                        function u(t) {
                                            return 'string' == typeof t
                                                ? { type: t }
                                                : t;
                                        }
                                        function c(t, n) {
                                            return {
                                                value: t,
                                                context: n,
                                                actions: [],
                                                changed: !1,
                                                matches: a(t),
                                            };
                                        }
                                        function f(t, n, e) {
                                            var r = n,
                                                o = !1;
                                            return [
                                                t.filter(function (t) {
                                                    if (
                                                        'xstate.assign' ===
                                                        t.type
                                                    ) {
                                                        o = !0;
                                                        var n = Object.assign(
                                                            {},
                                                            r
                                                        );
                                                        return (
                                                            'function' ==
                                                            typeof t.assignment
                                                                ? (n = t.assignment(
                                                                      r,
                                                                      e
                                                                  ))
                                                                : Object.keys(
                                                                      t.assignment
                                                                  ).forEach(
                                                                      function (
                                                                          o
                                                                      ) {
                                                                          n[o] =
                                                                              'function' ==
                                                                              typeof t
                                                                                  .assignment[
                                                                                  o
                                                                              ]
                                                                                  ? t.assignment[
                                                                                        o
                                                                                    ](
                                                                                        r,
                                                                                        e
                                                                                    )
                                                                                  : t
                                                                                        .assignment[
                                                                                        o
                                                                                    ];
                                                                      }
                                                                  ),
                                                            (r = n),
                                                            !1
                                                        );
                                                    }
                                                    return !0;
                                                }),
                                                r,
                                                o,
                                            ];
                                        }
                                        function s(n, o) {
                                            void 0 === o && (o = {});
                                            var s = t(
                                                    f(
                                                        r(
                                                            n.states[n.initial]
                                                                .entry
                                                        ).map(function (t) {
                                                            return i(
                                                                t,
                                                                o.actions
                                                            );
                                                        }),
                                                        n.context,
                                                        e
                                                    ),
                                                    2
                                                ),
                                                l = s[0],
                                                v = s[1],
                                                y = {
                                                    config: n,
                                                    _options: o,
                                                    initialState: {
                                                        value: n.initial,
                                                        actions: l,
                                                        context: v,
                                                        matches: a(n.initial),
                                                    },
                                                    transition: function (
                                                        e,
                                                        o
                                                    ) {
                                                        var s,
                                                            l,
                                                            v =
                                                                'string' ==
                                                                typeof e
                                                                    ? {
                                                                          value: e,
                                                                          context:
                                                                              n.context,
                                                                      }
                                                                    : e,
                                                            p = v.value,
                                                            g = v.context,
                                                            d = u(o),
                                                            x = n.states[p];
                                                        if (x.on) {
                                                            var m = r(
                                                                x.on[d.type]
                                                            );
                                                            try {
                                                                for (
                                                                    var h = (function (
                                                                            t
                                                                        ) {
                                                                            var n =
                                                                                    'function' ==
                                                                                        typeof Symbol &&
                                                                                    Symbol.iterator,
                                                                                e =
                                                                                    n &&
                                                                                    t[
                                                                                        n
                                                                                    ],
                                                                                r = 0;
                                                                            if (
                                                                                e
                                                                            )
                                                                                return e.call(
                                                                                    t
                                                                                );
                                                                            if (
                                                                                t &&
                                                                                'number' ==
                                                                                    typeof t.length
                                                                            )
                                                                                return {
                                                                                    next: function () {
                                                                                        return (
                                                                                            t &&
                                                                                                r >=
                                                                                                    t.length &&
                                                                                                (t = void 0),
                                                                                            {
                                                                                                value:
                                                                                                    t &&
                                                                                                    t[
                                                                                                        r++
                                                                                                    ],
                                                                                                done: !t,
                                                                                            }
                                                                                        );
                                                                                    },
                                                                                };
                                                                            throw new TypeError(
                                                                                n
                                                                                    ? 'Object is not iterable.'
                                                                                    : 'Symbol.iterator is not defined.'
                                                                            );
                                                                        })(m),
                                                                        b = h.next();
                                                                    !b.done;
                                                                    b = h.next()
                                                                ) {
                                                                    var S =
                                                                        b.value;
                                                                    if (
                                                                        void 0 ===
                                                                        S
                                                                    )
                                                                        return c(
                                                                            p,
                                                                            g
                                                                        );
                                                                    var w =
                                                                            'string' ==
                                                                            typeof S
                                                                                ? {
                                                                                      target: S,
                                                                                  }
                                                                                : S,
                                                                        j =
                                                                            w.target,
                                                                        E =
                                                                            w.actions,
                                                                        R =
                                                                            void 0 ===
                                                                            E
                                                                                ? []
                                                                                : E,
                                                                        N =
                                                                            w.cond,
                                                                        O =
                                                                            void 0 ===
                                                                            j;
                                                                    if (
                                                                        (void 0 ===
                                                                            N
                                                                            ? function () {
                                                                                  return !0;
                                                                              }
                                                                            : N)(
                                                                            g,
                                                                            d
                                                                        )
                                                                    ) {
                                                                        var _ =
                                                                                n
                                                                                    .states[
                                                                                    null !=
                                                                                    j
                                                                                        ? j
                                                                                        : p
                                                                                ],
                                                                            k = t(
                                                                                f(
                                                                                    (O
                                                                                        ? r(
                                                                                              R
                                                                                          )
                                                                                        : []
                                                                                              .concat(
                                                                                                  x.exit,
                                                                                                  R,
                                                                                                  _.entry
                                                                                              )
                                                                                              .filter(
                                                                                                  function (
                                                                                                      t
                                                                                                  ) {
                                                                                                      return t;
                                                                                                  }
                                                                                              )
                                                                                    ).map(
                                                                                        function (
                                                                                            t
                                                                                        ) {
                                                                                            return i(
                                                                                                t,
                                                                                                y
                                                                                                    ._options
                                                                                                    .actions
                                                                                            );
                                                                                        }
                                                                                    ),
                                                                                    g,
                                                                                    d
                                                                                ),
                                                                                3
                                                                            ),
                                                                            T =
                                                                                k[0],
                                                                            q =
                                                                                k[1],
                                                                            z =
                                                                                k[2],
                                                                            A =
                                                                                null !=
                                                                                j
                                                                                    ? j
                                                                                    : p;
                                                                        return {
                                                                            value: A,
                                                                            context: q,
                                                                            actions: T,
                                                                            changed:
                                                                                j !==
                                                                                    p ||
                                                                                T.length >
                                                                                    0 ||
                                                                                z,
                                                                            matches: a(
                                                                                A
                                                                            ),
                                                                        };
                                                                    }
                                                                }
                                                            } catch (t) {
                                                                s = {
                                                                    error: t,
                                                                };
                                                            } finally {
                                                                try {
                                                                    b &&
                                                                        !b.done &&
                                                                        (l =
                                                                            h.return) &&
                                                                        l.call(
                                                                            h
                                                                        );
                                                                } finally {
                                                                    if (s)
                                                                        throw s.error;
                                                                }
                                                            }
                                                        }
                                                        return c(p, g);
                                                    },
                                                };
                                            return y;
                                        }
                                        var l = function (t, n) {
                                            return t.actions.forEach(function (
                                                e
                                            ) {
                                                var r = e.exec;
                                                return r && r(t.context, n);
                                            });
                                        };
                                        function v(t) {
                                            var r = t.initialState,
                                                o = n.NotStarted,
                                                i = new Set(),
                                                c = {
                                                    _machine: t,
                                                    send: function (e) {
                                                        o === n.Running &&
                                                            ((r = t.transition(
                                                                r,
                                                                e
                                                            )),
                                                            l(r, u(e)),
                                                            i.forEach(function (
                                                                t
                                                            ) {
                                                                return t(r);
                                                            }));
                                                    },
                                                    subscribe: function (t) {
                                                        return (
                                                            i.add(t),
                                                            t(r),
                                                            {
                                                                unsubscribe: function () {
                                                                    return i.delete(
                                                                        t
                                                                    );
                                                                },
                                                            }
                                                        );
                                                    },
                                                    start: function (i) {
                                                        if (i) {
                                                            var u =
                                                                'object' ==
                                                                typeof i
                                                                    ? i
                                                                    : {
                                                                          context:
                                                                              t
                                                                                  .config
                                                                                  .context,
                                                                          value: i,
                                                                      };
                                                            r = {
                                                                value: u.value,
                                                                actions: [],
                                                                context:
                                                                    u.context,
                                                                matches: a(
                                                                    u.value
                                                                ),
                                                            };
                                                        }
                                                        return (
                                                            (o = n.Running),
                                                            l(r, e),
                                                            c
                                                        );
                                                    },
                                                    stop: function () {
                                                        return (
                                                            (o = n.Stopped),
                                                            i.clear(),
                                                            c
                                                        );
                                                    },
                                                    get state() {
                                                        return r;
                                                    },
                                                    get status() {
                                                        return o;
                                                    },
                                                };
                                            return c;
                                        }

                                        /***/
                                    },

                                /***/ './src/replay/styles/style.css':
                                    /*!*************************************!*\
  !*** ./src/replay/styles/style.css ***!
  \*************************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        __webpack_exports__,
                                        __nested_webpack_require_5333__
                                    ) => {
                                        __nested_webpack_require_5333__.r(
                                            __webpack_exports__
                                        );
                                        // extracted by mini-css-extract-plugin

                                        /***/
                                    },

                                /***/ './node_modules/mitt/dist/mitt.es.js':
                                    /*!*******************************************!*\
  !*** ./node_modules/mitt/dist/mitt.es.js ***!
  \*******************************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        __webpack_exports__,
                                        __nested_webpack_require_5702__
                                    ) => {
                                        __nested_webpack_require_5702__.r(
                                            __webpack_exports__
                                        );
                                        /* harmony export */ __nested_webpack_require_5702__.d(
                                            __webpack_exports__,
                                            {
                                                /* harmony export */ default: () =>
                                                    __WEBPACK_DEFAULT_EXPORT__,
                                                /* harmony export */
                                            }
                                        );
                                        //
                                        // An event handler can take an optional event argument
                                        // and should not return a value

                                        // An array of all currently registered event handlers for a type

                                        // A map of event types and their corresponding event handlers.

                                        /** Mitt: Tiny (~200b) functional event emitter / pubsub.
                                         *  @name mitt
                                         *  @returns {Mitt}
                                         */
                                        function mitt(all) {
                                            all = all || Object.create(null);

                                            return {
                                                /**
                                                 * Register an event handler for the given type.
                                                 *
                                                 * @param  {String} type	Type of event to listen for, or `"*"` for all events
                                                 * @param  {Function} handler Function to call in response to given event
                                                 * @memberOf mitt
                                                 */
                                                on: function on(type, handler) {
                                                    (
                                                        all[type] ||
                                                        (all[type] = [])
                                                    ).push(handler);
                                                },

                                                /**
                                                 * Remove an event handler for the given type.
                                                 *
                                                 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
                                                 * @param  {Function} handler Handler function to remove
                                                 * @memberOf mitt
                                                 */
                                                off: function off(
                                                    type,
                                                    handler
                                                ) {
                                                    if (all[type]) {
                                                        all[type].splice(
                                                            all[type].indexOf(
                                                                handler
                                                            ) >>> 0,
                                                            1
                                                        );
                                                    }
                                                },

                                                /**
                                                 * Invoke all handlers for the given type.
                                                 * If present, `"*"` handlers are invoked after type-matched handlers.
                                                 *
                                                 * @param {String} type  The event type to invoke
                                                 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
                                                 * @memberOf mitt
                                                 */
                                                emit: function emit(type, evt) {
                                                    (all[type] || [])
                                                        .slice()
                                                        .map(function (
                                                            handler
                                                        ) {
                                                            handler(evt);
                                                        });
                                                    (all['*'] || [])
                                                        .slice()
                                                        .map(function (
                                                            handler
                                                        ) {
                                                            handler(type, evt);
                                                        });
                                                },
                                            };
                                        }

                                        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = mitt;
                                        //# sourceMappingURL=mitt.es.js.map

                                        /***/
                                    },

                                /***/ './src/record/index.ts':
                                    /*!*****************************!*\
  !*** ./src/record/index.ts ***!
  \*****************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_8203__
                                    ) {
                                        var __assign =
                                            (this && this.__assign) ||
                                            function () {
                                                __assign =
                                                    Object.assign ||
                                                    function (t) {
                                                        for (
                                                            var s,
                                                                i = 1,
                                                                n =
                                                                    arguments.length;
                                                            i < n;
                                                            i++
                                                        ) {
                                                            s = arguments[i];
                                                            for (var p in s)
                                                                if (
                                                                    Object.prototype.hasOwnProperty.call(
                                                                        s,
                                                                        p
                                                                    )
                                                                )
                                                                    t[p] = s[p];
                                                        }
                                                        return t;
                                                    };
                                                return __assign.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                        var __read =
                                            (this && this.__read) ||
                                            function (o, n) {
                                                var m =
                                                    typeof Symbol ===
                                                        'function' &&
                                                    o[Symbol.iterator];
                                                if (!m) return o;
                                                var i = m.call(o),
                                                    r,
                                                    ar = [],
                                                    e;
                                                try {
                                                    while (
                                                        (n === void 0 ||
                                                            n-- > 0) &&
                                                        !(r = i.next()).done
                                                    )
                                                        ar.push(r.value);
                                                } catch (error) {
                                                    e = { error: error };
                                                } finally {
                                                    try {
                                                        if (
                                                            r &&
                                                            !r.done &&
                                                            (m = i['return'])
                                                        )
                                                            m.call(i);
                                                    } finally {
                                                        if (e) throw e.error;
                                                    }
                                                }
                                                return ar;
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        var snapshot_1 = __nested_webpack_require_8203__(
                                            /*! ../snapshot */ './src/snapshot/index.ts'
                                        );
                                        var observer_1 = __nested_webpack_require_8203__(
                                            /*! ./observer */ './src/record/observer.ts'
                                        );
                                        var utils_1 = __nested_webpack_require_8203__(
                                            /*! ../utils */ './src/utils.ts'
                                        );
                                        var types_1 = __nested_webpack_require_8203__(
                                            /*! ../types */ './src/types.ts'
                                        );
                                        function wrapEvent(e) {
                                            return __assign(__assign({}, e), {
                                                timestamp: Date.now(),
                                            });
                                        }
                                        var wrappedEmit;
                                        function record(options) {
                                            if (options === void 0) {
                                                options = {};
                                            }
                                            var emit = options.emit,
                                                checkoutEveryNms =
                                                    options.checkoutEveryNms,
                                                checkoutEveryNth =
                                                    options.checkoutEveryNth,
                                                _a = options.blockClass,
                                                blockClass =
                                                    _a === void 0
                                                        ? 'rr-block'
                                                        : _a,
                                                _b = options.blockSelector,
                                                blockSelector =
                                                    _b === void 0 ? null : _b,
                                                _c = options.ignoreClass,
                                                ignoreClass =
                                                    _c === void 0
                                                        ? 'rr-ignore'
                                                        : _c,
                                                _d = options.inlineStylesheet,
                                                inlineStylesheet =
                                                    _d === void 0 ? true : _d,
                                                maskAllInputs =
                                                    options.maskAllInputs,
                                                _maskInputOptions =
                                                    options.maskInputOptions,
                                                _slimDOMOptions =
                                                    options.slimDOMOptions,
                                                maskInputFn =
                                                    options.maskInputFn,
                                                hooks = options.hooks,
                                                packFn = options.packFn,
                                                _e = options.sampling,
                                                sampling =
                                                    _e === void 0 ? {} : _e,
                                                mousemoveWait =
                                                    options.mousemoveWait,
                                                _f = options.recordCanvas,
                                                recordCanvas =
                                                    _f === void 0 ? false : _f,
                                                _g = options.collectFonts,
                                                collectFonts =
                                                    _g === void 0 ? false : _g,
                                                _h = options.recordLog,
                                                recordLog =
                                                    _h === void 0 ? false : _h,
                                                debug = options.debug;
                                            if (!emit) {
                                                throw new Error(
                                                    'emit function is required'
                                                );
                                            }
                                            if (
                                                mousemoveWait !== undefined &&
                                                sampling.mousemove === undefined
                                            ) {
                                                sampling.mousemove = mousemoveWait;
                                            }
                                            var maskInputOptions =
                                                maskAllInputs === true
                                                    ? {
                                                          color: true,
                                                          date: true,
                                                          'datetime-local': true,
                                                          email: true,
                                                          month: true,
                                                          number: true,
                                                          range: true,
                                                          search: true,
                                                          tel: true,
                                                          text: true,
                                                          time: true,
                                                          url: true,
                                                          week: true,
                                                          textarea: true,
                                                          select: true,
                                                      }
                                                    : _maskInputOptions !==
                                                      undefined
                                                    ? _maskInputOptions
                                                    : {};
                                            var slimDOMOptions =
                                                _slimDOMOptions === true ||
                                                _slimDOMOptions === 'all'
                                                    ? {
                                                          script: true,
                                                          comment: true,
                                                          headFavicon: true,
                                                          headWhitespace: true,
                                                          headMetaSocial: true,
                                                          headMetaRobots: true,
                                                          headMetaHttpEquiv: true,
                                                          headMetaVerification: true,
                                                          headMetaAuthorship:
                                                              _slimDOMOptions ===
                                                              'all',
                                                          headMetaDescKeywords:
                                                              _slimDOMOptions ===
                                                              'all',
                                                      }
                                                    : _slimDOMOptions
                                                    ? _slimDOMOptions
                                                    : {};
                                            var defaultLogOptions = {
                                                level: [
                                                    'assert',
                                                    'clear',
                                                    'count',
                                                    'countReset',
                                                    'debug',
                                                    'dir',
                                                    'dirxml',
                                                    'error',
                                                    'group',
                                                    'groupCollapsed',
                                                    'groupEnd',
                                                    'info',
                                                    'log',
                                                    'table',
                                                    'time',
                                                    'timeEnd',
                                                    'timeLog',
                                                    'trace',
                                                    'warn',
                                                ],
                                                lengthThreshold: 1000,
                                                logger: console,
                                            };
                                            var logOptions = recordLog
                                                ? recordLog === true
                                                    ? defaultLogOptions
                                                    : Object.assign(
                                                          {},
                                                          defaultLogOptions,
                                                          recordLog
                                                      )
                                                : {};
                                            utils_1.polyfill();
                                            var lastFullSnapshotEvent;
                                            var incrementalSnapshotCount = 0;
                                            wrappedEmit = function (
                                                e,
                                                isCheckout
                                            ) {
                                                if (
                                                    observer_1.mutationBuffer.isFrozen() &&
                                                    e.type !==
                                                        types_1.EventType
                                                            .FullSnapshot &&
                                                    !(
                                                        e.type ===
                                                            types_1.EventType
                                                                .IncrementalSnapshot &&
                                                        e.data.source ===
                                                            types_1
                                                                .IncrementalSource
                                                                .Mutation
                                                    )
                                                ) {
                                                    observer_1.mutationBuffer.emit();
                                                    observer_1.mutationBuffer.unfreeze();
                                                }
                                                emit(
                                                    packFn ? packFn(e) : e,
                                                    isCheckout
                                                );
                                                if (
                                                    e.type ===
                                                    types_1.EventType
                                                        .FullSnapshot
                                                ) {
                                                    lastFullSnapshotEvent = e;
                                                    incrementalSnapshotCount = 0;
                                                } else if (
                                                    e.type ===
                                                    types_1.EventType
                                                        .IncrementalSnapshot
                                                ) {
                                                    incrementalSnapshotCount++;
                                                    var exceedCount =
                                                        checkoutEveryNth &&
                                                        incrementalSnapshotCount >=
                                                            checkoutEveryNth;
                                                    var exceedTime =
                                                        checkoutEveryNms &&
                                                        e.timestamp -
                                                            lastFullSnapshotEvent.timestamp >
                                                            checkoutEveryNms;
                                                    if (
                                                        exceedCount ||
                                                        exceedTime
                                                    ) {
                                                        takeFullSnapshot(true);
                                                    }
                                                }
                                            };
                                            function takeFullSnapshot(
                                                isCheckout
                                            ) {
                                                var _a, _b, _c, _d;
                                                if (isCheckout === void 0) {
                                                    isCheckout = false;
                                                }
                                                wrappedEmit(
                                                    wrapEvent({
                                                        type:
                                                            types_1.EventType
                                                                .Meta,
                                                        data: {
                                                            href:
                                                                window.location
                                                                    .href,
                                                            width: utils_1.getWindowWidth(),
                                                            height: utils_1.getWindowHeight(),
                                                        },
                                                    }),
                                                    isCheckout
                                                );
                                                var wasFrozen = observer_1.mutationBuffer.isFrozen();
                                                observer_1.mutationBuffer.freeze();
                                                var _e = __read(
                                                        snapshot_1.snapshot(
                                                            document,
                                                            {
                                                                blockClass: blockClass,
                                                                blockSelector: blockSelector,
                                                                inlineStylesheet: inlineStylesheet,
                                                                maskAllInputs: maskInputOptions,
                                                                slimDOM: slimDOMOptions,
                                                                recordCanvas: recordCanvas,
                                                            }
                                                        ),
                                                        2
                                                    ),
                                                    node = _e[0],
                                                    idNodeMap = _e[1];
                                                if (!node) {
                                                    return console.warn(
                                                        'Failed to snapshot the document'
                                                    );
                                                }
                                                utils_1.mirror.map = idNodeMap;
                                                wrappedEmit(
                                                    wrapEvent({
                                                        type:
                                                            types_1.EventType
                                                                .FullSnapshot,
                                                        data: {
                                                            node: node,
                                                            initialOffset: {
                                                                left:
                                                                    window.pageXOffset !==
                                                                    undefined
                                                                        ? window.pageXOffset
                                                                        : (document ===
                                                                              null ||
                                                                          document ===
                                                                              void 0
                                                                              ? void 0
                                                                              : document
                                                                                    .documentElement
                                                                                    .scrollLeft) ||
                                                                          ((_b =
                                                                              (_a =
                                                                                  document ===
                                                                                      null ||
                                                                                  document ===
                                                                                      void 0
                                                                                      ? void 0
                                                                                      : document.body) ===
                                                                                  null ||
                                                                              _a ===
                                                                                  void 0
                                                                                  ? void 0
                                                                                  : _a.parentElement) ===
                                                                              null ||
                                                                          _b ===
                                                                              void 0
                                                                              ? void 0
                                                                              : _b.scrollLeft) ||
                                                                          (document ===
                                                                              null ||
                                                                          document ===
                                                                              void 0
                                                                              ? void 0
                                                                              : document
                                                                                    .body
                                                                                    .scrollLeft) ||
                                                                          0,
                                                                top:
                                                                    window.pageYOffset !==
                                                                    undefined
                                                                        ? window.pageYOffset
                                                                        : (document ===
                                                                              null ||
                                                                          document ===
                                                                              void 0
                                                                              ? void 0
                                                                              : document
                                                                                    .documentElement
                                                                                    .scrollTop) ||
                                                                          ((_d =
                                                                              (_c =
                                                                                  document ===
                                                                                      null ||
                                                                                  document ===
                                                                                      void 0
                                                                                      ? void 0
                                                                                      : document.body) ===
                                                                                  null ||
                                                                              _c ===
                                                                                  void 0
                                                                                  ? void 0
                                                                                  : _c.parentElement) ===
                                                                              null ||
                                                                          _d ===
                                                                              void 0
                                                                              ? void 0
                                                                              : _d.scrollTop) ||
                                                                          (document ===
                                                                              null ||
                                                                          document ===
                                                                              void 0
                                                                              ? void 0
                                                                              : document
                                                                                    .body
                                                                                    .scrollTop) ||
                                                                          0,
                                                            },
                                                        },
                                                    })
                                                );
                                                if (!wasFrozen) {
                                                    observer_1.mutationBuffer.emit();
                                                    observer_1.mutationBuffer.unfreeze();
                                                }
                                            }
                                            try {
                                                var handlers_1 = [];
                                                handlers_1.push(
                                                    utils_1.on(
                                                        'DOMContentLoaded',
                                                        function () {
                                                            wrappedEmit(
                                                                wrapEvent({
                                                                    type:
                                                                        types_1
                                                                            .EventType
                                                                            .DomContentLoaded,
                                                                    data: {},
                                                                })
                                                            );
                                                        }
                                                    )
                                                );
                                                var init_1 = function () {
                                                    takeFullSnapshot();
                                                    handlers_1.push(
                                                        observer_1.initObservers(
                                                            {
                                                                mutationCb: function (
                                                                    m
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .Mutation,
                                                                                    },
                                                                                    m
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                mousemoveCb: function (
                                                                    positions,
                                                                    source
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: {
                                                                                    source: source,
                                                                                    positions: positions,
                                                                                },
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                mouseInteractionCb: function (
                                                                    d
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .MouseInteraction,
                                                                                    },
                                                                                    d
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                scrollCb: function (
                                                                    p
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .Scroll,
                                                                                    },
                                                                                    p
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                viewportResizeCb: function (
                                                                    d
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .ViewportResize,
                                                                                    },
                                                                                    d
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                inputCb: function (
                                                                    v
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .Input,
                                                                                    },
                                                                                    v
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                mediaInteractionCb: function (
                                                                    p
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .MediaInteraction,
                                                                                    },
                                                                                    p
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                styleSheetRuleCb: function (
                                                                    r
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .StyleSheetRule,
                                                                                    },
                                                                                    r
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                canvasMutationCb: function (
                                                                    p
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .CanvasMutation,
                                                                                    },
                                                                                    p
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                fontCb: function (
                                                                    p
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .Font,
                                                                                    },
                                                                                    p
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                logCb: function (
                                                                    p
                                                                ) {
                                                                    return wrappedEmit(
                                                                        wrapEvent(
                                                                            {
                                                                                type:
                                                                                    types_1
                                                                                        .EventType
                                                                                        .IncrementalSnapshot,
                                                                                data: __assign(
                                                                                    {
                                                                                        source:
                                                                                            types_1
                                                                                                .IncrementalSource
                                                                                                .Log,
                                                                                    },
                                                                                    p
                                                                                ),
                                                                            }
                                                                        )
                                                                    );
                                                                },
                                                                blockClass: blockClass,
                                                                blockSelector: blockSelector,
                                                                ignoreClass: ignoreClass,
                                                                maskInputOptions: maskInputOptions,
                                                                maskInputFn: maskInputFn,
                                                                inlineStylesheet: inlineStylesheet,
                                                                sampling: sampling,
                                                                recordCanvas: recordCanvas,
                                                                collectFonts: collectFonts,
                                                                slimDOMOptions: slimDOMOptions,
                                                                logOptions: logOptions,
                                                            },
                                                            hooks
                                                        )
                                                    );
                                                };
                                                if (
                                                    document.readyState ===
                                                        'interactive' ||
                                                    document.readyState ===
                                                        'complete'
                                                ) {
                                                    init_1();
                                                } else {
                                                    handlers_1.push(
                                                        utils_1.on(
                                                            'load',
                                                            function () {
                                                                wrappedEmit(
                                                                    wrapEvent({
                                                                        type:
                                                                            types_1
                                                                                .EventType
                                                                                .Load,
                                                                        data: {},
                                                                    })
                                                                );
                                                                init_1();
                                                            },
                                                            window
                                                        )
                                                    );
                                                }
                                                return function () {
                                                    handlers_1.forEach(
                                                        function (h) {
                                                            return h();
                                                        }
                                                    );
                                                };
                                            } catch (error) {
                                                console.warn(error);
                                            }
                                        }
                                        record.addCustomEvent = function (
                                            tag,
                                            payload
                                        ) {
                                            if (!wrappedEmit) {
                                                throw new Error(
                                                    'please add custom event after start recording'
                                                );
                                            }
                                            wrappedEmit(
                                                wrapEvent({
                                                    type:
                                                        types_1.EventType
                                                            .Custom,
                                                    data: {
                                                        tag: tag,
                                                        payload: payload,
                                                    },
                                                })
                                            );
                                        };
                                        record.freezePage = function () {
                                            observer_1.mutationBuffer.freeze();
                                        };
                                        exports.default = record;

                                        /***/
                                    },

                                /***/ './src/record/mutation.ts':
                                    /*!********************************!*\
  !*** ./src/record/mutation.ts ***!
  \********************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_21661__
                                    ) {
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        var snapshot_1 = __nested_webpack_require_21661__(
                                            /*! ../snapshot */ './src/snapshot/index.ts'
                                        );
                                        var utils_1 = __nested_webpack_require_21661__(
                                            /*! ../utils */ './src/utils.ts'
                                        );
                                        function isNodeInLinkedList(n) {
                                            return '__ln' in n;
                                        }
                                        var DoubleLinkedList = (function () {
                                            function DoubleLinkedList() {
                                                this.length = 0;
                                                this.head = null;
                                            }
                                            DoubleLinkedList.prototype.get = function (
                                                position
                                            ) {
                                                if (position >= this.length) {
                                                    throw new Error(
                                                        'Position outside of list range'
                                                    );
                                                }
                                                var current = this.head;
                                                for (
                                                    var index = 0;
                                                    index < position;
                                                    index++
                                                ) {
                                                    current =
                                                        (current === null ||
                                                        current === void 0
                                                            ? void 0
                                                            : current.next) ||
                                                        null;
                                                }
                                                return current;
                                            };
                                            DoubleLinkedList.prototype.addNode = function (
                                                n
                                            ) {
                                                var node = {
                                                    value: n,
                                                    previous: null,
                                                    next: null,
                                                };
                                                n.__ln = node;
                                                if (
                                                    n.previousSibling &&
                                                    isNodeInLinkedList(
                                                        n.previousSibling
                                                    )
                                                ) {
                                                    var current =
                                                        n.previousSibling.__ln
                                                            .next;
                                                    node.next = current;
                                                    node.previous =
                                                        n.previousSibling.__ln;
                                                    n.previousSibling.__ln.next = node;
                                                    if (current) {
                                                        current.previous = node;
                                                    }
                                                } else if (
                                                    n.nextSibling &&
                                                    isNodeInLinkedList(
                                                        n.nextSibling
                                                    )
                                                ) {
                                                    var current =
                                                        n.nextSibling.__ln
                                                            .previous;
                                                    node.previous = current;
                                                    node.next =
                                                        n.nextSibling.__ln;
                                                    n.nextSibling.__ln.previous = node;
                                                    if (current) {
                                                        current.next = node;
                                                    }
                                                } else {
                                                    if (this.head) {
                                                        this.head.previous = node;
                                                    }
                                                    node.next = this.head;
                                                    this.head = node;
                                                }
                                                this.length++;
                                            };
                                            DoubleLinkedList.prototype.removeNode = function (
                                                n
                                            ) {
                                                var current = n.__ln;
                                                if (!this.head) {
                                                    return;
                                                }
                                                if (!current.previous) {
                                                    this.head = current.next;
                                                    if (this.head) {
                                                        this.head.previous = null;
                                                    }
                                                } else {
                                                    current.previous.next =
                                                        current.next;
                                                    if (current.next) {
                                                        current.next.previous =
                                                            current.previous;
                                                    }
                                                }
                                                if (n.__ln) {
                                                    delete n.__ln;
                                                }
                                                this.length--;
                                            };
                                            return DoubleLinkedList;
                                        })();
                                        var moveKey = function (id, parentId) {
                                            return id + '@' + parentId;
                                        };
                                        function isINode(n) {
                                            return '__sn' in n;
                                        }
                                        var MutationBuffer = (function () {
                                            function MutationBuffer() {
                                                var _this = this;
                                                this.frozen = false;
                                                this.texts = [];
                                                this.attributes = [];
                                                this.removes = [];
                                                this.mapRemoves = [];
                                                this.movedMap = {};
                                                this.addedSet = new Set();
                                                this.movedSet = new Set();
                                                this.droppedSet = new Set();
                                                this.processMutations = function (
                                                    mutations
                                                ) {
                                                    mutations.forEach(
                                                        _this.processMutation
                                                    );
                                                    if (!_this.frozen) {
                                                        _this.emit();
                                                    }
                                                };
                                                this.emit = function () {
                                                    var e_1, _a, e_2, _b;
                                                    var adds = [];
                                                    var addList = new DoubleLinkedList();
                                                    var getNextId = function (
                                                        n
                                                    ) {
                                                        var ns = n;
                                                        var nextId =
                                                            snapshot_1.IGNORED_NODE;
                                                        while (
                                                            nextId ===
                                                            snapshot_1.IGNORED_NODE
                                                        ) {
                                                            ns =
                                                                ns &&
                                                                ns.nextSibling;
                                                            nextId =
                                                                ns &&
                                                                utils_1.mirror.getId(
                                                                    ns
                                                                );
                                                        }
                                                        if (
                                                            nextId === -1 &&
                                                            utils_1.isBlocked(
                                                                n.nextSibling,
                                                                _this.blockClass
                                                            )
                                                        ) {
                                                            nextId = null;
                                                        }
                                                        return nextId;
                                                    };
                                                    var pushAdd = function (n) {
                                                        if (
                                                            !n.parentNode ||
                                                            !document.contains(
                                                                n
                                                            )
                                                        ) {
                                                            return;
                                                        }
                                                        var parentId = utils_1.mirror.getId(
                                                            n.parentNode
                                                        );
                                                        var nextId = getNextId(
                                                            n
                                                        );
                                                        if (
                                                            parentId === -1 ||
                                                            nextId === -1
                                                        ) {
                                                            return addList.addNode(
                                                                n
                                                            );
                                                        }
                                                        var sn = snapshot_1.serializeNodeWithId(
                                                            n,
                                                            {
                                                                doc: document,
                                                                map:
                                                                    utils_1
                                                                        .mirror
                                                                        .map,
                                                                blockClass:
                                                                    _this.blockClass,
                                                                blockSelector:
                                                                    _this.blockSelector,
                                                                skipChild: true,
                                                                inlineStylesheet:
                                                                    _this.inlineStylesheet,
                                                                maskInputOptions:
                                                                    _this.maskInputOptions,
                                                                slimDOMOptions:
                                                                    _this.slimDOMOptions,
                                                                recordCanvas:
                                                                    _this.recordCanvas,
                                                            }
                                                        );
                                                        if (sn) {
                                                            adds.push({
                                                                parentId: parentId,
                                                                nextId: nextId,
                                                                node: sn,
                                                            });
                                                        }
                                                    };
                                                    while (
                                                        _this.mapRemoves.length
                                                    ) {
                                                        utils_1.mirror.removeNodeFromMap(
                                                            _this.mapRemoves.shift()
                                                        );
                                                    }
                                                    try {
                                                        for (
                                                            var _c = __values(
                                                                    _this.movedSet
                                                                ),
                                                                _d = _c.next();
                                                            !_d.done;
                                                            _d = _c.next()
                                                        ) {
                                                            var n = _d.value;
                                                            if (
                                                                isParentRemoved(
                                                                    _this.removes,
                                                                    n
                                                                ) &&
                                                                !_this.movedSet.has(
                                                                    n.parentNode
                                                                )
                                                            ) {
                                                                continue;
                                                            }
                                                            pushAdd(n);
                                                        }
                                                    } catch (e_1_1) {
                                                        e_1 = { error: e_1_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                _d &&
                                                                !_d.done &&
                                                                (_a = _c.return)
                                                            )
                                                                _a.call(_c);
                                                        } finally {
                                                            if (e_1)
                                                                throw e_1.error;
                                                        }
                                                    }
                                                    try {
                                                        for (
                                                            var _e = __values(
                                                                    _this.addedSet
                                                                ),
                                                                _f = _e.next();
                                                            !_f.done;
                                                            _f = _e.next()
                                                        ) {
                                                            var n = _f.value;
                                                            if (
                                                                !isAncestorInSet(
                                                                    _this.droppedSet,
                                                                    n
                                                                ) &&
                                                                !isParentRemoved(
                                                                    _this.removes,
                                                                    n
                                                                )
                                                            ) {
                                                                pushAdd(n);
                                                            } else if (
                                                                isAncestorInSet(
                                                                    _this.movedSet,
                                                                    n
                                                                )
                                                            ) {
                                                                pushAdd(n);
                                                            } else {
                                                                _this.droppedSet.add(
                                                                    n
                                                                );
                                                            }
                                                        }
                                                    } catch (e_2_1) {
                                                        e_2 = { error: e_2_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                _f &&
                                                                !_f.done &&
                                                                (_b = _e.return)
                                                            )
                                                                _b.call(_e);
                                                        } finally {
                                                            if (e_2)
                                                                throw e_2.error;
                                                        }
                                                    }
                                                    var candidate = null;
                                                    while (addList.length) {
                                                        var node = null;
                                                        if (candidate) {
                                                            var parentId = utils_1.mirror.getId(
                                                                candidate.value
                                                                    .parentNode
                                                            );
                                                            var nextId = getNextId(
                                                                candidate.value
                                                            );
                                                            if (
                                                                parentId !==
                                                                    -1 &&
                                                                nextId !== -1
                                                            ) {
                                                                node = candidate;
                                                            }
                                                        }
                                                        if (!node) {
                                                            for (
                                                                var index =
                                                                    addList.length -
                                                                    1;
                                                                index >= 0;
                                                                index--
                                                            ) {
                                                                var _node = addList.get(
                                                                    index
                                                                );
                                                                var parentId = utils_1.mirror.getId(
                                                                    _node.value
                                                                        .parentNode
                                                                );
                                                                var nextId = getNextId(
                                                                    _node.value
                                                                );
                                                                if (
                                                                    parentId !==
                                                                        -1 &&
                                                                    nextId !==
                                                                        -1
                                                                ) {
                                                                    node = _node;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (!node) {
                                                            while (
                                                                addList.head
                                                            ) {
                                                                addList.removeNode(
                                                                    addList.head
                                                                        .value
                                                                );
                                                            }
                                                            break;
                                                        }
                                                        candidate =
                                                            node.previous;
                                                        addList.removeNode(
                                                            node.value
                                                        );
                                                        pushAdd(node.value);
                                                    }
                                                    var payload = {
                                                        texts: _this.texts
                                                            .map(function (
                                                                text
                                                            ) {
                                                                return {
                                                                    id: utils_1.mirror.getId(
                                                                        text.node
                                                                    ),
                                                                    value:
                                                                        text.value,
                                                                };
                                                            })
                                                            .filter(function (
                                                                text
                                                            ) {
                                                                return utils_1.mirror.has(
                                                                    text.id
                                                                );
                                                            }),
                                                        attributes: _this.attributes
                                                            .map(function (
                                                                attribute
                                                            ) {
                                                                return {
                                                                    id: utils_1.mirror.getId(
                                                                        attribute.node
                                                                    ),
                                                                    attributes:
                                                                        attribute.attributes,
                                                                };
                                                            })
                                                            .filter(function (
                                                                attribute
                                                            ) {
                                                                return utils_1.mirror.has(
                                                                    attribute.id
                                                                );
                                                            }),
                                                        removes: _this.removes,
                                                        adds: adds,
                                                    };
                                                    if (
                                                        !payload.texts.length &&
                                                        !payload.attributes
                                                            .length &&
                                                        !payload.removes
                                                            .length &&
                                                        !payload.adds.length
                                                    ) {
                                                        return;
                                                    }
                                                    _this.texts = [];
                                                    _this.attributes = [];
                                                    _this.removes = [];
                                                    _this.addedSet = new Set();
                                                    _this.movedSet = new Set();
                                                    _this.droppedSet = new Set();
                                                    _this.movedMap = {};
                                                    _this.emissionCallback(
                                                        payload
                                                    );
                                                };
                                                this.processMutation = function (
                                                    m
                                                ) {
                                                    if (
                                                        utils_1.isIgnored(
                                                            m.target
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    switch (m.type) {
                                                        case 'characterData': {
                                                            var value =
                                                                m.target
                                                                    .textContent;
                                                            if (
                                                                !utils_1.isBlocked(
                                                                    m.target,
                                                                    _this.blockClass
                                                                ) &&
                                                                value !==
                                                                    m.oldValue
                                                            ) {
                                                                _this.texts.push(
                                                                    {
                                                                        value: value,
                                                                        node:
                                                                            m.target,
                                                                    }
                                                                );
                                                            }
                                                            break;
                                                        }
                                                        case 'attributes': {
                                                            var value = m.target.getAttribute(
                                                                m.attributeName
                                                            );
                                                            if (
                                                                utils_1.isBlocked(
                                                                    m.target,
                                                                    _this.blockClass
                                                                ) ||
                                                                value ===
                                                                    m.oldValue
                                                            ) {
                                                                return;
                                                            }
                                                            var item = _this.attributes.find(
                                                                function (a) {
                                                                    return (
                                                                        a.node ===
                                                                        m.target
                                                                    );
                                                                }
                                                            );
                                                            if (!item) {
                                                                item = {
                                                                    node:
                                                                        m.target,
                                                                    attributes: {},
                                                                };
                                                                _this.attributes.push(
                                                                    item
                                                                );
                                                            }
                                                            item.attributes[
                                                                m.attributeName
                                                            ] = snapshot_1.transformAttribute(
                                                                document,
                                                                m.attributeName,
                                                                value
                                                            );
                                                            break;
                                                        }
                                                        case 'childList': {
                                                            m.addedNodes.forEach(
                                                                function (n) {
                                                                    return _this.genAdds(
                                                                        n,
                                                                        m.target
                                                                    );
                                                                }
                                                            );
                                                            m.removedNodes.forEach(
                                                                function (n) {
                                                                    var nodeId = utils_1.mirror.getId(
                                                                        n
                                                                    );
                                                                    var parentId = utils_1.mirror.getId(
                                                                        m.target
                                                                    );
                                                                    if (
                                                                        utils_1.isBlocked(
                                                                            n,
                                                                            _this.blockClass
                                                                        ) ||
                                                                        utils_1.isBlocked(
                                                                            m.target,
                                                                            _this.blockClass
                                                                        ) ||
                                                                        utils_1.isIgnored(
                                                                            n
                                                                        )
                                                                    ) {
                                                                        return;
                                                                    }
                                                                    if (
                                                                        _this.addedSet.has(
                                                                            n
                                                                        )
                                                                    ) {
                                                                        deepDelete(
                                                                            _this.addedSet,
                                                                            n
                                                                        );
                                                                        _this.droppedSet.add(
                                                                            n
                                                                        );
                                                                    } else if (
                                                                        _this.addedSet.has(
                                                                            m.target
                                                                        ) &&
                                                                        nodeId ===
                                                                            -1
                                                                    ) {
                                                                    } else if (
                                                                        utils_1.isAncestorRemoved(
                                                                            m.target
                                                                        )
                                                                    ) {
                                                                    } else if (
                                                                        _this.movedSet.has(
                                                                            n
                                                                        ) &&
                                                                        _this
                                                                            .movedMap[
                                                                            moveKey(
                                                                                nodeId,
                                                                                parentId
                                                                            )
                                                                        ]
                                                                    ) {
                                                                        deepDelete(
                                                                            _this.movedSet,
                                                                            n
                                                                        );
                                                                    } else {
                                                                        _this.removes.push(
                                                                            {
                                                                                parentId: parentId,
                                                                                id: nodeId,
                                                                            }
                                                                        );
                                                                    }
                                                                    _this.mapRemoves.push(
                                                                        n
                                                                    );
                                                                }
                                                            );
                                                            break;
                                                        }
                                                        default:
                                                            break;
                                                    }
                                                };
                                                this.genAdds = function (
                                                    n,
                                                    target
                                                ) {
                                                    if (
                                                        utils_1.isBlocked(
                                                            n,
                                                            _this.blockClass
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    if (
                                                        target &&
                                                        utils_1.isBlocked(
                                                            target,
                                                            _this.blockClass
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    if (isINode(n)) {
                                                        if (
                                                            utils_1.isIgnored(n)
                                                        ) {
                                                            return;
                                                        }
                                                        _this.movedSet.add(n);
                                                        var targetId = null;
                                                        if (
                                                            target &&
                                                            isINode(target)
                                                        ) {
                                                            targetId =
                                                                target.__sn.id;
                                                        }
                                                        if (targetId) {
                                                            _this.movedMap[
                                                                moveKey(
                                                                    n.__sn.id,
                                                                    targetId
                                                                )
                                                            ] = true;
                                                        }
                                                    } else {
                                                        _this.addedSet.add(n);
                                                        _this.droppedSet.delete(
                                                            n
                                                        );
                                                    }
                                                    n.childNodes.forEach(
                                                        function (childN) {
                                                            return _this.genAdds(
                                                                childN
                                                            );
                                                        }
                                                    );
                                                };
                                            }
                                            MutationBuffer.prototype.init = function (
                                                cb,
                                                blockClass,
                                                blockSelector,
                                                inlineStylesheet,
                                                maskInputOptions,
                                                recordCanvas,
                                                slimDOMOptions
                                            ) {
                                                this.blockClass = blockClass;
                                                this.blockSelector = blockSelector;
                                                this.inlineStylesheet = inlineStylesheet;
                                                this.maskInputOptions = maskInputOptions;
                                                this.recordCanvas = recordCanvas;
                                                this.slimDOMOptions = slimDOMOptions;
                                                this.emissionCallback = cb;
                                            };
                                            MutationBuffer.prototype.freeze = function () {
                                                this.frozen = true;
                                            };
                                            MutationBuffer.prototype.unfreeze = function () {
                                                this.frozen = false;
                                            };
                                            MutationBuffer.prototype.isFrozen = function () {
                                                return this.frozen;
                                            };
                                            return MutationBuffer;
                                        })();
                                        exports.default = MutationBuffer;
                                        function deepDelete(addsSet, n) {
                                            addsSet.delete(n);
                                            n.childNodes.forEach(function (
                                                childN
                                            ) {
                                                return deepDelete(
                                                    addsSet,
                                                    childN
                                                );
                                            });
                                        }
                                        function isParentRemoved(removes, n) {
                                            var parentNode = n.parentNode;
                                            if (!parentNode) {
                                                return false;
                                            }
                                            var parentId = utils_1.mirror.getId(
                                                parentNode
                                            );
                                            if (
                                                removes.some(function (r) {
                                                    return r.id === parentId;
                                                })
                                            ) {
                                                return true;
                                            }
                                            return isParentRemoved(
                                                removes,
                                                parentNode
                                            );
                                        }
                                        function isAncestorInSet(set, n) {
                                            var parentNode = n.parentNode;
                                            if (!parentNode) {
                                                return false;
                                            }
                                            if (set.has(parentNode)) {
                                                return true;
                                            }
                                            return isAncestorInSet(
                                                set,
                                                parentNode
                                            );
                                        }

                                        /***/
                                    },

                                /***/ './src/record/observer.ts':
                                    /*!********************************!*\
  !*** ./src/record/observer.ts ***!
  \********************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_36929__
                                    ) {
                                        var __assign =
                                            (this && this.__assign) ||
                                            function () {
                                                __assign =
                                                    Object.assign ||
                                                    function (t) {
                                                        for (
                                                            var s,
                                                                i = 1,
                                                                n =
                                                                    arguments.length;
                                                            i < n;
                                                            i++
                                                        ) {
                                                            s = arguments[i];
                                                            for (var p in s)
                                                                if (
                                                                    Object.prototype.hasOwnProperty.call(
                                                                        s,
                                                                        p
                                                                    )
                                                                )
                                                                    t[p] = s[p];
                                                        }
                                                        return t;
                                                    };
                                                return __assign.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                        var __read =
                                            (this && this.__read) ||
                                            function (o, n) {
                                                var m =
                                                    typeof Symbol ===
                                                        'function' &&
                                                    o[Symbol.iterator];
                                                if (!m) return o;
                                                var i = m.call(o),
                                                    r,
                                                    ar = [],
                                                    e;
                                                try {
                                                    while (
                                                        (n === void 0 ||
                                                            n-- > 0) &&
                                                        !(r = i.next()).done
                                                    )
                                                        ar.push(r.value);
                                                } catch (error) {
                                                    e = { error: error };
                                                } finally {
                                                    try {
                                                        if (
                                                            r &&
                                                            !r.done &&
                                                            (m = i['return'])
                                                        )
                                                            m.call(i);
                                                    } finally {
                                                        if (e) throw e.error;
                                                    }
                                                }
                                                return ar;
                                            };
                                        var __spread =
                                            (this && this.__spread) ||
                                            function () {
                                                for (
                                                    var ar = [], i = 0;
                                                    i < arguments.length;
                                                    i++
                                                )
                                                    ar = ar.concat(
                                                        __read(arguments[i])
                                                    );
                                                return ar;
                                            };
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.initObservers = exports.INPUT_TAGS = exports.mutationBuffer = void 0;
                                        var utils_1 = __nested_webpack_require_36929__(
                                            /*! ../utils */ './src/utils.ts'
                                        );
                                        var types_1 = __nested_webpack_require_36929__(
                                            /*! ../types */ './src/types.ts'
                                        );
                                        var mutation_1 = __nested_webpack_require_36929__(
                                            /*! ./mutation */ './src/record/mutation.ts'
                                        );
                                        var stringify_1 = __nested_webpack_require_36929__(
                                            /*! ./stringify */ './src/record/stringify.ts'
                                        );
                                        exports.mutationBuffer = new mutation_1.default();
                                        function initMutationObserver(
                                            cb,
                                            blockClass,
                                            blockSelector,
                                            inlineStylesheet,
                                            maskInputOptions,
                                            recordCanvas,
                                            slimDOMOptions
                                        ) {
                                            var _a, _b, _c;
                                            exports.mutationBuffer.init(
                                                cb,
                                                blockClass,
                                                blockSelector,
                                                inlineStylesheet,
                                                maskInputOptions,
                                                recordCanvas,
                                                slimDOMOptions
                                            );
                                            var mutationBufferCtor =
                                                window.MutationObserver;
                                            var angularZoneSymbol =
                                                (_c =
                                                    (_b =
                                                        (_a = window) ===
                                                            null ||
                                                        _a === void 0
                                                            ? void 0
                                                            : _a.Zone) ===
                                                        null || _b === void 0
                                                        ? void 0
                                                        : _b.__symbol__) ===
                                                    null || _c === void 0
                                                    ? void 0
                                                    : _c.call(
                                                          _b,
                                                          'MutationObserver'
                                                      );
                                            if (
                                                angularZoneSymbol &&
                                                window[angularZoneSymbol]
                                            ) {
                                                mutationBufferCtor =
                                                    window[angularZoneSymbol];
                                            }
                                            var observer = new mutationBufferCtor(
                                                exports.mutationBuffer.processMutations.bind(
                                                    exports.mutationBuffer
                                                )
                                            );
                                            observer.observe(document, {
                                                attributes: true,
                                                attributeOldValue: true,
                                                characterData: true,
                                                characterDataOldValue: true,
                                                childList: true,
                                                subtree: true,
                                            });
                                            return observer;
                                        }
                                        function initMoveObserver(
                                            cb,
                                            sampling
                                        ) {
                                            if (sampling.mousemove === false) {
                                                return function () {};
                                            }
                                            var threshold =
                                                typeof sampling.mousemove ===
                                                'number'
                                                    ? sampling.mousemove
                                                    : 50;
                                            var positions = [];
                                            var timeBaseline;
                                            var wrappedCb = utils_1.throttle(
                                                function (isTouch) {
                                                    var totalOffset =
                                                        Date.now() -
                                                        timeBaseline;
                                                    cb(
                                                        positions.map(function (
                                                            p
                                                        ) {
                                                            p.timeOffset -= totalOffset;
                                                            return p;
                                                        }),
                                                        isTouch
                                                            ? types_1
                                                                  .IncrementalSource
                                                                  .TouchMove
                                                            : types_1
                                                                  .IncrementalSource
                                                                  .MouseMove
                                                    );
                                                    positions = [];
                                                    timeBaseline = null;
                                                },
                                                500
                                            );
                                            var updatePosition = utils_1.throttle(
                                                function (evt) {
                                                    var target = evt.target;
                                                    var _a = utils_1.isTouchEvent(
                                                            evt
                                                        )
                                                            ? evt
                                                                  .changedTouches[0]
                                                            : evt,
                                                        clientX = _a.clientX,
                                                        clientY = _a.clientY;
                                                    if (!timeBaseline) {
                                                        timeBaseline = Date.now();
                                                    }
                                                    positions.push({
                                                        x: clientX,
                                                        y: clientY,
                                                        id: utils_1.mirror.getId(
                                                            target
                                                        ),
                                                        timeOffset:
                                                            Date.now() -
                                                            timeBaseline,
                                                    });
                                                    wrappedCb(
                                                        utils_1.isTouchEvent(
                                                            evt
                                                        )
                                                    );
                                                },
                                                threshold,
                                                {
                                                    trailing: false,
                                                }
                                            );
                                            var handlers = [
                                                utils_1.on(
                                                    'mousemove',
                                                    updatePosition
                                                ),
                                                utils_1.on(
                                                    'touchmove',
                                                    updatePosition
                                                ),
                                            ];
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initMouseInteractionObserver(
                                            cb,
                                            blockClass,
                                            sampling
                                        ) {
                                            if (
                                                sampling.mouseInteraction ===
                                                false
                                            ) {
                                                return function () {};
                                            }
                                            var disableMap =
                                                sampling.mouseInteraction ===
                                                    true ||
                                                sampling.mouseInteraction ===
                                                    undefined
                                                    ? {}
                                                    : sampling.mouseInteraction;
                                            var handlers = [];
                                            var getHandler = function (
                                                eventKey
                                            ) {
                                                return function (event) {
                                                    if (
                                                        utils_1.isBlocked(
                                                            event.target,
                                                            blockClass
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    var id = utils_1.mirror.getId(
                                                        event.target
                                                    );
                                                    var _a = utils_1.isTouchEvent(
                                                            event
                                                        )
                                                            ? event
                                                                  .changedTouches[0]
                                                            : event,
                                                        clientX = _a.clientX,
                                                        clientY = _a.clientY;
                                                    cb({
                                                        type:
                                                            types_1
                                                                .MouseInteractions[
                                                                eventKey
                                                            ],
                                                        id: id,
                                                        x: clientX,
                                                        y: clientY,
                                                    });
                                                };
                                            };
                                            Object.keys(
                                                types_1.MouseInteractions
                                            )
                                                .filter(function (key) {
                                                    return (
                                                        Number.isNaN(
                                                            Number(key)
                                                        ) &&
                                                        !key.endsWith(
                                                            '_Departed'
                                                        ) &&
                                                        disableMap[key] !==
                                                            false
                                                    );
                                                })
                                                .forEach(function (eventKey) {
                                                    var eventName = eventKey.toLowerCase();
                                                    var handler = getHandler(
                                                        eventKey
                                                    );
                                                    handlers.push(
                                                        utils_1.on(
                                                            eventName,
                                                            handler
                                                        )
                                                    );
                                                });
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initScrollObserver(
                                            cb,
                                            blockClass,
                                            sampling
                                        ) {
                                            var updatePosition = utils_1.throttle(
                                                function (evt) {
                                                    if (
                                                        !evt.target ||
                                                        utils_1.isBlocked(
                                                            evt.target,
                                                            blockClass
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    var id = utils_1.mirror.getId(
                                                        evt.target
                                                    );
                                                    if (
                                                        evt.target === document
                                                    ) {
                                                        var scrollEl =
                                                            document.scrollingElement ||
                                                            document.documentElement;
                                                        cb({
                                                            id: id,
                                                            x:
                                                                scrollEl.scrollLeft,
                                                            y:
                                                                scrollEl.scrollTop,
                                                        });
                                                    } else {
                                                        cb({
                                                            id: id,
                                                            x:
                                                                evt.target
                                                                    .scrollLeft,
                                                            y:
                                                                evt.target
                                                                    .scrollTop,
                                                        });
                                                    }
                                                },
                                                sampling.scroll || 100
                                            );
                                            return utils_1.on(
                                                'scroll',
                                                updatePosition
                                            );
                                        }
                                        function initViewportResizeObserver(
                                            cb
                                        ) {
                                            var last_h = -1;
                                            var last_w = -1;
                                            var updateDimension = utils_1.throttle(
                                                function () {
                                                    var height = utils_1.getWindowHeight();
                                                    var width = utils_1.getWindowWidth();
                                                    if (
                                                        last_h !== height ||
                                                        last_w != width
                                                    ) {
                                                        cb({
                                                            width: Number(
                                                                width
                                                            ),
                                                            height: Number(
                                                                height
                                                            ),
                                                        });
                                                        last_h = height;
                                                        last_w = width;
                                                    }
                                                },
                                                200
                                            );
                                            return utils_1.on(
                                                'resize',
                                                updateDimension,
                                                window
                                            );
                                        }
                                        exports.INPUT_TAGS = [
                                            'INPUT',
                                            'TEXTAREA',
                                            'SELECT',
                                        ];
                                        var lastInputValueMap = new WeakMap();
                                        function initInputObserver(
                                            cb,
                                            blockClass,
                                            ignoreClass,
                                            maskInputOptions,
                                            maskInputFn,
                                            sampling
                                        ) {
                                            function eventHandler(event) {
                                                var target = event.target;
                                                if (
                                                    !target ||
                                                    !target.tagName ||
                                                    exports.INPUT_TAGS.indexOf(
                                                        target.tagName
                                                    ) < 0 ||
                                                    utils_1.isBlocked(
                                                        target,
                                                        blockClass
                                                    )
                                                ) {
                                                    return;
                                                }
                                                var type = target.type;
                                                if (
                                                    type === 'password' ||
                                                    target.classList.contains(
                                                        ignoreClass
                                                    )
                                                ) {
                                                    return;
                                                }
                                                var text = target.value;
                                                var isChecked = false;
                                                if (
                                                    type === 'radio' ||
                                                    type === 'checkbox'
                                                ) {
                                                    isChecked = target.checked;
                                                } else if (
                                                    maskInputOptions[
                                                        target.tagName.toLowerCase()
                                                    ] ||
                                                    maskInputOptions[type]
                                                ) {
                                                    if (maskInputFn) {
                                                        text = maskInputFn(
                                                            text
                                                        );
                                                    } else {
                                                        text = '*'.repeat(
                                                            text.length
                                                        );
                                                    }
                                                }
                                                cbWithDedup(target, {
                                                    text: text,
                                                    isChecked: isChecked,
                                                });
                                                var name = target.name;
                                                if (
                                                    type === 'radio' &&
                                                    name &&
                                                    isChecked
                                                ) {
                                                    document
                                                        .querySelectorAll(
                                                            'input[type="radio"][name="' +
                                                                name +
                                                                '"]'
                                                        )
                                                        .forEach(function (el) {
                                                            if (el !== target) {
                                                                cbWithDedup(
                                                                    el,
                                                                    {
                                                                        text:
                                                                            el.value,
                                                                        isChecked: !isChecked,
                                                                    }
                                                                );
                                                            }
                                                        });
                                                }
                                            }
                                            function cbWithDedup(target, v) {
                                                var lastInputValue = lastInputValueMap.get(
                                                    target
                                                );
                                                if (
                                                    !lastInputValue ||
                                                    lastInputValue.text !==
                                                        v.text ||
                                                    lastInputValue.isChecked !==
                                                        v.isChecked
                                                ) {
                                                    lastInputValueMap.set(
                                                        target,
                                                        v
                                                    );
                                                    var id = utils_1.mirror.getId(
                                                        target
                                                    );
                                                    cb(
                                                        __assign(
                                                            __assign({}, v),
                                                            { id: id }
                                                        )
                                                    );
                                                }
                                            }
                                            var events =
                                                sampling.input === 'last'
                                                    ? ['change']
                                                    : ['input', 'change'];
                                            var handlers = events.map(function (
                                                eventName
                                            ) {
                                                return utils_1.on(
                                                    eventName,
                                                    eventHandler
                                                );
                                            });
                                            var propertyDescriptor = Object.getOwnPropertyDescriptor(
                                                HTMLInputElement.prototype,
                                                'value'
                                            );
                                            var hookProperties = [
                                                [
                                                    HTMLInputElement.prototype,
                                                    'value',
                                                ],
                                                [
                                                    HTMLInputElement.prototype,
                                                    'checked',
                                                ],
                                                [
                                                    HTMLSelectElement.prototype,
                                                    'value',
                                                ],
                                                [
                                                    HTMLTextAreaElement.prototype,
                                                    'value',
                                                ],
                                                [
                                                    HTMLSelectElement.prototype,
                                                    'selectedIndex',
                                                ],
                                            ];
                                            if (
                                                propertyDescriptor &&
                                                propertyDescriptor.set
                                            ) {
                                                handlers.push.apply(
                                                    handlers,
                                                    __spread(
                                                        hookProperties.map(
                                                            function (p) {
                                                                return utils_1.hookSetter(
                                                                    p[0],
                                                                    p[1],
                                                                    {
                                                                        set: function () {
                                                                            eventHandler(
                                                                                {
                                                                                    target: this,
                                                                                }
                                                                            );
                                                                        },
                                                                    }
                                                                );
                                                            }
                                                        )
                                                    )
                                                );
                                            }
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initStyleSheetObserver(cb) {
                                            var insertRule =
                                                CSSStyleSheet.prototype
                                                    .insertRule;
                                            CSSStyleSheet.prototype.insertRule = function (
                                                rule,
                                                index
                                            ) {
                                                var id = utils_1.mirror.getId(
                                                    this.ownerNode
                                                );
                                                if (id !== -1) {
                                                    cb({
                                                        id: id,
                                                        adds: [
                                                            {
                                                                rule: rule,
                                                                index: index,
                                                            },
                                                        ],
                                                    });
                                                }
                                                return insertRule.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                            var deleteRule =
                                                CSSStyleSheet.prototype
                                                    .deleteRule;
                                            CSSStyleSheet.prototype.deleteRule = function (
                                                index
                                            ) {
                                                var id = utils_1.mirror.getId(
                                                    this.ownerNode
                                                );
                                                if (id !== -1) {
                                                    cb({
                                                        id: id,
                                                        removes: [
                                                            { index: index },
                                                        ],
                                                    });
                                                }
                                                return deleteRule.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                            return function () {
                                                CSSStyleSheet.prototype.insertRule = insertRule;
                                                CSSStyleSheet.prototype.deleteRule = deleteRule;
                                            };
                                        }
                                        function initMediaInteractionObserver(
                                            mediaInteractionCb,
                                            blockClass
                                        ) {
                                            var handler = function (type) {
                                                return function (event) {
                                                    var target = event.target;
                                                    if (
                                                        !target ||
                                                        utils_1.isBlocked(
                                                            target,
                                                            blockClass
                                                        )
                                                    ) {
                                                        return;
                                                    }
                                                    mediaInteractionCb({
                                                        type:
                                                            type === 'play'
                                                                ? 0
                                                                : 1,
                                                        id: utils_1.mirror.getId(
                                                            target
                                                        ),
                                                    });
                                                };
                                            };
                                            var handlers = [
                                                utils_1.on(
                                                    'play',
                                                    handler('play')
                                                ),
                                                utils_1.on(
                                                    'pause',
                                                    handler('pause')
                                                ),
                                            ];
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initCanvasMutationObserver(
                                            cb,
                                            blockClass
                                        ) {
                                            var e_1, _a;
                                            var props = Object.getOwnPropertyNames(
                                                CanvasRenderingContext2D.prototype
                                            );
                                            var handlers = [];
                                            var _loop_1 = function (prop) {
                                                try {
                                                    if (
                                                        typeof CanvasRenderingContext2D
                                                            .prototype[prop] !==
                                                        'function'
                                                    ) {
                                                        return 'continue';
                                                    }
                                                    var restoreHandler = utils_1.patch(
                                                        CanvasRenderingContext2D.prototype,
                                                        prop,
                                                        function (original) {
                                                            return function () {
                                                                var _this = this;
                                                                var args = [];
                                                                for (
                                                                    var _i = 0;
                                                                    _i <
                                                                    arguments.length;
                                                                    _i++
                                                                ) {
                                                                    args[_i] =
                                                                        arguments[
                                                                            _i
                                                                        ];
                                                                }
                                                                if (
                                                                    !utils_1.isBlocked(
                                                                        this
                                                                            .canvas,
                                                                        blockClass
                                                                    )
                                                                ) {
                                                                    setTimeout(
                                                                        function () {
                                                                            var recordArgs = __spread(
                                                                                args
                                                                            );
                                                                            if (
                                                                                prop ===
                                                                                'drawImage'
                                                                            ) {
                                                                                if (
                                                                                    recordArgs[0] &&
                                                                                    recordArgs[0] instanceof
                                                                                        HTMLCanvasElement
                                                                                ) {
                                                                                    recordArgs[0] = recordArgs[0].toDataURL();
                                                                                }
                                                                            }
                                                                            cb({
                                                                                id: utils_1.mirror.getId(
                                                                                    _this.canvas
                                                                                ),
                                                                                property: prop,
                                                                                args: recordArgs,
                                                                            });
                                                                        },
                                                                        0
                                                                    );
                                                                }
                                                                return original.apply(
                                                                    this,
                                                                    args
                                                                );
                                                            };
                                                        }
                                                    );
                                                    handlers.push(
                                                        restoreHandler
                                                    );
                                                } catch (_a) {
                                                    var hookHandler = utils_1.hookSetter(
                                                        CanvasRenderingContext2D.prototype,
                                                        prop,
                                                        {
                                                            set: function (v) {
                                                                cb({
                                                                    id: utils_1.mirror.getId(
                                                                        this
                                                                            .canvas
                                                                    ),
                                                                    property: prop,
                                                                    args: [v],
                                                                    setter: true,
                                                                });
                                                            },
                                                        }
                                                    );
                                                    handlers.push(hookHandler);
                                                }
                                            };
                                            try {
                                                for (
                                                    var props_1 = __values(
                                                            props
                                                        ),
                                                        props_1_1 = props_1.next();
                                                    !props_1_1.done;
                                                    props_1_1 = props_1.next()
                                                ) {
                                                    var prop = props_1_1.value;
                                                    _loop_1(prop);
                                                }
                                            } catch (e_1_1) {
                                                e_1 = { error: e_1_1 };
                                            } finally {
                                                try {
                                                    if (
                                                        props_1_1 &&
                                                        !props_1_1.done &&
                                                        (_a = props_1.return)
                                                    )
                                                        _a.call(props_1);
                                                } finally {
                                                    if (e_1) throw e_1.error;
                                                }
                                            }
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initFontObserver(cb) {
                                            var handlers = [];
                                            var fontMap = new WeakMap();
                                            var originalFontFace = FontFace;
                                            window.FontFace = function FontFace(
                                                family,
                                                source,
                                                descriptors
                                            ) {
                                                var fontFace = new originalFontFace(
                                                    family,
                                                    source,
                                                    descriptors
                                                );
                                                fontMap.set(fontFace, {
                                                    family: family,
                                                    buffer:
                                                        typeof source !==
                                                        'string',
                                                    descriptors: descriptors,
                                                    fontSource:
                                                        typeof source ===
                                                        'string'
                                                            ? source
                                                            : JSON.stringify(
                                                                  Array.from(
                                                                      new Uint8Array(
                                                                          source
                                                                      )
                                                                  )
                                                              ),
                                                });
                                                return fontFace;
                                            };
                                            var restoreHandler = utils_1.patch(
                                                document.fonts,
                                                'add',
                                                function (original) {
                                                    return function (fontFace) {
                                                        setTimeout(function () {
                                                            var p = fontMap.get(
                                                                fontFace
                                                            );
                                                            if (p) {
                                                                cb(p);
                                                                fontMap.delete(
                                                                    fontFace
                                                                );
                                                            }
                                                        }, 0);
                                                        return original.apply(
                                                            this,
                                                            [fontFace]
                                                        );
                                                    };
                                                }
                                            );
                                            handlers.push(function () {
                                                window.FonFace = originalFontFace;
                                            });
                                            handlers.push(restoreHandler);
                                            return function () {
                                                handlers.forEach(function (h) {
                                                    return h();
                                                });
                                            };
                                        }
                                        function initLogObserver(
                                            cb,
                                            logOptions
                                        ) {
                                            var e_2, _a;
                                            var _this = this;
                                            var logger = logOptions.logger;
                                            if (!logger) return function () {};
                                            var logCount = 0;
                                            var cancelHandlers = [];
                                            if (
                                                logOptions.level.includes(
                                                    'error'
                                                )
                                            ) {
                                                if (window) {
                                                    var originalOnError_1 =
                                                        window.onerror;
                                                    window.onerror = function () {
                                                        var args = [];
                                                        for (
                                                            var _i = 0;
                                                            _i <
                                                            arguments.length;
                                                            _i++
                                                        ) {
                                                            args[_i] =
                                                                arguments[_i];
                                                        }
                                                        originalOnError_1 &&
                                                            originalOnError_1.apply(
                                                                _this,
                                                                args
                                                            );
                                                        var stack = [];
                                                        if (
                                                            args[
                                                                args.length - 1
                                                            ] instanceof Error
                                                        )
                                                            stack = parseStack(
                                                                args[
                                                                    args.length -
                                                                        1
                                                                ].stack,
                                                                0
                                                            );
                                                        var payload = [
                                                            stringify_1.stringify(
                                                                args[0],
                                                                logOptions.stringifyOptions
                                                            ),
                                                        ];
                                                        cb({
                                                            level: 'error',
                                                            trace: stack,
                                                            payload: payload,
                                                        });
                                                    };
                                                    cancelHandlers.push(
                                                        function () {
                                                            window.onerror = originalOnError_1;
                                                        }
                                                    );
                                                }
                                            }
                                            try {
                                                for (
                                                    var _b = __values(
                                                            logOptions.level
                                                        ),
                                                        _c = _b.next();
                                                    !_c.done;
                                                    _c = _b.next()
                                                ) {
                                                    var levelType = _c.value;
                                                    cancelHandlers.push(
                                                        replace(
                                                            logger,
                                                            levelType
                                                        )
                                                    );
                                                }
                                            } catch (e_2_1) {
                                                e_2 = { error: e_2_1 };
                                            } finally {
                                                try {
                                                    if (
                                                        _c &&
                                                        !_c.done &&
                                                        (_a = _b.return)
                                                    )
                                                        _a.call(_b);
                                                } finally {
                                                    if (e_2) throw e_2.error;
                                                }
                                            }
                                            return function () {
                                                cancelHandlers.forEach(
                                                    function (h) {
                                                        return h();
                                                    }
                                                );
                                            };
                                            function replace(logger, level) {
                                                var _this = this;
                                                if (!logger[level])
                                                    return function () {};
                                                return utils_1.patch(
                                                    logger,
                                                    level,
                                                    function (original) {
                                                        return function () {
                                                            var args = [];
                                                            for (
                                                                var _i = 0;
                                                                _i <
                                                                arguments.length;
                                                                _i++
                                                            ) {
                                                                args[_i] =
                                                                    arguments[
                                                                        _i
                                                                    ];
                                                            }
                                                            original.apply(
                                                                _this,
                                                                args
                                                            );
                                                            try {
                                                                var stack = parseStack(
                                                                    new Error()
                                                                        .stack
                                                                );
                                                                var payload = args.map(
                                                                    function (
                                                                        s
                                                                    ) {
                                                                        return stringify_1.stringify(
                                                                            s,
                                                                            logOptions.stringifyOptions
                                                                        );
                                                                    }
                                                                );
                                                                logCount++;
                                                                if (
                                                                    logCount <
                                                                    logOptions.lengthThreshold
                                                                )
                                                                    cb({
                                                                        level: level,
                                                                        trace: stack,
                                                                        payload: payload,
                                                                    });
                                                                else if (
                                                                    logCount ===
                                                                    logOptions.lengthThreshold
                                                                )
                                                                    cb({
                                                                        level:
                                                                            'warn',
                                                                        trace: [],
                                                                        payload: [
                                                                            stringify_1.stringify(
                                                                                'The number of log records reached the threshold.'
                                                                            ),
                                                                        ],
                                                                    });
                                                            } catch (error) {
                                                                original.apply(
                                                                    void 0,
                                                                    __spread(
                                                                        [
                                                                            'rrweb logger error:',
                                                                            error,
                                                                        ],
                                                                        args
                                                                    )
                                                                );
                                                            }
                                                        };
                                                    }
                                                );
                                            }
                                            function parseStack(
                                                stack,
                                                omitDepth
                                            ) {
                                                if (omitDepth === void 0) {
                                                    omitDepth = 1;
                                                }
                                                var stacks = [];
                                                if (stack) {
                                                    stacks = stack
                                                        .split('at')
                                                        .splice(1 + omitDepth)
                                                        .map(function (s) {
                                                            return s.trim();
                                                        });
                                                }
                                                return stacks;
                                            }
                                        }
                                        function mergeHooks(o, hooks) {
                                            var mutationCb = o.mutationCb,
                                                mousemoveCb = o.mousemoveCb,
                                                mouseInteractionCb =
                                                    o.mouseInteractionCb,
                                                scrollCb = o.scrollCb,
                                                viewportResizeCb =
                                                    o.viewportResizeCb,
                                                inputCb = o.inputCb,
                                                mediaInteractionCb =
                                                    o.mediaInteractionCb,
                                                styleSheetRuleCb =
                                                    o.styleSheetRuleCb,
                                                canvasMutationCb =
                                                    o.canvasMutationCb,
                                                fontCb = o.fontCb,
                                                logCb = o.logCb;
                                            o.mutationCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.mutation) {
                                                    hooks.mutation.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                mutationCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.mousemoveCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.mousemove) {
                                                    hooks.mousemove.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                mousemoveCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.mouseInteractionCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.mouseInteraction) {
                                                    hooks.mouseInteraction.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                mouseInteractionCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.scrollCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.scroll) {
                                                    hooks.scroll.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                scrollCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.viewportResizeCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.viewportResize) {
                                                    hooks.viewportResize.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                viewportResizeCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.inputCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.input) {
                                                    hooks.input.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                inputCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.mediaInteractionCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.mediaInteaction) {
                                                    hooks.mediaInteaction.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                mediaInteractionCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.styleSheetRuleCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.styleSheetRule) {
                                                    hooks.styleSheetRule.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                styleSheetRuleCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.canvasMutationCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.canvasMutation) {
                                                    hooks.canvasMutation.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                canvasMutationCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.fontCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.font) {
                                                    hooks.font.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                fontCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                            o.logCb = function () {
                                                var p = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    p[_i] = arguments[_i];
                                                }
                                                if (hooks.log) {
                                                    hooks.log.apply(
                                                        hooks,
                                                        __spread(p)
                                                    );
                                                }
                                                logCb.apply(
                                                    void 0,
                                                    __spread(p)
                                                );
                                            };
                                        }
                                        function initObservers(o, hooks) {
                                            if (hooks === void 0) {
                                                hooks = {};
                                            }
                                            mergeHooks(o, hooks);
                                            var mutationObserver = initMutationObserver(
                                                o.mutationCb,
                                                o.blockClass,
                                                o.blockSelector,
                                                o.inlineStylesheet,
                                                o.maskInputOptions,
                                                o.recordCanvas,
                                                o.slimDOMOptions
                                            );
                                            var mousemoveHandler = initMoveObserver(
                                                o.mousemoveCb,
                                                o.sampling
                                            );
                                            var mouseInteractionHandler = initMouseInteractionObserver(
                                                o.mouseInteractionCb,
                                                o.blockClass,
                                                o.sampling
                                            );
                                            var scrollHandler = initScrollObserver(
                                                o.scrollCb,
                                                o.blockClass,
                                                o.sampling
                                            );
                                            var viewportResizeHandler = initViewportResizeObserver(
                                                o.viewportResizeCb
                                            );
                                            var inputHandler = initInputObserver(
                                                o.inputCb,
                                                o.blockClass,
                                                o.ignoreClass,
                                                o.maskInputOptions,
                                                o.maskInputFn,
                                                o.sampling
                                            );
                                            var mediaInteractionHandler = initMediaInteractionObserver(
                                                o.mediaInteractionCb,
                                                o.blockClass
                                            );
                                            var styleSheetObserver = initStyleSheetObserver(
                                                o.styleSheetRuleCb
                                            );
                                            var canvasMutationObserver = o.recordCanvas
                                                ? initCanvasMutationObserver(
                                                      o.canvasMutationCb,
                                                      o.blockClass
                                                  )
                                                : function () {};
                                            var fontObserver = o.collectFonts
                                                ? initFontObserver(o.fontCb)
                                                : function () {};
                                            var logObserver = o.logOptions
                                                ? initLogObserver(
                                                      o.logCb,
                                                      o.logOptions
                                                  )
                                                : function () {};
                                            return function () {
                                                mutationObserver.disconnect();
                                                mousemoveHandler();
                                                mouseInteractionHandler();
                                                scrollHandler();
                                                viewportResizeHandler();
                                                inputHandler();
                                                mediaInteractionHandler();
                                                styleSheetObserver();
                                                canvasMutationObserver();
                                                fontObserver();
                                                logObserver();
                                            };
                                        }
                                        exports.initObservers = initObservers;

                                        /***/
                                    },

                                /***/ './src/record/stringify.ts':
                                    /*!*********************************!*\
  !*** ./src/record/stringify.ts ***!
  \*********************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        exports
                                    ) => {
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.stringify = void 0;
                                        function pathToSelector(node) {
                                            if (!node || !node.outerHTML) {
                                                return '';
                                            }
                                            var path = '';
                                            while (node.parentElement) {
                                                var name = node.localName;
                                                if (!name) break;
                                                name = name.toLowerCase();
                                                var parent = node.parentElement;
                                                var domSiblings = [];
                                                if (
                                                    parent.children &&
                                                    parent.children.length > 0
                                                ) {
                                                    for (
                                                        var i = 0;
                                                        i <
                                                        parent.children.length;
                                                        i++
                                                    ) {
                                                        var sibling =
                                                            parent.children[i];
                                                        if (
                                                            sibling.localName &&
                                                            sibling.localName
                                                                .toLowerCase
                                                        ) {
                                                            if (
                                                                sibling.localName.toLowerCase() ===
                                                                name
                                                            ) {
                                                                domSiblings.push(
                                                                    sibling
                                                                );
                                                            }
                                                        }
                                                    }
                                                }
                                                if (domSiblings.length > 1) {
                                                    name +=
                                                        ':eq(' +
                                                        domSiblings.indexOf(
                                                            node
                                                        ) +
                                                        ')';
                                                }
                                                path =
                                                    name +
                                                    (path ? '>' + path : '');
                                                node = parent;
                                            }
                                            return path;
                                        }
                                        function stringify(
                                            obj,
                                            stringifyOptions
                                        ) {
                                            var options = {
                                                numOfKeysLimit: 50,
                                            };
                                            Object.assign(
                                                options,
                                                stringifyOptions
                                            );
                                            var stack = [],
                                                keys = [];
                                            return JSON.stringify(
                                                obj,
                                                function (key, value) {
                                                    if (stack.length > 0) {
                                                        var thisPos = stack.indexOf(
                                                            this
                                                        );
                                                        ~thisPos
                                                            ? stack.splice(
                                                                  thisPos + 1
                                                              )
                                                            : stack.push(this);
                                                        ~thisPos
                                                            ? keys.splice(
                                                                  thisPos,
                                                                  Infinity,
                                                                  key
                                                              )
                                                            : keys.push(key);
                                                        if (
                                                            ~stack.indexOf(
                                                                value
                                                            )
                                                        ) {
                                                            if (
                                                                stack[0] ===
                                                                value
                                                            )
                                                                value =
                                                                    '[Circular ~]';
                                                            else
                                                                value =
                                                                    '[Circular ~.' +
                                                                    keys
                                                                        .slice(
                                                                            0,
                                                                            stack.indexOf(
                                                                                value
                                                                            )
                                                                        )
                                                                        .join(
                                                                            '.'
                                                                        ) +
                                                                    ']';
                                                        }
                                                    } else stack.push(value);
                                                    if (
                                                        value === null ||
                                                        value === undefined
                                                    )
                                                        return value;
                                                    if (shouldToString(value)) {
                                                        return toString(value);
                                                    }
                                                    if (
                                                        value instanceof Event
                                                    ) {
                                                        var eventResult = {};
                                                        for (var key_1 in value) {
                                                            var eventValue =
                                                                value[key_1];
                                                            if (
                                                                Array.isArray(
                                                                    eventValue
                                                                )
                                                            )
                                                                eventResult[
                                                                    key_1
                                                                ] = pathToSelector(
                                                                    eventValue.length
                                                                        ? eventValue[0]
                                                                        : null
                                                                );
                                                            else
                                                                eventResult[
                                                                    key_1
                                                                ] = eventValue;
                                                        }
                                                        return eventResult;
                                                    } else if (
                                                        value instanceof Node
                                                    ) {
                                                        if (
                                                            value instanceof
                                                            HTMLElement
                                                        )
                                                            return value
                                                                ? value.outerHTML
                                                                : '';
                                                        return value.nodeName;
                                                    }
                                                    return value;
                                                }
                                            );
                                            function shouldToString(obj) {
                                                if (
                                                    typeof obj === 'object' &&
                                                    Object.keys(obj).length >
                                                        options.numOfKeysLimit
                                                )
                                                    return true;
                                                if (typeof obj === 'function')
                                                    return true;
                                                return false;
                                            }
                                            function toString(obj) {
                                                var str = obj.toString();
                                                if (
                                                    options.stringLengthLimit &&
                                                    str.length >
                                                        options.stringLengthLimit
                                                ) {
                                                    str =
                                                        str.slice(
                                                            0,
                                                            options.stringLengthLimit
                                                        ) + '...';
                                                }
                                                return str;
                                            }
                                        }
                                        exports.stringify = stringify;

                                        /***/
                                    },

                                /***/ './src/replay/index.ts':
                                    /*!*****************************!*\
  !*** ./src/replay/index.ts ***!
  \*****************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_65235__
                                    ) {
                                        var __assign =
                                            (this && this.__assign) ||
                                            function () {
                                                __assign =
                                                    Object.assign ||
                                                    function (t) {
                                                        for (
                                                            var s,
                                                                i = 1,
                                                                n =
                                                                    arguments.length;
                                                            i < n;
                                                            i++
                                                        ) {
                                                            s = arguments[i];
                                                            for (var p in s)
                                                                if (
                                                                    Object.prototype.hasOwnProperty.call(
                                                                        s,
                                                                        p
                                                                    )
                                                                )
                                                                    t[p] = s[p];
                                                        }
                                                        return t;
                                                    };
                                                return __assign.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        var __read =
                                            (this && this.__read) ||
                                            function (o, n) {
                                                var m =
                                                    typeof Symbol ===
                                                        'function' &&
                                                    o[Symbol.iterator];
                                                if (!m) return o;
                                                var i = m.call(o),
                                                    r,
                                                    ar = [],
                                                    e;
                                                try {
                                                    while (
                                                        (n === void 0 ||
                                                            n-- > 0) &&
                                                        !(r = i.next()).done
                                                    )
                                                        ar.push(r.value);
                                                } catch (error) {
                                                    e = { error: error };
                                                } finally {
                                                    try {
                                                        if (
                                                            r &&
                                                            !r.done &&
                                                            (m = i['return'])
                                                        )
                                                            m.call(i);
                                                    } finally {
                                                        if (e) throw e.error;
                                                    }
                                                }
                                                return ar;
                                            };
                                        var __spread =
                                            (this && this.__spread) ||
                                            function () {
                                                for (
                                                    var ar = [], i = 0;
                                                    i < arguments.length;
                                                    i++
                                                )
                                                    ar = ar.concat(
                                                        __read(arguments[i])
                                                    );
                                                return ar;
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.Replayer = void 0;
                                        var snapshot_1 = __nested_webpack_require_65235__(
                                            /*! ../snapshot */ './src/snapshot/index.ts'
                                        );
                                        var mittProxy = __nested_webpack_require_65235__(
                                            /*! mitt */ './node_modules/mitt/dist/mitt.es.js'
                                        );
                                        var smoothscroll_1 = __nested_webpack_require_65235__(
                                            /*! ./smoothscroll */ './src/replay/smoothscroll.ts'
                                        );
                                        var timer_1 = __nested_webpack_require_65235__(
                                            /*! ./timer */ './src/replay/timer.ts'
                                        );
                                        var machine_1 = __nested_webpack_require_65235__(
                                            /*! ./machine */ './src/replay/machine.ts'
                                        );
                                        var types_1 = __nested_webpack_require_65235__(
                                            /*! ../types */ './src/types.ts'
                                        );
                                        var utils_1 = __nested_webpack_require_65235__(
                                            /*! ../utils */ './src/utils.ts'
                                        );
                                        var inject_style_1 = __nested_webpack_require_65235__(
                                            /*! ./styles/inject-style */ './src/replay/styles/inject-style.ts'
                                        );
                                        __nested_webpack_require_65235__(
                                            /*! ./styles/style.css */ './src/replay/styles/style.css'
                                        );
                                        var SKIP_TIME_THRESHOLD = 10 * 1000;
                                        var SKIP_TIME_INTERVAL = 5 * 1000;
                                        var mitt =
                                            mittProxy.default || mittProxy;
                                        var REPLAY_CONSOLE_PREFIX =
                                            '[replayer]';
                                        var defaultMouseTailConfig = {
                                            duration: 500,
                                            lineCap: 'round',
                                            lineWidth: 3,
                                            strokeStyle: 'red',
                                        };
                                        var defaultLogConfig = {
                                            level: [
                                                'assert',
                                                'clear',
                                                'count',
                                                'countReset',
                                                'debug',
                                                'dir',
                                                'dirxml',
                                                'error',
                                                'group',
                                                'groupCollapsed',
                                                'groupEnd',
                                                'info',
                                                'log',
                                                'table',
                                                'time',
                                                'timeEnd',
                                                'timeLog',
                                                'trace',
                                                'warn',
                                            ],
                                            replayLogger: undefined,
                                        };
                                        var Replayer = (function () {
                                            function Replayer(events, config) {
                                                var _this = this;
                                                this.mouseTail = null;
                                                this.tailPositions = [];
                                                this.emitter = mitt();
                                                this.legacy_missingNodeRetryMap = {};
                                                this.imageMap = new Map();
                                                this.activityIntervals = [];
                                                if (
                                                    !(config === null ||
                                                    config === void 0
                                                        ? void 0
                                                        : config.liveMode) &&
                                                    events.length < 2
                                                ) {
                                                    throw new Error(
                                                        'Replayer need at least 2 events.'
                                                    );
                                                }
                                                var defaultConfig = {
                                                    speed: 1,
                                                    root: document.body,
                                                    loadTimeout: 0,
                                                    skipInactive: false,
                                                    showWarning: true,
                                                    showDebug: false,
                                                    blockClass: 'rr-block',
                                                    liveMode: false,
                                                    insertStyleRules: [],
                                                    triggerFocus: true,
                                                    UNSAFE_replayCanvas: false,
                                                    pauseAnimation: true,
                                                    mouseTail: defaultMouseTailConfig,
                                                    logConfig: defaultLogConfig,
                                                    inactiveThreshold: 0.02,
                                                    inactiveSkipTime: SKIP_TIME_INTERVAL,
                                                    maxSkipSpeed: 360,
                                                };
                                                this.config = Object.assign(
                                                    {},
                                                    defaultConfig,
                                                    config
                                                );
                                                if (
                                                    !this.config.logConfig
                                                        .replayLogger
                                                )
                                                    this.config.logConfig.replayLogger = this.getConsoleLogger();
                                                this.handleResize = this.handleResize.bind(
                                                    this
                                                );
                                                this.getCastFn = this.getCastFn.bind(
                                                    this
                                                );
                                                this.emitter.on(
                                                    types_1.ReplayerEvents
                                                        .Resize,
                                                    this.handleResize
                                                );
                                                this.setupDom();
                                                this.treeIndex = new utils_1.TreeIndex();
                                                this.fragmentParentMap = new Map();
                                                this.elementStateMap = new Map();
                                                this.emitter.on(
                                                    types_1.ReplayerEvents
                                                        .Flush,
                                                    function () {
                                                        var e_1,
                                                            _a,
                                                            e_2,
                                                            _b,
                                                            e_3,
                                                            _c;
                                                        var _d = _this.treeIndex.flush(),
                                                            scrollMap =
                                                                _d.scrollMap,
                                                            inputMap =
                                                                _d.inputMap;
                                                        try {
                                                            for (
                                                                var _e = __values(
                                                                        _this.fragmentParentMap.entries()
                                                                    ),
                                                                    _f = _e.next();
                                                                !_f.done;
                                                                _f = _e.next()
                                                            ) {
                                                                var _g = __read(
                                                                        _f.value,
                                                                        2
                                                                    ),
                                                                    frag =
                                                                        _g[0],
                                                                    parent_1 =
                                                                        _g[1];
                                                                utils_1.mirror.map[
                                                                    parent_1.__sn.id
                                                                ] = parent_1;
                                                                if (
                                                                    parent_1
                                                                        .__sn
                                                                        .type ===
                                                                        snapshot_1
                                                                            .NodeType
                                                                            .Element &&
                                                                    parent_1
                                                                        .__sn
                                                                        .tagName ===
                                                                        'textarea' &&
                                                                    frag.textContent
                                                                ) {
                                                                    parent_1.value =
                                                                        frag.textContent;
                                                                }
                                                                parent_1.appendChild(
                                                                    frag
                                                                );
                                                                _this.restoreState(
                                                                    parent_1
                                                                );
                                                            }
                                                        } catch (e_1_1) {
                                                            e_1 = {
                                                                error: e_1_1,
                                                            };
                                                        } finally {
                                                            try {
                                                                if (
                                                                    _f &&
                                                                    !_f.done &&
                                                                    (_a =
                                                                        _e.return)
                                                                )
                                                                    _a.call(_e);
                                                            } finally {
                                                                if (e_1)
                                                                    throw e_1.error;
                                                            }
                                                        }
                                                        _this.fragmentParentMap.clear();
                                                        _this.elementStateMap.clear();
                                                        try {
                                                            for (
                                                                var _h = __values(
                                                                        scrollMap.values()
                                                                    ),
                                                                    _j = _h.next();
                                                                !_j.done;
                                                                _j = _h.next()
                                                            ) {
                                                                var d =
                                                                    _j.value;
                                                                _this.applyScroll(
                                                                    d
                                                                );
                                                            }
                                                        } catch (e_2_1) {
                                                            e_2 = {
                                                                error: e_2_1,
                                                            };
                                                        } finally {
                                                            try {
                                                                if (
                                                                    _j &&
                                                                    !_j.done &&
                                                                    (_b =
                                                                        _h.return)
                                                                )
                                                                    _b.call(_h);
                                                            } finally {
                                                                if (e_2)
                                                                    throw e_2.error;
                                                            }
                                                        }
                                                        try {
                                                            for (
                                                                var _k = __values(
                                                                        inputMap.values()
                                                                    ),
                                                                    _l = _k.next();
                                                                !_l.done;
                                                                _l = _k.next()
                                                            ) {
                                                                var d =
                                                                    _l.value;
                                                                _this.applyInput(
                                                                    d
                                                                );
                                                            }
                                                        } catch (e_3_1) {
                                                            e_3 = {
                                                                error: e_3_1,
                                                            };
                                                        } finally {
                                                            try {
                                                                if (
                                                                    _l &&
                                                                    !_l.done &&
                                                                    (_c =
                                                                        _k.return)
                                                                )
                                                                    _c.call(_k);
                                                            } finally {
                                                                if (e_3)
                                                                    throw e_3.error;
                                                            }
                                                        }
                                                    }
                                                );
                                                var timer = new timer_1.Timer(
                                                    [],
                                                    (config === null ||
                                                    config === void 0
                                                        ? void 0
                                                        : config.speed) ||
                                                        defaultConfig.speed
                                                );
                                                this.service = machine_1.createPlayerService(
                                                    {
                                                        events: events.map(
                                                            function (e) {
                                                                if (
                                                                    config &&
                                                                    config.unpackFn
                                                                ) {
                                                                    return config.unpackFn(
                                                                        e
                                                                    );
                                                                }
                                                                return e;
                                                            }
                                                        ),
                                                        timer: timer,
                                                        timeOffset: 0,
                                                        baselineTime: 0,
                                                        lastPlayedEvent: null,
                                                    },
                                                    {
                                                        getCastFn: this
                                                            .getCastFn,
                                                        emitter: this.emitter,
                                                    }
                                                );
                                                this.service.start();
                                                this.service.subscribe(
                                                    function (state) {
                                                        _this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .StateChange,
                                                            {
                                                                player: state,
                                                            }
                                                        );
                                                    }
                                                );
                                                this.speedService = machine_1.createSpeedService(
                                                    {
                                                        normalSpeed: -1,
                                                        timer: timer,
                                                    }
                                                );
                                                this.speedService.start();
                                                this.speedService.subscribe(
                                                    function (state) {
                                                        _this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .StateChange,
                                                            {
                                                                speed: state,
                                                            }
                                                        );
                                                    }
                                                );
                                                var firstMeta = this.service.state.context.events.find(
                                                    function (e) {
                                                        return (
                                                            e.type ===
                                                            types_1.EventType
                                                                .Meta
                                                        );
                                                    }
                                                );
                                                var firstFullsnapshot = this.service.state.context.events.find(
                                                    function (e) {
                                                        return (
                                                            e.type ===
                                                            types_1.EventType
                                                                .FullSnapshot
                                                        );
                                                    }
                                                );
                                                if (firstMeta) {
                                                    var _a = firstMeta.data,
                                                        width_1 = _a.width,
                                                        height_1 = _a.height;
                                                    setTimeout(function () {
                                                        _this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .Resize,
                                                            {
                                                                width: width_1,
                                                                height: height_1,
                                                            }
                                                        );
                                                    }, 0);
                                                }
                                                if (firstFullsnapshot) {
                                                    setTimeout(function () {
                                                        _this.rebuildFullSnapshot(
                                                            firstFullsnapshot
                                                        );
                                                        _this.iframe.contentWindow.scrollTo(
                                                            firstFullsnapshot
                                                                .data
                                                                .initialOffset
                                                        );
                                                    }, 1);
                                                }
                                                var allIntervals = [];
                                                var metadata = this.getMetaData();
                                                var userInteractionEvents = __spread(
                                                    [
                                                        {
                                                            timestamp:
                                                                metadata.startTime,
                                                        },
                                                    ],
                                                    this.service.state.context.events.filter(
                                                        function (ev) {
                                                            return _this.isUserInteraction(
                                                                ev
                                                            );
                                                        }
                                                    ),
                                                    [
                                                        {
                                                            timestamp:
                                                                metadata.endTime,
                                                        },
                                                    ]
                                                );
                                                for (
                                                    var i = 1;
                                                    i <
                                                    userInteractionEvents.length;
                                                    i++
                                                ) {
                                                    var currentInterval_1 =
                                                        userInteractionEvents[
                                                            i - 1
                                                        ];
                                                    var _event =
                                                        userInteractionEvents[
                                                            i
                                                        ];
                                                    if (
                                                        _event.timestamp -
                                                            currentInterval_1.timestamp >
                                                        SKIP_TIME_THRESHOLD
                                                    ) {
                                                        allIntervals.push({
                                                            startTime:
                                                                currentInterval_1.timestamp,
                                                            endTime:
                                                                _event.timestamp,
                                                            duration:
                                                                _event.timestamp -
                                                                currentInterval_1.timestamp,
                                                            active: false,
                                                        });
                                                    } else {
                                                        allIntervals.push({
                                                            startTime:
                                                                currentInterval_1.timestamp,
                                                            endTime:
                                                                _event.timestamp,
                                                            duration:
                                                                _event.timestamp -
                                                                currentInterval_1.timestamp,
                                                            active: true,
                                                        });
                                                    }
                                                }
                                                var mergedIntervals = [];
                                                var currentInterval =
                                                    allIntervals[0];
                                                for (
                                                    var i = 1;
                                                    i < allIntervals.length;
                                                    i++
                                                ) {
                                                    if (
                                                        allIntervals[i]
                                                            .active !=
                                                        allIntervals[i - 1]
                                                            .active
                                                    ) {
                                                        mergedIntervals.push({
                                                            startTime:
                                                                currentInterval.startTime,
                                                            endTime:
                                                                allIntervals[
                                                                    i - 1
                                                                ].endTime,
                                                            duration:
                                                                allIntervals[
                                                                    i - 1
                                                                ].endTime -
                                                                currentInterval.startTime,
                                                            active:
                                                                allIntervals[
                                                                    i - 1
                                                                ].active,
                                                        });
                                                        currentInterval =
                                                            allIntervals[i];
                                                    }
                                                }
                                                if (
                                                    currentInterval &&
                                                    allIntervals.length > 0
                                                ) {
                                                    mergedIntervals.push({
                                                        startTime:
                                                            currentInterval.startTime,
                                                        endTime:
                                                            allIntervals[
                                                                allIntervals.length -
                                                                    1
                                                            ].endTime,
                                                        duration:
                                                            allIntervals[
                                                                allIntervals.length -
                                                                    1
                                                            ].endTime -
                                                            currentInterval.startTime,
                                                        active:
                                                            allIntervals[
                                                                allIntervals.length -
                                                                    1
                                                            ].active,
                                                    });
                                                }
                                                currentInterval =
                                                    mergedIntervals[0];
                                                for (
                                                    var i = 1;
                                                    i < mergedIntervals.length;
                                                    i++
                                                ) {
                                                    if (
                                                        (!mergedIntervals[i]
                                                            .active &&
                                                            mergedIntervals[i]
                                                                .duration >
                                                                this.config
                                                                    .inactiveThreshold *
                                                                    metadata.totalTime) ||
                                                        (!mergedIntervals[i - 1]
                                                            .active &&
                                                            mergedIntervals[
                                                                i - 1
                                                            ].duration >
                                                                this.config
                                                                    .inactiveThreshold *
                                                                    metadata.totalTime)
                                                    ) {
                                                        this.activityIntervals.push(
                                                            {
                                                                startTime:
                                                                    currentInterval.startTime,
                                                                endTime:
                                                                    mergedIntervals[
                                                                        i - 1
                                                                    ].endTime,
                                                                duration:
                                                                    mergedIntervals[
                                                                        i - 1
                                                                    ].endTime -
                                                                    currentInterval.startTime,
                                                                active:
                                                                    mergedIntervals[
                                                                        i - 1
                                                                    ].active,
                                                            }
                                                        );
                                                        currentInterval =
                                                            mergedIntervals[i];
                                                    }
                                                }
                                                if (
                                                    currentInterval &&
                                                    mergedIntervals.length > 0
                                                ) {
                                                    this.activityIntervals.push(
                                                        {
                                                            startTime:
                                                                currentInterval.startTime,
                                                            endTime:
                                                                mergedIntervals[
                                                                    mergedIntervals.length -
                                                                        1
                                                                ].endTime,
                                                            duration:
                                                                mergedIntervals[
                                                                    mergedIntervals.length -
                                                                        1
                                                                ].endTime -
                                                                currentInterval.startTime,
                                                            active:
                                                                mergedIntervals[
                                                                    mergedIntervals.length -
                                                                        1
                                                                ].active,
                                                        }
                                                    );
                                                }
                                            }
                                            Object.defineProperty(
                                                Replayer.prototype,
                                                'timer',
                                                {
                                                    get: function () {
                                                        return this.service
                                                            .state.context
                                                            .timer;
                                                    },
                                                    enumerable: false,
                                                    configurable: true,
                                                }
                                            );
                                            Replayer.prototype.on = function (
                                                event,
                                                handler
                                            ) {
                                                this.emitter.on(event, handler);
                                                return this;
                                            };
                                            Replayer.prototype.setConfig = function (
                                                config
                                            ) {
                                                var _this = this;
                                                Object.keys(config).forEach(
                                                    function (key) {
                                                        _this.config[key] =
                                                            config[key];
                                                    }
                                                );
                                                if (!this.config.skipInactive) {
                                                    this.backToNormal();
                                                }
                                                if (
                                                    typeof config.speed !==
                                                    'undefined'
                                                ) {
                                                    this.speedService.send({
                                                        type: 'SET_SPEED',
                                                        payload: {
                                                            speed: config.speed,
                                                        },
                                                    });
                                                }
                                                if (
                                                    typeof config.mouseTail !==
                                                    'undefined'
                                                ) {
                                                    if (
                                                        config.mouseTail ===
                                                        false
                                                    ) {
                                                        if (this.mouseTail) {
                                                            this.mouseTail.style.display =
                                                                'none';
                                                        }
                                                    } else {
                                                        if (!this.mouseTail) {
                                                            this.mouseTail = document.createElement(
                                                                'canvas'
                                                            );
                                                            this.mouseTail.width = Number.parseFloat(
                                                                this.iframe
                                                                    .width
                                                            );
                                                            this.mouseTail.height = Number.parseFloat(
                                                                this.iframe
                                                                    .height
                                                            );
                                                            this.mouseTail.classList.add(
                                                                'replayer-mouse-tail'
                                                            );
                                                            this.wrapper.insertBefore(
                                                                this.mouseTail,
                                                                this.iframe
                                                            );
                                                        }
                                                        this.mouseTail.style.display =
                                                            'inherit';
                                                    }
                                                }
                                            };
                                            Replayer.prototype.getActivityIntervals = function () {
                                                return this.activityIntervals;
                                            };
                                            Replayer.prototype.getMetaData = function () {
                                                var firstEvent = this.service
                                                    .state.context.events[0];
                                                var lastEvent = this.service
                                                    .state.context.events[
                                                    this.service.state.context
                                                        .events.length - 1
                                                ];
                                                return {
                                                    startTime:
                                                        firstEvent.timestamp,
                                                    endTime:
                                                        lastEvent.timestamp,
                                                    totalTime:
                                                        lastEvent.timestamp -
                                                        firstEvent.timestamp,
                                                };
                                            };
                                            Replayer.prototype.getCurrentTime = function () {
                                                return (
                                                    this.timer.timeOffset +
                                                    this.getTimeOffset()
                                                );
                                            };
                                            Replayer.prototype.getTimeOffset = function () {
                                                var _a = this.service.state
                                                        .context,
                                                    baselineTime =
                                                        _a.baselineTime,
                                                    events = _a.events;
                                                return (
                                                    baselineTime -
                                                    events[0].timestamp
                                                );
                                            };
                                            Replayer.prototype.play = function (
                                                timeOffset
                                            ) {
                                                var _a;
                                                if (timeOffset === void 0) {
                                                    timeOffset = 0;
                                                }
                                                if (
                                                    this.service.state.matches(
                                                        'paused'
                                                    )
                                                ) {
                                                    this.service.send({
                                                        type: 'PLAY',
                                                        payload: {
                                                            timeOffset: timeOffset,
                                                        },
                                                    });
                                                } else {
                                                    this.service.send({
                                                        type: 'PAUSE',
                                                    });
                                                    this.service.send({
                                                        type: 'PLAY',
                                                        payload: {
                                                            timeOffset: timeOffset,
                                                        },
                                                    });
                                                }
                                                (_a = this.iframe
                                                    .contentDocument) ===
                                                    null || _a === void 0
                                                    ? void 0
                                                    : _a
                                                          .getElementsByTagName(
                                                              'html'
                                                          )[0]
                                                          .classList.remove(
                                                              'rrweb-paused'
                                                          );
                                                this.emitter.emit(
                                                    types_1.ReplayerEvents.Start
                                                );
                                                this.handleInactivity(
                                                    this.getMetaData()
                                                        .startTime + timeOffset,
                                                    true
                                                );
                                            };
                                            Replayer.prototype.pause = function (
                                                timeOffset
                                            ) {
                                                var _a;
                                                if (
                                                    timeOffset === undefined &&
                                                    this.service.state.matches(
                                                        'playing'
                                                    )
                                                ) {
                                                    this.service.send({
                                                        type: 'PAUSE',
                                                    });
                                                }
                                                if (
                                                    typeof timeOffset ===
                                                    'number'
                                                ) {
                                                    this.play(timeOffset);
                                                    this.service.send({
                                                        type: 'PAUSE',
                                                    });
                                                }
                                                (_a = this.iframe
                                                    .contentDocument) ===
                                                    null || _a === void 0
                                                    ? void 0
                                                    : _a
                                                          .getElementsByTagName(
                                                              'html'
                                                          )[0]
                                                          .classList.add(
                                                              'rrweb-paused'
                                                          );
                                                this.emitter.emit(
                                                    types_1.ReplayerEvents.Pause
                                                );
                                            };
                                            Replayer.prototype.resume = function (
                                                timeOffset
                                            ) {
                                                if (timeOffset === void 0) {
                                                    timeOffset = 0;
                                                }
                                                console.warn(
                                                    "The 'resume' will be departed in 1.0. Please use 'play' method which has the same interface."
                                                );
                                                this.play(timeOffset);
                                                this.emitter.emit(
                                                    types_1.ReplayerEvents
                                                        .Resume
                                                );
                                            };
                                            Replayer.prototype.startLive = function (
                                                baselineTime
                                            ) {
                                                this.service.send({
                                                    type: 'TO_LIVE',
                                                    payload: {
                                                        baselineTime: baselineTime,
                                                    },
                                                });
                                            };
                                            Replayer.prototype.addEvent = function (
                                                rawEvent
                                            ) {
                                                var _this = this;
                                                var event = this.config.unpackFn
                                                    ? this.config.unpackFn(
                                                          rawEvent
                                                      )
                                                    : rawEvent;
                                                Promise.resolve().then(
                                                    function () {
                                                        return _this.service.send(
                                                            {
                                                                type:
                                                                    'ADD_EVENT',
                                                                payload: {
                                                                    event: event,
                                                                },
                                                            }
                                                        );
                                                    }
                                                );
                                            };
                                            Replayer.prototype.enableInteract = function () {
                                                this.iframe.setAttribute(
                                                    'scrolling',
                                                    'auto'
                                                );
                                                this.iframe.style.pointerEvents =
                                                    'auto';
                                            };
                                            Replayer.prototype.disableInteract = function () {
                                                this.iframe.setAttribute(
                                                    'scrolling',
                                                    'no'
                                                );
                                                this.iframe.style.pointerEvents =
                                                    'none';
                                            };
                                            Replayer.prototype.setupDom = function () {
                                                this.wrapper = document.createElement(
                                                    'div'
                                                );
                                                this.wrapper.classList.add(
                                                    'replayer-wrapper'
                                                );
                                                this.config.root.appendChild(
                                                    this.wrapper
                                                );
                                                this.mouse = document.createElement(
                                                    'div'
                                                );
                                                this.mouse.classList.add(
                                                    'replayer-mouse'
                                                );
                                                this.wrapper.appendChild(
                                                    this.mouse
                                                );
                                                if (
                                                    this.config.mouseTail !==
                                                    false
                                                ) {
                                                    this.mouseTail = document.createElement(
                                                        'canvas'
                                                    );
                                                    this.mouseTail.classList.add(
                                                        'replayer-mouse-tail'
                                                    );
                                                    this.mouseTail.style.display =
                                                        'inherit';
                                                    this.wrapper.appendChild(
                                                        this.mouseTail
                                                    );
                                                }
                                                this.iframe = document.createElement(
                                                    'iframe'
                                                );
                                                var attributes = [
                                                    'allow-same-origin',
                                                ];
                                                if (
                                                    this.config
                                                        .UNSAFE_replayCanvas
                                                ) {
                                                    attributes.push(
                                                        'allow-scripts'
                                                    );
                                                }
                                                this.iframe.style.display =
                                                    'none';
                                                this.iframe.setAttribute(
                                                    'sandbox',
                                                    attributes.join(' ')
                                                );
                                                this.disableInteract();
                                                this.wrapper.appendChild(
                                                    this.iframe
                                                );
                                                if (
                                                    this.iframe.contentWindow &&
                                                    this.iframe.contentDocument
                                                ) {
                                                    smoothscroll_1.polyfill(
                                                        this.iframe
                                                            .contentWindow,
                                                        this.iframe
                                                            .contentDocument
                                                    );
                                                    utils_1.polyfill(
                                                        this.iframe
                                                            .contentWindow
                                                    );
                                                }
                                            };
                                            Replayer.prototype.handleResize = function (
                                                dimension
                                            ) {
                                                var e_4, _a;
                                                this.iframe.style.display =
                                                    'inherit';
                                                try {
                                                    for (
                                                        var _b = __values([
                                                                this.mouseTail,
                                                                this.iframe,
                                                            ]),
                                                            _c = _b.next();
                                                        !_c.done;
                                                        _c = _b.next()
                                                    ) {
                                                        var el = _c.value;
                                                        if (!el) {
                                                            continue;
                                                        }
                                                        el.setAttribute(
                                                            'width',
                                                            String(
                                                                dimension.width
                                                            )
                                                        );
                                                        el.setAttribute(
                                                            'height',
                                                            String(
                                                                dimension.height
                                                            )
                                                        );
                                                    }
                                                } catch (e_4_1) {
                                                    e_4 = { error: e_4_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _c &&
                                                            !_c.done &&
                                                            (_a = _b.return)
                                                        )
                                                            _a.call(_b);
                                                    } finally {
                                                        if (e_4)
                                                            throw e_4.error;
                                                    }
                                                }
                                            };
                                            Replayer.prototype.getCastFn = function (
                                                event,
                                                isSync
                                            ) {
                                                var _this = this;
                                                if (isSync === void 0) {
                                                    isSync = false;
                                                }
                                                var castFn;
                                                switch (event.type) {
                                                    case types_1.EventType
                                                        .DomContentLoaded:
                                                    case types_1.EventType.Load:
                                                        break;
                                                    case types_1.EventType
                                                        .Custom:
                                                        castFn = function () {
                                                            _this.emitter.emit(
                                                                types_1
                                                                    .ReplayerEvents
                                                                    .CustomEvent,
                                                                event
                                                            );
                                                        };
                                                        break;
                                                    case types_1.EventType.Meta:
                                                        castFn = function () {
                                                            return _this.emitter.emit(
                                                                types_1
                                                                    .ReplayerEvents
                                                                    .Resize,
                                                                {
                                                                    width:
                                                                        event
                                                                            .data
                                                                            .width,
                                                                    height:
                                                                        event
                                                                            .data
                                                                            .height,
                                                                }
                                                            );
                                                        };
                                                        break;
                                                    case types_1.EventType
                                                        .FullSnapshot:
                                                        castFn = function () {
                                                            _this.rebuildFullSnapshot(
                                                                event,
                                                                isSync
                                                            );
                                                            _this.iframe.contentWindow.scrollTo(
                                                                event.data
                                                                    .initialOffset
                                                            );
                                                        };
                                                        break;
                                                    case types_1.EventType
                                                        .IncrementalSnapshot:
                                                        castFn = function () {
                                                            _this.applyIncremental(
                                                                event,
                                                                isSync
                                                            );
                                                            if (isSync) {
                                                                return;
                                                            }
                                                            _this.handleInactivity(
                                                                event.timestamp
                                                            );
                                                        };
                                                        break;
                                                    default:
                                                }
                                                var wrappedCastFn = function () {
                                                    if (castFn) {
                                                        castFn();
                                                    }
                                                    _this.service.send({
                                                        type: 'CAST_EVENT',
                                                        payload: {
                                                            event: event,
                                                        },
                                                    });
                                                    if (
                                                        event ===
                                                        _this.service.state
                                                            .context.events[
                                                            _this.service.state
                                                                .context.events
                                                                .length - 1
                                                        ]
                                                    ) {
                                                        var finish_1 = function () {
                                                            _this.backToNormal();
                                                            _this.service.send(
                                                                'END'
                                                            );
                                                            _this.emitter.emit(
                                                                types_1
                                                                    .ReplayerEvents
                                                                    .Finish
                                                            );
                                                        };
                                                        if (
                                                            event.type ===
                                                                types_1
                                                                    .EventType
                                                                    .IncrementalSnapshot &&
                                                            event.data
                                                                .source ===
                                                                types_1
                                                                    .IncrementalSource
                                                                    .MouseMove &&
                                                            event.data.positions
                                                                .length
                                                        ) {
                                                            setTimeout(
                                                                function () {
                                                                    finish_1();
                                                                },
                                                                Math.max(
                                                                    0,
                                                                    -event.data
                                                                        .positions[0]
                                                                        .timeOffset +
                                                                        50
                                                                )
                                                            );
                                                        } else {
                                                            finish_1();
                                                        }
                                                    }
                                                };
                                                return wrappedCastFn;
                                            };
                                            Replayer.prototype.handleInactivity = function (
                                                timestamp,
                                                resetNext
                                            ) {
                                                var e_5, _a;
                                                if (
                                                    timestamp ===
                                                        this
                                                            .inactiveEndTimestamp ||
                                                    resetNext
                                                ) {
                                                    this.inactiveEndTimestamp = null;
                                                    this.backToNormal();
                                                }
                                                if (
                                                    this.config.skipInactive &&
                                                    !this.inactiveEndTimestamp
                                                ) {
                                                    try {
                                                        for (
                                                            var _b = __values(
                                                                    this
                                                                        .activityIntervals
                                                                ),
                                                                _c = _b.next();
                                                            !_c.done;
                                                            _c = _b.next()
                                                        ) {
                                                            var interval =
                                                                _c.value;
                                                            if (
                                                                timestamp >=
                                                                    interval.startTime &&
                                                                timestamp <
                                                                    interval.endTime &&
                                                                !interval.active
                                                            ) {
                                                                this.inactiveEndTimestamp =
                                                                    interval.endTime;
                                                                break;
                                                            }
                                                        }
                                                    } catch (e_5_1) {
                                                        e_5 = { error: e_5_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                _c &&
                                                                !_c.done &&
                                                                (_a = _b.return)
                                                            )
                                                                _a.call(_b);
                                                        } finally {
                                                            if (e_5)
                                                                throw e_5.error;
                                                        }
                                                    }
                                                    if (
                                                        this
                                                            .inactiveEndTimestamp
                                                    ) {
                                                        var skipTime =
                                                            this
                                                                .inactiveEndTimestamp -
                                                            timestamp;
                                                        var payload = {
                                                            speed: Math.min(
                                                                Math.round(
                                                                    skipTime /
                                                                        this
                                                                            .config
                                                                            .inactiveSkipTime
                                                                ),
                                                                this.config
                                                                    .maxSkipSpeed
                                                            ),
                                                        };
                                                        this.speedService.send({
                                                            type:
                                                                'FAST_FORWARD',
                                                            payload: payload,
                                                        });
                                                        this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .SkipStart,
                                                            payload
                                                        );
                                                    }
                                                }
                                            };
                                            Replayer.prototype.rebuildFullSnapshot = function (
                                                event,
                                                isSync
                                            ) {
                                                if (isSync === void 0) {
                                                    isSync = false;
                                                }
                                                if (
                                                    !this.iframe.contentDocument
                                                ) {
                                                    return console.warn(
                                                        'Looks like your replayer has been destroyed.'
                                                    );
                                                }
                                                if (
                                                    Object.keys(
                                                        this
                                                            .legacy_missingNodeRetryMap
                                                    ).length
                                                ) {
                                                    console.warn(
                                                        'Found unresolved missing node map',
                                                        this
                                                            .legacy_missingNodeRetryMap
                                                    );
                                                }
                                                this.legacy_missingNodeRetryMap = {};
                                                utils_1.mirror.map = snapshot_1.rebuild(
                                                    event.data.node,
                                                    {
                                                        doc: this.iframe
                                                            .contentDocument,
                                                    }
                                                )[1];
                                                var styleEl = document.createElement(
                                                    'style'
                                                );
                                                var _a = this.iframe
                                                        .contentDocument,
                                                    documentElement =
                                                        _a.documentElement,
                                                    head = _a.head;
                                                documentElement.insertBefore(
                                                    styleEl,
                                                    head
                                                );
                                                var injectStylesRules = inject_style_1
                                                    .default(
                                                        this.config.blockClass
                                                    )
                                                    .concat(
                                                        this.config
                                                            .insertStyleRules
                                                    );
                                                if (
                                                    this.config.pauseAnimation
                                                ) {
                                                    injectStylesRules.push(
                                                        'html.rrweb-paused * { animation-play-state: paused !important; }'
                                                    );
                                                }
                                                if (
                                                    !this.service.state.matches(
                                                        'playing'
                                                    )
                                                ) {
                                                    this.iframe.contentDocument
                                                        .getElementsByTagName(
                                                            'html'
                                                        )[0]
                                                        .classList.add(
                                                            'rrweb-paused'
                                                        );
                                                }
                                                for (
                                                    var idx = 0;
                                                    idx <
                                                    injectStylesRules.length;
                                                    idx++
                                                ) {
                                                    styleEl.sheet.insertRule(
                                                        injectStylesRules[idx],
                                                        idx
                                                    );
                                                }
                                                this.emitter.emit(
                                                    types_1.ReplayerEvents
                                                        .FullsnapshotRebuilded,
                                                    event
                                                );
                                                if (!isSync) {
                                                    this.waitForStylesheetLoad();
                                                }
                                                if (
                                                    this.config
                                                        .UNSAFE_replayCanvas
                                                ) {
                                                    this.preloadAllImages();
                                                }
                                            };
                                            Replayer.prototype.waitForStylesheetLoad = function () {
                                                var _this = this;
                                                var _a;
                                                var head =
                                                    (_a = this.iframe
                                                        .contentDocument) ===
                                                        null || _a === void 0
                                                        ? void 0
                                                        : _a.head;
                                                if (head) {
                                                    var unloadSheets_1 = new Set();
                                                    var timer_2;
                                                    var beforeLoadState_1 = this
                                                        .service.state;
                                                    var stateHandler_1 = function () {
                                                        beforeLoadState_1 =
                                                            _this.service.state;
                                                    };
                                                    this.emitter.on(
                                                        types_1.ReplayerEvents
                                                            .Start,
                                                        stateHandler_1
                                                    );
                                                    this.emitter.on(
                                                        types_1.ReplayerEvents
                                                            .Pause,
                                                        stateHandler_1
                                                    );
                                                    var unsubscribe_1 = function () {
                                                        _this.emitter.off(
                                                            types_1
                                                                .ReplayerEvents
                                                                .Start,
                                                            stateHandler_1
                                                        );
                                                        _this.emitter.off(
                                                            types_1
                                                                .ReplayerEvents
                                                                .Pause,
                                                            stateHandler_1
                                                        );
                                                    };
                                                    head.querySelectorAll(
                                                        'link[rel="stylesheet"]'
                                                    ).forEach(function (css) {
                                                        if (!css.sheet) {
                                                            unloadSheets_1.add(
                                                                css
                                                            );
                                                            css.addEventListener(
                                                                'load',
                                                                function () {
                                                                    unloadSheets_1.delete(
                                                                        css
                                                                    );
                                                                    if (
                                                                        unloadSheets_1.size ===
                                                                            0 &&
                                                                        timer_2 !==
                                                                            -1
                                                                    ) {
                                                                        if (
                                                                            beforeLoadState_1.matches(
                                                                                'playing'
                                                                            )
                                                                        ) {
                                                                            _this.play(
                                                                                _this.getCurrentTime()
                                                                            );
                                                                        }
                                                                        _this.emitter.emit(
                                                                            types_1
                                                                                .ReplayerEvents
                                                                                .LoadStylesheetEnd
                                                                        );
                                                                        if (
                                                                            timer_2
                                                                        ) {
                                                                            window.clearTimeout(
                                                                                timer_2
                                                                            );
                                                                        }
                                                                        unsubscribe_1();
                                                                    }
                                                                }
                                                            );
                                                        }
                                                    });
                                                    if (
                                                        unloadSheets_1.size > 0
                                                    ) {
                                                        this.service.send({
                                                            type: 'PAUSE',
                                                        });
                                                        this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .LoadStylesheetStart
                                                        );
                                                        timer_2 = window.setTimeout(
                                                            function () {
                                                                if (
                                                                    beforeLoadState_1.matches(
                                                                        'playing'
                                                                    )
                                                                ) {
                                                                    _this.play(
                                                                        _this.getCurrentTime()
                                                                    );
                                                                }
                                                                timer_2 = -1;
                                                                unsubscribe_1();
                                                            },
                                                            this.config
                                                                .loadTimeout
                                                        );
                                                    }
                                                }
                                            };
                                            Replayer.prototype.preloadAllImages = function () {
                                                var e_6, _a;
                                                var _this = this;
                                                var beforeLoadState = this
                                                    .service.state;
                                                var stateHandler = function () {
                                                    beforeLoadState =
                                                        _this.service.state;
                                                };
                                                this.emitter.on(
                                                    types_1.ReplayerEvents
                                                        .Start,
                                                    stateHandler
                                                );
                                                this.emitter.on(
                                                    types_1.ReplayerEvents
                                                        .Pause,
                                                    stateHandler
                                                );
                                                var unsubscribe = function () {
                                                    _this.emitter.off(
                                                        types_1.ReplayerEvents
                                                            .Start,
                                                        stateHandler
                                                    );
                                                    _this.emitter.off(
                                                        types_1.ReplayerEvents
                                                            .Pause,
                                                        stateHandler
                                                    );
                                                };
                                                var count = 0;
                                                var resolved = 0;
                                                try {
                                                    for (
                                                        var _b = __values(
                                                                this.service
                                                                    .state
                                                                    .context
                                                                    .events
                                                            ),
                                                            _c = _b.next();
                                                        !_c.done;
                                                        _c = _b.next()
                                                    ) {
                                                        var event_1 = _c.value;
                                                        if (
                                                            event_1.type ===
                                                                types_1
                                                                    .EventType
                                                                    .IncrementalSnapshot &&
                                                            event_1.data
                                                                .source ===
                                                                types_1
                                                                    .IncrementalSource
                                                                    .CanvasMutation &&
                                                            event_1.data
                                                                .property ===
                                                                'drawImage' &&
                                                            typeof event_1.data
                                                                .args[0] ===
                                                                'string' &&
                                                            !this.imageMap.has(
                                                                event_1
                                                            )
                                                        ) {
                                                            count++;
                                                            var image = document.createElement(
                                                                'img'
                                                            );
                                                            image.src =
                                                                event_1.data.args[0];
                                                            this.imageMap.set(
                                                                event_1,
                                                                image
                                                            );
                                                            image.onload = function () {
                                                                resolved++;
                                                                if (
                                                                    resolved ===
                                                                    count
                                                                ) {
                                                                    if (
                                                                        beforeLoadState.matches(
                                                                            'playing'
                                                                        )
                                                                    ) {
                                                                        _this.play(
                                                                            _this.getCurrentTime()
                                                                        );
                                                                    }
                                                                    unsubscribe();
                                                                }
                                                            };
                                                        }
                                                    }
                                                } catch (e_6_1) {
                                                    e_6 = { error: e_6_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _c &&
                                                            !_c.done &&
                                                            (_a = _b.return)
                                                        )
                                                            _a.call(_b);
                                                    } finally {
                                                        if (e_6)
                                                            throw e_6.error;
                                                    }
                                                }
                                                if (count !== resolved) {
                                                    this.service.send({
                                                        type: 'PAUSE',
                                                    });
                                                }
                                            };
                                            Replayer.prototype.applyIncremental = function (
                                                e,
                                                isSync
                                            ) {
                                                var _this = this;
                                                var _a, _b;
                                                var d = e.data;
                                                switch (d.source) {
                                                    case types_1
                                                        .IncrementalSource
                                                        .Mutation: {
                                                        if (isSync) {
                                                            d.adds.forEach(
                                                                function (m) {
                                                                    return _this.treeIndex.add(
                                                                        m
                                                                    );
                                                                }
                                                            );
                                                            d.texts.forEach(
                                                                function (m) {
                                                                    return _this.treeIndex.text(
                                                                        m
                                                                    );
                                                                }
                                                            );
                                                            d.attributes.forEach(
                                                                function (m) {
                                                                    return _this.treeIndex.attribute(
                                                                        m
                                                                    );
                                                                }
                                                            );
                                                            d.removes.forEach(
                                                                function (m) {
                                                                    return _this.treeIndex.remove(
                                                                        m
                                                                    );
                                                                }
                                                            );
                                                        }
                                                        this.applyMutation(
                                                            d,
                                                            isSync
                                                        );
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .MouseMove:
                                                        if (isSync) {
                                                            var lastPosition =
                                                                d.positions[
                                                                    d.positions
                                                                        .length -
                                                                        1
                                                                ];
                                                            this.moveAndHover(
                                                                d,
                                                                lastPosition.x,
                                                                lastPosition.y,
                                                                lastPosition.id
                                                            );
                                                        } else {
                                                            d.positions.forEach(
                                                                function (p) {
                                                                    var action = {
                                                                        doAction: function () {
                                                                            _this.moveAndHover(
                                                                                d,
                                                                                p.x,
                                                                                p.y,
                                                                                p.id
                                                                            );
                                                                        },
                                                                        delay:
                                                                            p.timeOffset +
                                                                            e.timestamp -
                                                                            _this
                                                                                .service
                                                                                .state
                                                                                .context
                                                                                .baselineTime,
                                                                    };
                                                                    _this.timer.addAction(
                                                                        action
                                                                    );
                                                                }
                                                            );
                                                            this.timer.addAction(
                                                                {
                                                                    doAction: function () {},
                                                                    delay:
                                                                        e.delay -
                                                                        ((_a =
                                                                            d
                                                                                .positions[0]) ===
                                                                            null ||
                                                                        _a ===
                                                                            void 0
                                                                            ? void 0
                                                                            : _a.timeOffset),
                                                                }
                                                            );
                                                        }
                                                        break;
                                                    case types_1
                                                        .IncrementalSource
                                                        .MouseInteraction: {
                                                        if (d.id === -1) {
                                                            break;
                                                        }
                                                        var event_2 = new Event(
                                                            types_1.MouseInteractions[
                                                                d.type
                                                            ].toLowerCase()
                                                        );
                                                        var target = utils_1.mirror.getNode(
                                                            d.id
                                                        );
                                                        if (!target) {
                                                            return this.debugNodeNotFound(
                                                                d,
                                                                d.id
                                                            );
                                                        }
                                                        this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .MouseInteraction,
                                                            {
                                                                type: d.type,
                                                                target: target,
                                                            }
                                                        );
                                                        var triggerFocus = this
                                                            .config
                                                            .triggerFocus;
                                                        switch (d.type) {
                                                            case types_1
                                                                .MouseInteractions
                                                                .Blur:
                                                                if (
                                                                    'blur' in
                                                                    target
                                                                ) {
                                                                    target.blur();
                                                                }
                                                                break;
                                                            case types_1
                                                                .MouseInteractions
                                                                .Focus:
                                                                if (
                                                                    triggerFocus &&
                                                                    target.focus
                                                                ) {
                                                                    target.focus(
                                                                        {
                                                                            preventScroll: true,
                                                                        }
                                                                    );
                                                                }
                                                                break;
                                                            case types_1
                                                                .MouseInteractions
                                                                .Click:
                                                            case types_1
                                                                .MouseInteractions
                                                                .TouchStart:
                                                            case types_1
                                                                .MouseInteractions
                                                                .TouchEnd:
                                                                if (!isSync) {
                                                                    this.moveAndHover(
                                                                        d,
                                                                        d.x,
                                                                        d.y,
                                                                        d.id
                                                                    );
                                                                    this.mouse.classList.remove(
                                                                        'active'
                                                                    );
                                                                    void this
                                                                        .mouse
                                                                        .offsetWidth;
                                                                    this.mouse.classList.add(
                                                                        'active'
                                                                    );
                                                                }
                                                                break;
                                                            default:
                                                                target.dispatchEvent(
                                                                    event_2
                                                                );
                                                        }
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .Scroll: {
                                                        if (d.id === -1) {
                                                            break;
                                                        }
                                                        if (isSync) {
                                                            this.treeIndex.scroll(
                                                                d
                                                            );
                                                            break;
                                                        }
                                                        this.applyScroll(d);
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .ViewportResize:
                                                        this.emitter.emit(
                                                            types_1
                                                                .ReplayerEvents
                                                                .Resize,
                                                            {
                                                                width: d.width,
                                                                height:
                                                                    d.height,
                                                            }
                                                        );
                                                        break;
                                                    case types_1
                                                        .IncrementalSource
                                                        .Input: {
                                                        if (d.id === -1) {
                                                            break;
                                                        }
                                                        if (isSync) {
                                                            this.treeIndex.input(
                                                                d
                                                            );
                                                            break;
                                                        }
                                                        this.applyInput(d);
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .MediaInteraction: {
                                                        var target = utils_1.mirror.getNode(
                                                            d.id
                                                        );
                                                        if (!target) {
                                                            return this.debugNodeNotFound(
                                                                d,
                                                                d.id
                                                            );
                                                        }
                                                        var mediaEl_1 = target;
                                                        try {
                                                            if (d.type === 1) {
                                                                mediaEl_1.pause();
                                                            }
                                                            if (d.type === 0) {
                                                                if (
                                                                    mediaEl_1.readyState >=
                                                                    HTMLMediaElement.HAVE_CURRENT_DATA
                                                                ) {
                                                                    mediaEl_1.play();
                                                                } else {
                                                                    mediaEl_1.addEventListener(
                                                                        'canplay',
                                                                        function () {
                                                                            mediaEl_1.play();
                                                                        }
                                                                    );
                                                                }
                                                            }
                                                        } catch (error) {
                                                            if (
                                                                this.config
                                                                    .showWarning
                                                            ) {
                                                                console.warn(
                                                                    'Failed to replay media interactions: ' +
                                                                        (error.message ||
                                                                            error)
                                                                );
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .StyleSheetRule: {
                                                        var target = utils_1.mirror.getNode(
                                                            d.id
                                                        );
                                                        if (!target) {
                                                            return this.debugNodeNotFound(
                                                                d,
                                                                d.id
                                                            );
                                                        }
                                                        var styleEl = target;
                                                        var parent_2 =
                                                            target.parentNode;
                                                        var usingVirtualParent = this.fragmentParentMap.has(
                                                            parent_2
                                                        );
                                                        var placeholderNode = void 0;
                                                        if (
                                                            usingVirtualParent
                                                        ) {
                                                            var domParent = this.fragmentParentMap.get(
                                                                target.parentNode
                                                            );
                                                            placeholderNode = document.createTextNode(
                                                                ''
                                                            );
                                                            parent_2.replaceChild(
                                                                placeholderNode,
                                                                target
                                                            );
                                                            domParent.appendChild(
                                                                target
                                                            );
                                                        }
                                                        var styleSheet_1 =
                                                            styleEl.sheet;
                                                        if (d.adds) {
                                                            d.adds.forEach(
                                                                function (_a) {
                                                                    var rule =
                                                                            _a.rule,
                                                                        index =
                                                                            _a.index;
                                                                    try {
                                                                        var _index =
                                                                            index ===
                                                                            undefined
                                                                                ? undefined
                                                                                : Math.min(
                                                                                      index,
                                                                                      styleSheet_1
                                                                                          .rules
                                                                                          .length
                                                                                  );
                                                                        try {
                                                                            styleSheet_1.insertRule(
                                                                                rule,
                                                                                _index
                                                                            );
                                                                        } catch (e) {}
                                                                    } catch (e) {}
                                                                }
                                                            );
                                                        }
                                                        if (d.removes) {
                                                            d.removes.forEach(
                                                                function (_a) {
                                                                    var index =
                                                                        _a.index;
                                                                    try {
                                                                        styleSheet_1.deleteRule(
                                                                            index
                                                                        );
                                                                    } catch (e) {}
                                                                }
                                                            );
                                                        }
                                                        if (
                                                            usingVirtualParent &&
                                                            placeholderNode
                                                        ) {
                                                            parent_2.replaceChild(
                                                                target,
                                                                placeholderNode
                                                            );
                                                        }
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .CanvasMutation: {
                                                        if (
                                                            !this.config
                                                                .UNSAFE_replayCanvas
                                                        ) {
                                                            return;
                                                        }
                                                        var target = utils_1.mirror.getNode(
                                                            d.id
                                                        );
                                                        if (!target) {
                                                            return this.debugNodeNotFound(
                                                                d,
                                                                d.id
                                                            );
                                                        }
                                                        try {
                                                            var ctx = target.getContext(
                                                                '2d'
                                                            );
                                                            if (d.setter) {
                                                                ctx[
                                                                    d.property
                                                                ] = d.args[0];
                                                                return;
                                                            }
                                                            var original =
                                                                ctx[d.property];
                                                            if (
                                                                d.property ===
                                                                    'drawImage' &&
                                                                typeof d
                                                                    .args[0] ===
                                                                    'string'
                                                            ) {
                                                                var image = this.imageMap.get(
                                                                    e
                                                                );
                                                                d.args[0] = image;
                                                                original.apply(
                                                                    ctx,
                                                                    d.args
                                                                );
                                                            } else {
                                                                original.apply(
                                                                    ctx,
                                                                    d.args
                                                                );
                                                            }
                                                        } catch (error) {
                                                            this.warnCanvasMutationFailed(
                                                                d,
                                                                d.id,
                                                                error
                                                            );
                                                        }
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .Font: {
                                                        try {
                                                            var fontFace = new FontFace(
                                                                d.family,
                                                                d.buffer
                                                                    ? new Uint8Array(
                                                                          JSON.parse(
                                                                              d.fontSource
                                                                          )
                                                                      )
                                                                    : d.fontSource,
                                                                d.descriptors
                                                            );
                                                            (_b = this.iframe
                                                                .contentDocument) ===
                                                                null ||
                                                            _b === void 0
                                                                ? void 0
                                                                : _b.fonts.add(
                                                                      fontFace
                                                                  );
                                                        } catch (error) {
                                                            if (
                                                                this.config
                                                                    .showWarning
                                                            ) {
                                                                console.warn(
                                                                    error
                                                                );
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    case types_1
                                                        .IncrementalSource
                                                        .Log: {
                                                        try {
                                                            var logData =
                                                                e.data;
                                                            var replayLogger = this
                                                                .config
                                                                .logConfig
                                                                .replayLogger;
                                                            if (
                                                                typeof replayLogger[
                                                                    logData
                                                                        .level
                                                                ] === 'function'
                                                            )
                                                                replayLogger[
                                                                    logData
                                                                        .level
                                                                ](logData);
                                                        } catch (error) {
                                                            if (
                                                                this.config
                                                                    .showWarning
                                                            ) {
                                                                console.warn(
                                                                    error
                                                                );
                                                            }
                                                        }
                                                    }
                                                    default:
                                                }
                                            };
                                            Replayer.prototype.applyMutation = function (
                                                d,
                                                useVirtualParent
                                            ) {
                                                var e_7, _a;
                                                var _this = this;
                                                d.removes.forEach(function (
                                                    mutation
                                                ) {
                                                    var target = utils_1.mirror.getNode(
                                                        mutation.id
                                                    );
                                                    if (!target) {
                                                        return _this.warnNodeNotFound(
                                                            d,
                                                            mutation.id
                                                        );
                                                    }
                                                    var parent = utils_1.mirror.getNode(
                                                        mutation.parentId
                                                    );
                                                    if (!parent) {
                                                        return _this.warnNodeNotFound(
                                                            d,
                                                            mutation.parentId
                                                        );
                                                    }
                                                    utils_1.mirror.removeNodeFromMap(
                                                        target
                                                    );
                                                    if (parent) {
                                                        var realParent = _this.fragmentParentMap.get(
                                                            parent
                                                        );
                                                        if (
                                                            realParent &&
                                                            realParent.contains(
                                                                target
                                                            )
                                                        ) {
                                                            realParent.removeChild(
                                                                target
                                                            );
                                                        } else if (
                                                            _this.fragmentParentMap.has(
                                                                target
                                                            )
                                                        ) {
                                                            var realTarget = _this.fragmentParentMap.get(
                                                                target
                                                            );
                                                            parent.removeChild(
                                                                realTarget
                                                            );
                                                            _this.fragmentParentMap.delete(
                                                                target
                                                            );
                                                        } else {
                                                            parent.removeChild(
                                                                target
                                                            );
                                                        }
                                                    }
                                                });
                                                var legacy_missingNodeMap = __assign(
                                                    {},
                                                    this
                                                        .legacy_missingNodeRetryMap
                                                );
                                                var queue = [];
                                                function nextNotInDOM(
                                                    mutation
                                                ) {
                                                    var next = null;
                                                    if (mutation.nextId) {
                                                        next = utils_1.mirror.getNode(
                                                            mutation.nextId
                                                        );
                                                    }
                                                    if (
                                                        mutation.nextId !==
                                                            null &&
                                                        mutation.nextId !==
                                                            undefined &&
                                                        mutation.nextId !==
                                                            -1 &&
                                                        !next
                                                    ) {
                                                        return true;
                                                    }
                                                    return false;
                                                }
                                                var appendNode = function (
                                                    mutation
                                                ) {
                                                    if (
                                                        !_this.iframe
                                                            .contentDocument
                                                    ) {
                                                        return console.warn(
                                                            'Looks like your replayer has been destroyed.'
                                                        );
                                                    }
                                                    var parent = utils_1.mirror.getNode(
                                                        mutation.parentId
                                                    );
                                                    if (!parent) {
                                                        return queue.push(
                                                            mutation
                                                        );
                                                    }
                                                    var parentInDocument = null;
                                                    if (
                                                        _this.iframe
                                                            .contentDocument
                                                            .contains
                                                    ) {
                                                        parentInDocument = _this.iframe.contentDocument.contains(
                                                            parent
                                                        );
                                                    } else if (
                                                        _this.iframe
                                                            .contentDocument
                                                            .body.contains
                                                    ) {
                                                        parentInDocument = _this.iframe.contentDocument.body.contains(
                                                            parent
                                                        );
                                                    }
                                                    if (
                                                        useVirtualParent &&
                                                        parentInDocument
                                                    ) {
                                                        var virtualParent = document.createDocumentFragment();
                                                        utils_1.mirror.map[
                                                            mutation.parentId
                                                        ] = virtualParent;
                                                        _this.fragmentParentMap.set(
                                                            virtualParent,
                                                            parent
                                                        );
                                                        _this.storeState(
                                                            parent
                                                        );
                                                        while (
                                                            parent.firstChild
                                                        ) {
                                                            virtualParent.appendChild(
                                                                parent.firstChild
                                                            );
                                                        }
                                                        parent = virtualParent;
                                                    }
                                                    var previous = null;
                                                    var next = null;
                                                    if (mutation.previousId) {
                                                        previous = utils_1.mirror.getNode(
                                                            mutation.previousId
                                                        );
                                                    }
                                                    if (mutation.nextId) {
                                                        next = utils_1.mirror.getNode(
                                                            mutation.nextId
                                                        );
                                                    }
                                                    if (
                                                        nextNotInDOM(mutation)
                                                    ) {
                                                        return queue.push(
                                                            mutation
                                                        );
                                                    }
                                                    var target = snapshot_1.buildNodeWithSN(
                                                        mutation.node,
                                                        {
                                                            doc:
                                                                _this.iframe
                                                                    .contentDocument,
                                                            map:
                                                                utils_1.mirror
                                                                    .map,
                                                            skipChild: true,
                                                            hackCss: true,
                                                        }
                                                    );
                                                    if (
                                                        mutation.previousId ===
                                                            -1 ||
                                                        mutation.nextId === -1
                                                    ) {
                                                        legacy_missingNodeMap[
                                                            mutation.node.id
                                                        ] = {
                                                            node: target,
                                                            mutation: mutation,
                                                        };
                                                        return;
                                                    }
                                                    if (
                                                        previous &&
                                                        previous.nextSibling &&
                                                        previous.nextSibling
                                                            .parentNode
                                                    ) {
                                                        parent.insertBefore(
                                                            target,
                                                            previous.nextSibling
                                                        );
                                                    } else if (
                                                        next &&
                                                        next.parentNode
                                                    ) {
                                                        parent.contains(next)
                                                            ? parent.insertBefore(
                                                                  target,
                                                                  next
                                                              )
                                                            : parent.insertBefore(
                                                                  target,
                                                                  null
                                                              );
                                                    } else {
                                                        parent.appendChild(
                                                            target
                                                        );
                                                    }
                                                    if (
                                                        mutation.previousId ||
                                                        mutation.nextId
                                                    ) {
                                                        _this.legacy_resolveMissingNode(
                                                            legacy_missingNodeMap,
                                                            parent,
                                                            target,
                                                            mutation
                                                        );
                                                    }
                                                };
                                                d.adds.forEach(function (
                                                    mutation
                                                ) {
                                                    appendNode(mutation);
                                                });
                                                var startTime = Date.now();
                                                while (queue.length) {
                                                    var resolveTrees = utils_1.queueToResolveTrees(
                                                        queue
                                                    );
                                                    queue.length = 0;
                                                    if (
                                                        Date.now() - startTime >
                                                        500
                                                    ) {
                                                        this.warn(
                                                            'Timeout in the loop, please check the resolve tree data:',
                                                            resolveTrees
                                                        );
                                                        break;
                                                    }
                                                    try {
                                                        for (
                                                            var resolveTrees_1 =
                                                                    ((e_7 = void 0),
                                                                    __values(
                                                                        resolveTrees
                                                                    )),
                                                                resolveTrees_1_1 = resolveTrees_1.next();
                                                            !resolveTrees_1_1.done;
                                                            resolveTrees_1_1 = resolveTrees_1.next()
                                                        ) {
                                                            var tree =
                                                                resolveTrees_1_1.value;
                                                            var parent_3 = utils_1.mirror.getNode(
                                                                tree.value
                                                                    .parentId
                                                            );
                                                            if (!parent_3) {
                                                                this.debug(
                                                                    'Drop resolve tree since there is no parent for the root node.',
                                                                    tree
                                                                );
                                                            } else {
                                                                utils_1.iterateResolveTree(
                                                                    tree,
                                                                    function (
                                                                        mutation
                                                                    ) {
                                                                        appendNode(
                                                                            mutation
                                                                        );
                                                                    }
                                                                );
                                                            }
                                                        }
                                                    } catch (e_7_1) {
                                                        e_7 = { error: e_7_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                resolveTrees_1_1 &&
                                                                !resolveTrees_1_1.done &&
                                                                (_a =
                                                                    resolveTrees_1.return)
                                                            )
                                                                _a.call(
                                                                    resolveTrees_1
                                                                );
                                                        } finally {
                                                            if (e_7)
                                                                throw e_7.error;
                                                        }
                                                    }
                                                }
                                                if (
                                                    Object.keys(
                                                        legacy_missingNodeMap
                                                    ).length
                                                ) {
                                                    Object.assign(
                                                        this
                                                            .legacy_missingNodeRetryMap,
                                                        legacy_missingNodeMap
                                                    );
                                                }
                                                d.texts.forEach(function (
                                                    mutation
                                                ) {
                                                    var target = utils_1.mirror.getNode(
                                                        mutation.id
                                                    );
                                                    if (!target) {
                                                        return _this.warnNodeNotFound(
                                                            d,
                                                            mutation.id
                                                        );
                                                    }
                                                    if (
                                                        _this.fragmentParentMap.has(
                                                            target
                                                        )
                                                    ) {
                                                        target = _this.fragmentParentMap.get(
                                                            target
                                                        );
                                                    }
                                                    target.textContent =
                                                        mutation.value;
                                                });
                                                d.attributes.forEach(function (
                                                    mutation
                                                ) {
                                                    var target = utils_1.mirror.getNode(
                                                        mutation.id
                                                    );
                                                    if (!target) {
                                                        return _this.warnNodeNotFound(
                                                            d,
                                                            mutation.id
                                                        );
                                                    }
                                                    if (
                                                        _this.fragmentParentMap.has(
                                                            target
                                                        )
                                                    ) {
                                                        target = _this.fragmentParentMap.get(
                                                            target
                                                        );
                                                    }
                                                    for (var attributeName in mutation.attributes) {
                                                        if (
                                                            typeof attributeName ===
                                                            'string'
                                                        ) {
                                                            var value =
                                                                mutation
                                                                    .attributes[
                                                                    attributeName
                                                                ];
                                                            try {
                                                                if (
                                                                    value !==
                                                                    null
                                                                ) {
                                                                    target.setAttribute(
                                                                        attributeName,
                                                                        value
                                                                    );
                                                                } else {
                                                                    target.removeAttribute(
                                                                        attributeName
                                                                    );
                                                                }
                                                            } catch (error) {
                                                                if (
                                                                    _this.config
                                                                        .showWarning
                                                                ) {
                                                                    console.warn(
                                                                        'An error occurred may due to the checkout feature.',
                                                                        error
                                                                    );
                                                                }
                                                            }
                                                        }
                                                    }
                                                });
                                            };
                                            Replayer.prototype.applyScroll = function (
                                                d
                                            ) {
                                                var target = utils_1.mirror.getNode(
                                                    d.id
                                                );
                                                if (!target) {
                                                    return this.debugNodeNotFound(
                                                        d,
                                                        d.id
                                                    );
                                                }
                                                if (
                                                    target ===
                                                    this.iframe.contentDocument
                                                ) {
                                                    this.iframe.contentWindow.scrollTo(
                                                        {
                                                            top: d.y,
                                                            left: d.x,
                                                            behavior: 'smooth',
                                                        }
                                                    );
                                                } else {
                                                    try {
                                                        target.scrollTop = d.y;
                                                        target.scrollLeft = d.x;
                                                    } catch (error) {}
                                                }
                                            };
                                            Replayer.prototype.applyInput = function (
                                                d
                                            ) {
                                                var target = utils_1.mirror.getNode(
                                                    d.id
                                                );
                                                if (!target) {
                                                    return this.debugNodeNotFound(
                                                        d,
                                                        d.id
                                                    );
                                                }
                                                try {
                                                    target.checked =
                                                        d.isChecked;
                                                    target.value = d.text;
                                                } catch (error) {}
                                            };
                                            Replayer.prototype.formatMessage = function (
                                                data
                                            ) {
                                                if (data.trace.length === 0)
                                                    return '';
                                                var stackPrefix = '\n\tat ';
                                                var result = stackPrefix;
                                                result += data.trace.join(
                                                    stackPrefix
                                                );
                                                return result;
                                            };
                                            Replayer.prototype.getConsoleLogger = function () {
                                                var e_8, _a;
                                                var _this = this;
                                                var rrwebOriginal =
                                                    '__rrweb_original__';
                                                var replayLogger = {};
                                                var _loop_1 = function (level) {
                                                    if (level === 'trace')
                                                        replayLogger[
                                                            level
                                                        ] = function (data) {
                                                            var logger = console
                                                                .log[
                                                                rrwebOriginal
                                                            ]
                                                                ? console.log[
                                                                      rrwebOriginal
                                                                  ]
                                                                : console.log;
                                                            logger.apply(
                                                                void 0,
                                                                __spread(
                                                                    data.payload.map(
                                                                        function (
                                                                            s
                                                                        ) {
                                                                            return JSON.parse(
                                                                                s
                                                                            );
                                                                        }
                                                                    ),
                                                                    [
                                                                        _this.formatMessage(
                                                                            data
                                                                        ),
                                                                    ]
                                                                )
                                                            );
                                                        };
                                                    else
                                                        replayLogger[
                                                            level
                                                        ] = function (data) {
                                                            var logger = console[
                                                                level
                                                            ][rrwebOriginal]
                                                                ? console[
                                                                      level
                                                                  ][
                                                                      rrwebOriginal
                                                                  ]
                                                                : console[
                                                                      level
                                                                  ];
                                                            logger.apply(
                                                                void 0,
                                                                __spread(
                                                                    data.payload.map(
                                                                        function (
                                                                            s
                                                                        ) {
                                                                            return JSON.parse(
                                                                                s
                                                                            );
                                                                        }
                                                                    ),
                                                                    [
                                                                        _this.formatMessage(
                                                                            data
                                                                        ),
                                                                    ]
                                                                )
                                                            );
                                                        };
                                                };
                                                try {
                                                    for (
                                                        var _b = __values(
                                                                this.config
                                                                    .logConfig
                                                                    .level
                                                            ),
                                                            _c = _b.next();
                                                        !_c.done;
                                                        _c = _b.next()
                                                    ) {
                                                        var level = _c.value;
                                                        _loop_1(level);
                                                    }
                                                } catch (e_8_1) {
                                                    e_8 = { error: e_8_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _c &&
                                                            !_c.done &&
                                                            (_a = _b.return)
                                                        )
                                                            _a.call(_b);
                                                    } finally {
                                                        if (e_8)
                                                            throw e_8.error;
                                                    }
                                                }
                                                return replayLogger;
                                            };
                                            Replayer.prototype.legacy_resolveMissingNode = function (
                                                map,
                                                parent,
                                                target,
                                                targetMutation
                                            ) {
                                                var previousId =
                                                        targetMutation.previousId,
                                                    nextId =
                                                        targetMutation.nextId;
                                                var previousInMap =
                                                    previousId &&
                                                    map[previousId];
                                                var nextInMap =
                                                    nextId && map[nextId];
                                                if (previousInMap) {
                                                    var _a = previousInMap,
                                                        node = _a.node,
                                                        mutation = _a.mutation;
                                                    parent.insertBefore(
                                                        node,
                                                        target
                                                    );
                                                    delete map[
                                                        mutation.node.id
                                                    ];
                                                    delete this
                                                        .legacy_missingNodeRetryMap[
                                                        mutation.node.id
                                                    ];
                                                    if (
                                                        mutation.previousId ||
                                                        mutation.nextId
                                                    ) {
                                                        this.legacy_resolveMissingNode(
                                                            map,
                                                            parent,
                                                            node,
                                                            mutation
                                                        );
                                                    }
                                                }
                                                if (nextInMap) {
                                                    var _b = nextInMap,
                                                        node = _b.node,
                                                        mutation = _b.mutation;
                                                    parent.insertBefore(
                                                        node,
                                                        target.nextSibling
                                                    );
                                                    delete map[
                                                        mutation.node.id
                                                    ];
                                                    delete this
                                                        .legacy_missingNodeRetryMap[
                                                        mutation.node.id
                                                    ];
                                                    if (
                                                        mutation.previousId ||
                                                        mutation.nextId
                                                    ) {
                                                        this.legacy_resolveMissingNode(
                                                            map,
                                                            parent,
                                                            node,
                                                            mutation
                                                        );
                                                    }
                                                }
                                            };
                                            Replayer.prototype.moveAndHover = function (
                                                d,
                                                x,
                                                y,
                                                id
                                            ) {
                                                this.mouse.style.left =
                                                    x + 'px';
                                                this.mouse.style.top = y + 'px';
                                                this.drawMouseTail({
                                                    x: x,
                                                    y: y,
                                                });
                                                var target = utils_1.mirror.getNode(
                                                    id
                                                );
                                                if (!target) {
                                                    return this.debugNodeNotFound(
                                                        d,
                                                        id
                                                    );
                                                }
                                                this.hoverElements(target);
                                            };
                                            Replayer.prototype.drawMouseTail = function (
                                                position
                                            ) {
                                                var _this = this;
                                                if (!this.mouseTail) {
                                                    return;
                                                }
                                                var _a =
                                                        this.config
                                                            .mouseTail === true
                                                            ? defaultMouseTailConfig
                                                            : Object.assign(
                                                                  {},
                                                                  defaultMouseTailConfig,
                                                                  this.config
                                                                      .mouseTail
                                                              ),
                                                    lineCap = _a.lineCap,
                                                    lineWidth = _a.lineWidth,
                                                    strokeStyle =
                                                        _a.strokeStyle,
                                                    duration = _a.duration;
                                                var draw = function () {
                                                    if (!_this.mouseTail) {
                                                        return;
                                                    }
                                                    var ctx = _this.mouseTail.getContext(
                                                        '2d'
                                                    );
                                                    if (
                                                        !ctx ||
                                                        !_this.tailPositions
                                                            .length
                                                    ) {
                                                        return;
                                                    }
                                                    ctx.clearRect(
                                                        0,
                                                        0,
                                                        _this.mouseTail.width,
                                                        _this.mouseTail.height
                                                    );
                                                    ctx.beginPath();
                                                    ctx.lineWidth = lineWidth;
                                                    ctx.lineCap = lineCap;
                                                    ctx.strokeStyle = strokeStyle;
                                                    ctx.moveTo(
                                                        _this.tailPositions[0]
                                                            .x,
                                                        _this.tailPositions[0].y
                                                    );
                                                    _this.tailPositions.forEach(
                                                        function (p) {
                                                            return ctx.lineTo(
                                                                p.x,
                                                                p.y
                                                            );
                                                        }
                                                    );
                                                    ctx.stroke();
                                                };
                                                this.tailPositions.push(
                                                    position
                                                );
                                                draw();
                                                setTimeout(function () {
                                                    _this.tailPositions = _this.tailPositions.filter(
                                                        function (p) {
                                                            return (
                                                                p !== position
                                                            );
                                                        }
                                                    );
                                                    draw();
                                                }, duration /
                                                    this.speedService.state
                                                        .context.timer.speed);
                                            };
                                            Replayer.prototype.hoverElements = function (
                                                el
                                            ) {
                                                var _a;
                                                (_a = this.iframe
                                                    .contentDocument) ===
                                                    null || _a === void 0
                                                    ? void 0
                                                    : _a
                                                          .querySelectorAll(
                                                              '.\\:hover'
                                                          )
                                                          .forEach(function (
                                                              hoveredEl
                                                          ) {
                                                              hoveredEl.classList.remove(
                                                                  ':hover'
                                                              );
                                                          });
                                                var currentEl = el;
                                                while (currentEl) {
                                                    if (currentEl.classList) {
                                                        currentEl.classList.add(
                                                            ':hover'
                                                        );
                                                    }
                                                    currentEl =
                                                        currentEl.parentElement;
                                                }
                                            };
                                            Replayer.prototype.isUserInteraction = function (
                                                event
                                            ) {
                                                if (
                                                    event.type !==
                                                    types_1.EventType
                                                        .IncrementalSnapshot
                                                ) {
                                                    return false;
                                                }
                                                return (
                                                    event.data.source >
                                                        types_1
                                                            .IncrementalSource
                                                            .Mutation &&
                                                    event.data.source <=
                                                        types_1
                                                            .IncrementalSource
                                                            .Input
                                                );
                                            };
                                            Replayer.prototype.backToNormal = function () {
                                                this.inactiveEndTimestamp = null;
                                                if (
                                                    this.speedService.state.matches(
                                                        'normal'
                                                    )
                                                ) {
                                                    return;
                                                }
                                                this.speedService.send({
                                                    type: 'BACK_TO_NORMAL',
                                                });
                                                this.emitter.emit(
                                                    types_1.ReplayerEvents
                                                        .SkipEnd,
                                                    {
                                                        speed: this.speedService
                                                            .state.context
                                                            .normalSpeed,
                                                    }
                                                );
                                            };
                                            Replayer.prototype.storeState = function (
                                                parent
                                            ) {
                                                var e_9, _a;
                                                if (parent) {
                                                    if (
                                                        parent.nodeType ===
                                                        parent.ELEMENT_NODE
                                                    ) {
                                                        var parentElement = parent;
                                                        if (
                                                            parentElement.scrollLeft ||
                                                            parentElement.scrollTop
                                                        ) {
                                                            this.elementStateMap.set(
                                                                parent,
                                                                {
                                                                    scroll: [
                                                                        parentElement.scrollLeft,
                                                                        parentElement.scrollTop,
                                                                    ],
                                                                }
                                                            );
                                                        }
                                                        var children =
                                                            parentElement.children;
                                                        try {
                                                            for (
                                                                var _b = __values(
                                                                        Array.from(
                                                                            children
                                                                        )
                                                                    ),
                                                                    _c = _b.next();
                                                                !_c.done;
                                                                _c = _b.next()
                                                            ) {
                                                                var child =
                                                                    _c.value;
                                                                this.storeState(
                                                                    child
                                                                );
                                                            }
                                                        } catch (e_9_1) {
                                                            e_9 = {
                                                                error: e_9_1,
                                                            };
                                                        } finally {
                                                            try {
                                                                if (
                                                                    _c &&
                                                                    !_c.done &&
                                                                    (_a =
                                                                        _b.return)
                                                                )
                                                                    _a.call(_b);
                                                            } finally {
                                                                if (e_9)
                                                                    throw e_9.error;
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                            Replayer.prototype.restoreState = function (
                                                parent
                                            ) {
                                                var e_10, _a;
                                                if (
                                                    parent.nodeType ===
                                                    parent.ELEMENT_NODE
                                                ) {
                                                    var parentElement = parent;
                                                    if (
                                                        this.elementStateMap.has(
                                                            parent
                                                        )
                                                    ) {
                                                        var storedState = this.elementStateMap.get(
                                                            parent
                                                        );
                                                        if (
                                                            storedState.scroll
                                                        ) {
                                                            parentElement.scrollLeft =
                                                                storedState.scroll[0];
                                                            parentElement.scrollTop =
                                                                storedState.scroll[1];
                                                        }
                                                        this.elementStateMap.delete(
                                                            parent
                                                        );
                                                    }
                                                    var children =
                                                        parentElement.children;
                                                    try {
                                                        for (
                                                            var _b = __values(
                                                                    Array.from(
                                                                        children
                                                                    )
                                                                ),
                                                                _c = _b.next();
                                                            !_c.done;
                                                            _c = _b.next()
                                                        ) {
                                                            var child =
                                                                _c.value;
                                                            this.restoreState(
                                                                child
                                                            );
                                                        }
                                                    } catch (e_10_1) {
                                                        e_10 = {
                                                            error: e_10_1,
                                                        };
                                                    } finally {
                                                        try {
                                                            if (
                                                                _c &&
                                                                !_c.done &&
                                                                (_a = _b.return)
                                                            )
                                                                _a.call(_b);
                                                        } finally {
                                                            if (e_10)
                                                                throw e_10.error;
                                                        }
                                                    }
                                                }
                                            };
                                            Replayer.prototype.warnNodeNotFound = function (
                                                d,
                                                id
                                            ) {
                                                this.warn(
                                                    "Node with id '" +
                                                        id +
                                                        "' not found in",
                                                    d
                                                );
                                            };
                                            Replayer.prototype.warnCanvasMutationFailed = function (
                                                d,
                                                id,
                                                error
                                            ) {
                                                this.warn(
                                                    "Has error on update canvas '" +
                                                        id +
                                                        "'",
                                                    d,
                                                    error
                                                );
                                            };
                                            Replayer.prototype.debugNodeNotFound = function (
                                                d,
                                                id
                                            ) {
                                                this.debug(
                                                    REPLAY_CONSOLE_PREFIX,
                                                    "Node with id '" +
                                                        id +
                                                        "' not found in",
                                                    d
                                                );
                                            };
                                            Replayer.prototype.warn = function () {
                                                var args = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    args[_i] = arguments[_i];
                                                }
                                                if (!this.config.showWarning) {
                                                    return;
                                                }
                                                console.warn.apply(
                                                    console,
                                                    __spread(
                                                        [REPLAY_CONSOLE_PREFIX],
                                                        args
                                                    )
                                                );
                                            };
                                            Replayer.prototype.debug = function () {
                                                var args = [];
                                                for (
                                                    var _i = 0;
                                                    _i < arguments.length;
                                                    _i++
                                                ) {
                                                    args[_i] = arguments[_i];
                                                }
                                                if (!this.config.showDebug) {
                                                    return;
                                                }
                                                console.log.apply(
                                                    console,
                                                    __spread(
                                                        [REPLAY_CONSOLE_PREFIX],
                                                        args
                                                    )
                                                );
                                            };
                                            return Replayer;
                                        })();
                                        exports.Replayer = Replayer;

                                        /***/
                                    },

                                /***/ './src/replay/machine.ts':
                                    /*!*******************************!*\
  !*** ./src/replay/machine.ts ***!
  \*******************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_122968__
                                    ) {
                                        var __assign =
                                            (this && this.__assign) ||
                                            function () {
                                                __assign =
                                                    Object.assign ||
                                                    function (t) {
                                                        for (
                                                            var s,
                                                                i = 1,
                                                                n =
                                                                    arguments.length;
                                                            i < n;
                                                            i++
                                                        ) {
                                                            s = arguments[i];
                                                            for (var p in s)
                                                                if (
                                                                    Object.prototype.hasOwnProperty.call(
                                                                        s,
                                                                        p
                                                                    )
                                                                )
                                                                    t[p] = s[p];
                                                        }
                                                        return t;
                                                    };
                                                return __assign.apply(
                                                    this,
                                                    arguments
                                                );
                                            };
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.createSpeedService = exports.createPlayerService = exports.discardPriorSnapshots = void 0;
                                        var fsm_1 = __nested_webpack_require_122968__(
                                            /*! @xstate/fsm */ './node_modules/@xstate/fsm/es/index.js'
                                        );
                                        var types_1 = __nested_webpack_require_122968__(
                                            /*! ../types */ './src/types.ts'
                                        );
                                        var timer_1 = __nested_webpack_require_122968__(
                                            /*! ./timer */ './src/replay/timer.ts'
                                        );
                                        var utils_1 = __nested_webpack_require_122968__(
                                            /*! ../utils */ './src/utils.ts'
                                        );
                                        function discardPriorSnapshots(
                                            events,
                                            baselineTime
                                        ) {
                                            for (
                                                var idx = events.length - 1;
                                                idx >= 0;
                                                idx--
                                            ) {
                                                var event_1 = events[idx];
                                                if (
                                                    event_1.type ===
                                                    types_1.EventType.Meta
                                                ) {
                                                    if (
                                                        event_1.timestamp <=
                                                        baselineTime
                                                    ) {
                                                        return events.slice(
                                                            idx
                                                        );
                                                    }
                                                }
                                            }
                                            return events;
                                        }
                                        exports.discardPriorSnapshots = discardPriorSnapshots;
                                        function createPlayerService(
                                            context,
                                            _a
                                        ) {
                                            var getCastFn = _a.getCastFn,
                                                emitter = _a.emitter;
                                            var playerMachine = fsm_1.createMachine(
                                                {
                                                    id: 'player',
                                                    context: context,
                                                    initial: 'paused',
                                                    states: {
                                                        playing: {
                                                            on: {
                                                                PAUSE: {
                                                                    target:
                                                                        'paused',
                                                                    actions: [
                                                                        'pause',
                                                                    ],
                                                                },
                                                                CAST_EVENT: {
                                                                    target:
                                                                        'playing',
                                                                    actions:
                                                                        'castEvent',
                                                                },
                                                                END: {
                                                                    target:
                                                                        'paused',
                                                                    actions: [
                                                                        'resetLastPlayedEvent',
                                                                        'pause',
                                                                    ],
                                                                },
                                                                ADD_EVENT: {
                                                                    target:
                                                                        'playing',
                                                                    actions: [
                                                                        'addEvent',
                                                                    ],
                                                                },
                                                            },
                                                        },
                                                        paused: {
                                                            on: {
                                                                PLAY: {
                                                                    target:
                                                                        'playing',
                                                                    actions: [
                                                                        'recordTimeOffset',
                                                                        'play',
                                                                    ],
                                                                },
                                                                CAST_EVENT: {
                                                                    target:
                                                                        'paused',
                                                                    actions:
                                                                        'castEvent',
                                                                },
                                                                TO_LIVE: {
                                                                    target:
                                                                        'live',
                                                                    actions: [
                                                                        'startLive',
                                                                    ],
                                                                },
                                                                ADD_EVENT: {
                                                                    target:
                                                                        'paused',
                                                                    actions: [
                                                                        'addEvent',
                                                                    ],
                                                                },
                                                            },
                                                        },
                                                        live: {
                                                            on: {
                                                                ADD_EVENT: {
                                                                    target:
                                                                        'live',
                                                                    actions: [
                                                                        'addEvent',
                                                                    ],
                                                                },
                                                                CAST_EVENT: {
                                                                    target:
                                                                        'live',
                                                                    actions: [
                                                                        'castEvent',
                                                                    ],
                                                                },
                                                            },
                                                        },
                                                    },
                                                },
                                                {
                                                    actions: {
                                                        castEvent: fsm_1.assign(
                                                            {
                                                                lastPlayedEvent: function (
                                                                    ctx,
                                                                    event
                                                                ) {
                                                                    if (
                                                                        event.type ===
                                                                        'CAST_EVENT'
                                                                    ) {
                                                                        return event
                                                                            .payload
                                                                            .event;
                                                                    }
                                                                    return ctx.lastPlayedEvent;
                                                                },
                                                            }
                                                        ),
                                                        recordTimeOffset: fsm_1.assign(
                                                            function (
                                                                ctx,
                                                                event
                                                            ) {
                                                                var timeOffset =
                                                                    ctx.timeOffset;
                                                                if (
                                                                    'payload' in
                                                                        event &&
                                                                    'timeOffset' in
                                                                        event.payload
                                                                ) {
                                                                    timeOffset =
                                                                        event
                                                                            .payload
                                                                            .timeOffset;
                                                                }
                                                                return __assign(
                                                                    __assign(
                                                                        {},
                                                                        ctx
                                                                    ),
                                                                    {
                                                                        timeOffset: timeOffset,
                                                                        baselineTime:
                                                                            ctx
                                                                                .events[0]
                                                                                .timestamp +
                                                                            timeOffset,
                                                                    }
                                                                );
                                                            }
                                                        ),
                                                        play: function (ctx) {
                                                            var e_1,
                                                                _a,
                                                                e_2,
                                                                _b;
                                                            var _c;
                                                            console.warn(
                                                                'play'
                                                            );
                                                            var timer =
                                                                    ctx.timer,
                                                                events =
                                                                    ctx.events,
                                                                baselineTime =
                                                                    ctx.baselineTime,
                                                                lastPlayedEvent =
                                                                    ctx.lastPlayedEvent;
                                                            timer.clear();
                                                            try {
                                                                for (
                                                                    var events_1 = __values(
                                                                            events
                                                                        ),
                                                                        events_1_1 = events_1.next();
                                                                    !events_1_1.done;
                                                                    events_1_1 = events_1.next()
                                                                ) {
                                                                    var event_2 =
                                                                        events_1_1.value;
                                                                    timer_1.addDelay(
                                                                        event_2,
                                                                        baselineTime
                                                                    );
                                                                }
                                                            } catch (e_1_1) {
                                                                e_1 = {
                                                                    error: e_1_1,
                                                                };
                                                            } finally {
                                                                try {
                                                                    if (
                                                                        events_1_1 &&
                                                                        !events_1_1.done &&
                                                                        (_a =
                                                                            events_1.return)
                                                                    )
                                                                        _a.call(
                                                                            events_1
                                                                        );
                                                                } finally {
                                                                    if (e_1)
                                                                        throw e_1.error;
                                                                }
                                                            }
                                                            var neededEvents = discardPriorSnapshots(
                                                                events,
                                                                baselineTime
                                                            );
                                                            var actions = new Array();
                                                            var _loop_1 = function (
                                                                event_3
                                                            ) {
                                                                var lastPlayedTimestamp =
                                                                    lastPlayedEvent ===
                                                                        null ||
                                                                    lastPlayedEvent ===
                                                                        void 0
                                                                        ? void 0
                                                                        : lastPlayedEvent.timestamp;
                                                                if (
                                                                    (lastPlayedEvent ===
                                                                        null ||
                                                                    lastPlayedEvent ===
                                                                        void 0
                                                                        ? void 0
                                                                        : lastPlayedEvent.type) ===
                                                                        types_1
                                                                            .EventType
                                                                            .IncrementalSnapshot &&
                                                                    lastPlayedEvent
                                                                        .data
                                                                        .source ===
                                                                        types_1
                                                                            .IncrementalSource
                                                                            .MouseMove
                                                                ) {
                                                                    lastPlayedTimestamp =
                                                                        lastPlayedEvent.timestamp +
                                                                        ((_c =
                                                                            lastPlayedEvent
                                                                                .data
                                                                                .positions[0]) ===
                                                                            null ||
                                                                        _c ===
                                                                            void 0
                                                                            ? void 0
                                                                            : _c.timeOffset);
                                                                }
                                                                if (
                                                                    lastPlayedTimestamp &&
                                                                    lastPlayedTimestamp <
                                                                        baselineTime &&
                                                                    (event_3.timestamp <=
                                                                        lastPlayedTimestamp ||
                                                                        event_3 ===
                                                                            lastPlayedEvent)
                                                                ) {
                                                                    return 'continue';
                                                                }
                                                                var isSync =
                                                                    event_3.timestamp <
                                                                    baselineTime;
                                                                if (
                                                                    isSync &&
                                                                    !utils_1.needCastInSyncMode(
                                                                        event_3
                                                                    )
                                                                ) {
                                                                    return 'continue';
                                                                }
                                                                var castFn = getCastFn(
                                                                    event_3,
                                                                    isSync
                                                                );
                                                                if (isSync) {
                                                                    castFn();
                                                                } else {
                                                                    actions.push(
                                                                        {
                                                                            doAction: function () {
                                                                                castFn();
                                                                                emitter.emit(
                                                                                    types_1
                                                                                        .ReplayerEvents
                                                                                        .EventCast,
                                                                                    event_3
                                                                                );
                                                                            },
                                                                            delay:
                                                                                event_3.delay,
                                                                        }
                                                                    );
                                                                }
                                                            };
                                                            try {
                                                                for (
                                                                    var neededEvents_1 = __values(
                                                                            neededEvents
                                                                        ),
                                                                        neededEvents_1_1 = neededEvents_1.next();
                                                                    !neededEvents_1_1.done;
                                                                    neededEvents_1_1 = neededEvents_1.next()
                                                                ) {
                                                                    var event_3 =
                                                                        neededEvents_1_1.value;
                                                                    _loop_1(
                                                                        event_3
                                                                    );
                                                                }
                                                            } catch (e_2_1) {
                                                                e_2 = {
                                                                    error: e_2_1,
                                                                };
                                                            } finally {
                                                                try {
                                                                    if (
                                                                        neededEvents_1_1 &&
                                                                        !neededEvents_1_1.done &&
                                                                        (_b =
                                                                            neededEvents_1.return)
                                                                    )
                                                                        _b.call(
                                                                            neededEvents_1
                                                                        );
                                                                } finally {
                                                                    if (e_2)
                                                                        throw e_2.error;
                                                                }
                                                            }
                                                            emitter.emit(
                                                                types_1
                                                                    .ReplayerEvents
                                                                    .Flush
                                                            );
                                                            timer.addActions(
                                                                actions
                                                            );
                                                            timer.start();
                                                        },
                                                        pause: function (ctx) {
                                                            ctx.timer.clear();
                                                        },
                                                        resetLastPlayedEvent: fsm_1.assign(
                                                            function (ctx) {
                                                                return __assign(
                                                                    __assign(
                                                                        {},
                                                                        ctx
                                                                    ),
                                                                    {
                                                                        lastPlayedEvent: null,
                                                                    }
                                                                );
                                                            }
                                                        ),
                                                        startLive: fsm_1.assign(
                                                            {
                                                                baselineTime: function (
                                                                    ctx,
                                                                    event
                                                                ) {
                                                                    ctx.timer.toggleLiveMode(
                                                                        true
                                                                    );
                                                                    ctx.timer.start();
                                                                    if (
                                                                        event.type ===
                                                                            'TO_LIVE' &&
                                                                        event
                                                                            .payload
                                                                            .baselineTime
                                                                    ) {
                                                                        return event
                                                                            .payload
                                                                            .baselineTime;
                                                                    }
                                                                    return Date.now();
                                                                },
                                                            }
                                                        ),
                                                        addEvent: fsm_1.assign(
                                                            function (
                                                                ctx,
                                                                machineEvent
                                                            ) {
                                                                var baselineTime =
                                                                        ctx.baselineTime,
                                                                    timer =
                                                                        ctx.timer,
                                                                    events =
                                                                        ctx.events;
                                                                if (
                                                                    machineEvent.type ===
                                                                    'ADD_EVENT'
                                                                ) {
                                                                    var event_4 =
                                                                        machineEvent
                                                                            .payload
                                                                            .event;
                                                                    timer_1.addDelay(
                                                                        event_4,
                                                                        baselineTime
                                                                    );
                                                                    events.push(
                                                                        event_4
                                                                    );
                                                                    var isSync =
                                                                        event_4.timestamp <
                                                                        baselineTime;
                                                                    var castFn_1 = getCastFn(
                                                                        event_4,
                                                                        isSync
                                                                    );
                                                                    if (
                                                                        isSync
                                                                    ) {
                                                                        castFn_1();
                                                                    } else {
                                                                        timer.addAction(
                                                                            {
                                                                                doAction: function () {
                                                                                    castFn_1();
                                                                                    emitter.emit(
                                                                                        types_1
                                                                                            .ReplayerEvents
                                                                                            .EventCast,
                                                                                        event_4
                                                                                    );
                                                                                },
                                                                                delay:
                                                                                    event_4.delay,
                                                                            }
                                                                        );
                                                                        if (
                                                                            !timer.isActive()
                                                                        ) {
                                                                            timer.start();
                                                                        }
                                                                    }
                                                                }
                                                                return __assign(
                                                                    __assign(
                                                                        {},
                                                                        ctx
                                                                    ),
                                                                    {
                                                                        events: events,
                                                                    }
                                                                );
                                                            }
                                                        ),
                                                    },
                                                }
                                            );
                                            return fsm_1.interpret(
                                                playerMachine
                                            );
                                        }
                                        exports.createPlayerService = createPlayerService;
                                        function createSpeedService(context) {
                                            var speedMachine = fsm_1.createMachine(
                                                {
                                                    id: 'speed',
                                                    context: context,
                                                    initial: 'normal',
                                                    states: {
                                                        normal: {
                                                            on: {
                                                                FAST_FORWARD: {
                                                                    target:
                                                                        'skipping',
                                                                    actions: [
                                                                        'recordSpeed',
                                                                        'setSpeed',
                                                                    ],
                                                                },
                                                                SET_SPEED: {
                                                                    target:
                                                                        'normal',
                                                                    actions: [
                                                                        'setSpeed',
                                                                    ],
                                                                },
                                                            },
                                                        },
                                                        skipping: {
                                                            on: {
                                                                BACK_TO_NORMAL: {
                                                                    target:
                                                                        'normal',
                                                                    actions: [
                                                                        'restoreSpeed',
                                                                    ],
                                                                },
                                                                SET_SPEED: {
                                                                    target:
                                                                        'normal',
                                                                    actions: [
                                                                        'setSpeed',
                                                                    ],
                                                                },
                                                            },
                                                        },
                                                    },
                                                },
                                                {
                                                    actions: {
                                                        setSpeed: function (
                                                            ctx,
                                                            event
                                                        ) {
                                                            if (
                                                                'payload' in
                                                                event
                                                            ) {
                                                                ctx.timer.setSpeed(
                                                                    event
                                                                        .payload
                                                                        .speed
                                                                );
                                                            }
                                                        },
                                                        recordSpeed: fsm_1.assign(
                                                            {
                                                                normalSpeed: function (
                                                                    ctx
                                                                ) {
                                                                    return ctx
                                                                        .timer
                                                                        .speed;
                                                                },
                                                            }
                                                        ),
                                                        restoreSpeed: function (
                                                            ctx
                                                        ) {
                                                            ctx.timer.setSpeed(
                                                                ctx.normalSpeed
                                                            );
                                                        },
                                                    },
                                                }
                                            );
                                            return fsm_1.interpret(
                                                speedMachine
                                            );
                                        }
                                        exports.createSpeedService = createSpeedService;

                                        /***/
                                    },

                                /***/ './src/replay/smoothscroll.ts':
                                    /*!************************************!*\
  !*** ./src/replay/smoothscroll.ts ***!
  \************************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        exports
                                    ) => {
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.polyfill = void 0;
                                        function polyfill(w, d) {
                                            if (w === void 0) {
                                                w = window;
                                            }
                                            if (d === void 0) {
                                                d = document;
                                            }
                                            if (
                                                'scrollBehavior' in
                                                    d.documentElement.style &&
                                                w.__forceSmoothScrollPolyfill__ !==
                                                    true
                                            ) {
                                                return;
                                            }
                                            var Element =
                                                w.HTMLElement || w.Element;
                                            var SCROLL_TIME = 468;
                                            var original = {
                                                scroll: w.scroll || w.scrollTo,
                                                scrollBy: w.scrollBy,
                                                elementScroll:
                                                    Element.prototype.scroll ||
                                                    scrollElement,
                                                scrollIntoView:
                                                    Element.prototype
                                                        .scrollIntoView,
                                            };
                                            var now =
                                                w.performance &&
                                                w.performance.now
                                                    ? w.performance.now.bind(
                                                          w.performance
                                                      )
                                                    : Date.now;
                                            function isMicrosoftBrowser(
                                                userAgent
                                            ) {
                                                var userAgentPatterns = [
                                                    'MSIE ',
                                                    'Trident/',
                                                    'Edge/',
                                                ];
                                                return new RegExp(
                                                    userAgentPatterns.join('|')
                                                ).test(userAgent);
                                            }
                                            var ROUNDING_TOLERANCE = isMicrosoftBrowser(
                                                w.navigator.userAgent
                                            )
                                                ? 1
                                                : 0;
                                            function scrollElement(x, y) {
                                                this.scrollLeft = x;
                                                this.scrollTop = y;
                                            }
                                            function ease(k) {
                                                return (
                                                    0.5 *
                                                    (1 - Math.cos(Math.PI * k))
                                                );
                                            }
                                            function shouldBailOut(firstArg) {
                                                if (
                                                    firstArg === null ||
                                                    typeof firstArg !==
                                                        'object' ||
                                                    firstArg.behavior ===
                                                        undefined ||
                                                    firstArg.behavior ===
                                                        'auto' ||
                                                    firstArg.behavior ===
                                                        'instant'
                                                ) {
                                                    return true;
                                                }
                                                if (
                                                    typeof firstArg ===
                                                        'object' &&
                                                    firstArg.behavior ===
                                                        'smooth'
                                                ) {
                                                    return false;
                                                }
                                                throw new TypeError(
                                                    'behavior member of ScrollOptions ' +
                                                        firstArg.behavior +
                                                        ' is not a valid value for enumeration ScrollBehavior.'
                                                );
                                            }
                                            function hasScrollableSpace(
                                                el,
                                                axis
                                            ) {
                                                if (axis === 'Y') {
                                                    return (
                                                        el.clientHeight +
                                                            ROUNDING_TOLERANCE <
                                                        el.scrollHeight
                                                    );
                                                }
                                                if (axis === 'X') {
                                                    return (
                                                        el.clientWidth +
                                                            ROUNDING_TOLERANCE <
                                                        el.scrollWidth
                                                    );
                                                }
                                            }
                                            function canOverflow(el, axis) {
                                                var overflowValue = w.getComputedStyle(
                                                    el,
                                                    null
                                                )['overflow' + axis];
                                                return (
                                                    overflowValue === 'auto' ||
                                                    overflowValue === 'scroll'
                                                );
                                            }
                                            function isScrollable(el) {
                                                var isScrollableY =
                                                    hasScrollableSpace(
                                                        el,
                                                        'Y'
                                                    ) && canOverflow(el, 'Y');
                                                var isScrollableX =
                                                    hasScrollableSpace(
                                                        el,
                                                        'X'
                                                    ) && canOverflow(el, 'X');
                                                return (
                                                    isScrollableY ||
                                                    isScrollableX
                                                );
                                            }
                                            function findScrollableParent(el) {
                                                while (
                                                    el !== d.body &&
                                                    isScrollable(el) === false
                                                ) {
                                                    el =
                                                        el.parentNode ||
                                                        el.host;
                                                }
                                                return el;
                                            }
                                            function step(context) {
                                                var time = now();
                                                var value;
                                                var currentX;
                                                var currentY;
                                                var elapsed =
                                                    (time - context.startTime) /
                                                    SCROLL_TIME;
                                                elapsed =
                                                    elapsed > 1 ? 1 : elapsed;
                                                value = ease(elapsed);
                                                currentX =
                                                    context.startX +
                                                    (context.x -
                                                        context.startX) *
                                                        value;
                                                currentY =
                                                    context.startY +
                                                    (context.y -
                                                        context.startY) *
                                                        value;
                                                context.method.call(
                                                    context.scrollable,
                                                    currentX,
                                                    currentY
                                                );
                                                if (
                                                    currentX !== context.x ||
                                                    currentY !== context.y
                                                ) {
                                                    w.requestAnimationFrame(
                                                        step.bind(w, context)
                                                    );
                                                }
                                            }
                                            function smoothScroll(el, x, y) {
                                                var scrollable;
                                                var startX;
                                                var startY;
                                                var method;
                                                var startTime = now();
                                                if (el === d.body) {
                                                    scrollable = w;
                                                    startX =
                                                        w.scrollX ||
                                                        w.pageXOffset;
                                                    startY =
                                                        w.scrollY ||
                                                        w.pageYOffset;
                                                    method = original.scroll;
                                                } else {
                                                    scrollable = el;
                                                    startX = el.scrollLeft;
                                                    startY = el.scrollTop;
                                                    method = scrollElement;
                                                }
                                                step({
                                                    scrollable: scrollable,
                                                    method: method,
                                                    startTime: startTime,
                                                    startX: startX,
                                                    startY: startY,
                                                    x: x,
                                                    y: y,
                                                });
                                            }
                                            w.scroll = w.scrollTo = function () {
                                                if (
                                                    arguments[0] === undefined
                                                ) {
                                                    return;
                                                }
                                                if (
                                                    shouldBailOut(
                                                        arguments[0]
                                                    ) === true
                                                ) {
                                                    original.scroll.call(
                                                        w,
                                                        arguments[0].left !==
                                                            undefined
                                                            ? arguments[0].left
                                                            : typeof arguments[0] !==
                                                              'object'
                                                            ? arguments[0]
                                                            : w.scrollX ||
                                                              w.pageXOffset,
                                                        arguments[0].top !==
                                                            undefined
                                                            ? arguments[0].top
                                                            : arguments[1] !==
                                                              undefined
                                                            ? arguments[1]
                                                            : w.scrollY ||
                                                              w.pageYOffset
                                                    );
                                                    return;
                                                }
                                                smoothScroll.call(
                                                    w,
                                                    d.body,
                                                    arguments[0].left !==
                                                        undefined
                                                        ? ~~arguments[0].left
                                                        : w.scrollX ||
                                                              w.pageXOffset,
                                                    arguments[0].top !==
                                                        undefined
                                                        ? ~~arguments[0].top
                                                        : w.scrollY ||
                                                              w.pageYOffset
                                                );
                                            };
                                            w.scrollBy = function () {
                                                if (
                                                    arguments[0] === undefined
                                                ) {
                                                    return;
                                                }
                                                if (
                                                    shouldBailOut(arguments[0])
                                                ) {
                                                    original.scrollBy.call(
                                                        w,
                                                        arguments[0].left !==
                                                            undefined
                                                            ? arguments[0].left
                                                            : typeof arguments[0] !==
                                                              'object'
                                                            ? arguments[0]
                                                            : 0,
                                                        arguments[0].top !==
                                                            undefined
                                                            ? arguments[0].top
                                                            : arguments[1] !==
                                                              undefined
                                                            ? arguments[1]
                                                            : 0
                                                    );
                                                    return;
                                                }
                                                smoothScroll.call(
                                                    w,
                                                    d.body,
                                                    ~~arguments[0].left +
                                                        (w.scrollX ||
                                                            w.pageXOffset),
                                                    ~~arguments[0].top +
                                                        (w.scrollY ||
                                                            w.pageYOffset)
                                                );
                                            };
                                            Element.prototype.scroll = Element.prototype.scrollTo = function () {
                                                if (
                                                    arguments[0] === undefined
                                                ) {
                                                    return;
                                                }
                                                if (
                                                    shouldBailOut(
                                                        arguments[0]
                                                    ) === true
                                                ) {
                                                    if (
                                                        typeof arguments[0] ===
                                                            'number' &&
                                                        arguments[1] ===
                                                            undefined
                                                    ) {
                                                        throw new SyntaxError(
                                                            'Value could not be converted'
                                                        );
                                                    }
                                                    original.elementScroll.call(
                                                        this,
                                                        arguments[0].left !==
                                                            undefined
                                                            ? ~~arguments[0]
                                                                  .left
                                                            : typeof arguments[0] !==
                                                              'object'
                                                            ? ~~arguments[0]
                                                            : this.scrollLeft,
                                                        arguments[0].top !==
                                                            undefined
                                                            ? ~~arguments[0].top
                                                            : arguments[1] !==
                                                              undefined
                                                            ? ~~arguments[1]
                                                            : this.scrollTop
                                                    );
                                                    return;
                                                }
                                                var left = arguments[0].left;
                                                var top = arguments[0].top;
                                                smoothScroll.call(
                                                    this,
                                                    this,
                                                    typeof left === 'undefined'
                                                        ? this.scrollLeft
                                                        : ~~left,
                                                    typeof top === 'undefined'
                                                        ? this.scrollTop
                                                        : ~~top
                                                );
                                            };
                                            Element.prototype.scrollBy = function () {
                                                if (
                                                    arguments[0] === undefined
                                                ) {
                                                    return;
                                                }
                                                if (
                                                    shouldBailOut(
                                                        arguments[0]
                                                    ) === true
                                                ) {
                                                    original.elementScroll.call(
                                                        this,
                                                        arguments[0].left !==
                                                            undefined
                                                            ? ~~arguments[0]
                                                                  .left +
                                                                  this
                                                                      .scrollLeft
                                                            : ~~arguments[0] +
                                                                  this
                                                                      .scrollLeft,
                                                        arguments[0].top !==
                                                            undefined
                                                            ? ~~arguments[0]
                                                                  .top +
                                                                  this.scrollTop
                                                            : ~~arguments[1] +
                                                                  this.scrollTop
                                                    );
                                                    return;
                                                }
                                                this.scroll({
                                                    left:
                                                        ~~arguments[0].left +
                                                        this.scrollLeft,
                                                    top:
                                                        ~~arguments[0].top +
                                                        this.scrollTop,
                                                    behavior:
                                                        arguments[0].behavior,
                                                });
                                            };
                                            Element.prototype.scrollIntoView = function () {
                                                if (
                                                    shouldBailOut(
                                                        arguments[0]
                                                    ) === true
                                                ) {
                                                    original.scrollIntoView.call(
                                                        this,
                                                        arguments[0] ===
                                                            undefined
                                                            ? true
                                                            : arguments[0]
                                                    );
                                                    return;
                                                }
                                                var scrollableParent = findScrollableParent(
                                                    this
                                                );
                                                var parentRects = scrollableParent.getBoundingClientRect();
                                                var clientRects = this.getBoundingClientRect();
                                                if (
                                                    scrollableParent !== d.body
                                                ) {
                                                    smoothScroll.call(
                                                        this,
                                                        scrollableParent,
                                                        scrollableParent.scrollLeft +
                                                            clientRects.left -
                                                            parentRects.left,
                                                        scrollableParent.scrollTop +
                                                            clientRects.top -
                                                            parentRects.top
                                                    );
                                                    if (
                                                        w.getComputedStyle(
                                                            scrollableParent
                                                        ).position !== 'fixed'
                                                    ) {
                                                        w.scrollBy({
                                                            left:
                                                                parentRects.left,
                                                            top:
                                                                parentRects.top,
                                                            behavior: 'smooth',
                                                        });
                                                    }
                                                } else {
                                                    w.scrollBy({
                                                        left: clientRects.left,
                                                        top: clientRects.top,
                                                        behavior: 'smooth',
                                                    });
                                                }
                                            };
                                        }
                                        exports.polyfill = polyfill;

                                        /***/
                                    },

                                /***/ './src/replay/styles/inject-style.ts':
                                    /*!*******************************************!*\
  !*** ./src/replay/styles/inject-style.ts ***!
  \*******************************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        exports
                                    ) => {
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        var rules = function (blockClass) {
                                            return [
                                                'iframe, .' +
                                                    blockClass +
                                                    ' { background: #ccc }',
                                                'noscript { display: none !important; }',
                                            ];
                                        };
                                        exports.default = rules;

                                        /***/
                                    },

                                /***/ './src/replay/timer.ts':
                                    /*!*****************************!*\
  !*** ./src/replay/timer.ts ***!
  \*****************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_143973__
                                    ) {
                                        var __read =
                                            (this && this.__read) ||
                                            function (o, n) {
                                                var m =
                                                    typeof Symbol ===
                                                        'function' &&
                                                    o[Symbol.iterator];
                                                if (!m) return o;
                                                var i = m.call(o),
                                                    r,
                                                    ar = [],
                                                    e;
                                                try {
                                                    while (
                                                        (n === void 0 ||
                                                            n-- > 0) &&
                                                        !(r = i.next()).done
                                                    )
                                                        ar.push(r.value);
                                                } catch (error) {
                                                    e = { error: error };
                                                } finally {
                                                    try {
                                                        if (
                                                            r &&
                                                            !r.done &&
                                                            (m = i['return'])
                                                        )
                                                            m.call(i);
                                                    } finally {
                                                        if (e) throw e.error;
                                                    }
                                                }
                                                return ar;
                                            };
                                        var __spread =
                                            (this && this.__spread) ||
                                            function () {
                                                for (
                                                    var ar = [], i = 0;
                                                    i < arguments.length;
                                                    i++
                                                )
                                                    ar = ar.concat(
                                                        __read(arguments[i])
                                                    );
                                                return ar;
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.addDelay = exports.Timer = void 0;
                                        var types_1 = __nested_webpack_require_143973__(
                                            /*! ../types */ './src/types.ts'
                                        );
                                        var Timer = (function () {
                                            function Timer(actions, speed) {
                                                if (actions === void 0) {
                                                    actions = [];
                                                }
                                                this.timeOffset = 0;
                                                this.raf = null;
                                                this.actions = actions;
                                                this.speed = speed;
                                            }
                                            Timer.prototype.addAction = function (
                                                action
                                            ) {
                                                var index = this.findActionIndex(
                                                    action
                                                );
                                                this.actions.splice(
                                                    index,
                                                    0,
                                                    action
                                                );
                                            };
                                            Timer.prototype.addActions = function (
                                                actions
                                            ) {
                                                var _a;
                                                (_a = this.actions).push.apply(
                                                    _a,
                                                    __spread(actions)
                                                );
                                            };
                                            Timer.prototype.start = function () {
                                                this.actions.sort(function (
                                                    a1,
                                                    a2
                                                ) {
                                                    return a1.delay - a2.delay;
                                                });
                                                this.timeOffset = 0;
                                                var lastTimestamp = performance.now();
                                                var actions = this.actions;
                                                var self = this;
                                                function check() {
                                                    var time = performance.now();
                                                    self.timeOffset +=
                                                        (time - lastTimestamp) *
                                                        self.speed;
                                                    lastTimestamp = time;
                                                    while (actions.length) {
                                                        var action = actions[0];
                                                        if (
                                                            self.timeOffset >=
                                                            action.delay
                                                        ) {
                                                            actions.shift();
                                                            action.doAction();
                                                        } else {
                                                            break;
                                                        }
                                                    }
                                                    if (
                                                        actions.length > 0 ||
                                                        self.liveMode
                                                    ) {
                                                        self.raf = requestAnimationFrame(
                                                            check
                                                        );
                                                    }
                                                }
                                                this.raf = requestAnimationFrame(
                                                    check
                                                );
                                            };
                                            Timer.prototype.clear = function () {
                                                if (this.raf) {
                                                    cancelAnimationFrame(
                                                        this.raf
                                                    );
                                                    this.raf = null;
                                                }
                                                this.actions.length = 0;
                                            };
                                            Timer.prototype.setSpeed = function (
                                                speed
                                            ) {
                                                this.speed = speed;
                                            };
                                            Timer.prototype.toggleLiveMode = function (
                                                mode
                                            ) {
                                                this.liveMode = mode;
                                            };
                                            Timer.prototype.isActive = function () {
                                                return this.raf !== null;
                                            };
                                            Timer.prototype.findActionIndex = function (
                                                action
                                            ) {
                                                var start = 0;
                                                var end =
                                                    this.actions.length - 1;
                                                while (start <= end) {
                                                    var mid = Math.floor(
                                                        (start + end) / 2
                                                    );
                                                    if (
                                                        this.actions[mid]
                                                            .delay <
                                                        action.delay
                                                    ) {
                                                        start = mid + 1;
                                                    } else if (
                                                        this.actions[mid]
                                                            .delay >
                                                        action.delay
                                                    ) {
                                                        end = mid - 1;
                                                    } else {
                                                        return mid;
                                                    }
                                                }
                                                return start;
                                            };
                                            return Timer;
                                        })();
                                        exports.Timer = Timer;
                                        function addDelay(event, baselineTime) {
                                            if (
                                                event.type ===
                                                    types_1.EventType
                                                        .IncrementalSnapshot &&
                                                event.data.source ===
                                                    types_1.IncrementalSource
                                                        .MouseMove
                                            ) {
                                                var firstOffset =
                                                    event.data.positions[0]
                                                        .timeOffset;
                                                var firstTimestamp =
                                                    event.timestamp +
                                                    firstOffset;
                                                event.delay =
                                                    firstTimestamp -
                                                    baselineTime;
                                                return (
                                                    firstTimestamp -
                                                    baselineTime
                                                );
                                            }
                                            event.delay =
                                                event.timestamp - baselineTime;
                                            return event.delay;
                                        }
                                        exports.addDelay = addDelay;

                                        /***/
                                    },

                                /***/ './src/snapshot/css.ts':
                                    /*!*****************************!*\
  !*** ./src/snapshot/css.ts ***!
  \*****************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports
                                    ) {
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.parse = void 0;
                                        var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
                                        function parse(css, options) {
                                            if (options === void 0) {
                                                options = {};
                                            }
                                            var lineno = 1;
                                            var column = 1;
                                            function updatePosition(str) {
                                                var lines = str.match(/\n/g);
                                                if (lines) {
                                                    lineno += lines.length;
                                                }
                                                var i = str.lastIndexOf('\n');
                                                column =
                                                    i === -1
                                                        ? column + str.length
                                                        : str.length - i;
                                            }
                                            function position() {
                                                var start = {
                                                    line: lineno,
                                                    column: column,
                                                };
                                                return function (node) {
                                                    node.position = new Position(
                                                        start
                                                    );
                                                    whitespace();
                                                    return node;
                                                };
                                            }
                                            var Position = (function () {
                                                function Position(start) {
                                                    this.start = start;
                                                    this.end = {
                                                        line: lineno,
                                                        column: column,
                                                    };
                                                    this.source =
                                                        options.source;
                                                }
                                                return Position;
                                            })();
                                            Position.prototype.content = css;
                                            var errorsList = [];
                                            function error(msg) {
                                                var err = new Error(
                                                    options.source +
                                                        ':' +
                                                        lineno +
                                                        ':' +
                                                        column +
                                                        ': ' +
                                                        msg
                                                );
                                                err.reason = msg;
                                                err.filename = options.source;
                                                err.line = lineno;
                                                err.column = column;
                                                err.source = css;
                                                if (options.silent) {
                                                    errorsList.push(err);
                                                } else {
                                                    throw err;
                                                }
                                            }
                                            function stylesheet() {
                                                var rulesList = rules();
                                                return {
                                                    type: 'stylesheet',
                                                    stylesheet: {
                                                        source: options.source,
                                                        rules: rulesList,
                                                        parsingErrors: errorsList,
                                                    },
                                                };
                                            }
                                            function open() {
                                                return match(/^{\s*/);
                                            }
                                            function close() {
                                                return match(/^}/);
                                            }
                                            function rules() {
                                                var node;
                                                var rules = [];
                                                whitespace();
                                                comments(rules);
                                                while (
                                                    css.length &&
                                                    css.charAt(0) !== '}' &&
                                                    (node = atrule() || rule())
                                                ) {
                                                    if (node !== false) {
                                                        rules.push(node);
                                                        comments(rules);
                                                    }
                                                }
                                                return rules;
                                            }
                                            function match(re) {
                                                var m = re.exec(css);
                                                if (!m) {
                                                    return;
                                                }
                                                var str = m[0];
                                                updatePosition(str);
                                                css = css.slice(str.length);
                                                return m;
                                            }
                                            function whitespace() {
                                                match(/^\s*/);
                                            }
                                            function comments(rules) {
                                                if (rules === void 0) {
                                                    rules = [];
                                                }
                                                var c;
                                                while ((c = comment())) {
                                                    if (c !== false) {
                                                        rules.push(c);
                                                    }
                                                    c = comment();
                                                }
                                                return rules;
                                            }
                                            function comment() {
                                                var pos = position();
                                                if (
                                                    '/' !== css.charAt(0) ||
                                                    '*' !== css.charAt(1)
                                                ) {
                                                    return;
                                                }
                                                var i = 2;
                                                while (
                                                    '' !== css.charAt(i) &&
                                                    ('*' !== css.charAt(i) ||
                                                        '/' !==
                                                            css.charAt(i + 1))
                                                ) {
                                                    ++i;
                                                }
                                                i += 2;
                                                if ('' === css.charAt(i - 1)) {
                                                    return error(
                                                        'End of comment missing'
                                                    );
                                                }
                                                var str = css.slice(2, i - 2);
                                                column += 2;
                                                updatePosition(str);
                                                css = css.slice(i);
                                                column += 2;
                                                return pos({
                                                    type: 'comment',
                                                    comment: str,
                                                });
                                            }
                                            function selector() {
                                                var m = match(/^([^{]+)/);
                                                if (!m) {
                                                    return;
                                                }
                                                return trim(m[0])
                                                    .replace(
                                                        /\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g,
                                                        ''
                                                    )
                                                    .replace(
                                                        /"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g,
                                                        function (m) {
                                                            return m.replace(
                                                                /,/g,
                                                                '\u200C'
                                                            );
                                                        }
                                                    )
                                                    .split(/\s*(?![^(]*\)),\s*/)
                                                    .map(function (s) {
                                                        return s.replace(
                                                            /\u200C/g,
                                                            ','
                                                        );
                                                    });
                                            }
                                            function declaration() {
                                                var pos = position();
                                                var propMatch = match(
                                                    /^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
                                                );
                                                if (!propMatch) {
                                                    return;
                                                }
                                                var prop = trim(propMatch[0]);
                                                if (!match(/^:\s*/)) {
                                                    return error(
                                                        "property missing ':'"
                                                    );
                                                }
                                                var val = match(
                                                    /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/
                                                );
                                                var ret = pos({
                                                    type: 'declaration',
                                                    property: prop.replace(
                                                        commentre,
                                                        ''
                                                    ),
                                                    value: val
                                                        ? trim(val[0]).replace(
                                                              commentre,
                                                              ''
                                                          )
                                                        : '',
                                                });
                                                match(/^[;\s]*/);
                                                return ret;
                                            }
                                            function declarations() {
                                                var decls = [];
                                                if (!open()) {
                                                    return error("missing '{'");
                                                }
                                                comments(decls);
                                                var decl;
                                                while ((decl = declaration())) {
                                                    if (decl !== false) {
                                                        decls.push(decl);
                                                        comments(decls);
                                                    }
                                                    decl = declaration();
                                                }
                                                if (!close()) {
                                                    return error("missing '}'");
                                                }
                                                return decls;
                                            }
                                            function keyframe() {
                                                var m;
                                                var vals = [];
                                                var pos = position();
                                                while (
                                                    (m = match(
                                                        /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/
                                                    ))
                                                ) {
                                                    vals.push(m[1]);
                                                    match(/^,\s*/);
                                                }
                                                if (!vals.length) {
                                                    return;
                                                }
                                                return pos({
                                                    type: 'keyframe',
                                                    values: vals,
                                                    declarations: declarations(),
                                                });
                                            }
                                            function atkeyframes() {
                                                var pos = position();
                                                var m = match(
                                                    /^@([-\w]+)?keyframes\s*/
                                                );
                                                if (!m) {
                                                    return;
                                                }
                                                var vendor = m[1];
                                                m = match(/^([-\w]+)\s*/);
                                                if (!m) {
                                                    return error(
                                                        '@keyframes missing name'
                                                    );
                                                }
                                                var name = m[1];
                                                if (!open()) {
                                                    return error(
                                                        "@keyframes missing '{'"
                                                    );
                                                }
                                                var frame;
                                                var frames = comments();
                                                while ((frame = keyframe())) {
                                                    frames.push(frame);
                                                    frames = frames.concat(
                                                        comments()
                                                    );
                                                }
                                                if (!close()) {
                                                    return error(
                                                        "@keyframes missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'keyframes',
                                                    name: name,
                                                    vendor: vendor,
                                                    keyframes: frames,
                                                });
                                            }
                                            function atsupports() {
                                                var pos = position();
                                                var m = match(
                                                    /^@supports *([^{]+)/
                                                );
                                                if (!m) {
                                                    return;
                                                }
                                                var supports = trim(m[1]);
                                                if (!open()) {
                                                    return error(
                                                        "@supports missing '{'"
                                                    );
                                                }
                                                var style = comments().concat(
                                                    rules()
                                                );
                                                if (!close()) {
                                                    return error(
                                                        "@supports missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'supports',
                                                    supports: supports,
                                                    rules: style,
                                                });
                                            }
                                            function athost() {
                                                var pos = position();
                                                var m = match(/^@host\s*/);
                                                if (!m) {
                                                    return;
                                                }
                                                if (!open()) {
                                                    return error(
                                                        "@host missing '{'"
                                                    );
                                                }
                                                var style = comments().concat(
                                                    rules()
                                                );
                                                if (!close()) {
                                                    return error(
                                                        "@host missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'host',
                                                    rules: style,
                                                });
                                            }
                                            function atmedia() {
                                                var pos = position();
                                                var m = match(
                                                    /^@media *([^{]+)/
                                                );
                                                if (!m) {
                                                    return;
                                                }
                                                var media = trim(m[1]);
                                                if (!open()) {
                                                    return error(
                                                        "@media missing '{'"
                                                    );
                                                }
                                                var style = comments().concat(
                                                    rules()
                                                );
                                                if (!close()) {
                                                    return error(
                                                        "@media missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'media',
                                                    media: media,
                                                    rules: style,
                                                });
                                            }
                                            function atcustommedia() {
                                                var pos = position();
                                                var m = match(
                                                    /^@custom-media\s+(--[^\s]+)\s*([^{;]+);/
                                                );
                                                if (!m) {
                                                    return;
                                                }
                                                return pos({
                                                    type: 'custom-media',
                                                    name: trim(m[1]),
                                                    media: trim(m[2]),
                                                });
                                            }
                                            function atpage() {
                                                var pos = position();
                                                var m = match(/^@page */);
                                                if (!m) {
                                                    return;
                                                }
                                                var sel = selector() || [];
                                                if (!open()) {
                                                    return error(
                                                        "@page missing '{'"
                                                    );
                                                }
                                                var decls = comments();
                                                var decl;
                                                while ((decl = declaration())) {
                                                    decls.push(decl);
                                                    decls = decls.concat(
                                                        comments()
                                                    );
                                                }
                                                if (!close()) {
                                                    return error(
                                                        "@page missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'page',
                                                    selectors: sel,
                                                    declarations: decls,
                                                });
                                            }
                                            function atdocument() {
                                                var pos = position();
                                                var m = match(
                                                    /^@([-\w]+)?document *([^{]+)/
                                                );
                                                if (!m) {
                                                    return;
                                                }
                                                var vendor = trim(m[1]);
                                                var doc = trim(m[2]);
                                                if (!open()) {
                                                    return error(
                                                        "@document missing '{'"
                                                    );
                                                }
                                                var style = comments().concat(
                                                    rules()
                                                );
                                                if (!close()) {
                                                    return error(
                                                        "@document missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'document',
                                                    document: doc,
                                                    vendor: vendor,
                                                    rules: style,
                                                });
                                            }
                                            function atfontface() {
                                                var pos = position();
                                                var m = match(/^@font-face\s*/);
                                                if (!m) {
                                                    return;
                                                }
                                                if (!open()) {
                                                    return error(
                                                        "@font-face missing '{'"
                                                    );
                                                }
                                                var decls = comments();
                                                var decl;
                                                while ((decl = declaration())) {
                                                    decls.push(decl);
                                                    decls = decls.concat(
                                                        comments()
                                                    );
                                                }
                                                if (!close()) {
                                                    return error(
                                                        "@font-face missing '}'"
                                                    );
                                                }
                                                return pos({
                                                    type: 'font-face',
                                                    declarations: decls,
                                                });
                                            }
                                            var atimport = _compileAtrule(
                                                'import'
                                            );
                                            var atcharset = _compileAtrule(
                                                'charset'
                                            );
                                            var atnamespace = _compileAtrule(
                                                'namespace'
                                            );
                                            function _compileAtrule(name) {
                                                var re = new RegExp(
                                                    '^@' + name + '\\s*([^;]+);'
                                                );
                                                return function () {
                                                    var pos = position();
                                                    var m = match(re);
                                                    if (!m) {
                                                        return;
                                                    }
                                                    var ret = { type: name };
                                                    ret[name] = m[1].trim();
                                                    return pos(ret);
                                                };
                                            }
                                            function atrule() {
                                                if (css[0] !== '@') {
                                                    return;
                                                }
                                                return (
                                                    atkeyframes() ||
                                                    atmedia() ||
                                                    atcustommedia() ||
                                                    atsupports() ||
                                                    atimport() ||
                                                    atcharset() ||
                                                    atnamespace() ||
                                                    atdocument() ||
                                                    atpage() ||
                                                    athost() ||
                                                    atfontface()
                                                );
                                            }
                                            function rule() {
                                                var pos = position();
                                                var sel = selector();
                                                if (!sel) {
                                                    return error(
                                                        'selector missing'
                                                    );
                                                }
                                                comments();
                                                return pos({
                                                    type: 'rule',
                                                    selectors: sel,
                                                    declarations: declarations(),
                                                });
                                            }
                                            return addParent(stylesheet());
                                        }
                                        exports.parse = parse;
                                        function trim(str) {
                                            return str
                                                ? str.replace(/^\s+|\s+$/g, '')
                                                : '';
                                        }
                                        function addParent(obj, parent) {
                                            var e_1, _a;
                                            var isNode =
                                                obj &&
                                                typeof obj.type === 'string';
                                            var childParent = isNode
                                                ? obj
                                                : parent;
                                            try {
                                                for (
                                                    var _b = __values(
                                                            Object.keys(obj)
                                                        ),
                                                        _c = _b.next();
                                                    !_c.done;
                                                    _c = _b.next()
                                                ) {
                                                    var k = _c.value;
                                                    var value = obj[k];
                                                    if (Array.isArray(value)) {
                                                        value.forEach(function (
                                                            v
                                                        ) {
                                                            addParent(
                                                                v,
                                                                childParent
                                                            );
                                                        });
                                                    } else if (
                                                        value &&
                                                        typeof value ===
                                                            'object'
                                                    ) {
                                                        addParent(
                                                            value,
                                                            childParent
                                                        );
                                                    }
                                                }
                                            } catch (e_1_1) {
                                                e_1 = { error: e_1_1 };
                                            } finally {
                                                try {
                                                    if (
                                                        _c &&
                                                        !_c.done &&
                                                        (_a = _b.return)
                                                    )
                                                        _a.call(_b);
                                                } finally {
                                                    if (e_1) throw e_1.error;
                                                }
                                            }
                                            if (isNode) {
                                                Object.defineProperty(
                                                    obj,
                                                    'parent',
                                                    {
                                                        configurable: true,
                                                        writable: true,
                                                        enumerable: false,
                                                        value: parent || null,
                                                    }
                                                );
                                            }
                                            return obj;
                                        }

                                        /***/
                                    },

                                /***/ './src/snapshot/index.ts':
                                    /*!*******************************!*\
  !*** ./src/snapshot/index.ts ***!
  \*******************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_160920__
                                    ) {
                                        var __createBinding =
                                            (this && this.__createBinding) ||
                                            (Object.create
                                                ? function (o, m, k, k2) {
                                                      if (k2 === undefined)
                                                          k2 = k;
                                                      Object.defineProperty(
                                                          o,
                                                          k2,
                                                          {
                                                              enumerable: true,
                                                              get: function () {
                                                                  return m[k];
                                                              },
                                                          }
                                                      );
                                                  }
                                                : function (o, m, k, k2) {
                                                      if (k2 === undefined)
                                                          k2 = k;
                                                      o[k2] = m[k];
                                                  });
                                        var __exportStar =
                                            (this && this.__exportStar) ||
                                            function (m, exports) {
                                                for (var p in m)
                                                    if (
                                                        p !== 'default' &&
                                                        !exports.hasOwnProperty(
                                                            p
                                                        )
                                                    )
                                                        __createBinding(
                                                            exports,
                                                            m,
                                                            p
                                                        );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.IGNORED_NODE = exports.cleanupSnapshot = exports.visitSnapshot = exports.transformAttribute = exports.addHoverClass = exports.buildNodeWithSN = exports.rebuild = exports.serializeNodeWithId = exports.snapshot = void 0;
                                        var snapshot_1 = __nested_webpack_require_160920__(
                                            /*! ./snapshot */ './src/snapshot/snapshot.ts'
                                        );
                                        exports.snapshot = snapshot_1.default;
                                        Object.defineProperty(
                                            exports,
                                            'serializeNodeWithId',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return snapshot_1.serializeNodeWithId;
                                                },
                                            }
                                        );
                                        Object.defineProperty(
                                            exports,
                                            'transformAttribute',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return snapshot_1.transformAttribute;
                                                },
                                            }
                                        );
                                        Object.defineProperty(
                                            exports,
                                            'visitSnapshot',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return snapshot_1.visitSnapshot;
                                                },
                                            }
                                        );
                                        Object.defineProperty(
                                            exports,
                                            'cleanupSnapshot',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return snapshot_1.cleanupSnapshot;
                                                },
                                            }
                                        );
                                        Object.defineProperty(
                                            exports,
                                            'IGNORED_NODE',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return snapshot_1.IGNORED_NODE;
                                                },
                                            }
                                        );
                                        var rebuild_1 = __nested_webpack_require_160920__(
                                            /*! ./rebuild */ './src/snapshot/rebuild.ts'
                                        );
                                        exports.rebuild = rebuild_1.default;
                                        Object.defineProperty(
                                            exports,
                                            'buildNodeWithSN',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return rebuild_1.buildNodeWithSN;
                                                },
                                            }
                                        );
                                        Object.defineProperty(
                                            exports,
                                            'addHoverClass',
                                            {
                                                enumerable: true,
                                                get: function () {
                                                    return rebuild_1.addHoverClass;
                                                },
                                            }
                                        );
                                        __exportStar(
                                            __nested_webpack_require_160920__(
                                                /*! ./types */ './src/snapshot/types.ts'
                                            ),
                                            exports
                                        );

                                        /***/
                                    },

                                /***/ './src/snapshot/rebuild.ts':
                                    /*!*********************************!*\
  !*** ./src/snapshot/rebuild.ts ***!
  \*********************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_163193__
                                    ) {
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.buildNodeWithSN = exports.addHoverClass = void 0;
                                        var css_1 = __nested_webpack_require_163193__(
                                            /*! ./css */ './src/snapshot/css.ts'
                                        );
                                        var types_1 = __nested_webpack_require_163193__(
                                            /*! ./types */ './src/snapshot/types.ts'
                                        );
                                        var tagMap = {
                                            script: 'noscript',
                                            altglyph: 'altGlyph',
                                            altglyphdef: 'altGlyphDef',
                                            altglyphitem: 'altGlyphItem',
                                            animatecolor: 'animateColor',
                                            animatemotion: 'animateMotion',
                                            animatetransform:
                                                'animateTransform',
                                            clippath: 'clipPath',
                                            feblend: 'feBlend',
                                            fecolormatrix: 'feColorMatrix',
                                            fecomponenttransfer:
                                                'feComponentTransfer',
                                            fecomposite: 'feComposite',
                                            feconvolvematrix:
                                                'feConvolveMatrix',
                                            fediffuselighting:
                                                'feDiffuseLighting',
                                            fedisplacementmap:
                                                'feDisplacementMap',
                                            fedistantlight: 'feDistantLight',
                                            fedropshadow: 'feDropShadow',
                                            feflood: 'feFlood',
                                            fefunca: 'feFuncA',
                                            fefuncb: 'feFuncB',
                                            fefuncg: 'feFuncG',
                                            fefuncr: 'feFuncR',
                                            fegaussianblur: 'feGaussianBlur',
                                            feimage: 'feImage',
                                            femerge: 'feMerge',
                                            femergenode: 'feMergeNode',
                                            femorphology: 'feMorphology',
                                            feoffset: 'feOffset',
                                            fepointlight: 'fePointLight',
                                            fespecularlighting:
                                                'feSpecularLighting',
                                            fespotlight: 'feSpotLight',
                                            fetile: 'feTile',
                                            feturbulence: 'feTurbulence',
                                            foreignobject: 'foreignObject',
                                            glyphref: 'glyphRef',
                                            lineargradient: 'linearGradient',
                                            radialgradient: 'radialGradient',
                                        };
                                        function getTagName(n) {
                                            var tagName = tagMap[n.tagName]
                                                ? tagMap[n.tagName]
                                                : n.tagName;
                                            if (
                                                tagName === 'link' &&
                                                n.attributes._cssText
                                            ) {
                                                tagName = 'style';
                                            }
                                            return tagName;
                                        }
                                        var HOVER_SELECTOR = /([^\\]):hover/g;
                                        function addHoverClass(cssText) {
                                            var ast = css_1.parse(cssText, {
                                                silent: true,
                                            });
                                            if (!ast.stylesheet) {
                                                return cssText;
                                            }
                                            ast.stylesheet.rules.forEach(
                                                function (rule) {
                                                    if ('selectors' in rule) {
                                                        (
                                                            rule.selectors || []
                                                        ).forEach(function (
                                                            selector
                                                        ) {
                                                            if (
                                                                HOVER_SELECTOR.test(
                                                                    selector
                                                                )
                                                            ) {
                                                                var newSelector = selector.replace(
                                                                    HOVER_SELECTOR,
                                                                    '$1.\\:hover'
                                                                );
                                                                cssText = cssText.replace(
                                                                    selector,
                                                                    selector +
                                                                        ', ' +
                                                                        newSelector
                                                                );
                                                            }
                                                        });
                                                    }
                                                }
                                            );
                                            return cssText;
                                        }
                                        exports.addHoverClass = addHoverClass;
                                        function buildNode(n, options) {
                                            var doc = options.doc,
                                                hackCss = options.hackCss;
                                            switch (n.type) {
                                                case types_1.NodeType.Document:
                                                    return doc.implementation.createDocument(
                                                        null,
                                                        '',
                                                        null
                                                    );
                                                case types_1.NodeType
                                                    .DocumentType:
                                                    return doc.implementation.createDocumentType(
                                                        n.name || 'html',
                                                        n.publicId,
                                                        n.systemId
                                                    );
                                                case types_1.NodeType.Element:
                                                    var tagName = getTagName(n);
                                                    var node_1;
                                                    if (n.isSVG) {
                                                        node_1 = doc.createElementNS(
                                                            'http://www.w3.org/2000/svg',
                                                            tagName
                                                        );
                                                    } else {
                                                        node_1 = doc.createElement(
                                                            tagName
                                                        );
                                                    }
                                                    var _loop_1 = function (
                                                        name_1
                                                    ) {
                                                        var e_1, _a;
                                                        if (
                                                            !n.attributes.hasOwnProperty(
                                                                name_1
                                                            )
                                                        ) {
                                                            return 'continue';
                                                        }
                                                        var value =
                                                            n.attributes[
                                                                name_1
                                                            ];
                                                        value =
                                                            typeof value ===
                                                                'boolean' ||
                                                            typeof value ===
                                                                'number'
                                                                ? ''
                                                                : value;
                                                        if (
                                                            !name_1.startsWith(
                                                                'rr_'
                                                            )
                                                        ) {
                                                            var isTextarea =
                                                                tagName ===
                                                                    'textarea' &&
                                                                name_1 ===
                                                                    'value';
                                                            var isRemoteOrDynamicCss =
                                                                tagName ===
                                                                    'style' &&
                                                                name_1 ===
                                                                    '_cssText';
                                                            if (
                                                                isRemoteOrDynamicCss &&
                                                                hackCss
                                                            ) {
                                                                value = addHoverClass(
                                                                    value
                                                                );
                                                            }
                                                            if (
                                                                isTextarea ||
                                                                isRemoteOrDynamicCss
                                                            ) {
                                                                var child = doc.createTextNode(
                                                                    value
                                                                );
                                                                try {
                                                                    for (
                                                                        var _b =
                                                                                ((e_1 = void 0),
                                                                                __values(
                                                                                    Array.from(
                                                                                        node_1.childNodes
                                                                                    )
                                                                                )),
                                                                            _c = _b.next();
                                                                        !_c.done;
                                                                        _c = _b.next()
                                                                    ) {
                                                                        var c =
                                                                            _c.value;
                                                                        if (
                                                                            c.nodeType ===
                                                                            node_1.TEXT_NODE
                                                                        ) {
                                                                            node_1.removeChild(
                                                                                c
                                                                            );
                                                                        }
                                                                    }
                                                                } catch (e_1_1) {
                                                                    e_1 = {
                                                                        error: e_1_1,
                                                                    };
                                                                } finally {
                                                                    try {
                                                                        if (
                                                                            _c &&
                                                                            !_c.done &&
                                                                            (_a =
                                                                                _b.return)
                                                                        )
                                                                            _a.call(
                                                                                _b
                                                                            );
                                                                    } finally {
                                                                        if (e_1)
                                                                            throw e_1.error;
                                                                    }
                                                                }
                                                                node_1.appendChild(
                                                                    child
                                                                );
                                                                return 'continue';
                                                            }
                                                            if (
                                                                tagName ===
                                                                    'iframe' &&
                                                                name_1 === 'src'
                                                            ) {
                                                                return 'continue';
                                                            }
                                                            try {
                                                                if (
                                                                    n.isSVG &&
                                                                    name_1 ===
                                                                        'xlink:href'
                                                                ) {
                                                                    node_1.setAttributeNS(
                                                                        'http://www.w3.org/1999/xlink',
                                                                        name_1,
                                                                        value
                                                                    );
                                                                } else if (
                                                                    name_1 ===
                                                                        'onload' ||
                                                                    name_1 ===
                                                                        'onclick' ||
                                                                    name_1.substring(
                                                                        0,
                                                                        7
                                                                    ) ===
                                                                        'onmouse'
                                                                ) {
                                                                    node_1.setAttribute(
                                                                        '_' +
                                                                            name_1,
                                                                        value
                                                                    );
                                                                } else {
                                                                    node_1.setAttribute(
                                                                        name_1,
                                                                        value
                                                                    );
                                                                }
                                                            } catch (error) {}
                                                        } else {
                                                            if (
                                                                tagName ===
                                                                    'canvas' &&
                                                                name_1 ===
                                                                    'rr_dataURL'
                                                            ) {
                                                                var image_1 = document.createElement(
                                                                    'img'
                                                                );
                                                                image_1.src = value;
                                                                image_1.onload = function () {
                                                                    var ctx = node_1.getContext(
                                                                        '2d'
                                                                    );
                                                                    if (ctx) {
                                                                        ctx.drawImage(
                                                                            image_1,
                                                                            0,
                                                                            0,
                                                                            image_1.width,
                                                                            image_1.height
                                                                        );
                                                                    }
                                                                };
                                                            }
                                                            if (
                                                                name_1 ===
                                                                'rr_width'
                                                            ) {
                                                                node_1.style.width = value;
                                                            }
                                                            if (
                                                                name_1 ===
                                                                'rr_height'
                                                            ) {
                                                                node_1.style.height = value;
                                                            }
                                                            if (
                                                                name_1 ===
                                                                'rr_mediaState'
                                                            ) {
                                                                switch (value) {
                                                                    case 'played':
                                                                        node_1.play();
                                                                    case 'paused':
                                                                        node_1.pause();
                                                                        break;
                                                                    default:
                                                                }
                                                            }
                                                        }
                                                    };
                                                    for (var name_1 in n.attributes) {
                                                        _loop_1(name_1);
                                                    }
                                                    return node_1;
                                                case types_1.NodeType.Text:
                                                    return doc.createTextNode(
                                                        n.isStyle && hackCss
                                                            ? addHoverClass(
                                                                  n.textContent
                                                              )
                                                            : n.textContent
                                                    );
                                                case types_1.NodeType.CDATA:
                                                    return doc.createCDATASection(
                                                        n.textContent
                                                    );
                                                case types_1.NodeType.Comment:
                                                    return doc.createComment(
                                                        n.textContent
                                                    );
                                                default:
                                                    return null;
                                            }
                                        }
                                        function buildNodeWithSN(n, options) {
                                            var e_2, _a;
                                            var doc = options.doc,
                                                map = options.map,
                                                _b = options.skipChild,
                                                skipChild =
                                                    _b === void 0 ? false : _b,
                                                _c = options.hackCss,
                                                hackCss =
                                                    _c === void 0 ? true : _c;
                                            var node = buildNode(n, {
                                                doc: doc,
                                                hackCss: hackCss,
                                            });
                                            if (!node) {
                                                return null;
                                            }
                                            if (
                                                n.type ===
                                                types_1.NodeType.Document
                                            ) {
                                                doc.close();
                                                doc.open();
                                                node = doc;
                                            }
                                            node.__sn = n;
                                            map[n.id] = node;
                                            if (
                                                (n.type ===
                                                    types_1.NodeType.Document ||
                                                    n.type ===
                                                        types_1.NodeType
                                                            .Element) &&
                                                !skipChild
                                            ) {
                                                try {
                                                    for (
                                                        var _d = __values(
                                                                n.childNodes
                                                            ),
                                                            _e = _d.next();
                                                        !_e.done;
                                                        _e = _d.next()
                                                    ) {
                                                        var childN = _e.value;
                                                        var childNode = buildNodeWithSN(
                                                            childN,
                                                            {
                                                                doc: doc,
                                                                map: map,
                                                                skipChild: false,
                                                                hackCss: hackCss,
                                                            }
                                                        );
                                                        if (!childNode) {
                                                            console.warn(
                                                                'Failed to rebuild',
                                                                childN
                                                            );
                                                        } else {
                                                            node.appendChild(
                                                                childNode
                                                            );
                                                        }
                                                    }
                                                } catch (e_2_1) {
                                                    e_2 = { error: e_2_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _e &&
                                                            !_e.done &&
                                                            (_a = _d.return)
                                                        )
                                                            _a.call(_d);
                                                    } finally {
                                                        if (e_2)
                                                            throw e_2.error;
                                                    }
                                                }
                                            }
                                            return node;
                                        }
                                        exports.buildNodeWithSN = buildNodeWithSN;
                                        function visit(idNodeMap, onVisit) {
                                            function walk(node) {
                                                onVisit(node);
                                            }
                                            for (var key in idNodeMap) {
                                                if (idNodeMap[key]) {
                                                    walk(idNodeMap[key]);
                                                }
                                            }
                                        }
                                        function handleScroll(node) {
                                            var n = node.__sn;
                                            if (
                                                n.type !==
                                                types_1.NodeType.Element
                                            ) {
                                                return;
                                            }
                                            var el = node;
                                            for (var name_2 in n.attributes) {
                                                if (
                                                    !(
                                                        n.attributes.hasOwnProperty(
                                                            name_2
                                                        ) &&
                                                        name_2.startsWith('rr_')
                                                    )
                                                ) {
                                                    continue;
                                                }
                                                var value =
                                                    n.attributes[name_2];
                                                if (
                                                    name_2 === 'rr_scrollLeft'
                                                ) {
                                                    el.scrollLeft = value;
                                                }
                                                if (name_2 === 'rr_scrollTop') {
                                                    el.scrollTop = value;
                                                }
                                            }
                                        }
                                        function rebuild(n, options) {
                                            var doc = options.doc,
                                                onVisit = options.onVisit,
                                                _a = options.hackCss,
                                                hackCss =
                                                    _a === void 0 ? true : _a;
                                            var idNodeMap = {};
                                            var node = buildNodeWithSN(n, {
                                                doc: doc,
                                                map: idNodeMap,
                                                skipChild: false,
                                                hackCss: hackCss,
                                            });
                                            visit(
                                                idNodeMap,
                                                function (visitedNode) {
                                                    if (onVisit) {
                                                        onVisit(visitedNode);
                                                    }
                                                    handleScroll(visitedNode);
                                                }
                                            );
                                            return [node, idNodeMap];
                                        }
                                        exports.default = rebuild;

                                        /***/
                                    },

                                /***/ './src/snapshot/snapshot.ts':
                                    /*!**********************************!*\
  !*** ./src/snapshot/snapshot.ts ***!
  \**********************************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_173978__
                                    ) {
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.cleanupSnapshot = exports.visitSnapshot = exports.serializeNodeWithId = exports._isBlockedElement = exports.transformAttribute = exports.absoluteToDoc = exports.absoluteToStylesheet = exports.IGNORED_NODE = void 0;
                                        var types_1 = __nested_webpack_require_173978__(
                                            /*! ./types */ './src/snapshot/types.ts'
                                        );
                                        var _id = 1;
                                        var tagNameRegex = RegExp(
                                            '[^a-z1-6-_]'
                                        );
                                        exports.IGNORED_NODE = -2;
                                        function genId() {
                                            return _id++;
                                        }
                                        function getValidTagName(element) {
                                            if (
                                                element instanceof
                                                HTMLFormElement
                                            ) {
                                                return 'form';
                                            }
                                            var processedTagName = element.tagName
                                                .toLowerCase()
                                                .trim();
                                            if (
                                                tagNameRegex.test(
                                                    processedTagName
                                                )
                                            ) {
                                                return 'div';
                                            }
                                            return processedTagName;
                                        }
                                        function getCssRulesString(s) {
                                            try {
                                                var rules =
                                                    s.rules || s.cssRules;
                                                return rules
                                                    ? Array.from(rules)
                                                          .map(getCssRuleString)
                                                          .join('')
                                                    : null;
                                            } catch (error) {
                                                return null;
                                            }
                                        }
                                        function getCssRuleString(rule) {
                                            return isCSSImportRule(rule)
                                                ? getCssRulesString(
                                                      rule.styleSheet
                                                  ) || ''
                                                : rule.cssText;
                                        }
                                        function isCSSImportRule(rule) {
                                            return 'styleSheet' in rule;
                                        }
                                        function extractOrigin(url) {
                                            var origin;
                                            if (url.indexOf('//') > -1) {
                                                origin = url
                                                    .split('/')
                                                    .slice(0, 3)
                                                    .join('/');
                                            } else {
                                                origin = url.split('/')[0];
                                            }
                                            origin = origin.split('?')[0];
                                            return origin;
                                        }
                                        var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm;
                                        var RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/;
                                        var DATA_URI = /^(data:)([^,]*),(.*)/i;
                                        function absoluteToStylesheet(
                                            cssText,
                                            href
                                        ) {
                                            return (cssText || '').replace(
                                                URL_IN_CSS_REF,
                                                function (
                                                    origin,
                                                    quote1,
                                                    path1,
                                                    quote2,
                                                    path2,
                                                    path3
                                                ) {
                                                    var e_1, _a;
                                                    var filePath =
                                                        path1 || path2 || path3;
                                                    var maybeQuote =
                                                        quote1 || quote2 || '';
                                                    if (!filePath) {
                                                        return origin;
                                                    }
                                                    if (
                                                        !RELATIVE_PATH.test(
                                                            filePath
                                                        )
                                                    ) {
                                                        return (
                                                            'url(' +
                                                            maybeQuote +
                                                            filePath +
                                                            maybeQuote +
                                                            ')'
                                                        );
                                                    }
                                                    if (
                                                        DATA_URI.test(filePath)
                                                    ) {
                                                        return (
                                                            'url(' +
                                                            maybeQuote +
                                                            filePath +
                                                            maybeQuote +
                                                            ')'
                                                        );
                                                    }
                                                    if (filePath[0] === '/') {
                                                        return (
                                                            'url(' +
                                                            maybeQuote +
                                                            (extractOrigin(
                                                                href
                                                            ) +
                                                                filePath) +
                                                            maybeQuote +
                                                            ')'
                                                        );
                                                    }
                                                    var stack = href.split('/');
                                                    var parts = filePath.split(
                                                        '/'
                                                    );
                                                    stack.pop();
                                                    try {
                                                        for (
                                                            var parts_1 = __values(
                                                                    parts
                                                                ),
                                                                parts_1_1 = parts_1.next();
                                                            !parts_1_1.done;
                                                            parts_1_1 = parts_1.next()
                                                        ) {
                                                            var part =
                                                                parts_1_1.value;
                                                            if (part === '.') {
                                                                continue;
                                                            } else if (
                                                                part === '..'
                                                            ) {
                                                                stack.pop();
                                                            } else {
                                                                stack.push(
                                                                    part
                                                                );
                                                            }
                                                        }
                                                    } catch (e_1_1) {
                                                        e_1 = { error: e_1_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                parts_1_1 &&
                                                                !parts_1_1.done &&
                                                                (_a =
                                                                    parts_1.return)
                                                            )
                                                                _a.call(
                                                                    parts_1
                                                                );
                                                        } finally {
                                                            if (e_1)
                                                                throw e_1.error;
                                                        }
                                                    }
                                                    return (
                                                        'url(' +
                                                        maybeQuote +
                                                        stack.join('/') +
                                                        maybeQuote +
                                                        ')'
                                                    );
                                                }
                                            );
                                        }
                                        exports.absoluteToStylesheet = absoluteToStylesheet;
                                        function getAbsoluteSrcsetString(
                                            doc,
                                            attributeValue
                                        ) {
                                            if (attributeValue.trim() === '') {
                                                return attributeValue;
                                            }
                                            var srcsetValues = attributeValue.split(
                                                ','
                                            );
                                            var resultingSrcsetString = srcsetValues
                                                .map(function (srcItem) {
                                                    var trimmedSrcItem = srcItem
                                                        .trimLeft()
                                                        .trimRight();
                                                    var urlAndSize = trimmedSrcItem.split(
                                                        ' '
                                                    );
                                                    if (
                                                        urlAndSize.length === 2
                                                    ) {
                                                        var absUrl = absoluteToDoc(
                                                            doc,
                                                            urlAndSize[0]
                                                        );
                                                        return (
                                                            absUrl +
                                                            ' ' +
                                                            urlAndSize[1]
                                                        );
                                                    } else if (
                                                        urlAndSize.length === 1
                                                    ) {
                                                        var absUrl = absoluteToDoc(
                                                            doc,
                                                            urlAndSize[0]
                                                        );
                                                        return '' + absUrl;
                                                    }
                                                    return '';
                                                })
                                                .join(', ');
                                            return resultingSrcsetString;
                                        }
                                        function absoluteToDoc(
                                            doc,
                                            attributeValue
                                        ) {
                                            if (
                                                !attributeValue ||
                                                attributeValue.trim() === ''
                                            ) {
                                                return attributeValue;
                                            }
                                            var a = doc.createElement('a');
                                            a.href = attributeValue;
                                            return a.href;
                                        }
                                        exports.absoluteToDoc = absoluteToDoc;
                                        function isSVGElement(el) {
                                            return (
                                                el.tagName === 'svg' ||
                                                el instanceof SVGElement
                                            );
                                        }
                                        function getHref() {
                                            var a = document.createElement('a');
                                            a.href = '';
                                            return a.href;
                                        }
                                        function transformAttribute(
                                            doc,
                                            name,
                                            value
                                        ) {
                                            if (
                                                name === 'src' ||
                                                ((name === 'href' ||
                                                    name === 'xlink:href') &&
                                                    value)
                                            ) {
                                                return absoluteToDoc(
                                                    doc,
                                                    value
                                                );
                                            } else if (
                                                name === 'srcset' &&
                                                value
                                            ) {
                                                return getAbsoluteSrcsetString(
                                                    doc,
                                                    value
                                                );
                                            } else if (
                                                name === 'style' &&
                                                value
                                            ) {
                                                return absoluteToStylesheet(
                                                    value,
                                                    getHref()
                                                );
                                            } else {
                                                return value;
                                            }
                                        }
                                        exports.transformAttribute = transformAttribute;
                                        function _isBlockedElement(
                                            element,
                                            blockClass,
                                            blockSelector
                                        ) {
                                            if (
                                                typeof blockClass === 'string'
                                            ) {
                                                if (
                                                    element.classList.contains(
                                                        blockClass
                                                    )
                                                ) {
                                                    return true;
                                                }
                                            } else {
                                                element.classList.forEach(
                                                    function (className) {
                                                        if (
                                                            blockClass.test(
                                                                className
                                                            )
                                                        ) {
                                                            return true;
                                                        }
                                                    }
                                                );
                                            }
                                            if (blockSelector) {
                                                return element.matches(
                                                    blockSelector
                                                );
                                            }
                                            return false;
                                        }
                                        exports._isBlockedElement = _isBlockedElement;
                                        function serializeNode(n, options) {
                                            var e_2, _a;
                                            var doc = options.doc,
                                                blockClass = options.blockClass,
                                                blockSelector =
                                                    options.blockSelector,
                                                inlineStylesheet =
                                                    options.inlineStylesheet,
                                                _b = options.maskInputOptions,
                                                maskInputOptions =
                                                    _b === void 0 ? {} : _b,
                                                recordCanvas =
                                                    options.recordCanvas;
                                            switch (n.nodeType) {
                                                case n.DOCUMENT_NODE:
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .Document,
                                                        childNodes: [],
                                                    };
                                                case n.DOCUMENT_TYPE_NODE:
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .DocumentType,
                                                        name: n.name,
                                                        publicId: n.publicId,
                                                        systemId: n.systemId,
                                                    };
                                                case n.ELEMENT_NODE:
                                                    var needBlock = _isBlockedElement(
                                                        n,
                                                        blockClass,
                                                        blockSelector
                                                    );
                                                    var tagName = getValidTagName(
                                                        n
                                                    );
                                                    var attributes = {};
                                                    try {
                                                        for (
                                                            var _c = __values(
                                                                    Array.from(
                                                                        n.attributes
                                                                    )
                                                                ),
                                                                _d = _c.next();
                                                            !_d.done;
                                                            _d = _c.next()
                                                        ) {
                                                            var _e = _d.value,
                                                                name_1 =
                                                                    _e.name,
                                                                value =
                                                                    _e.value;
                                                            attributes[
                                                                name_1
                                                            ] = transformAttribute(
                                                                doc,
                                                                name_1,
                                                                value
                                                            );
                                                        }
                                                    } catch (e_2_1) {
                                                        e_2 = { error: e_2_1 };
                                                    } finally {
                                                        try {
                                                            if (
                                                                _d &&
                                                                !_d.done &&
                                                                (_a = _c.return)
                                                            )
                                                                _a.call(_c);
                                                        } finally {
                                                            if (e_2)
                                                                throw e_2.error;
                                                        }
                                                    }
                                                    if (
                                                        tagName === 'link' &&
                                                        inlineStylesheet
                                                    ) {
                                                        var stylesheet = Array.from(
                                                            doc.styleSheets
                                                        ).find(function (s) {
                                                            return (
                                                                s.href ===
                                                                n.href
                                                            );
                                                        });
                                                        var cssText = getCssRulesString(
                                                            stylesheet
                                                        );
                                                        if (cssText) {
                                                            delete attributes.rel;
                                                            delete attributes.href;
                                                            attributes._cssText = absoluteToStylesheet(
                                                                cssText,
                                                                stylesheet.href
                                                            );
                                                        }
                                                    }
                                                    if (
                                                        tagName === 'style' &&
                                                        n.sheet &&
                                                        !(
                                                            n.innerText ||
                                                            n.textContent ||
                                                            ''
                                                        ).trim().length
                                                    ) {
                                                        var cssText = getCssRulesString(
                                                            n.sheet
                                                        );
                                                        if (cssText) {
                                                            attributes._cssText = absoluteToStylesheet(
                                                                cssText,
                                                                getHref()
                                                            );
                                                        }
                                                    }
                                                    if (
                                                        tagName === 'input' ||
                                                        tagName ===
                                                            'textarea' ||
                                                        tagName === 'select'
                                                    ) {
                                                        var value = n.value;
                                                        if (
                                                            attributes.type !==
                                                                'radio' &&
                                                            attributes.type !==
                                                                'checkbox' &&
                                                            attributes.type !==
                                                                'submit' &&
                                                            attributes.type !==
                                                                'button' &&
                                                            value
                                                        ) {
                                                            attributes.value =
                                                                maskInputOptions[
                                                                    attributes
                                                                        .type
                                                                ] ||
                                                                maskInputOptions[
                                                                    tagName
                                                                ]
                                                                    ? '*'.repeat(
                                                                          value.length
                                                                      )
                                                                    : value;
                                                        } else if (n.checked) {
                                                            attributes.checked =
                                                                n.checked;
                                                        }
                                                    }
                                                    if (tagName === 'option') {
                                                        var selectValue =
                                                            n.parentElement;
                                                        if (
                                                            attributes.value ===
                                                            selectValue.value
                                                        ) {
                                                            attributes.selected =
                                                                n.selected;
                                                        }
                                                    }
                                                    if (
                                                        tagName === 'canvas' &&
                                                        recordCanvas
                                                    ) {
                                                        attributes.rr_dataURL = n.toDataURL();
                                                    }
                                                    if (
                                                        tagName === 'audio' ||
                                                        tagName === 'video'
                                                    ) {
                                                        attributes.rr_mediaState = n.paused
                                                            ? 'paused'
                                                            : 'played';
                                                    }
                                                    if (n.scrollLeft) {
                                                        attributes.rr_scrollLeft =
                                                            n.scrollLeft;
                                                    }
                                                    if (n.scrollTop) {
                                                        attributes.rr_scrollTop =
                                                            n.scrollTop;
                                                    }
                                                    if (needBlock) {
                                                        var _f = n.getBoundingClientRect(),
                                                            width = _f.width,
                                                            height = _f.height;
                                                        attributes = {
                                                            class:
                                                                attributes.class,
                                                            rr_width:
                                                                width + 'px',
                                                            rr_height:
                                                                height + 'px',
                                                        };
                                                    }
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .Element,
                                                        tagName: tagName,
                                                        attributes: attributes,
                                                        childNodes: [],
                                                        isSVG:
                                                            isSVGElement(n) ||
                                                            undefined,
                                                        needBlock: needBlock,
                                                    };
                                                case n.TEXT_NODE:
                                                    var parentTagName =
                                                        n.parentNode &&
                                                        n.parentNode.tagName;
                                                    var textContent =
                                                        n.textContent;
                                                    var isStyle =
                                                        parentTagName ===
                                                        'STYLE'
                                                            ? true
                                                            : undefined;
                                                    if (
                                                        isStyle &&
                                                        textContent
                                                    ) {
                                                        textContent = absoluteToStylesheet(
                                                            textContent,
                                                            getHref()
                                                        );
                                                    }
                                                    if (
                                                        parentTagName ===
                                                        'SCRIPT'
                                                    ) {
                                                        textContent =
                                                            'SCRIPT_PLACEHOLDER';
                                                    }
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .Text,
                                                        textContent:
                                                            textContent || '',
                                                        isStyle: isStyle,
                                                    };
                                                case n.CDATA_SECTION_NODE:
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .CDATA,
                                                        textContent: '',
                                                    };
                                                case n.COMMENT_NODE:
                                                    return {
                                                        type:
                                                            types_1.NodeType
                                                                .Comment,
                                                        textContent:
                                                            n.textContent || '',
                                                    };
                                                default:
                                                    return false;
                                            }
                                        }
                                        function lowerIfExists(maybeAttr) {
                                            if (maybeAttr === undefined) {
                                                return '';
                                            } else {
                                                return maybeAttr.toLowerCase();
                                            }
                                        }
                                        function slimDOMExcluded(
                                            sn,
                                            slimDOMOptions
                                        ) {
                                            if (
                                                slimDOMOptions.comment &&
                                                sn.type ===
                                                    types_1.NodeType.Comment
                                            ) {
                                                return true;
                                            } else if (
                                                sn.type ===
                                                types_1.NodeType.Element
                                            ) {
                                                if (
                                                    slimDOMOptions.script &&
                                                    (sn.tagName === 'script' ||
                                                        (sn.tagName ===
                                                            'link' &&
                                                            sn.attributes
                                                                .rel ===
                                                                'preload' &&
                                                            sn.attributes.as ===
                                                                'script'))
                                                ) {
                                                    return true;
                                                } else if (
                                                    slimDOMOptions.headFavicon &&
                                                    ((sn.tagName === 'link' &&
                                                        sn.attributes.rel ===
                                                            'shortcut icon') ||
                                                        (sn.tagName ===
                                                            'meta' &&
                                                            (lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ).match(
                                                                /^msapplication-tile(image|color)$/
                                                            ) ||
                                                                lowerIfExists(
                                                                    sn
                                                                        .attributes
                                                                        .name
                                                                ) ===
                                                                    'application-name' ||
                                                                lowerIfExists(
                                                                    sn
                                                                        .attributes
                                                                        .rel
                                                                ) === 'icon' ||
                                                                lowerIfExists(
                                                                    sn
                                                                        .attributes
                                                                        .rel
                                                                ) ===
                                                                    'apple-touch-icon' ||
                                                                lowerIfExists(
                                                                    sn
                                                                        .attributes
                                                                        .rel
                                                                ) ===
                                                                    'shortcut icon')))
                                                ) {
                                                    return true;
                                                } else if (
                                                    sn.tagName === 'meta'
                                                ) {
                                                    if (
                                                        slimDOMOptions.headMetaDescKeywords &&
                                                        lowerIfExists(
                                                            sn.attributes.name
                                                        ).match(
                                                            /^description|keywords$/
                                                        )
                                                    ) {
                                                        return true;
                                                    } else if (
                                                        slimDOMOptions.headMetaSocial &&
                                                        (lowerIfExists(
                                                            sn.attributes
                                                                .property
                                                        ).match(
                                                            /^(og|twitter|fb):/
                                                        ) ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ).match(
                                                                /^(og|twitter):/
                                                            ) ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'pinterest')
                                                    ) {
                                                        return true;
                                                    } else if (
                                                        slimDOMOptions.headMetaRobots &&
                                                        (lowerIfExists(
                                                            sn.attributes.name
                                                        ) === 'robots' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'googlebot' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'bingbot')
                                                    ) {
                                                        return true;
                                                    } else if (
                                                        slimDOMOptions.headMetaHttpEquiv &&
                                                        sn.attributes[
                                                            'http-equiv'
                                                        ] !== undefined
                                                    ) {
                                                        return true;
                                                    } else if (
                                                        slimDOMOptions.headMetaAuthorship &&
                                                        (lowerIfExists(
                                                            sn.attributes.name
                                                        ) === 'author' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'generator' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'framework' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'publisher' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'progid' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .property
                                                            ).match(
                                                                /^article:/
                                                            ) ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .property
                                                            ).match(
                                                                /^product:/
                                                            ))
                                                    ) {
                                                        return true;
                                                    } else if (
                                                        slimDOMOptions.headMetaVerification &&
                                                        (lowerIfExists(
                                                            sn.attributes.name
                                                        ) ===
                                                            'google-site-verification' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) ===
                                                                'yandex-verification' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) ===
                                                                'csrf-token' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) ===
                                                                'p:domain_verify' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) === 'verify-v1' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) ===
                                                                'verification' ||
                                                            lowerIfExists(
                                                                sn.attributes
                                                                    .name
                                                            ) ===
                                                                'shopify-checkout-api-token')
                                                    ) {
                                                        return true;
                                                    }
                                                }
                                            }
                                            return false;
                                        }
                                        function serializeNodeWithId(
                                            n,
                                            options
                                        ) {
                                            var e_3, _a;
                                            var doc = options.doc,
                                                map = options.map,
                                                blockClass = options.blockClass,
                                                blockSelector =
                                                    options.blockSelector,
                                                _b = options.skipChild,
                                                skipChild =
                                                    _b === void 0 ? false : _b,
                                                _c = options.inlineStylesheet,
                                                inlineStylesheet =
                                                    _c === void 0 ? true : _c,
                                                _d = options.maskInputOptions,
                                                maskInputOptions =
                                                    _d === void 0 ? {} : _d,
                                                slimDOMOptions =
                                                    options.slimDOMOptions,
                                                _e = options.recordCanvas,
                                                recordCanvas =
                                                    _e === void 0 ? false : _e;
                                            var _f = options.preserveWhiteSpace,
                                                preserveWhiteSpace =
                                                    _f === void 0 ? true : _f;
                                            var _serializedNode = serializeNode(
                                                n,
                                                {
                                                    doc: doc,
                                                    blockClass: blockClass,
                                                    blockSelector: blockSelector,
                                                    inlineStylesheet: inlineStylesheet,
                                                    maskInputOptions: maskInputOptions,
                                                    recordCanvas: recordCanvas,
                                                }
                                            );
                                            if (!_serializedNode) {
                                                console.warn(
                                                    n,
                                                    'not serialized'
                                                );
                                                return null;
                                            }
                                            var id;
                                            if ('__sn' in n) {
                                                id = n.__sn.id;
                                            } else if (
                                                slimDOMExcluded(
                                                    _serializedNode,
                                                    slimDOMOptions
                                                ) ||
                                                (!preserveWhiteSpace &&
                                                    _serializedNode.type ===
                                                        types_1.NodeType.Text &&
                                                    !_serializedNode.isStyle &&
                                                    !_serializedNode.textContent.replace(
                                                        /^\s+|\s+$/gm,
                                                        ''
                                                    ).length)
                                            ) {
                                                id = exports.IGNORED_NODE;
                                            } else {
                                                id = genId();
                                            }
                                            var serializedNode = Object.assign(
                                                _serializedNode,
                                                { id: id }
                                            );
                                            n.__sn = serializedNode;
                                            if (id === exports.IGNORED_NODE) {
                                                return null;
                                            }
                                            map[id] = n;
                                            var recordChild = !skipChild;
                                            if (
                                                serializedNode.type ===
                                                types_1.NodeType.Element
                                            ) {
                                                recordChild =
                                                    recordChild &&
                                                    !serializedNode.needBlock;
                                                delete serializedNode.needBlock;
                                            }
                                            if (
                                                (serializedNode.type ===
                                                    types_1.NodeType.Document ||
                                                    serializedNode.type ===
                                                        types_1.NodeType
                                                            .Element) &&
                                                recordChild
                                            ) {
                                                if (
                                                    slimDOMOptions.headWhitespace &&
                                                    _serializedNode.type ===
                                                        types_1.NodeType
                                                            .Element &&
                                                    _serializedNode.tagName ===
                                                        'head'
                                                ) {
                                                    preserveWhiteSpace = false;
                                                }
                                                try {
                                                    for (
                                                        var _g = __values(
                                                                Array.from(
                                                                    n.childNodes
                                                                )
                                                            ),
                                                            _h = _g.next();
                                                        !_h.done;
                                                        _h = _g.next()
                                                    ) {
                                                        var childN = _h.value;
                                                        var serializedChildNode = serializeNodeWithId(
                                                            childN,
                                                            {
                                                                doc: doc,
                                                                map: map,
                                                                blockClass: blockClass,
                                                                blockSelector: blockSelector,
                                                                skipChild: skipChild,
                                                                inlineStylesheet: inlineStylesheet,
                                                                maskInputOptions: maskInputOptions,
                                                                slimDOMOptions: slimDOMOptions,
                                                                recordCanvas: recordCanvas,
                                                                preserveWhiteSpace: preserveWhiteSpace,
                                                            }
                                                        );
                                                        if (
                                                            serializedChildNode
                                                        ) {
                                                            serializedNode.childNodes.push(
                                                                serializedChildNode
                                                            );
                                                        }
                                                    }
                                                } catch (e_3_1) {
                                                    e_3 = { error: e_3_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _h &&
                                                            !_h.done &&
                                                            (_a = _g.return)
                                                        )
                                                            _a.call(_g);
                                                    } finally {
                                                        if (e_3)
                                                            throw e_3.error;
                                                    }
                                                }
                                            }
                                            return serializedNode;
                                        }
                                        exports.serializeNodeWithId = serializeNodeWithId;
                                        function snapshot(n, options) {
                                            var _a = options || {},
                                                _b = _a.blockClass,
                                                blockClass =
                                                    _b === void 0
                                                        ? 'rr-block'
                                                        : _b,
                                                _c = _a.inlineStylesheet,
                                                inlineStylesheet =
                                                    _c === void 0 ? true : _c,
                                                _d = _a.recordCanvas,
                                                recordCanvas =
                                                    _d === void 0 ? false : _d,
                                                _e = _a.blockSelector,
                                                blockSelector =
                                                    _e === void 0 ? null : _e,
                                                _f = _a.maskAllInputs,
                                                maskAllInputs =
                                                    _f === void 0 ? false : _f,
                                                _g = _a.slimDOM,
                                                slimDOM =
                                                    _g === void 0 ? false : _g;
                                            var idNodeMap = {};
                                            var maskInputOptions =
                                                maskAllInputs === true
                                                    ? {
                                                          color: true,
                                                          date: true,
                                                          'datetime-local': true,
                                                          email: true,
                                                          month: true,
                                                          number: true,
                                                          range: true,
                                                          search: true,
                                                          tel: true,
                                                          text: true,
                                                          time: true,
                                                          url: true,
                                                          week: true,
                                                          textarea: true,
                                                          select: true,
                                                      }
                                                    : maskAllInputs === false
                                                    ? {}
                                                    : maskAllInputs;
                                            var slimDOMOptions =
                                                slimDOM === true ||
                                                slimDOM === 'all'
                                                    ? {
                                                          script: true,
                                                          comment: true,
                                                          headFavicon: true,
                                                          headWhitespace: true,
                                                          headMetaDescKeywords:
                                                              slimDOM === 'all',
                                                          headMetaSocial: true,
                                                          headMetaRobots: true,
                                                          headMetaHttpEquiv: true,
                                                          headMetaAuthorship: true,
                                                          headMetaVerification: true,
                                                      }
                                                    : slimDOM === false
                                                    ? {}
                                                    : slimDOM;
                                            return [
                                                serializeNodeWithId(n, {
                                                    doc: n,
                                                    map: idNodeMap,
                                                    blockClass: blockClass,
                                                    blockSelector: blockSelector,
                                                    skipChild: false,
                                                    inlineStylesheet: inlineStylesheet,
                                                    maskInputOptions: maskInputOptions,
                                                    slimDOMOptions: slimDOMOptions,
                                                    recordCanvas: recordCanvas,
                                                }),
                                                idNodeMap,
                                            ];
                                        }
                                        function visitSnapshot(node, onVisit) {
                                            function walk(current) {
                                                onVisit(current);
                                                if (
                                                    current.type ===
                                                        types_1.NodeType
                                                            .Document ||
                                                    current.type ===
                                                        types_1.NodeType.Element
                                                ) {
                                                    current.childNodes.forEach(
                                                        walk
                                                    );
                                                }
                                            }
                                            walk(node);
                                        }
                                        exports.visitSnapshot = visitSnapshot;
                                        function cleanupSnapshot() {
                                            _id = 1;
                                        }
                                        exports.cleanupSnapshot = cleanupSnapshot;
                                        exports.default = snapshot;

                                        /***/
                                    },

                                /***/ './src/snapshot/types.ts':
                                    /*!*******************************!*\
  !*** ./src/snapshot/types.ts ***!
  \*******************************/
                                    /***/ (
                                        __unused_webpack_module,
                                        exports
                                    ) => {
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.NodeType = void 0;
                                        var NodeType;
                                        (function (NodeType) {
                                            NodeType[
                                                (NodeType['Document'] = 0)
                                            ] = 'Document';
                                            NodeType[
                                                (NodeType['DocumentType'] = 1)
                                            ] = 'DocumentType';
                                            NodeType[
                                                (NodeType['Element'] = 2)
                                            ] = 'Element';
                                            NodeType[(NodeType['Text'] = 3)] =
                                                'Text';
                                            NodeType[(NodeType['CDATA'] = 4)] =
                                                'CDATA';
                                            NodeType[
                                                (NodeType['Comment'] = 5)
                                            ] = 'Comment';
                                        })(
                                            (NodeType =
                                                exports.NodeType ||
                                                (exports.NodeType = {}))
                                        );

                                        /***/
                                    },

                                /***/ './src/types.ts':
                                    /*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
                                    /***/ (
                                        __unused_webpack_module,
                                        exports
                                    ) => {
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.ReplayerEvents = exports.MediaInteractions = exports.MouseInteractions = exports.IncrementalSource = exports.EventType = void 0;
                                        var EventType;
                                        (function (EventType) {
                                            EventType[
                                                (EventType[
                                                    'DomContentLoaded'
                                                ] = 0)
                                            ] = 'DomContentLoaded';
                                            EventType[(EventType['Load'] = 1)] =
                                                'Load';
                                            EventType[
                                                (EventType['FullSnapshot'] = 2)
                                            ] = 'FullSnapshot';
                                            EventType[
                                                (EventType[
                                                    'IncrementalSnapshot'
                                                ] = 3)
                                            ] = 'IncrementalSnapshot';
                                            EventType[(EventType['Meta'] = 4)] =
                                                'Meta';
                                            EventType[
                                                (EventType['Custom'] = 5)
                                            ] = 'Custom';
                                        })(
                                            (EventType =
                                                exports.EventType ||
                                                (exports.EventType = {}))
                                        );
                                        var IncrementalSource;
                                        (function (IncrementalSource) {
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'Mutation'
                                                ] = 0)
                                            ] = 'Mutation';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'MouseMove'
                                                ] = 1)
                                            ] = 'MouseMove';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'MouseInteraction'
                                                ] = 2)
                                            ] = 'MouseInteraction';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'Scroll'
                                                ] = 3)
                                            ] = 'Scroll';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'ViewportResize'
                                                ] = 4)
                                            ] = 'ViewportResize';
                                            IncrementalSource[
                                                (IncrementalSource['Input'] = 5)
                                            ] = 'Input';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'TouchMove'
                                                ] = 6)
                                            ] = 'TouchMove';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'MediaInteraction'
                                                ] = 7)
                                            ] = 'MediaInteraction';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'StyleSheetRule'
                                                ] = 8)
                                            ] = 'StyleSheetRule';
                                            IncrementalSource[
                                                (IncrementalSource[
                                                    'CanvasMutation'
                                                ] = 9)
                                            ] = 'CanvasMutation';
                                            IncrementalSource[
                                                (IncrementalSource['Font'] = 10)
                                            ] = 'Font';
                                            IncrementalSource[
                                                (IncrementalSource['Log'] = 11)
                                            ] = 'Log';
                                        })(
                                            (IncrementalSource =
                                                exports.IncrementalSource ||
                                                (exports.IncrementalSource = {}))
                                        );
                                        var MouseInteractions;
                                        (function (MouseInteractions) {
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'MouseUp'
                                                ] = 0)
                                            ] = 'MouseUp';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'MouseDown'
                                                ] = 1)
                                            ] = 'MouseDown';
                                            MouseInteractions[
                                                (MouseInteractions['Click'] = 2)
                                            ] = 'Click';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'ContextMenu'
                                                ] = 3)
                                            ] = 'ContextMenu';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'DblClick'
                                                ] = 4)
                                            ] = 'DblClick';
                                            MouseInteractions[
                                                (MouseInteractions['Focus'] = 5)
                                            ] = 'Focus';
                                            MouseInteractions[
                                                (MouseInteractions['Blur'] = 6)
                                            ] = 'Blur';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'TouchStart'
                                                ] = 7)
                                            ] = 'TouchStart';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'TouchMove_Departed'
                                                ] = 8)
                                            ] = 'TouchMove_Departed';
                                            MouseInteractions[
                                                (MouseInteractions[
                                                    'TouchEnd'
                                                ] = 9)
                                            ] = 'TouchEnd';
                                        })(
                                            (MouseInteractions =
                                                exports.MouseInteractions ||
                                                (exports.MouseInteractions = {}))
                                        );
                                        var MediaInteractions;
                                        (function (MediaInteractions) {
                                            MediaInteractions[
                                                (MediaInteractions['Play'] = 0)
                                            ] = 'Play';
                                            MediaInteractions[
                                                (MediaInteractions['Pause'] = 1)
                                            ] = 'Pause';
                                        })(
                                            (MediaInteractions =
                                                exports.MediaInteractions ||
                                                (exports.MediaInteractions = {}))
                                        );
                                        var ReplayerEvents;
                                        (function (ReplayerEvents) {
                                            ReplayerEvents['Start'] = 'start';
                                            ReplayerEvents['Pause'] = 'pause';
                                            ReplayerEvents['Resume'] = 'resume';
                                            ReplayerEvents['Resize'] = 'resize';
                                            ReplayerEvents['Finish'] = 'finish';
                                            ReplayerEvents[
                                                'FullsnapshotRebuilded'
                                            ] = 'fullsnapshot-rebuilded';
                                            ReplayerEvents[
                                                'LoadStylesheetStart'
                                            ] = 'load-stylesheet-start';
                                            ReplayerEvents[
                                                'LoadStylesheetEnd'
                                            ] = 'load-stylesheet-end';
                                            ReplayerEvents['SkipStart'] =
                                                'skip-start';
                                            ReplayerEvents['SkipEnd'] =
                                                'skip-end';
                                            ReplayerEvents['MouseInteraction'] =
                                                'mouse-interaction';
                                            ReplayerEvents['EventCast'] =
                                                'event-cast';
                                            ReplayerEvents['CustomEvent'] =
                                                'custom-event';
                                            ReplayerEvents['Flush'] = 'flush';
                                            ReplayerEvents['StateChange'] =
                                                'state-change';
                                        })(
                                            (ReplayerEvents =
                                                exports.ReplayerEvents ||
                                                (exports.ReplayerEvents = {}))
                                        );

                                        /***/
                                    },

                                /***/ './src/utils.ts':
                                    /*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
                                    /***/ function (
                                        __unused_webpack_module,
                                        exports,
                                        __nested_webpack_require_199565__
                                    ) {
                                        var __values =
                                            (this && this.__values) ||
                                            function (o) {
                                                var s =
                                                        typeof Symbol ===
                                                            'function' &&
                                                        Symbol.iterator,
                                                    m = s && o[s],
                                                    i = 0;
                                                if (m) return m.call(o);
                                                if (
                                                    o &&
                                                    typeof o.length === 'number'
                                                )
                                                    return {
                                                        next: function () {
                                                            if (
                                                                o &&
                                                                i >= o.length
                                                            )
                                                                o = void 0;
                                                            return {
                                                                value:
                                                                    o && o[i++],
                                                                done: !o,
                                                            };
                                                        },
                                                    };
                                                throw new TypeError(
                                                    s
                                                        ? 'Object is not iterable.'
                                                        : 'Symbol.iterator is not defined.'
                                                );
                                            };
                                        Object.defineProperty(
                                            exports,
                                            '__esModule',
                                            { value: true }
                                        );
                                        exports.iterateResolveTree = exports.queueToResolveTrees = exports.TreeIndex = exports.needCastInSyncMode = exports.polyfill = exports.isTouchEvent = exports.isAncestorRemoved = exports.isIgnored = exports.isBlocked = exports.getWindowWidth = exports.getWindowHeight = exports.patch = exports.hookSetter = exports.throttle = exports.mirror = exports.on = void 0;
                                        var types_1 = __nested_webpack_require_199565__(
                                            /*! ./types */ './src/types.ts'
                                        );
                                        var snapshot_1 = __nested_webpack_require_199565__(
                                            /*! ./snapshot */ './src/snapshot/index.ts'
                                        );
                                        function on(type, fn, target) {
                                            if (target === void 0) {
                                                target = document;
                                            }
                                            var options = {
                                                capture: true,
                                                passive: true,
                                            };
                                            target.addEventListener(
                                                type,
                                                fn,
                                                options
                                            );
                                            return function () {
                                                return target.removeEventListener(
                                                    type,
                                                    fn,
                                                    options
                                                );
                                            };
                                        }
                                        exports.on = on;
                                        exports.mirror = {
                                            map: {},
                                            getId: function (n) {
                                                if (!n.__sn) {
                                                    return -1;
                                                }
                                                return n.__sn.id;
                                            },
                                            getNode: function (id) {
                                                return (
                                                    exports.mirror.map[id] ||
                                                    null
                                                );
                                            },
                                            removeNodeFromMap: function (n) {
                                                var id = n.__sn && n.__sn.id;
                                                delete exports.mirror.map[id];
                                                if (n.childNodes) {
                                                    n.childNodes.forEach(
                                                        function (child) {
                                                            return exports.mirror.removeNodeFromMap(
                                                                child
                                                            );
                                                        }
                                                    );
                                                }
                                            },
                                            has: function (id) {
                                                return exports.mirror.map.hasOwnProperty(
                                                    id
                                                );
                                            },
                                        };
                                        function throttle(func, wait, options) {
                                            if (options === void 0) {
                                                options = {};
                                            }
                                            var timeout = null;
                                            var previous = 0;
                                            return function (arg) {
                                                var now = Date.now();
                                                if (
                                                    !previous &&
                                                    options.leading === false
                                                ) {
                                                    previous = now;
                                                }
                                                var remaining =
                                                    wait - (now - previous);
                                                var context = this;
                                                var args = arguments;
                                                if (
                                                    remaining <= 0 ||
                                                    remaining > wait
                                                ) {
                                                    if (timeout) {
                                                        window.clearTimeout(
                                                            timeout
                                                        );
                                                        timeout = null;
                                                    }
                                                    previous = now;
                                                    func.apply(context, args);
                                                } else if (
                                                    !timeout &&
                                                    options.trailing !== false
                                                ) {
                                                    timeout = window.setTimeout(
                                                        function () {
                                                            previous =
                                                                options.leading ===
                                                                false
                                                                    ? 0
                                                                    : Date.now();
                                                            timeout = null;
                                                            func.apply(
                                                                context,
                                                                args
                                                            );
                                                        },
                                                        remaining
                                                    );
                                                }
                                            };
                                        }
                                        exports.throttle = throttle;
                                        function hookSetter(
                                            target,
                                            key,
                                            d,
                                            isRevoked,
                                            win
                                        ) {
                                            if (win === void 0) {
                                                win = window;
                                            }
                                            var original = win.Object.getOwnPropertyDescriptor(
                                                target,
                                                key
                                            );
                                            win.Object.defineProperty(
                                                target,
                                                key,
                                                isRevoked
                                                    ? d
                                                    : {
                                                          set: function (
                                                              value
                                                          ) {
                                                              var _this = this;
                                                              setTimeout(
                                                                  function () {
                                                                      d.set.call(
                                                                          _this,
                                                                          value
                                                                      );
                                                                  },
                                                                  0
                                                              );
                                                              if (
                                                                  original &&
                                                                  original.set
                                                              ) {
                                                                  original.set.call(
                                                                      this,
                                                                      value
                                                                  );
                                                              }
                                                          },
                                                      }
                                            );
                                            return function () {
                                                return hookSetter(
                                                    target,
                                                    key,
                                                    original || {},
                                                    true
                                                );
                                            };
                                        }
                                        exports.hookSetter = hookSetter;
                                        function patch(
                                            source,
                                            name,
                                            replacement
                                        ) {
                                            try {
                                                if (!(name in source)) {
                                                    return function () {};
                                                }
                                                var original_1 = source[name];
                                                var wrapped = replacement(
                                                    original_1
                                                );
                                                if (
                                                    typeof wrapped ===
                                                    'function'
                                                ) {
                                                    wrapped.prototype =
                                                        wrapped.prototype || {};
                                                    Object.defineProperties(
                                                        wrapped,
                                                        {
                                                            __rrweb_original__: {
                                                                enumerable: false,
                                                                value: original_1,
                                                            },
                                                        }
                                                    );
                                                }
                                                source[name] = wrapped;
                                                return function () {
                                                    source[name] = original_1;
                                                };
                                            } catch (_a) {
                                                return function () {};
                                            }
                                        }
                                        exports.patch = patch;
                                        function getWindowHeight() {
                                            return (
                                                window.innerHeight ||
                                                (document.documentElement &&
                                                    document.documentElement
                                                        .clientHeight) ||
                                                (document.body &&
                                                    document.body.clientHeight)
                                            );
                                        }
                                        exports.getWindowHeight = getWindowHeight;
                                        function getWindowWidth() {
                                            return (
                                                window.innerWidth ||
                                                (document.documentElement &&
                                                    document.documentElement
                                                        .clientWidth) ||
                                                (document.body &&
                                                    document.body.clientWidth)
                                            );
                                        }
                                        exports.getWindowWidth = getWindowWidth;
                                        function isBlocked(node, blockClass) {
                                            if (!node) {
                                                return false;
                                            }
                                            if (
                                                node.nodeType ===
                                                node.ELEMENT_NODE
                                            ) {
                                                var needBlock_1 = false;
                                                if (
                                                    typeof blockClass ===
                                                    'string'
                                                ) {
                                                    needBlock_1 = node.classList.contains(
                                                        blockClass
                                                    );
                                                } else {
                                                    node.classList.forEach(
                                                        function (className) {
                                                            if (
                                                                blockClass.test(
                                                                    className
                                                                )
                                                            ) {
                                                                needBlock_1 = true;
                                                            }
                                                        }
                                                    );
                                                }
                                                return (
                                                    needBlock_1 ||
                                                    isBlocked(
                                                        node.parentNode,
                                                        blockClass
                                                    )
                                                );
                                            }
                                            if (
                                                node.nodeType === node.TEXT_NODE
                                            ) {
                                                return isBlocked(
                                                    node.parentNode,
                                                    blockClass
                                                );
                                            }
                                            return isBlocked(
                                                node.parentNode,
                                                blockClass
                                            );
                                        }
                                        exports.isBlocked = isBlocked;
                                        function isIgnored(n) {
                                            if ('__sn' in n) {
                                                return (
                                                    n.__sn.id ===
                                                    snapshot_1.IGNORED_NODE
                                                );
                                            }
                                            return false;
                                        }
                                        exports.isIgnored = isIgnored;
                                        function isAncestorRemoved(target) {
                                            var id = exports.mirror.getId(
                                                target
                                            );
                                            if (!exports.mirror.has(id)) {
                                                return true;
                                            }
                                            if (
                                                target.parentNode &&
                                                target.parentNode.nodeType ===
                                                    target.DOCUMENT_NODE
                                            ) {
                                                return false;
                                            }
                                            if (!target.parentNode) {
                                                return true;
                                            }
                                            return isAncestorRemoved(
                                                target.parentNode
                                            );
                                        }
                                        exports.isAncestorRemoved = isAncestorRemoved;
                                        function isTouchEvent(event) {
                                            return Boolean(
                                                event.changedTouches
                                            );
                                        }
                                        exports.isTouchEvent = isTouchEvent;
                                        function polyfill(win) {
                                            if (win === void 0) {
                                                win = window;
                                            }
                                            if (
                                                'NodeList' in win &&
                                                !win.NodeList.prototype.forEach
                                            ) {
                                                win.NodeList.prototype.forEach =
                                                    Array.prototype.forEach;
                                            }
                                            if (
                                                'DOMTokenList' in win &&
                                                !win.DOMTokenList.prototype
                                                    .forEach
                                            ) {
                                                win.DOMTokenList.prototype.forEach =
                                                    Array.prototype.forEach;
                                            }
                                        }
                                        exports.polyfill = polyfill;
                                        function needCastInSyncMode(event) {
                                            switch (event.type) {
                                                case types_1.EventType
                                                    .DomContentLoaded:
                                                case types_1.EventType.Load:
                                                case types_1.EventType.Custom:
                                                    return false;
                                                case types_1.EventType
                                                    .FullSnapshot:
                                                case types_1.EventType.Meta:
                                                    return true;
                                                default:
                                                    break;
                                            }
                                            switch (event.data.source) {
                                                case types_1.IncrementalSource
                                                    .MouseMove:
                                                case types_1.IncrementalSource
                                                    .MouseInteraction:
                                                case types_1.IncrementalSource
                                                    .TouchMove:
                                                case types_1.IncrementalSource
                                                    .MediaInteraction:
                                                    return false;
                                                case types_1.IncrementalSource
                                                    .ViewportResize:
                                                case types_1.IncrementalSource
                                                    .StyleSheetRule:
                                                case types_1.IncrementalSource
                                                    .Scroll:
                                                case types_1.IncrementalSource
                                                    .Input:
                                                    return true;
                                                default:
                                                    break;
                                            }
                                            return true;
                                        }
                                        exports.needCastInSyncMode = needCastInSyncMode;
                                        var TreeIndex = (function () {
                                            function TreeIndex() {
                                                this.reset();
                                            }
                                            TreeIndex.prototype.add = function (
                                                mutation
                                            ) {
                                                var parentTreeNode = this.indexes.get(
                                                    mutation.parentId
                                                );
                                                var treeNode = {
                                                    id: mutation.node.id,
                                                    mutation: mutation,
                                                    children: [],
                                                    texts: [],
                                                    attributes: [],
                                                };
                                                if (!parentTreeNode) {
                                                    this.tree[
                                                        treeNode.id
                                                    ] = treeNode;
                                                } else {
                                                    treeNode.parent = parentTreeNode;
                                                    parentTreeNode.children[
                                                        treeNode.id
                                                    ] = treeNode;
                                                }
                                                this.indexes.set(
                                                    treeNode.id,
                                                    treeNode
                                                );
                                            };
                                            TreeIndex.prototype.remove = function (
                                                mutation
                                            ) {
                                                var _this = this;
                                                var parentTreeNode = this.indexes.get(
                                                    mutation.parentId
                                                );
                                                var treeNode = this.indexes.get(
                                                    mutation.id
                                                );
                                                var deepRemoveFromMirror = function (
                                                    id
                                                ) {
                                                    _this.removeIdSet.add(id);
                                                    var node = exports.mirror.getNode(
                                                        id
                                                    );
                                                    node === null ||
                                                    node === void 0
                                                        ? void 0
                                                        : node.childNodes.forEach(
                                                              function (
                                                                  childNode
                                                              ) {
                                                                  if (
                                                                      '__sn' in
                                                                      childNode
                                                                  ) {
                                                                      deepRemoveFromMirror(
                                                                          childNode
                                                                              .__sn
                                                                              .id
                                                                      );
                                                                  }
                                                              }
                                                          );
                                                };
                                                var deepRemoveFromTreeIndex = function (
                                                    node
                                                ) {
                                                    _this.removeIdSet.add(
                                                        node.id
                                                    );
                                                    Object.values(
                                                        node.children
                                                    ).forEach(function (n) {
                                                        return deepRemoveFromTreeIndex(
                                                            n
                                                        );
                                                    });
                                                    var _treeNode = _this.indexes.get(
                                                        node.id
                                                    );
                                                    if (_treeNode) {
                                                        var _parentTreeNode =
                                                            _treeNode.parent;
                                                        if (_parentTreeNode) {
                                                            delete _treeNode.parent;
                                                            delete _parentTreeNode
                                                                .children[
                                                                _treeNode.id
                                                            ];
                                                            _this.indexes.delete(
                                                                mutation.id
                                                            );
                                                        }
                                                    }
                                                };
                                                if (!treeNode) {
                                                    this.removeNodeMutations.push(
                                                        mutation
                                                    );
                                                    deepRemoveFromMirror(
                                                        mutation.id
                                                    );
                                                } else if (!parentTreeNode) {
                                                    delete this.tree[
                                                        treeNode.id
                                                    ];
                                                    this.indexes.delete(
                                                        treeNode.id
                                                    );
                                                    deepRemoveFromTreeIndex(
                                                        treeNode
                                                    );
                                                } else {
                                                    delete treeNode.parent;
                                                    delete parentTreeNode
                                                        .children[treeNode.id];
                                                    this.indexes.delete(
                                                        mutation.id
                                                    );
                                                    deepRemoveFromTreeIndex(
                                                        treeNode
                                                    );
                                                }
                                            };
                                            TreeIndex.prototype.text = function (
                                                mutation
                                            ) {
                                                var treeNode = this.indexes.get(
                                                    mutation.id
                                                );
                                                if (treeNode) {
                                                    treeNode.texts.push(
                                                        mutation
                                                    );
                                                } else {
                                                    this.textMutations.push(
                                                        mutation
                                                    );
                                                }
                                            };
                                            TreeIndex.prototype.attribute = function (
                                                mutation
                                            ) {
                                                var treeNode = this.indexes.get(
                                                    mutation.id
                                                );
                                                if (treeNode) {
                                                    treeNode.attributes.push(
                                                        mutation
                                                    );
                                                } else {
                                                    this.attributeMutations.push(
                                                        mutation
                                                    );
                                                }
                                            };
                                            TreeIndex.prototype.scroll = function (
                                                d
                                            ) {
                                                this.scrollMap.set(d.id, d);
                                            };
                                            TreeIndex.prototype.input = function (
                                                d
                                            ) {
                                                this.inputMap.set(d.id, d);
                                            };
                                            TreeIndex.prototype.flush = function () {
                                                var e_1, _a, e_2, _b;
                                                var _this = this;
                                                var _c = this,
                                                    tree = _c.tree,
                                                    removeNodeMutations =
                                                        _c.removeNodeMutations,
                                                    textMutations =
                                                        _c.textMutations,
                                                    attributeMutations =
                                                        _c.attributeMutations;
                                                var batchMutationData = {
                                                    source:
                                                        types_1
                                                            .IncrementalSource
                                                            .Mutation,
                                                    removes: removeNodeMutations,
                                                    texts: textMutations,
                                                    attributes: attributeMutations,
                                                    adds: [],
                                                };
                                                var walk = function (
                                                    treeNode,
                                                    removed
                                                ) {
                                                    if (removed) {
                                                        _this.removeIdSet.add(
                                                            treeNode.id
                                                        );
                                                    }
                                                    batchMutationData.texts = batchMutationData.texts
                                                        .concat(
                                                            removed
                                                                ? []
                                                                : treeNode.texts
                                                        )
                                                        .filter(function (m) {
                                                            return !_this.removeIdSet.has(
                                                                m.id
                                                            );
                                                        });
                                                    batchMutationData.attributes = batchMutationData.attributes
                                                        .concat(
                                                            removed
                                                                ? []
                                                                : treeNode.attributes
                                                        )
                                                        .filter(function (m) {
                                                            return !_this.removeIdSet.has(
                                                                m.id
                                                            );
                                                        });
                                                    if (
                                                        !_this.removeIdSet.has(
                                                            treeNode.id
                                                        ) &&
                                                        !_this.removeIdSet.has(
                                                            treeNode.mutation
                                                                .parentId
                                                        ) &&
                                                        !removed
                                                    ) {
                                                        batchMutationData.adds.push(
                                                            treeNode.mutation
                                                        );
                                                        if (treeNode.children) {
                                                            Object.values(
                                                                treeNode.children
                                                            ).forEach(function (
                                                                n
                                                            ) {
                                                                return walk(
                                                                    n,
                                                                    false
                                                                );
                                                            });
                                                        }
                                                    } else {
                                                        Object.values(
                                                            treeNode.children
                                                        ).forEach(function (n) {
                                                            return walk(
                                                                n,
                                                                true
                                                            );
                                                        });
                                                    }
                                                };
                                                Object.values(tree).forEach(
                                                    function (n) {
                                                        return walk(n, false);
                                                    }
                                                );
                                                try {
                                                    for (
                                                        var _d = __values(
                                                                this.scrollMap.keys()
                                                            ),
                                                            _e = _d.next();
                                                        !_e.done;
                                                        _e = _d.next()
                                                    ) {
                                                        var id = _e.value;
                                                        if (
                                                            this.removeIdSet.has(
                                                                id
                                                            )
                                                        ) {
                                                            this.scrollMap.delete(
                                                                id
                                                            );
                                                        }
                                                    }
                                                } catch (e_1_1) {
                                                    e_1 = { error: e_1_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _e &&
                                                            !_e.done &&
                                                            (_a = _d.return)
                                                        )
                                                            _a.call(_d);
                                                    } finally {
                                                        if (e_1)
                                                            throw e_1.error;
                                                    }
                                                }
                                                try {
                                                    for (
                                                        var _f = __values(
                                                                this.inputMap.keys()
                                                            ),
                                                            _g = _f.next();
                                                        !_g.done;
                                                        _g = _f.next()
                                                    ) {
                                                        var id = _g.value;
                                                        if (
                                                            this.removeIdSet.has(
                                                                id
                                                            )
                                                        ) {
                                                            this.inputMap.delete(
                                                                id
                                                            );
                                                        }
                                                    }
                                                } catch (e_2_1) {
                                                    e_2 = { error: e_2_1 };
                                                } finally {
                                                    try {
                                                        if (
                                                            _g &&
                                                            !_g.done &&
                                                            (_b = _f.return)
                                                        )
                                                            _b.call(_f);
                                                    } finally {
                                                        if (e_2)
                                                            throw e_2.error;
                                                    }
                                                }
                                                var scrollMap = new Map(
                                                    this.scrollMap
                                                );
                                                var inputMap = new Map(
                                                    this.inputMap
                                                );
                                                this.reset();
                                                return {
                                                    mutationData: batchMutationData,
                                                    scrollMap: scrollMap,
                                                    inputMap: inputMap,
                                                };
                                            };
                                            TreeIndex.prototype.reset = function () {
                                                this.tree = [];
                                                this.indexes = new Map();
                                                this.removeNodeMutations = [];
                                                this.textMutations = [];
                                                this.attributeMutations = [];
                                                this.removeIdSet = new Set();
                                                this.scrollMap = new Map();
                                                this.inputMap = new Map();
                                            };
                                            return TreeIndex;
                                        })();
                                        exports.TreeIndex = TreeIndex;
                                        function queueToResolveTrees(queue) {
                                            var e_3, _a;
                                            var queueNodeMap = {};
                                            var putIntoMap = function (
                                                m,
                                                parent
                                            ) {
                                                var nodeInTree = {
                                                    value: m,
                                                    parent: parent,
                                                    children: [],
                                                };
                                                queueNodeMap[
                                                    m.node.id
                                                ] = nodeInTree;
                                                return nodeInTree;
                                            };
                                            var queueNodeTrees = [];
                                            try {
                                                for (
                                                    var queue_1 = __values(
                                                            queue
                                                        ),
                                                        queue_1_1 = queue_1.next();
                                                    !queue_1_1.done;
                                                    queue_1_1 = queue_1.next()
                                                ) {
                                                    var mutation =
                                                        queue_1_1.value;
                                                    var nextId =
                                                            mutation.nextId,
                                                        parentId =
                                                            mutation.parentId;
                                                    if (
                                                        nextId &&
                                                        nextId in queueNodeMap
                                                    ) {
                                                        var nextInTree =
                                                            queueNodeMap[
                                                                nextId
                                                            ];
                                                        if (nextInTree.parent) {
                                                            var idx = nextInTree.parent.children.indexOf(
                                                                nextInTree
                                                            );
                                                            nextInTree.parent.children.splice(
                                                                idx,
                                                                0,
                                                                putIntoMap(
                                                                    mutation,
                                                                    nextInTree.parent
                                                                )
                                                            );
                                                        } else {
                                                            var idx = queueNodeTrees.indexOf(
                                                                nextInTree
                                                            );
                                                            queueNodeTrees.splice(
                                                                idx,
                                                                0,
                                                                putIntoMap(
                                                                    mutation,
                                                                    null
                                                                )
                                                            );
                                                        }
                                                        continue;
                                                    }
                                                    if (
                                                        parentId in queueNodeMap
                                                    ) {
                                                        var parentInTree =
                                                            queueNodeMap[
                                                                parentId
                                                            ];
                                                        parentInTree.children.push(
                                                            putIntoMap(
                                                                mutation,
                                                                parentInTree
                                                            )
                                                        );
                                                        continue;
                                                    }
                                                    queueNodeTrees.push(
                                                        putIntoMap(
                                                            mutation,
                                                            null
                                                        )
                                                    );
                                                }
                                            } catch (e_3_1) {
                                                e_3 = { error: e_3_1 };
                                            } finally {
                                                try {
                                                    if (
                                                        queue_1_1 &&
                                                        !queue_1_1.done &&
                                                        (_a = queue_1.return)
                                                    )
                                                        _a.call(queue_1);
                                                } finally {
                                                    if (e_3) throw e_3.error;
                                                }
                                            }
                                            return queueNodeTrees;
                                        }
                                        exports.queueToResolveTrees = queueToResolveTrees;
                                        function iterateResolveTree(tree, cb) {
                                            cb(tree.value);
                                            for (
                                                var i =
                                                    tree.children.length - 1;
                                                i >= 0;
                                                i--
                                            ) {
                                                iterateResolveTree(
                                                    tree.children[i],
                                                    cb
                                                );
                                            }
                                        }
                                        exports.iterateResolveTree = iterateResolveTree;

                                        /***/
                                    },

                                /******/
                            }; // The module cache
                            /************************************************************************/
                            /******/ /******/ var __webpack_module_cache__ = {}; // The require function
                            /******/
                            /******/ /******/ function __nested_webpack_require_215901__(
                                moduleId
                            ) {
                                /******/ // Check if module is in cache
                                /******/ if (
                                    __webpack_module_cache__[moduleId]
                                ) {
                                    /******/ return __webpack_module_cache__[
                                        moduleId
                                    ].exports;
                                    /******/
                                } // Create a new module (and put it into the cache)
                                /******/ /******/ var module = (__webpack_module_cache__[
                                    moduleId
                                ] = {
                                    /******/ // no module.id needed
                                    /******/ // no module.loaded needed
                                    /******/ exports: {},
                                    /******/
                                }); // Execute the module function
                                /******/
                                /******/ /******/ __webpack_modules__[
                                    moduleId
                                ].call(
                                    module.exports,
                                    module,
                                    module.exports,
                                    __nested_webpack_require_215901__
                                ); // Return the exports of the module
                                /******/
                                /******/ /******/ return module.exports;
                                /******/
                            } /* webpack/runtime/define property getters */
                            /******/
                            /************************************************************************/
                            /******/ /******/ (() => {
                                /******/ // define getter functions for harmony exports
                                /******/ __nested_webpack_require_215901__.d = (
                                    exports,
                                    definition
                                ) => {
                                    /******/ for (var key in definition) {
                                        /******/ if (
                                            __nested_webpack_require_215901__.o(
                                                definition,
                                                key
                                            ) &&
                                            !__nested_webpack_require_215901__.o(
                                                exports,
                                                key
                                            )
                                        ) {
                                            /******/ Object.defineProperty(
                                                exports,
                                                key,
                                                {
                                                    enumerable: true,
                                                    get: definition[key],
                                                }
                                            );
                                            /******/
                                        }
                                        /******/
                                    }
                                    /******/
                                };
                                /******/
                            })(); /* webpack/runtime/hasOwnProperty shorthand */
                            /******/
                            /******/ /******/ (() => {
                                /******/ __nested_webpack_require_215901__.o = (
                                    obj,
                                    prop
                                ) =>
                                    Object.prototype.hasOwnProperty.call(
                                        obj,
                                        prop
                                    );
                                /******/
                            })(); /* webpack/runtime/make namespace object */
                            /******/
                            /******/ /******/ (() => {
                                /******/ // define __esModule on exports
                                /******/ __nested_webpack_require_215901__.r = (
                                    exports
                                ) => {
                                    /******/ if (
                                        typeof Symbol !== 'undefined' &&
                                        Symbol.toStringTag
                                    ) {
                                        /******/ Object.defineProperty(
                                            exports,
                                            Symbol.toStringTag,
                                            { value: 'Module' }
                                        );
                                        /******/
                                    }
                                    /******/ Object.defineProperty(
                                        exports,
                                        '__esModule',
                                        { value: true }
                                    );
                                    /******/
                                };
                                /******/
                            })();
                            /******/
                            /************************************************************************/
                            var __webpack_exports__ = {};
                            // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
                            (() => {
                                var exports = __webpack_exports__;
                                /*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

                                Object.defineProperty(exports, '__esModule', {
                                    value: true,
                                });
                                exports.utils = exports.mirror = exports.Replayer = exports.freezePage = exports.addCustomEvent = exports.record = void 0;
                                var record_1 = __nested_webpack_require_215901__(
                                    /*! ./record */ './src/record/index.ts'
                                );
                                exports.record = record_1.default;
                                var replay_1 = __nested_webpack_require_215901__(
                                    /*! ./replay */ './src/replay/index.ts'
                                );
                                Object.defineProperty(exports, 'Replayer', {
                                    enumerable: true,
                                    get: function () {
                                        return replay_1.Replayer;
                                    },
                                });
                                var utils_1 = __nested_webpack_require_215901__(
                                    /*! ./utils */ './src/utils.ts'
                                );
                                Object.defineProperty(exports, 'mirror', {
                                    enumerable: true,
                                    get: function () {
                                        return utils_1.mirror;
                                    },
                                });
                                var utils = __nested_webpack_require_215901__(
                                    /*! ./utils */ './src/utils.ts'
                                );
                                exports.utils = utils;
                                var types_1 = __nested_webpack_require_215901__(
                                    /*! ./types */ './src/types.ts'
                                );
                                Object.defineProperty(exports, 'EventType', {
                                    enumerable: true,
                                    get: function () {
                                        return types_1.EventType;
                                    },
                                });
                                Object.defineProperty(
                                    exports,
                                    'IncrementalSource',
                                    {
                                        enumerable: true,
                                        get: function () {
                                            return types_1.IncrementalSource;
                                        },
                                    }
                                );
                                Object.defineProperty(
                                    exports,
                                    'MouseInteractions',
                                    {
                                        enumerable: true,
                                        get: function () {
                                            return types_1.MouseInteractions;
                                        },
                                    }
                                );
                                Object.defineProperty(
                                    exports,
                                    'ReplayerEvents',
                                    {
                                        enumerable: true,
                                        get: function () {
                                            return types_1.ReplayerEvents;
                                        },
                                    }
                                );
                                var addCustomEvent =
                                    record_1.default.addCustomEvent;
                                exports.addCustomEvent = addCustomEvent;
                                var freezePage = record_1.default.freezePage;
                                exports.freezePage = freezePage;
                            })();

                            /******/ return __webpack_exports__;
                            /******/
                        })();
                    });
                    //# sourceMappingURL=index.js.map

                    /***/
                },

            /***/ './node_modules/cross-fetch/dist/browser-ponyfill.js':
                /*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
                /***/ function (module, exports) {
                    var __self__ = (function (root) {
                        function F() {
                            this.fetch = false;
                            this.DOMException = root.DOMException;
                        }
                        F.prototype = root;
                        return new F();
                    })(typeof self !== 'undefined' ? self : this);
                    (function (self) {
                        var irrelevant = (function (exports) {
                            var support = {
                                searchParams: 'URLSearchParams' in self,
                                iterable:
                                    'Symbol' in self && 'iterator' in Symbol,
                                blob:
                                    'FileReader' in self &&
                                    'Blob' in self &&
                                    (function () {
                                        try {
                                            new Blob();
                                            return true;
                                        } catch (e) {
                                            return false;
                                        }
                                    })(),
                                formData: 'FormData' in self,
                                arrayBuffer: 'ArrayBuffer' in self,
                            };

                            function isDataView(obj) {
                                return (
                                    obj && DataView.prototype.isPrototypeOf(obj)
                                );
                            }

                            if (support.arrayBuffer) {
                                var viewClasses = [
                                    '[object Int8Array]',
                                    '[object Uint8Array]',
                                    '[object Uint8ClampedArray]',
                                    '[object Int16Array]',
                                    '[object Uint16Array]',
                                    '[object Int32Array]',
                                    '[object Uint32Array]',
                                    '[object Float32Array]',
                                    '[object Float64Array]',
                                ];

                                var isArrayBufferView =
                                    ArrayBuffer.isView ||
                                    function (obj) {
                                        return (
                                            obj &&
                                            viewClasses.indexOf(
                                                Object.prototype.toString.call(
                                                    obj
                                                )
                                            ) > -1
                                        );
                                    };
                            }

                            function normalizeName(name) {
                                if (typeof name !== 'string') {
                                    name = String(name);
                                }
                                if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
                                    throw new TypeError(
                                        'Invalid character in header field name'
                                    );
                                }
                                return name.toLowerCase();
                            }

                            function normalizeValue(value) {
                                if (typeof value !== 'string') {
                                    value = String(value);
                                }
                                return value;
                            }

                            // Build a destructive iterator for the value list
                            function iteratorFor(items) {
                                var iterator = {
                                    next: function () {
                                        var value = items.shift();
                                        return {
                                            done: value === undefined,
                                            value: value,
                                        };
                                    },
                                };

                                if (support.iterable) {
                                    iterator[Symbol.iterator] = function () {
                                        return iterator;
                                    };
                                }

                                return iterator;
                            }

                            function Headers(headers) {
                                this.map = {};

                                if (headers instanceof Headers) {
                                    headers.forEach(function (value, name) {
                                        this.append(name, value);
                                    }, this);
                                } else if (Array.isArray(headers)) {
                                    headers.forEach(function (header) {
                                        this.append(header[0], header[1]);
                                    }, this);
                                } else if (headers) {
                                    Object.getOwnPropertyNames(headers).forEach(
                                        function (name) {
                                            this.append(name, headers[name]);
                                        },
                                        this
                                    );
                                }
                            }

                            Headers.prototype.append = function (name, value) {
                                name = normalizeName(name);
                                value = normalizeValue(value);
                                var oldValue = this.map[name];
                                this.map[name] = oldValue
                                    ? oldValue + ', ' + value
                                    : value;
                            };

                            Headers.prototype['delete'] = function (name) {
                                delete this.map[normalizeName(name)];
                            };

                            Headers.prototype.get = function (name) {
                                name = normalizeName(name);
                                return this.has(name) ? this.map[name] : null;
                            };

                            Headers.prototype.has = function (name) {
                                return this.map.hasOwnProperty(
                                    normalizeName(name)
                                );
                            };

                            Headers.prototype.set = function (name, value) {
                                this.map[normalizeName(name)] = normalizeValue(
                                    value
                                );
                            };

                            Headers.prototype.forEach = function (
                                callback,
                                thisArg
                            ) {
                                for (var name in this.map) {
                                    if (this.map.hasOwnProperty(name)) {
                                        callback.call(
                                            thisArg,
                                            this.map[name],
                                            name,
                                            this
                                        );
                                    }
                                }
                            };

                            Headers.prototype.keys = function () {
                                var items = [];
                                this.forEach(function (value, name) {
                                    items.push(name);
                                });
                                return iteratorFor(items);
                            };

                            Headers.prototype.values = function () {
                                var items = [];
                                this.forEach(function (value) {
                                    items.push(value);
                                });
                                return iteratorFor(items);
                            };

                            Headers.prototype.entries = function () {
                                var items = [];
                                this.forEach(function (value, name) {
                                    items.push([name, value]);
                                });
                                return iteratorFor(items);
                            };

                            if (support.iterable) {
                                Headers.prototype[Symbol.iterator] =
                                    Headers.prototype.entries;
                            }

                            function consumed(body) {
                                if (body.bodyUsed) {
                                    return Promise.reject(
                                        new TypeError('Already read')
                                    );
                                }
                                body.bodyUsed = true;
                            }

                            function fileReaderReady(reader) {
                                return new Promise(function (resolve, reject) {
                                    reader.onload = function () {
                                        resolve(reader.result);
                                    };
                                    reader.onerror = function () {
                                        reject(reader.error);
                                    };
                                });
                            }

                            function readBlobAsArrayBuffer(blob) {
                                var reader = new FileReader();
                                var promise = fileReaderReady(reader);
                                reader.readAsArrayBuffer(blob);
                                return promise;
                            }

                            function readBlobAsText(blob) {
                                var reader = new FileReader();
                                var promise = fileReaderReady(reader);
                                reader.readAsText(blob);
                                return promise;
                            }

                            function readArrayBufferAsText(buf) {
                                var view = new Uint8Array(buf);
                                var chars = new Array(view.length);

                                for (var i = 0; i < view.length; i++) {
                                    chars[i] = String.fromCharCode(view[i]);
                                }
                                return chars.join('');
                            }

                            function bufferClone(buf) {
                                if (buf.slice) {
                                    return buf.slice(0);
                                } else {
                                    var view = new Uint8Array(buf.byteLength);
                                    view.set(new Uint8Array(buf));
                                    return view.buffer;
                                }
                            }

                            function Body() {
                                this.bodyUsed = false;

                                this._initBody = function (body) {
                                    this._bodyInit = body;
                                    if (!body) {
                                        this._bodyText = '';
                                    } else if (typeof body === 'string') {
                                        this._bodyText = body;
                                    } else if (
                                        support.blob &&
                                        Blob.prototype.isPrototypeOf(body)
                                    ) {
                                        this._bodyBlob = body;
                                    } else if (
                                        support.formData &&
                                        FormData.prototype.isPrototypeOf(body)
                                    ) {
                                        this._bodyFormData = body;
                                    } else if (
                                        support.searchParams &&
                                        URLSearchParams.prototype.isPrototypeOf(
                                            body
                                        )
                                    ) {
                                        this._bodyText = body.toString();
                                    } else if (
                                        support.arrayBuffer &&
                                        support.blob &&
                                        isDataView(body)
                                    ) {
                                        this._bodyArrayBuffer = bufferClone(
                                            body.buffer
                                        );
                                        // IE 10-11 can't handle a DataView body.
                                        this._bodyInit = new Blob([
                                            this._bodyArrayBuffer,
                                        ]);
                                    } else if (
                                        support.arrayBuffer &&
                                        (ArrayBuffer.prototype.isPrototypeOf(
                                            body
                                        ) ||
                                            isArrayBufferView(body))
                                    ) {
                                        this._bodyArrayBuffer = bufferClone(
                                            body
                                        );
                                    } else {
                                        this._bodyText = body = Object.prototype.toString.call(
                                            body
                                        );
                                    }

                                    if (!this.headers.get('content-type')) {
                                        if (typeof body === 'string') {
                                            this.headers.set(
                                                'content-type',
                                                'text/plain;charset=UTF-8'
                                            );
                                        } else if (
                                            this._bodyBlob &&
                                            this._bodyBlob.type
                                        ) {
                                            this.headers.set(
                                                'content-type',
                                                this._bodyBlob.type
                                            );
                                        } else if (
                                            support.searchParams &&
                                            URLSearchParams.prototype.isPrototypeOf(
                                                body
                                            )
                                        ) {
                                            this.headers.set(
                                                'content-type',
                                                'application/x-www-form-urlencoded;charset=UTF-8'
                                            );
                                        }
                                    }
                                };

                                if (support.blob) {
                                    this.blob = function () {
                                        var rejected = consumed(this);
                                        if (rejected) {
                                            return rejected;
                                        }

                                        if (this._bodyBlob) {
                                            return Promise.resolve(
                                                this._bodyBlob
                                            );
                                        } else if (this._bodyArrayBuffer) {
                                            return Promise.resolve(
                                                new Blob([
                                                    this._bodyArrayBuffer,
                                                ])
                                            );
                                        } else if (this._bodyFormData) {
                                            throw new Error(
                                                'could not read FormData body as blob'
                                            );
                                        } else {
                                            return Promise.resolve(
                                                new Blob([this._bodyText])
                                            );
                                        }
                                    };

                                    this.arrayBuffer = function () {
                                        if (this._bodyArrayBuffer) {
                                            return (
                                                consumed(this) ||
                                                Promise.resolve(
                                                    this._bodyArrayBuffer
                                                )
                                            );
                                        } else {
                                            return this.blob().then(
                                                readBlobAsArrayBuffer
                                            );
                                        }
                                    };
                                }

                                this.text = function () {
                                    var rejected = consumed(this);
                                    if (rejected) {
                                        return rejected;
                                    }

                                    if (this._bodyBlob) {
                                        return readBlobAsText(this._bodyBlob);
                                    } else if (this._bodyArrayBuffer) {
                                        return Promise.resolve(
                                            readArrayBufferAsText(
                                                this._bodyArrayBuffer
                                            )
                                        );
                                    } else if (this._bodyFormData) {
                                        throw new Error(
                                            'could not read FormData body as text'
                                        );
                                    } else {
                                        return Promise.resolve(this._bodyText);
                                    }
                                };

                                if (support.formData) {
                                    this.formData = function () {
                                        return this.text().then(decode);
                                    };
                                }

                                this.json = function () {
                                    return this.text().then(JSON.parse);
                                };

                                return this;
                            }

                            // HTTP methods whose capitalization should be normalized
                            var methods = [
                                'DELETE',
                                'GET',
                                'HEAD',
                                'OPTIONS',
                                'POST',
                                'PUT',
                            ];

                            function normalizeMethod(method) {
                                var upcased = method.toUpperCase();
                                return methods.indexOf(upcased) > -1
                                    ? upcased
                                    : method;
                            }

                            function Request(input, options) {
                                options = options || {};
                                var body = options.body;

                                if (input instanceof Request) {
                                    if (input.bodyUsed) {
                                        throw new TypeError('Already read');
                                    }
                                    this.url = input.url;
                                    this.credentials = input.credentials;
                                    if (!options.headers) {
                                        this.headers = new Headers(
                                            input.headers
                                        );
                                    }
                                    this.method = input.method;
                                    this.mode = input.mode;
                                    this.signal = input.signal;
                                    if (!body && input._bodyInit != null) {
                                        body = input._bodyInit;
                                        input.bodyUsed = true;
                                    }
                                } else {
                                    this.url = String(input);
                                }

                                this.credentials =
                                    options.credentials ||
                                    this.credentials ||
                                    'same-origin';
                                if (options.headers || !this.headers) {
                                    this.headers = new Headers(options.headers);
                                }
                                this.method = normalizeMethod(
                                    options.method || this.method || 'GET'
                                );
                                this.mode = options.mode || this.mode || null;
                                this.signal = options.signal || this.signal;
                                this.referrer = null;

                                if (
                                    (this.method === 'GET' ||
                                        this.method === 'HEAD') &&
                                    body
                                ) {
                                    throw new TypeError(
                                        'Body not allowed for GET or HEAD requests'
                                    );
                                }
                                this._initBody(body);
                            }

                            Request.prototype.clone = function () {
                                return new Request(this, {
                                    body: this._bodyInit,
                                });
                            };

                            function decode(body) {
                                var form = new FormData();
                                body.trim()
                                    .split('&')
                                    .forEach(function (bytes) {
                                        if (bytes) {
                                            var split = bytes.split('=');
                                            var name = split
                                                .shift()
                                                .replace(/\+/g, ' ');
                                            var value = split
                                                .join('=')
                                                .replace(/\+/g, ' ');
                                            form.append(
                                                decodeURIComponent(name),
                                                decodeURIComponent(value)
                                            );
                                        }
                                    });
                                return form;
                            }

                            function parseHeaders(rawHeaders) {
                                var headers = new Headers();
                                // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
                                // https://tools.ietf.org/html/rfc7230#section-3.2
                                var preProcessedHeaders = rawHeaders.replace(
                                    /\r?\n[\t ]+/g,
                                    ' '
                                );
                                preProcessedHeaders
                                    .split(/\r?\n/)
                                    .forEach(function (line) {
                                        var parts = line.split(':');
                                        var key = parts.shift().trim();
                                        if (key) {
                                            var value = parts.join(':').trim();
                                            headers.append(key, value);
                                        }
                                    });
                                return headers;
                            }

                            Body.call(Request.prototype);

                            function Response(bodyInit, options) {
                                if (!options) {
                                    options = {};
                                }

                                this.type = 'default';
                                this.status =
                                    options.status === undefined
                                        ? 200
                                        : options.status;
                                this.ok =
                                    this.status >= 200 && this.status < 300;
                                this.statusText =
                                    'statusText' in options
                                        ? options.statusText
                                        : 'OK';
                                this.headers = new Headers(options.headers);
                                this.url = options.url || '';
                                this._initBody(bodyInit);
                            }

                            Body.call(Response.prototype);

                            Response.prototype.clone = function () {
                                return new Response(this._bodyInit, {
                                    status: this.status,
                                    statusText: this.statusText,
                                    headers: new Headers(this.headers),
                                    url: this.url,
                                });
                            };

                            Response.error = function () {
                                var response = new Response(null, {
                                    status: 0,
                                    statusText: '',
                                });
                                response.type = 'error';
                                return response;
                            };

                            var redirectStatuses = [301, 302, 303, 307, 308];

                            Response.redirect = function (url, status) {
                                if (redirectStatuses.indexOf(status) === -1) {
                                    throw new RangeError('Invalid status code');
                                }

                                return new Response(null, {
                                    status: status,
                                    headers: { location: url },
                                });
                            };

                            exports.DOMException = self.DOMException;
                            try {
                                new exports.DOMException();
                            } catch (err) {
                                exports.DOMException = function (
                                    message,
                                    name
                                ) {
                                    this.message = message;
                                    this.name = name;
                                    var error = Error(message);
                                    this.stack = error.stack;
                                };
                                exports.DOMException.prototype = Object.create(
                                    Error.prototype
                                );
                                exports.DOMException.prototype.constructor =
                                    exports.DOMException;
                            }

                            function fetch(input, init) {
                                return new Promise(function (resolve, reject) {
                                    var request = new Request(input, init);

                                    if (
                                        request.signal &&
                                        request.signal.aborted
                                    ) {
                                        return reject(
                                            new exports.DOMException(
                                                'Aborted',
                                                'AbortError'
                                            )
                                        );
                                    }

                                    var xhr = new XMLHttpRequest();

                                    function abortXhr() {
                                        xhr.abort();
                                    }

                                    xhr.onload = function () {
                                        var options = {
                                            status: xhr.status,
                                            statusText: xhr.statusText,
                                            headers: parseHeaders(
                                                xhr.getAllResponseHeaders() ||
                                                    ''
                                            ),
                                        };
                                        options.url =
                                            'responseURL' in xhr
                                                ? xhr.responseURL
                                                : options.headers.get(
                                                      'X-Request-URL'
                                                  );
                                        var body =
                                            'response' in xhr
                                                ? xhr.response
                                                : xhr.responseText;
                                        resolve(new Response(body, options));
                                    };

                                    xhr.onerror = function () {
                                        reject(
                                            new TypeError(
                                                'Network request failed'
                                            )
                                        );
                                    };

                                    xhr.ontimeout = function () {
                                        reject(
                                            new TypeError(
                                                'Network request failed'
                                            )
                                        );
                                    };

                                    xhr.onabort = function () {
                                        reject(
                                            new exports.DOMException(
                                                'Aborted',
                                                'AbortError'
                                            )
                                        );
                                    };

                                    xhr.open(request.method, request.url, true);

                                    if (request.credentials === 'include') {
                                        xhr.withCredentials = true;
                                    } else if (request.credentials === 'omit') {
                                        xhr.withCredentials = false;
                                    }

                                    if ('responseType' in xhr && support.blob) {
                                        xhr.responseType = 'blob';
                                    }

                                    request.headers.forEach(function (
                                        value,
                                        name
                                    ) {
                                        xhr.setRequestHeader(name, value);
                                    });

                                    if (request.signal) {
                                        request.signal.addEventListener(
                                            'abort',
                                            abortXhr
                                        );

                                        xhr.onreadystatechange = function () {
                                            // DONE (success or failure)
                                            if (xhr.readyState === 4) {
                                                request.signal.removeEventListener(
                                                    'abort',
                                                    abortXhr
                                                );
                                            }
                                        };
                                    }

                                    xhr.send(
                                        typeof request._bodyInit === 'undefined'
                                            ? null
                                            : request._bodyInit
                                    );
                                });
                            }

                            fetch.polyfill = true;

                            if (!self.fetch) {
                                self.fetch = fetch;
                                self.Headers = Headers;
                                self.Request = Request;
                                self.Response = Response;
                            }

                            exports.Headers = Headers;
                            exports.Request = Request;
                            exports.Response = Response;
                            exports.fetch = fetch;

                            return exports;
                        })({});
                    })(__self__);
                    delete __self__.fetch.polyfill;
                    exports = __self__.fetch; // To enable: import fetch from 'cross-fetch'
                    exports.default = __self__.fetch; // For TypeScript consumers without esModuleInterop.
                    exports.fetch = __self__.fetch; // To enable: import {fetch} from 'cross-fetch'
                    exports.Headers = __self__.Headers;
                    exports.Request = __self__.Request;
                    exports.Response = __self__.Response;
                    module.exports = exports;

                    /***/
                },

            /***/ './node_modules/error-stack-parser/error-stack-parser.js':
                /*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
                /***/ function (module, exports, __webpack_require__) {
                    var __WEBPACK_AMD_DEFINE_FACTORY__,
                        __WEBPACK_AMD_DEFINE_ARRAY__,
                        __WEBPACK_AMD_DEFINE_RESULT__;
                    (function (root, factory) {
                        'use strict';
                        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

                        /* istanbul ignore next */
                        if (true) {
                            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                                __webpack_require__(
                                    /*! stackframe */ './node_modules/stackframe/stackframe.js'
                                ),
                            ]),
                            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
                            (__WEBPACK_AMD_DEFINE_RESULT__ =
                                typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
                                'function'
                                    ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                          exports,
                                          __WEBPACK_AMD_DEFINE_ARRAY__
                                      )
                                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else {
                        }
                    })(this, function ErrorStackParser(StackFrame) {
                        'use strict';

                        var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
                        var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
                        var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

                        return {
                            /**
                             * Given an Error object, extract the most information from it.
                             *
                             * @param {Error} error object
                             * @return {Array} of StackFrames
                             */
                            parse: function ErrorStackParser$$parse(error) {
                                if (
                                    typeof error.stacktrace !== 'undefined' ||
                                    typeof error['opera#sourceloc'] !==
                                        'undefined'
                                ) {
                                    return this.parseOpera(error);
                                } else if (
                                    error.stack &&
                                    error.stack.match(CHROME_IE_STACK_REGEXP)
                                ) {
                                    return this.parseV8OrIE(error);
                                } else if (error.stack) {
                                    return this.parseFFOrSafari(error);
                                } else {
                                    throw new Error(
                                        'Cannot parse given Error object'
                                    );
                                }
                            },

                            // Separate line and column numbers from a string of the form: (URI:Line:Column)
                            extractLocation: function ErrorStackParser$$extractLocation(
                                urlLike
                            ) {
                                // Fail-fast but return locations like "(native)"
                                if (urlLike.indexOf(':') === -1) {
                                    return [urlLike];
                                }

                                var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
                                var parts = regExp.exec(
                                    urlLike.replace(/[()]/g, '')
                                );
                                return [
                                    parts[1],
                                    parts[2] || undefined,
                                    parts[3] || undefined,
                                ];
                            },

                            parseV8OrIE: function ErrorStackParser$$parseV8OrIE(
                                error
                            ) {
                                var filtered = error.stack
                                    .split('\n')
                                    .filter(function (line) {
                                        return !!line.match(
                                            CHROME_IE_STACK_REGEXP
                                        );
                                    }, this);

                                return filtered.map(function (line) {
                                    if (line.indexOf('(eval ') > -1) {
                                        // Throw away eval information until we implement stacktrace.js/stackframe#8
                                        line = line
                                            .replace(/eval code/g, 'eval')
                                            .replace(
                                                /(\(eval at [^()]*)|(\),.*$)/g,
                                                ''
                                            );
                                    }
                                    var sanitizedLine = line
                                        .replace(/^\s+/, '')
                                        .replace(/\(eval code/g, '(');

                                    // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                                    // case it has spaces in it, as the string is split on \s+ later on
                                    var location = sanitizedLine.match(
                                        / (\((.+):(\d+):(\d+)\)$)/
                                    );

                                    // remove the parenthesized location from the line, if it was matched
                                    sanitizedLine = location
                                        ? sanitizedLine.replace(location[0], '')
                                        : sanitizedLine;

                                    var tokens = sanitizedLine
                                        .split(/\s+/)
                                        .slice(1);
                                    // if a location was matched, pass it to extractLocation() otherwise pop the last token
                                    var locationParts = this.extractLocation(
                                        location ? location[1] : tokens.pop()
                                    );
                                    var functionName =
                                        tokens.join(' ') || undefined;
                                    var fileName =
                                        ['eval', '<anonymous>'].indexOf(
                                            locationParts[0]
                                        ) > -1
                                            ? undefined
                                            : locationParts[0];

                                    return new StackFrame({
                                        functionName: functionName,
                                        fileName: fileName,
                                        lineNumber: locationParts[1],
                                        columnNumber: locationParts[2],
                                        source: line,
                                    });
                                }, this);
                            },

                            parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(
                                error
                            ) {
                                var filtered = error.stack
                                    .split('\n')
                                    .filter(function (line) {
                                        return !line.match(
                                            SAFARI_NATIVE_CODE_REGEXP
                                        );
                                    }, this);

                                return filtered.map(function (line) {
                                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                                    if (line.indexOf(' > eval') > -1) {
                                        line = line.replace(
                                            / line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,
                                            ':$1'
                                        );
                                    }

                                    if (
                                        line.indexOf('@') === -1 &&
                                        line.indexOf(':') === -1
                                    ) {
                                        // Safari eval frames only have function names and nothing else
                                        return new StackFrame({
                                            functionName: line,
                                        });
                                    } else {
                                        var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                                        var matches = line.match(
                                            functionNameRegex
                                        );
                                        var functionName =
                                            matches && matches[1]
                                                ? matches[1]
                                                : undefined;
                                        var locationParts = this.extractLocation(
                                            line.replace(functionNameRegex, '')
                                        );

                                        return new StackFrame({
                                            functionName: functionName,
                                            fileName: locationParts[0],
                                            lineNumber: locationParts[1],
                                            columnNumber: locationParts[2],
                                            source: line,
                                        });
                                    }
                                }, this);
                            },

                            parseOpera: function ErrorStackParser$$parseOpera(
                                e
                            ) {
                                if (
                                    !e.stacktrace ||
                                    (e.message.indexOf('\n') > -1 &&
                                        e.message.split('\n').length >
                                            e.stacktrace.split('\n').length)
                                ) {
                                    return this.parseOpera9(e);
                                } else if (!e.stack) {
                                    return this.parseOpera10(e);
                                } else {
                                    return this.parseOpera11(e);
                                }
                            },

                            parseOpera9: function ErrorStackParser$$parseOpera9(
                                e
                            ) {
                                var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
                                var lines = e.message.split('\n');
                                var result = [];

                                for (
                                    var i = 2, len = lines.length;
                                    i < len;
                                    i += 2
                                ) {
                                    var match = lineRE.exec(lines[i]);
                                    if (match) {
                                        result.push(
                                            new StackFrame({
                                                fileName: match[2],
                                                lineNumber: match[1],
                                                source: lines[i],
                                            })
                                        );
                                    }
                                }

                                return result;
                            },

                            parseOpera10: function ErrorStackParser$$parseOpera10(
                                e
                            ) {
                                var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
                                var lines = e.stacktrace.split('\n');
                                var result = [];

                                for (
                                    var i = 0, len = lines.length;
                                    i < len;
                                    i += 2
                                ) {
                                    var match = lineRE.exec(lines[i]);
                                    if (match) {
                                        result.push(
                                            new StackFrame({
                                                functionName:
                                                    match[3] || undefined,
                                                fileName: match[2],
                                                lineNumber: match[1],
                                                source: lines[i],
                                            })
                                        );
                                    }
                                }

                                return result;
                            },

                            // Opera 10.65+ Error.stack very similar to FF/Safari
                            parseOpera11: function ErrorStackParser$$parseOpera11(
                                error
                            ) {
                                var filtered = error.stack
                                    .split('\n')
                                    .filter(function (line) {
                                        return (
                                            !!line.match(
                                                FIREFOX_SAFARI_STACK_REGEXP
                                            ) &&
                                            !line.match(/^Error created at/)
                                        );
                                    }, this);

                                return filtered.map(function (line) {
                                    var tokens = line.split('@');
                                    var locationParts = this.extractLocation(
                                        tokens.pop()
                                    );
                                    var functionCall = tokens.shift() || '';
                                    var functionName =
                                        functionCall
                                            .replace(
                                                /<anonymous function(: (\w+))?>/,
                                                '$2'
                                            )
                                            .replace(/\([^)]*\)/g, '') ||
                                        undefined;
                                    var argsRaw;
                                    if (functionCall.match(/\(([^)]*)\)/)) {
                                        argsRaw = functionCall.replace(
                                            /^[^(]+\(([^)]*)\)$/,
                                            '$1'
                                        );
                                    }
                                    var args =
                                        argsRaw === undefined ||
                                        argsRaw === '[arguments not available]'
                                            ? undefined
                                            : argsRaw.split(',');

                                    return new StackFrame({
                                        functionName: functionName,
                                        args: args,
                                        fileName: locationParts[0],
                                        lineNumber: locationParts[1],
                                        columnNumber: locationParts[2],
                                        source: line,
                                    });
                                }, this);
                            },
                        };
                    });

                    /***/
                },

            /***/ './node_modules/extract-files/public/ReactNativeFile.js':
                /*!**************************************************************!*\
  !*** ./node_modules/extract-files/public/ReactNativeFile.js ***!
  \**************************************************************/
                /***/ (module) => {
                    'use strict';

                    module.exports = function ReactNativeFile(_ref) {
                        var uri = _ref.uri,
                            name = _ref.name,
                            type = _ref.type;
                        this.uri = uri;
                        this.name = name;
                        this.type = type;
                    };

                    /***/
                },

            /***/ './node_modules/extract-files/public/extractFiles.js':
                /*!***********************************************************!*\
  !*** ./node_modules/extract-files/public/extractFiles.js ***!
  \***********************************************************/
                /***/ (
                    module,
                    __unused_webpack_exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    var defaultIsExtractableFile = __webpack_require__(
                        /*! ./isExtractableFile */ './node_modules/extract-files/public/isExtractableFile.js'
                    );

                    module.exports = function extractFiles(
                        value,
                        path,
                        isExtractableFile
                    ) {
                        if (path === void 0) {
                            path = '';
                        }

                        if (isExtractableFile === void 0) {
                            isExtractableFile = defaultIsExtractableFile;
                        }

                        var clone;
                        var files = new Map();

                        function addFile(paths, file) {
                            var storedPaths = files.get(file);
                            if (storedPaths)
                                storedPaths.push.apply(storedPaths, paths);
                            else files.set(file, paths);
                        }

                        if (isExtractableFile(value)) {
                            clone = null;
                            addFile([path], value);
                        } else {
                            var prefix = path ? path + '.' : '';
                            if (
                                typeof FileList !== 'undefined' &&
                                value instanceof FileList
                            )
                                clone = Array.prototype.map.call(
                                    value,
                                    function (file, i) {
                                        addFile(['' + prefix + i], file);
                                        return null;
                                    }
                                );
                            else if (Array.isArray(value))
                                clone = value.map(function (child, i) {
                                    var result = extractFiles(
                                        child,
                                        '' + prefix + i,
                                        isExtractableFile
                                    );
                                    result.files.forEach(addFile);
                                    return result.clone;
                                });
                            else if (value && value.constructor === Object) {
                                clone = {};

                                for (var i in value) {
                                    var result = extractFiles(
                                        value[i],
                                        '' + prefix + i,
                                        isExtractableFile
                                    );
                                    result.files.forEach(addFile);
                                    clone[i] = result.clone;
                                }
                            } else clone = value;
                        }

                        return {
                            clone: clone,
                            files: files,
                        };
                    };

                    /***/
                },

            /***/ './node_modules/extract-files/public/index.js':
                /*!****************************************************!*\
  !*** ./node_modules/extract-files/public/index.js ***!
  \****************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    exports.ReactNativeFile = __webpack_require__(
                        /*! ./ReactNativeFile */ './node_modules/extract-files/public/ReactNativeFile.js'
                    );
                    exports.extractFiles = __webpack_require__(
                        /*! ./extractFiles */ './node_modules/extract-files/public/extractFiles.js'
                    );
                    exports.isExtractableFile = __webpack_require__(
                        /*! ./isExtractableFile */ './node_modules/extract-files/public/isExtractableFile.js'
                    );

                    /***/
                },

            /***/ './node_modules/extract-files/public/isExtractableFile.js':
                /*!****************************************************************!*\
  !*** ./node_modules/extract-files/public/isExtractableFile.js ***!
  \****************************************************************/
                /***/ (
                    module,
                    __unused_webpack_exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    var ReactNativeFile = __webpack_require__(
                        /*! ./ReactNativeFile */ './node_modules/extract-files/public/ReactNativeFile.js'
                    );

                    module.exports = function isExtractableFile(value) {
                        return (
                            (typeof File !== 'undefined' &&
                                value instanceof File) ||
                            (typeof Blob !== 'undefined' &&
                                value instanceof Blob) ||
                            value instanceof ReactNativeFile
                        );
                    };

                    /***/
                },

            /***/ './node_modules/form-data/lib/browser.js':
                /*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
                /***/ (module) => {
                    /* eslint-env browser */
                    module.exports =
                        typeof self == 'object'
                            ? self.FormData
                            : window.FormData;

                    /***/
                },

            /***/ './node_modules/graphql-request/dist/createRequestBody.js':
                /*!****************************************************************!*\
  !*** ./node_modules/graphql-request/dist/createRequestBody.js ***!
  \****************************************************************/
                /***/ function (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) {
                    'use strict';

                    var __importDefault =
                        (this && this.__importDefault) ||
                        function (mod) {
                            return mod && mod.__esModule
                                ? mod
                                : { default: mod };
                        };
                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    var extract_files_1 = __webpack_require__(
                        /*! extract-files */ './node_modules/extract-files/public/index.js'
                    );
                    var form_data_1 = __importDefault(
                        __webpack_require__(
                            /*! form-data */ './node_modules/form-data/lib/browser.js'
                        )
                    );
                    /**
                     * Duck type if NodeJS stream
                     * https://github.com/sindresorhus/is-stream/blob/3750505b0727f6df54324784fe369365ef78841e/index.js#L3
                     */
                    var isExtractableFileEnhanced = function (value) {
                        return (
                            extract_files_1.isExtractableFile(value) ||
                            (value !== null &&
                                typeof value === 'object' &&
                                typeof value.pipe === 'function')
                        );
                    };
                    /**
                     * Returns Multipart Form if body contains files
                     * (https://github.com/jaydenseric/graphql-multipart-request-spec)
                     * Otherwise returns JSON
                     */
                    function createRequestBody(query, variables) {
                        var _a = extract_files_1.extractFiles(
                                { query: query, variables: variables },
                                '',
                                isExtractableFileEnhanced
                            ),
                            clone = _a.clone,
                            files = _a.files;
                        if (files.size === 0) {
                            return JSON.stringify(clone);
                        }
                        var Form =
                            typeof FormData === 'undefined'
                                ? form_data_1.default
                                : FormData;
                        var form = new Form();
                        form.append('operations', JSON.stringify(clone));
                        var map = {};
                        var i = 0;
                        files.forEach(function (paths) {
                            map[++i] = paths;
                        });
                        form.append('map', JSON.stringify(map));
                        i = 0;
                        files.forEach(function (paths, file) {
                            form.append('' + ++i, file);
                        });
                        return form;
                    }
                    exports.default = createRequestBody;
                    //# sourceMappingURL=createRequestBody.js.map

                    /***/
                },

            /***/ './node_modules/graphql-request/dist/index.js':
                /*!****************************************************!*\
  !*** ./node_modules/graphql-request/dist/index.js ***!
  \****************************************************/
                /***/ function (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) {
                    'use strict';

                    var __assign =
                        (this && this.__assign) ||
                        function () {
                            __assign =
                                Object.assign ||
                                function (t) {
                                    for (
                                        var s, i = 1, n = arguments.length;
                                        i < n;
                                        i++
                                    ) {
                                        s = arguments[i];
                                        for (var p in s)
                                            if (
                                                Object.prototype.hasOwnProperty.call(
                                                    s,
                                                    p
                                                )
                                            )
                                                t[p] = s[p];
                                    }
                                    return t;
                                };
                            return __assign.apply(this, arguments);
                        };
                    var __createBinding =
                        (this && this.__createBinding) ||
                        (Object.create
                            ? function (o, m, k, k2) {
                                  if (k2 === undefined) k2 = k;
                                  Object.defineProperty(o, k2, {
                                      enumerable: true,
                                      get: function () {
                                          return m[k];
                                      },
                                  });
                              }
                            : function (o, m, k, k2) {
                                  if (k2 === undefined) k2 = k;
                                  o[k2] = m[k];
                              });
                    var __setModuleDefault =
                        (this && this.__setModuleDefault) ||
                        (Object.create
                            ? function (o, v) {
                                  Object.defineProperty(o, 'default', {
                                      enumerable: true,
                                      value: v,
                                  });
                              }
                            : function (o, v) {
                                  o['default'] = v;
                              });
                    var __importStar =
                        (this && this.__importStar) ||
                        function (mod) {
                            if (mod && mod.__esModule) return mod;
                            var result = {};
                            if (mod != null)
                                for (var k in mod)
                                    if (
                                        k !== 'default' &&
                                        Object.prototype.hasOwnProperty.call(
                                            mod,
                                            k
                                        )
                                    )
                                        __createBinding(result, mod, k);
                            __setModuleDefault(result, mod);
                            return result;
                        };
                    var __awaiter =
                        (this && this.__awaiter) ||
                        function (thisArg, _arguments, P, generator) {
                            function adopt(value) {
                                return value instanceof P
                                    ? value
                                    : new P(function (resolve) {
                                          resolve(value);
                                      });
                            }
                            return new (P || (P = Promise))(function (
                                resolve,
                                reject
                            ) {
                                function fulfilled(value) {
                                    try {
                                        step(generator.next(value));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                                function rejected(value) {
                                    try {
                                        step(generator['throw'](value));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                                function step(result) {
                                    result.done
                                        ? resolve(result.value)
                                        : adopt(result.value).then(
                                              fulfilled,
                                              rejected
                                          );
                                }
                                step(
                                    (generator = generator.apply(
                                        thisArg,
                                        _arguments || []
                                    )).next()
                                );
                            });
                        };
                    var __generator =
                        (this && this.__generator) ||
                        function (thisArg, body) {
                            var _ = {
                                    label: 0,
                                    sent: function () {
                                        if (t[0] & 1) throw t[1];
                                        return t[1];
                                    },
                                    trys: [],
                                    ops: [],
                                },
                                f,
                                y,
                                t,
                                g;
                            return (
                                (g = {
                                    next: verb(0),
                                    throw: verb(1),
                                    return: verb(2),
                                }),
                                typeof Symbol === 'function' &&
                                    (g[Symbol.iterator] = function () {
                                        return this;
                                    }),
                                g
                            );
                            function verb(n) {
                                return function (v) {
                                    return step([n, v]);
                                };
                            }
                            function step(op) {
                                if (f)
                                    throw new TypeError(
                                        'Generator is already executing.'
                                    );
                                while (_)
                                    try {
                                        if (
                                            ((f = 1),
                                            y &&
                                                (t =
                                                    op[0] & 2
                                                        ? y['return']
                                                        : op[0]
                                                        ? y['throw'] ||
                                                          ((t = y['return']) &&
                                                              t.call(y),
                                                          0)
                                                        : y.next) &&
                                                !(t = t.call(y, op[1])).done)
                                        )
                                            return t;
                                        if (((y = 0), t))
                                            op = [op[0] & 2, t.value];
                                        switch (op[0]) {
                                            case 0:
                                            case 1:
                                                t = op;
                                                break;
                                            case 4:
                                                _.label++;
                                                return {
                                                    value: op[1],
                                                    done: false,
                                                };
                                            case 5:
                                                _.label++;
                                                y = op[1];
                                                op = [0];
                                                continue;
                                            case 7:
                                                op = _.ops.pop();
                                                _.trys.pop();
                                                continue;
                                            default:
                                                if (
                                                    !((t = _.trys),
                                                    (t =
                                                        t.length > 0 &&
                                                        t[t.length - 1])) &&
                                                    (op[0] === 6 || op[0] === 2)
                                                ) {
                                                    _ = 0;
                                                    continue;
                                                }
                                                if (
                                                    op[0] === 3 &&
                                                    (!t ||
                                                        (op[1] > t[0] &&
                                                            op[1] < t[3]))
                                                ) {
                                                    _.label = op[1];
                                                    break;
                                                }
                                                if (
                                                    op[0] === 6 &&
                                                    _.label < t[1]
                                                ) {
                                                    _.label = t[1];
                                                    t = op;
                                                    break;
                                                }
                                                if (t && _.label < t[2]) {
                                                    _.label = t[2];
                                                    _.ops.push(op);
                                                    break;
                                                }
                                                if (t[2]) _.ops.pop();
                                                _.trys.pop();
                                                continue;
                                        }
                                        op = body.call(thisArg, _);
                                    } catch (e) {
                                        op = [6, e];
                                        y = 0;
                                    } finally {
                                        f = t = 0;
                                    }
                                if (op[0] & 5) throw op[1];
                                return {
                                    value: op[0] ? op[1] : void 0,
                                    done: true,
                                };
                            }
                        };
                    var __rest =
                        (this && this.__rest) ||
                        function (s, e) {
                            var t = {};
                            for (var p in s)
                                if (
                                    Object.prototype.hasOwnProperty.call(
                                        s,
                                        p
                                    ) &&
                                    e.indexOf(p) < 0
                                )
                                    t[p] = s[p];
                            if (
                                s != null &&
                                typeof Object.getOwnPropertySymbols ===
                                    'function'
                            )
                                for (
                                    var i = 0,
                                        p = Object.getOwnPropertySymbols(s);
                                    i < p.length;
                                    i++
                                ) {
                                    if (
                                        e.indexOf(p[i]) < 0 &&
                                        Object.prototype.propertyIsEnumerable.call(
                                            s,
                                            p[i]
                                        )
                                    )
                                        t[p[i]] = s[p[i]];
                                }
                            return t;
                        };
                    var __importDefault =
                        (this && this.__importDefault) ||
                        function (mod) {
                            return mod && mod.__esModule
                                ? mod
                                : { default: mod };
                        };
                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.gql = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
                    var cross_fetch_1 = __importStar(
                            __webpack_require__(
                                /*! cross-fetch */ './node_modules/cross-fetch/dist/browser-ponyfill.js'
                            )
                        ),
                        CrossFetch = cross_fetch_1;
                    var printer_1 = __webpack_require__(
                        /*! graphql/language/printer */ './node_modules/graphql/language/printer.js'
                    );
                    var createRequestBody_1 = __importDefault(
                        __webpack_require__(
                            /*! ./createRequestBody */ './node_modules/graphql-request/dist/createRequestBody.js'
                        )
                    );
                    var types_1 = __webpack_require__(
                        /*! ./types */ './node_modules/graphql-request/dist/types.js'
                    );
                    var types_2 = __webpack_require__(
                        /*! ./types */ './node_modules/graphql-request/dist/types.js'
                    );
                    Object.defineProperty(exports, 'ClientError', {
                        enumerable: true,
                        get: function () {
                            return types_2.ClientError;
                        },
                    });
                    /**
                     * Convert the given headers configuration into a plain object.
                     */
                    var resolveHeaders = function (headers) {
                        var oHeaders = {};
                        if (headers) {
                            if (
                                (typeof Headers !== 'undefined' &&
                                    headers instanceof Headers) ||
                                headers instanceof CrossFetch.Headers
                            ) {
                                oHeaders = HeadersInstanceToPlainObject(
                                    headers
                                );
                            } else if (Array.isArray(headers)) {
                                headers.forEach(function (_a) {
                                    var name = _a[0],
                                        value = _a[1];
                                    oHeaders[name] = value;
                                });
                            } else {
                                oHeaders = headers;
                            }
                        }
                        return oHeaders;
                    };
                    /**
                     * todo
                     */
                    var GraphQLClient = /** @class */ (function () {
                        function GraphQLClient(url, options) {
                            this.url = url;
                            this.options = options || {};
                        }
                        GraphQLClient.prototype.rawRequest = function (
                            query,
                            variables,
                            requestHeaders
                        ) {
                            return __awaiter(this, void 0, void 0, function () {
                                var _a,
                                    headers,
                                    _b,
                                    localFetch,
                                    others,
                                    body,
                                    response,
                                    result,
                                    headers_1,
                                    status_1,
                                    errorResult;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            (_a = this.options),
                                                (headers = _a.headers),
                                                (_b = _a.fetch),
                                                (localFetch =
                                                    _b === void 0
                                                        ? cross_fetch_1.default
                                                        : _b),
                                                (others = __rest(_a, [
                                                    'headers',
                                                    'fetch',
                                                ]));
                                            body = createRequestBody_1.default(
                                                query,
                                                variables
                                            );
                                            return [
                                                4 /*yield*/,
                                                localFetch(
                                                    this.url,
                                                    __assign(
                                                        {
                                                            method: 'POST',
                                                            headers: __assign(
                                                                __assign(
                                                                    __assign(
                                                                        {},
                                                                        typeof body ===
                                                                            'string'
                                                                            ? {
                                                                                  'Content-Type':
                                                                                      'application/json',
                                                                              }
                                                                            : {}
                                                                    ),
                                                                    resolveHeaders(
                                                                        headers
                                                                    )
                                                                ),
                                                                resolveHeaders(
                                                                    requestHeaders
                                                                )
                                                            ),
                                                            body: body,
                                                        },
                                                        others
                                                    )
                                                ),
                                            ];
                                        case 1:
                                            response = _c.sent();
                                            return [
                                                4 /*yield*/,
                                                getResult(response),
                                            ];
                                        case 2:
                                            result = _c.sent();
                                            if (
                                                response.ok &&
                                                !result.errors &&
                                                result.data
                                            ) {
                                                (headers_1 = response.headers),
                                                    (status_1 =
                                                        response.status);
                                                return [
                                                    2 /*return*/,
                                                    __assign(
                                                        __assign({}, result),
                                                        {
                                                            headers: headers_1,
                                                            status: status_1,
                                                        }
                                                    ),
                                                ];
                                            } else {
                                                errorResult =
                                                    typeof result === 'string'
                                                        ? { error: result }
                                                        : result;
                                                throw new types_1.ClientError(
                                                    __assign(
                                                        __assign(
                                                            {},
                                                            errorResult
                                                        ),
                                                        {
                                                            status:
                                                                response.status,
                                                            headers:
                                                                response.headers,
                                                        }
                                                    ),
                                                    {
                                                        query: query,
                                                        variables: variables,
                                                    }
                                                );
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        /**
                         * Send a GraphQL document to the server.
                         */
                        GraphQLClient.prototype.request = function (
                            document,
                            variables,
                            requestHeaders
                        ) {
                            return __awaiter(this, void 0, void 0, function () {
                                var _a,
                                    headers,
                                    _b,
                                    localFetch,
                                    others,
                                    resolvedDoc,
                                    body,
                                    response,
                                    result,
                                    errorResult;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            (_a = this.options),
                                                (headers = _a.headers),
                                                (_b = _a.fetch),
                                                (localFetch =
                                                    _b === void 0
                                                        ? cross_fetch_1.default
                                                        : _b),
                                                (others = __rest(_a, [
                                                    'headers',
                                                    'fetch',
                                                ]));
                                            resolvedDoc = resolveRequestDocument(
                                                document
                                            );
                                            body = createRequestBody_1.default(
                                                resolvedDoc,
                                                variables
                                            );
                                            return [
                                                4 /*yield*/,
                                                localFetch(
                                                    this.url,
                                                    __assign(
                                                        {
                                                            method: 'POST',
                                                            headers: __assign(
                                                                __assign(
                                                                    __assign(
                                                                        {},
                                                                        typeof body ===
                                                                            'string'
                                                                            ? {
                                                                                  'Content-Type':
                                                                                      'application/json',
                                                                              }
                                                                            : {}
                                                                    ),
                                                                    resolveHeaders(
                                                                        headers
                                                                    )
                                                                ),
                                                                resolveHeaders(
                                                                    requestHeaders
                                                                )
                                                            ),
                                                            body: body,
                                                        },
                                                        others
                                                    )
                                                ),
                                            ];
                                        case 1:
                                            response = _c.sent();
                                            return [
                                                4 /*yield*/,
                                                getResult(response),
                                            ];
                                        case 2:
                                            result = _c.sent();
                                            if (
                                                response.ok &&
                                                !result.errors &&
                                                result.data
                                            ) {
                                                return [
                                                    2 /*return*/,
                                                    result.data,
                                                ];
                                            } else {
                                                errorResult =
                                                    typeof result === 'string'
                                                        ? { error: result }
                                                        : result;
                                                throw new types_1.ClientError(
                                                    __assign(
                                                        __assign(
                                                            {},
                                                            errorResult
                                                        ),
                                                        {
                                                            status:
                                                                response.status,
                                                        }
                                                    ),
                                                    {
                                                        query: resolvedDoc,
                                                        variables: variables,
                                                    }
                                                );
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        GraphQLClient.prototype.setHeaders = function (
                            headers
                        ) {
                            this.options.headers = headers;
                            return this;
                        };
                        /**
                         * Attach a header to the client. All subsequent requests will have this header.
                         */
                        GraphQLClient.prototype.setHeader = function (
                            key,
                            value
                        ) {
                            var _a;
                            var headers = this.options.headers;
                            if (headers) {
                                // todo what if headers is in nested array form... ?
                                //@ts-ignore
                                headers[key] = value;
                            } else {
                                this.options.headers =
                                    ((_a = {}), (_a[key] = value), _a);
                            }
                            return this;
                        };
                        return GraphQLClient;
                    })();
                    exports.GraphQLClient = GraphQLClient;
                    /**
                     * todo
                     */
                    function rawRequest(url, query, variables) {
                        return __awaiter(this, void 0, void 0, function () {
                            var client;
                            return __generator(this, function (_a) {
                                client = new GraphQLClient(url);
                                return [
                                    2 /*return*/,
                                    client.rawRequest(query, variables),
                                ];
                            });
                        });
                    }
                    exports.rawRequest = rawRequest;
                    /**
                     * Send a GraphQL Document to the GraphQL server for exectuion.
                     *
                     * @example
                     *
                     * ```ts
                     * // You can pass a raw string
                     *
                     * await request('https://foo.bar/graphql', `
                     *   {
                     *     query {
                     *       users
                     *     }
                     *   }
                     * `)
                     *
                     * // You can also pass a GraphQL DocumentNode. Convenient if you
                     * // are using graphql-tag package.
                     *
                     * import gql from 'graphql-tag'
                     *
                     * await request('https://foo.bar/graphql', gql`...`)
                     *
                     * // If you don't actually care about using DocumentNode but just
                     * // want the tooling support for gql template tag like IDE syntax
                     * // coloring and prettier autoformat then note you can use the
                     * // passthrough gql tag shipped with graphql-request to save a bit
                     * // of performance and not have to install another dep into your project.
                     *
                     * import { gql } from 'graphql-request'
                     *
                     * await request('https://foo.bar/graphql', gql`...`)
                     * ```
                     */
                    function request(url, document, variables) {
                        return __awaiter(this, void 0, void 0, function () {
                            var client;
                            return __generator(this, function (_a) {
                                client = new GraphQLClient(url);
                                return [
                                    2 /*return*/,
                                    client.request(document, variables),
                                ];
                            });
                        });
                    }
                    exports.request = request;
                    exports.default = request;
                    /**
                     * todo
                     */
                    function getResult(response) {
                        var contentType = response.headers.get('Content-Type');
                        if (
                            contentType &&
                            contentType.startsWith('application/json')
                        ) {
                            return response.json();
                        } else {
                            return response.text();
                        }
                    }
                    /**
                     * helpers
                     */
                    function resolveRequestDocument(document) {
                        if (typeof document === 'string') return document;
                        return printer_1.print(document);
                    }
                    /**
                     * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.
                     *
                     * @example
                     *
                     * import { gql } from 'graphql-request'
                     *
                     * await request('https://foo.bar/graphql', gql`...`)
                     *
                     * @remarks
                     *
                     * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named "gql". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.
                     */
                    function gql(chunks) {
                        var variables = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            variables[_i - 1] = arguments[_i];
                        }
                        return chunks.reduce(function (
                            accumulator,
                            chunk,
                            index
                        ) {
                            return (
                                '' +
                                accumulator +
                                chunk +
                                (index in variables ? variables[index] : '')
                            );
                        },
                        '');
                    }
                    exports.gql = gql;
                    /**
                     * Convert Headers instance into regular object
                     */
                    function HeadersInstanceToPlainObject(headers) {
                        var o = {};
                        headers.forEach(function (v, k) {
                            o[k] = v;
                        });
                        return o;
                    }
                    //# sourceMappingURL=index.js.map

                    /***/
                },

            /***/ './node_modules/graphql-request/dist/types.js':
                /*!****************************************************!*\
  !*** ./node_modules/graphql-request/dist/types.js ***!
  \****************************************************/
                /***/ function (__unused_webpack_module, exports) {
                    'use strict';

                    var __extends =
                        (this && this.__extends) ||
                        (function () {
                            var extendStatics = function (d, b) {
                                extendStatics =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (d, b) {
                                            d.__proto__ = b;
                                        }) ||
                                    function (d, b) {
                                        for (var p in b)
                                            if (
                                                Object.prototype.hasOwnProperty.call(
                                                    b,
                                                    p
                                                )
                                            )
                                                d[p] = b[p];
                                    };
                                return extendStatics(d, b);
                            };
                            return function (d, b) {
                                extendStatics(d, b);
                                function __() {
                                    this.constructor = d;
                                }
                                d.prototype =
                                    b === null
                                        ? Object.create(b)
                                        : ((__.prototype = b.prototype),
                                          new __());
                            };
                        })();
                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.ClientError = void 0;
                    var ClientError = /** @class */ (function (_super) {
                        __extends(ClientError, _super);
                        function ClientError(response, request) {
                            var _this = this;
                            var message =
                                ClientError.extractMessage(response) +
                                ': ' +
                                JSON.stringify({
                                    response: response,
                                    request: request,
                                });
                            _this = _super.call(this, message) || this;
                            Object.setPrototypeOf(_this, ClientError.prototype);
                            _this.response = response;
                            _this.request = request;
                            // this is needed as Safari doesn't support .captureStackTrace
                            if (typeof Error.captureStackTrace === 'function') {
                                Error.captureStackTrace(_this, ClientError);
                            }
                            return _this;
                        }
                        ClientError.extractMessage = function (response) {
                            try {
                                return response.errors[0].message;
                            } catch (e) {
                                return (
                                    'GraphQL Error (Code: ' +
                                    response.status +
                                    ')'
                                );
                            }
                        };
                        return ClientError;
                    })(Error);
                    exports.ClientError = ClientError;
                    //# sourceMappingURL=types.js.map

                    /***/
                },

            /***/ './node_modules/graphql-tag/src/index.js':
                /*!***********************************************!*\
  !*** ./node_modules/graphql-tag/src/index.js ***!
  \***********************************************/
                /***/ (
                    module,
                    __unused_webpack_exports,
                    __webpack_require__
                ) => {
                    var parser = __webpack_require__(
                        /*! graphql/language/parser */ './node_modules/graphql/language/parser.js'
                    );

                    var parse = parser.parse;

                    // Strip insignificant whitespace
                    // Note that this could do a lot more, such as reorder fields etc.
                    function normalize(string) {
                        return string.replace(/[\s,]+/g, ' ').trim();
                    }

                    // A map docString -> graphql document
                    var docCache = {};

                    // A map fragmentName -> [normalized source]
                    var fragmentSourceMap = {};

                    function cacheKeyFromLoc(loc) {
                        return normalize(
                            loc.source.body.substring(loc.start, loc.end)
                        );
                    }

                    // For testing.
                    function resetCaches() {
                        docCache = {};
                        fragmentSourceMap = {};
                    }

                    // Take a unstripped parsed document (query/mutation or even fragment), and
                    // check all fragment definitions, checking for name->source uniqueness.
                    // We also want to make sure only unique fragments exist in the document.
                    var printFragmentWarnings = true;
                    function processFragments(ast) {
                        var astFragmentMap = {};
                        var definitions = [];

                        for (var i = 0; i < ast.definitions.length; i++) {
                            var fragmentDefinition = ast.definitions[i];

                            if (
                                fragmentDefinition.kind === 'FragmentDefinition'
                            ) {
                                var fragmentName =
                                    fragmentDefinition.name.value;
                                var sourceKey = cacheKeyFromLoc(
                                    fragmentDefinition.loc
                                );

                                // We know something about this fragment
                                if (
                                    fragmentSourceMap.hasOwnProperty(
                                        fragmentName
                                    ) &&
                                    !fragmentSourceMap[fragmentName][sourceKey]
                                ) {
                                    // this is a problem because the app developer is trying to register another fragment with
                                    // the same name as one previously registered. So, we tell them about it.
                                    if (printFragmentWarnings) {
                                        console.warn(
                                            'Warning: fragment with name ' +
                                                fragmentName +
                                                ' already exists.\n' +
                                                'graphql-tag enforces all fragment names across your application to be unique; read more about\n' +
                                                'this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names'
                                        );
                                    }

                                    fragmentSourceMap[fragmentName][
                                        sourceKey
                                    ] = true;
                                } else if (
                                    !fragmentSourceMap.hasOwnProperty(
                                        fragmentName
                                    )
                                ) {
                                    fragmentSourceMap[fragmentName] = {};
                                    fragmentSourceMap[fragmentName][
                                        sourceKey
                                    ] = true;
                                }

                                if (!astFragmentMap[sourceKey]) {
                                    astFragmentMap[sourceKey] = true;
                                    definitions.push(fragmentDefinition);
                                }
                            } else {
                                definitions.push(fragmentDefinition);
                            }
                        }

                        ast.definitions = definitions;
                        return ast;
                    }

                    function disableFragmentWarnings() {
                        printFragmentWarnings = false;
                    }

                    function stripLoc(doc, removeLocAtThisLevel) {
                        var docType = Object.prototype.toString.call(doc);

                        if (docType === '[object Array]') {
                            return doc.map(function (d) {
                                return stripLoc(d, removeLocAtThisLevel);
                            });
                        }

                        if (docType !== '[object Object]') {
                            throw new Error('Unexpected input.');
                        }

                        // We don't want to remove the root loc field so we can use it
                        // for fragment substitution (see below)
                        if (removeLocAtThisLevel && doc.loc) {
                            delete doc.loc;
                        }

                        // https://github.com/apollographql/graphql-tag/issues/40
                        if (doc.loc) {
                            delete doc.loc.startToken;
                            delete doc.loc.endToken;
                        }

                        var keys = Object.keys(doc);
                        var key;
                        var value;
                        var valueType;

                        for (key in keys) {
                            if (keys.hasOwnProperty(key)) {
                                value = doc[keys[key]];
                                valueType = Object.prototype.toString.call(
                                    value
                                );

                                if (
                                    valueType === '[object Object]' ||
                                    valueType === '[object Array]'
                                ) {
                                    doc[keys[key]] = stripLoc(value, true);
                                }
                            }
                        }

                        return doc;
                    }

                    var experimentalFragmentVariables = false;
                    function parseDocument(doc) {
                        var cacheKey = normalize(doc);

                        if (docCache[cacheKey]) {
                            return docCache[cacheKey];
                        }

                        var parsed = parse(doc, {
                            experimentalFragmentVariables: experimentalFragmentVariables,
                        });
                        if (!parsed || parsed.kind !== 'Document') {
                            throw new Error('Not a valid GraphQL document.');
                        }

                        // check that all "new" fragments inside the documents are consistent with
                        // existing fragments of the same name
                        parsed = processFragments(parsed);
                        parsed = stripLoc(parsed, false);
                        docCache[cacheKey] = parsed;

                        return parsed;
                    }

                    function enableExperimentalFragmentVariables() {
                        experimentalFragmentVariables = true;
                    }

                    function disableExperimentalFragmentVariables() {
                        experimentalFragmentVariables = false;
                    }

                    // XXX This should eventually disallow arbitrary string interpolation, like Relay does
                    function gql(/* arguments */) {
                        var args = Array.prototype.slice.call(arguments);

                        var literals = args[0];

                        // We always get literals[0] and then matching post literals for each arg given
                        var result =
                            typeof literals === 'string'
                                ? literals
                                : literals[0];

                        for (var i = 1; i < args.length; i++) {
                            if (
                                args[i] &&
                                args[i].kind &&
                                args[i].kind === 'Document'
                            ) {
                                result += args[i].loc.source.body;
                            } else {
                                result += args[i];
                            }

                            result += literals[i];
                        }

                        return parseDocument(result);
                    }

                    // Support typescript, which isn't as nice as Babel about default exports
                    gql.default = gql;
                    gql.resetCaches = resetCaches;
                    gql.disableFragmentWarnings = disableFragmentWarnings;
                    gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
                    gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

                    module.exports = gql;

                    /***/
                },

            /***/ './node_modules/graphql/error/GraphQLError.js':
                /*!****************************************************!*\
  !*** ./node_modules/graphql/error/GraphQLError.js ***!
  \****************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.printError = printError;
                    exports.GraphQLError = void 0;

                    var _isObjectLike = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/isObjectLike.js */ './node_modules/graphql/jsutils/isObjectLike.js'
                        )
                    );

                    var _symbols = __webpack_require__(
                        /*! ../polyfills/symbols.js */ './node_modules/graphql/polyfills/symbols.js'
                    );

                    var _location = __webpack_require__(
                        /*! ../language/location.js */ './node_modules/graphql/language/location.js'
                    );

                    var _printLocation = __webpack_require__(
                        /*! ../language/printLocation.js */ './node_modules/graphql/language/printLocation.js'
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _typeof(obj) {
                        '@babel/helpers - typeof';
                        if (
                            typeof Symbol === 'function' &&
                            typeof Symbol.iterator === 'symbol'
                        ) {
                            _typeof = function _typeof(obj) {
                                return typeof obj;
                            };
                        } else {
                            _typeof = function _typeof(obj) {
                                return obj &&
                                    typeof Symbol === 'function' &&
                                    obj.constructor === Symbol &&
                                    obj !== Symbol.prototype
                                    ? 'symbol'
                                    : typeof obj;
                            };
                        }
                        return _typeof(obj);
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                'Cannot call a class as a function'
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    function _inherits(subClass, superClass) {
                        if (
                            typeof superClass !== 'function' &&
                            superClass !== null
                        ) {
                            throw new TypeError(
                                'Super expression must either be null or a function'
                            );
                        }
                        subClass.prototype = Object.create(
                            superClass && superClass.prototype,
                            {
                                constructor: {
                                    value: subClass,
                                    writable: true,
                                    configurable: true,
                                },
                            }
                        );
                        if (superClass) _setPrototypeOf(subClass, superClass);
                    }

                    function _createSuper(Derived) {
                        var hasNativeReflectConstruct = _isNativeReflectConstruct();
                        return function _createSuperInternal() {
                            var Super = _getPrototypeOf(Derived),
                                result;
                            if (hasNativeReflectConstruct) {
                                var NewTarget = _getPrototypeOf(this)
                                    .constructor;
                                result = Reflect.construct(
                                    Super,
                                    arguments,
                                    NewTarget
                                );
                            } else {
                                result = Super.apply(this, arguments);
                            }
                            return _possibleConstructorReturn(this, result);
                        };
                    }

                    function _possibleConstructorReturn(self, call) {
                        if (
                            call &&
                            (_typeof(call) === 'object' ||
                                typeof call === 'function')
                        ) {
                            return call;
                        }
                        return _assertThisInitialized(self);
                    }

                    function _assertThisInitialized(self) {
                        if (self === void 0) {
                            throw new ReferenceError(
                                "this hasn't been initialised - super() hasn't been called"
                            );
                        }
                        return self;
                    }

                    function _wrapNativeSuper(Class) {
                        var _cache =
                            typeof Map === 'function' ? new Map() : undefined;
                        _wrapNativeSuper = function _wrapNativeSuper(Class) {
                            if (Class === null || !_isNativeFunction(Class))
                                return Class;
                            if (typeof Class !== 'function') {
                                throw new TypeError(
                                    'Super expression must either be null or a function'
                                );
                            }
                            if (typeof _cache !== 'undefined') {
                                if (_cache.has(Class)) return _cache.get(Class);
                                _cache.set(Class, Wrapper);
                            }
                            function Wrapper() {
                                return _construct(
                                    Class,
                                    arguments,
                                    _getPrototypeOf(this).constructor
                                );
                            }
                            Wrapper.prototype = Object.create(Class.prototype, {
                                constructor: {
                                    value: Wrapper,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true,
                                },
                            });
                            return _setPrototypeOf(Wrapper, Class);
                        };
                        return _wrapNativeSuper(Class);
                    }

                    function _construct(Parent, args, Class) {
                        if (_isNativeReflectConstruct()) {
                            _construct = Reflect.construct;
                        } else {
                            _construct = function _construct(
                                Parent,
                                args,
                                Class
                            ) {
                                var a = [null];
                                a.push.apply(a, args);
                                var Constructor = Function.bind.apply(
                                    Parent,
                                    a
                                );
                                var instance = new Constructor();
                                if (Class)
                                    _setPrototypeOf(instance, Class.prototype);
                                return instance;
                            };
                        }
                        return _construct.apply(null, arguments);
                    }

                    function _isNativeReflectConstruct() {
                        if (
                            typeof Reflect === 'undefined' ||
                            !Reflect.construct
                        )
                            return false;
                        if (Reflect.construct.sham) return false;
                        if (typeof Proxy === 'function') return true;
                        try {
                            Date.prototype.toString.call(
                                Reflect.construct(Date, [], function () {})
                            );
                            return true;
                        } catch (e) {
                            return false;
                        }
                    }

                    function _isNativeFunction(fn) {
                        return (
                            Function.toString
                                .call(fn)
                                .indexOf('[native code]') !== -1
                        );
                    }

                    function _setPrototypeOf(o, p) {
                        _setPrototypeOf =
                            Object.setPrototypeOf ||
                            function _setPrototypeOf(o, p) {
                                o.__proto__ = p;
                                return o;
                            };
                        return _setPrototypeOf(o, p);
                    }

                    function _getPrototypeOf(o) {
                        _getPrototypeOf = Object.setPrototypeOf
                            ? Object.getPrototypeOf
                            : function _getPrototypeOf(o) {
                                  return (
                                      o.__proto__ || Object.getPrototypeOf(o)
                                  );
                              };
                        return _getPrototypeOf(o);
                    }

                    /**
                     * A GraphQLError describes an Error found during the parse, validate, or
                     * execute phases of performing a GraphQL operation. In addition to a message
                     * and stack trace, it also includes information about the locations in a
                     * GraphQL document and/or execution result that correspond to the Error.
                     */
                    var GraphQLError = /*#__PURE__*/ (function (_Error) {
                        _inherits(GraphQLError, _Error);

                        var _super = _createSuper(GraphQLError);

                        /**
                         * A message describing the Error for debugging purposes.
                         *
                         * Enumerable, and appears in the result of JSON.stringify().
                         *
                         * Note: should be treated as readonly, despite invariant usage.
                         */

                        /**
                         * An array of { line, column } locations within the source GraphQL document
                         * which correspond to this error.
                         *
                         * Errors during validation often contain multiple locations, for example to
                         * point out two things with the same name. Errors during execution include a
                         * single location, the field which produced the error.
                         *
                         * Enumerable, and appears in the result of JSON.stringify().
                         */

                        /**
                         * An array describing the JSON-path into the execution response which
                         * corresponds to this error. Only included for errors during execution.
                         *
                         * Enumerable, and appears in the result of JSON.stringify().
                         */

                        /**
                         * An array of GraphQL AST Nodes corresponding to this error.
                         */

                        /**
                         * The source GraphQL document for the first location of this error.
                         *
                         * Note that if this Error represents more than one node, the source may not
                         * represent nodes after the first node.
                         */

                        /**
                         * An array of character offsets within the source GraphQL document
                         * which correspond to this error.
                         */

                        /**
                         * The original error thrown from a field resolver during execution.
                         */

                        /**
                         * Extension fields to add to the formatted error.
                         */
                        function GraphQLError(
                            message,
                            nodes,
                            source,
                            positions,
                            path,
                            originalError,
                            extensions
                        ) {
                            var _locations2,
                                _source2,
                                _positions2,
                                _extensions2;

                            var _this;

                            _classCallCheck(this, GraphQLError);

                            _this = _super.call(this, message); // Compute list of blame nodes.

                            var _nodes = Array.isArray(nodes)
                                ? nodes.length !== 0
                                    ? nodes
                                    : undefined
                                : nodes
                                ? [nodes]
                                : undefined; // Compute locations in the source for the given nodes/positions.

                            var _source = source;

                            if (!_source && _nodes) {
                                var _nodes$0$loc;

                                _source =
                                    (_nodes$0$loc = _nodes[0].loc) === null ||
                                    _nodes$0$loc === void 0
                                        ? void 0
                                        : _nodes$0$loc.source;
                            }

                            var _positions = positions;

                            if (!_positions && _nodes) {
                                _positions = _nodes.reduce(function (
                                    list,
                                    node
                                ) {
                                    if (node.loc) {
                                        list.push(node.loc.start);
                                    }

                                    return list;
                                },
                                []);
                            }

                            if (_positions && _positions.length === 0) {
                                _positions = undefined;
                            }

                            var _locations;

                            if (positions && source) {
                                _locations = positions.map(function (pos) {
                                    return (0,
                                    _location.getLocation)(source, pos);
                                });
                            } else if (_nodes) {
                                _locations = _nodes.reduce(function (
                                    list,
                                    node
                                ) {
                                    if (node.loc) {
                                        list.push(
                                            (0, _location.getLocation)(
                                                node.loc.source,
                                                node.loc.start
                                            )
                                        );
                                    }

                                    return list;
                                },
                                []);
                            }

                            var _extensions = extensions;

                            if (_extensions == null && originalError != null) {
                                var originalExtensions =
                                    originalError.extensions;

                                if (
                                    (0, _isObjectLike.default)(
                                        originalExtensions
                                    )
                                ) {
                                    _extensions = originalExtensions;
                                }
                            }

                            Object.defineProperties(
                                _assertThisInitialized(_this),
                                {
                                    name: {
                                        value: 'GraphQLError',
                                    },
                                    message: {
                                        value: message,
                                        // By being enumerable, JSON.stringify will include `message` in the
                                        // resulting output. This ensures that the simplest possible GraphQL
                                        // service adheres to the spec.
                                        enumerable: true,
                                        writable: true,
                                    },
                                    locations: {
                                        // Coercing falsy values to undefined ensures they will not be included
                                        // in JSON.stringify() when not provided.
                                        value:
                                            (_locations2 = _locations) !==
                                                null && _locations2 !== void 0
                                                ? _locations2
                                                : undefined,
                                        // By being enumerable, JSON.stringify will include `locations` in the
                                        // resulting output. This ensures that the simplest possible GraphQL
                                        // service adheres to the spec.
                                        enumerable: _locations != null,
                                    },
                                    path: {
                                        // Coercing falsy values to undefined ensures they will not be included
                                        // in JSON.stringify() when not provided.
                                        value:
                                            path !== null && path !== void 0
                                                ? path
                                                : undefined,
                                        // By being enumerable, JSON.stringify will include `path` in the
                                        // resulting output. This ensures that the simplest possible GraphQL
                                        // service adheres to the spec.
                                        enumerable: path != null,
                                    },
                                    nodes: {
                                        value:
                                            _nodes !== null && _nodes !== void 0
                                                ? _nodes
                                                : undefined,
                                    },
                                    source: {
                                        value:
                                            (_source2 = _source) !== null &&
                                            _source2 !== void 0
                                                ? _source2
                                                : undefined,
                                    },
                                    positions: {
                                        value:
                                            (_positions2 = _positions) !==
                                                null && _positions2 !== void 0
                                                ? _positions2
                                                : undefined,
                                    },
                                    originalError: {
                                        value: originalError,
                                    },
                                    extensions: {
                                        // Coercing falsy values to undefined ensures they will not be included
                                        // in JSON.stringify() when not provided.
                                        value:
                                            (_extensions2 = _extensions) !==
                                                null && _extensions2 !== void 0
                                                ? _extensions2
                                                : undefined,
                                        // By being enumerable, JSON.stringify will include `path` in the
                                        // resulting output. This ensures that the simplest possible GraphQL
                                        // service adheres to the spec.
                                        enumerable: _extensions != null,
                                    },
                                }
                            ); // Include (non-enumerable) stack trace.

                            if (
                                originalError === null ||
                                originalError === void 0
                                    ? void 0
                                    : originalError.stack
                            ) {
                                Object.defineProperty(
                                    _assertThisInitialized(_this),
                                    'stack',
                                    {
                                        value: originalError.stack,
                                        writable: true,
                                        configurable: true,
                                    }
                                );
                                return _possibleConstructorReturn(_this);
                            } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(
                                    _assertThisInitialized(_this),
                                    GraphQLError
                                );
                            } else {
                                Object.defineProperty(
                                    _assertThisInitialized(_this),
                                    'stack',
                                    {
                                        value: Error().stack,
                                        writable: true,
                                        configurable: true,
                                    }
                                );
                            }

                            return _this;
                        }

                        _createClass(GraphQLError, [
                            {
                                key: 'toString',
                                value: function toString() {
                                    return printError(this);
                                }, // FIXME: workaround to not break chai comparisons, should be remove in v16
                                // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet
                            },
                            {
                                key: _symbols.SYMBOL_TO_STRING_TAG,
                                get: function get() {
                                    return 'Object';
                                },
                            },
                        ]);

                        return GraphQLError;
                    })(/*#__PURE__*/ _wrapNativeSuper(Error));
                    /**
                     * Prints a GraphQLError to a string, representing useful location information
                     * about the error's position in the source.
                     */

                    exports.GraphQLError = GraphQLError;

                    function printError(error) {
                        var output = error.message;

                        if (error.nodes) {
                            for (
                                var _i2 = 0, _error$nodes2 = error.nodes;
                                _i2 < _error$nodes2.length;
                                _i2++
                            ) {
                                var node = _error$nodes2[_i2];

                                if (node.loc) {
                                    output +=
                                        '\n\n' +
                                        (0, _printLocation.printLocation)(
                                            node.loc
                                        );
                                }
                            }
                        } else if (error.source && error.locations) {
                            for (
                                var _i4 = 0,
                                    _error$locations2 = error.locations;
                                _i4 < _error$locations2.length;
                                _i4++
                            ) {
                                var location = _error$locations2[_i4];
                                output +=
                                    '\n\n' +
                                    (0, _printLocation.printSourceLocation)(
                                        error.source,
                                        location
                                    );
                            }
                        }

                        return output;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/error/syntaxError.js':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/error/syntaxError.js ***!
  \***************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.syntaxError = syntaxError;

                    var _GraphQLError = __webpack_require__(
                        /*! ./GraphQLError.js */ './node_modules/graphql/error/GraphQLError.js'
                    );

                    /**
                     * Produces a GraphQLError representing a syntax error, containing useful
                     * descriptive information about the syntax error's position in the source.
                     */
                    function syntaxError(source, position, description) {
                        return new _GraphQLError.GraphQLError(
                            'Syntax Error: '.concat(description),
                            undefined,
                            source,
                            [position]
                        );
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/defineInspect.js':
                /*!*******************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineInspect.js ***!
  \*******************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = defineInspect;

                    var _invariant = _interopRequireDefault(
                        __webpack_require__(
                            /*! ./invariant.js */ './node_modules/graphql/jsutils/invariant.js'
                        )
                    );

                    var _nodejsCustomInspectSymbol = _interopRequireDefault(
                        __webpack_require__(
                            /*! ./nodejsCustomInspectSymbol.js */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js'
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    /**
                     * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`
                     */
                    function defineInspect(classObject) {
                        var fn = classObject.prototype.toJSON;
                        typeof fn === 'function' || (0, _invariant.default)(0);
                        classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')

                        if (_nodejsCustomInspectSymbol.default) {
                            classObject.prototype[
                                _nodejsCustomInspectSymbol.default
                            ] = fn;
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/defineInspect.mjs':
                /*!********************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineInspect.mjs ***!
  \********************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ default: () =>
                                /* binding */ defineInspect,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _invariant_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ./invariant.mjs */ './node_modules/graphql/jsutils/invariant.mjs'
                    );
                    /* harmony import */ var _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                        /*! ./nodejsCustomInspectSymbol.mjs */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs'
                    );

                    /**
                     * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`
                     */

                    function defineInspect(classObject) {
                        var fn = classObject.prototype.toJSON;
                        typeof fn === 'function' ||
                            (0,
                            _invariant_mjs__WEBPACK_IMPORTED_MODULE_0__.default)(
                                0
                            );
                        classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')

                        if (
                            _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__.default
                        ) {
                            classObject.prototype[
                                _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__.default
                            ] = fn;
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/devAssert.js':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/devAssert.js ***!
  \***************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = devAssert;

                    function devAssert(condition, message) {
                        var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

                        if (!booleanCondition) {
                            throw new Error(message);
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/inspect.js':
                /*!*************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.js ***!
  \*************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = inspect;

                    var _nodejsCustomInspectSymbol = _interopRequireDefault(
                        __webpack_require__(
                            /*! ./nodejsCustomInspectSymbol.js */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js'
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _typeof(obj) {
                        '@babel/helpers - typeof';
                        if (
                            typeof Symbol === 'function' &&
                            typeof Symbol.iterator === 'symbol'
                        ) {
                            _typeof = function _typeof(obj) {
                                return typeof obj;
                            };
                        } else {
                            _typeof = function _typeof(obj) {
                                return obj &&
                                    typeof Symbol === 'function' &&
                                    obj.constructor === Symbol &&
                                    obj !== Symbol.prototype
                                    ? 'symbol'
                                    : typeof obj;
                            };
                        }
                        return _typeof(obj);
                    }

                    var MAX_ARRAY_LENGTH = 10;
                    var MAX_RECURSIVE_DEPTH = 2;
                    /**
                     * Used to print values in error messages.
                     */

                    function inspect(value) {
                        return formatValue(value, []);
                    }

                    function formatValue(value, seenValues) {
                        switch (_typeof(value)) {
                            case 'string':
                                return JSON.stringify(value);

                            case 'function':
                                return value.name
                                    ? '[function '.concat(value.name, ']')
                                    : '[function]';

                            case 'object':
                                if (value === null) {
                                    return 'null';
                                }

                                return formatObjectValue(value, seenValues);

                            default:
                                return String(value);
                        }
                    }

                    function formatObjectValue(value, previouslySeenValues) {
                        if (previouslySeenValues.indexOf(value) !== -1) {
                            return '[Circular]';
                        }

                        var seenValues = [].concat(previouslySeenValues, [
                            value,
                        ]);
                        var customInspectFn = getCustomFn(value);

                        if (customInspectFn !== undefined) {
                            var customValue = customInspectFn.call(value); // check for infinite recursion

                            if (customValue !== value) {
                                return typeof customValue === 'string'
                                    ? customValue
                                    : formatValue(customValue, seenValues);
                            }
                        } else if (Array.isArray(value)) {
                            return formatArray(value, seenValues);
                        }

                        return formatObject(value, seenValues);
                    }

                    function formatObject(object, seenValues) {
                        var keys = Object.keys(object);

                        if (keys.length === 0) {
                            return '{}';
                        }

                        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
                            return '[' + getObjectTag(object) + ']';
                        }

                        var properties = keys.map(function (key) {
                            var value = formatValue(object[key], seenValues);
                            return key + ': ' + value;
                        });
                        return '{ ' + properties.join(', ') + ' }';
                    }

                    function formatArray(array, seenValues) {
                        if (array.length === 0) {
                            return '[]';
                        }

                        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
                            return '[Array]';
                        }

                        var len = Math.min(MAX_ARRAY_LENGTH, array.length);
                        var remaining = array.length - len;
                        var items = [];

                        for (var i = 0; i < len; ++i) {
                            items.push(formatValue(array[i], seenValues));
                        }

                        if (remaining === 1) {
                            items.push('... 1 more item');
                        } else if (remaining > 1) {
                            items.push('... '.concat(remaining, ' more items'));
                        }

                        return '[' + items.join(', ') + ']';
                    }

                    function getCustomFn(object) {
                        var customInspectFn =
                            object[String(_nodejsCustomInspectSymbol.default)];

                        if (typeof customInspectFn === 'function') {
                            return customInspectFn;
                        }

                        if (typeof object.inspect === 'function') {
                            return object.inspect;
                        }
                    }

                    function getObjectTag(object) {
                        var tag = Object.prototype.toString
                            .call(object)
                            .replace(/^\[object /, '')
                            .replace(/]$/, '');

                        if (
                            tag === 'Object' &&
                            typeof object.constructor === 'function'
                        ) {
                            var name = object.constructor.name;

                            if (typeof name === 'string' && name !== '') {
                                return name;
                            }
                        }

                        return tag;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/inspect.mjs':
                /*!**************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.mjs ***!
  \**************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ default: () =>
                                /* binding */ inspect,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ./nodejsCustomInspectSymbol.mjs */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs'
                    );
                    function _typeof(obj) {
                        '@babel/helpers - typeof';
                        if (
                            typeof Symbol === 'function' &&
                            typeof Symbol.iterator === 'symbol'
                        ) {
                            _typeof = function _typeof(obj) {
                                return typeof obj;
                            };
                        } else {
                            _typeof = function _typeof(obj) {
                                return obj &&
                                    typeof Symbol === 'function' &&
                                    obj.constructor === Symbol &&
                                    obj !== Symbol.prototype
                                    ? 'symbol'
                                    : typeof obj;
                            };
                        }
                        return _typeof(obj);
                    }

                    /* eslint-disable flowtype/no-weak-types */

                    var MAX_ARRAY_LENGTH = 10;
                    var MAX_RECURSIVE_DEPTH = 2;
                    /**
                     * Used to print values in error messages.
                     */

                    function inspect(value) {
                        return formatValue(value, []);
                    }

                    function formatValue(value, seenValues) {
                        switch (_typeof(value)) {
                            case 'string':
                                return JSON.stringify(value);

                            case 'function':
                                return value.name
                                    ? '[function '.concat(value.name, ']')
                                    : '[function]';

                            case 'object':
                                if (value === null) {
                                    return 'null';
                                }

                                return formatObjectValue(value, seenValues);

                            default:
                                return String(value);
                        }
                    }

                    function formatObjectValue(value, previouslySeenValues) {
                        if (previouslySeenValues.indexOf(value) !== -1) {
                            return '[Circular]';
                        }

                        var seenValues = [].concat(previouslySeenValues, [
                            value,
                        ]);
                        var customInspectFn = getCustomFn(value);

                        if (customInspectFn !== undefined) {
                            var customValue = customInspectFn.call(value); // check for infinite recursion

                            if (customValue !== value) {
                                return typeof customValue === 'string'
                                    ? customValue
                                    : formatValue(customValue, seenValues);
                            }
                        } else if (Array.isArray(value)) {
                            return formatArray(value, seenValues);
                        }

                        return formatObject(value, seenValues);
                    }

                    function formatObject(object, seenValues) {
                        var keys = Object.keys(object);

                        if (keys.length === 0) {
                            return '{}';
                        }

                        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
                            return '[' + getObjectTag(object) + ']';
                        }

                        var properties = keys.map(function (key) {
                            var value = formatValue(object[key], seenValues);
                            return key + ': ' + value;
                        });
                        return '{ ' + properties.join(', ') + ' }';
                    }

                    function formatArray(array, seenValues) {
                        if (array.length === 0) {
                            return '[]';
                        }

                        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
                            return '[Array]';
                        }

                        var len = Math.min(MAX_ARRAY_LENGTH, array.length);
                        var remaining = array.length - len;
                        var items = [];

                        for (var i = 0; i < len; ++i) {
                            items.push(formatValue(array[i], seenValues));
                        }

                        if (remaining === 1) {
                            items.push('... 1 more item');
                        } else if (remaining > 1) {
                            items.push('... '.concat(remaining, ' more items'));
                        }

                        return '[' + items.join(', ') + ']';
                    }

                    function getCustomFn(object) {
                        var customInspectFn =
                            object[
                                String(
                                    _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_0__.default
                                )
                            ];

                        if (typeof customInspectFn === 'function') {
                            return customInspectFn;
                        }

                        if (typeof object.inspect === 'function') {
                            return object.inspect;
                        }
                    }

                    function getObjectTag(object) {
                        var tag = Object.prototype.toString
                            .call(object)
                            .replace(/^\[object /, '')
                            .replace(/]$/, '');

                        if (
                            tag === 'Object' &&
                            typeof object.constructor === 'function'
                        ) {
                            var name = object.constructor.name;

                            if (typeof name === 'string' && name !== '') {
                                return name;
                            }
                        }

                        return tag;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/instanceOf.js':
                /*!****************************************************!*\
  !*** ./node_modules/graphql/jsutils/instanceOf.js ***!
  \****************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = void 0;

                    /**
                     * A replacement for instanceof which includes an error warning when multi-realm
                     * constructors are detected.
                     */
                    // See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
                    // See: https://webpack.js.org/guides/production/
                    var _default = false // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
                        ? // eslint-disable-next-line no-shadow
                          0 // eslint-disable-next-line no-shadow
                        : function instanceOf(value, constructor) {
                              if (value instanceof constructor) {
                                  return true;
                              }

                              if (value) {
                                  var valueClass = value.constructor;
                                  var className = constructor.name;

                                  if (
                                      className &&
                                      valueClass &&
                                      valueClass.name === className
                                  ) {
                                      throw new Error(
                                          'Cannot use '
                                              .concat(className, ' "')
                                              .concat(
                                                  value,
                                                  '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'
                                              )
                                      );
                                  }
                              }

                              return false;
                          };

                    exports.default = _default;

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/invariant.js':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.js ***!
  \***************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = invariant;

                    function invariant(condition, message) {
                        var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

                        if (!booleanCondition) {
                            throw new Error(
                                message != null
                                    ? message
                                    : 'Unexpected invariant triggered.'
                            );
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/invariant.mjs':
                /*!****************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.mjs ***!
  \****************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ default: () =>
                                /* binding */ invariant,
                            /* harmony export */
                        }
                    );
                    function invariant(condition, message) {
                        var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

                        if (!booleanCondition) {
                            throw new Error(
                                message != null
                                    ? message
                                    : 'Unexpected invariant triggered.'
                            );
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/isObjectLike.js':
                /*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/isObjectLike.js ***!
  \******************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = isObjectLike;

                    function _typeof(obj) {
                        '@babel/helpers - typeof';
                        if (
                            typeof Symbol === 'function' &&
                            typeof Symbol.iterator === 'symbol'
                        ) {
                            _typeof = function _typeof(obj) {
                                return typeof obj;
                            };
                        } else {
                            _typeof = function _typeof(obj) {
                                return obj &&
                                    typeof Symbol === 'function' &&
                                    obj.constructor === Symbol &&
                                    obj !== Symbol.prototype
                                    ? 'symbol'
                                    : typeof obj;
                            };
                        }
                        return _typeof(obj);
                    }

                    /**
                     * Return true if `value` is object-like. A value is object-like if it's not
                     * `null` and has a `typeof` result of "object".
                     */
                    function isObjectLike(value) {
                        return _typeof(value) == 'object' && value !== null;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js':
                /*!*******************************************************************!*\
  !*** ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js ***!
  \*******************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.default = void 0;
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
                    var nodejsCustomInspectSymbol =
                        typeof Symbol === 'function' &&
                        typeof Symbol.for === 'function'
                            ? Symbol.for('nodejs.util.inspect.custom')
                            : undefined;
                    var _default = nodejsCustomInspectSymbol;
                    exports.default = _default;

                    /***/
                },

            /***/ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs':
                /*!********************************************************************!*\
  !*** ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs ***!
  \********************************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ default: () =>
                                __WEBPACK_DEFAULT_EXPORT__,
                            /* harmony export */
                        }
                    );
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
                    var nodejsCustomInspectSymbol =
                        typeof Symbol === 'function' &&
                        typeof Symbol.for === 'function'
                            ? Symbol.for('nodejs.util.inspect.custom')
                            : undefined;
                    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = nodejsCustomInspectSymbol;

                    /***/
                },

            /***/ './node_modules/graphql/language/ast.js':
                /*!**********************************************!*\
  !*** ./node_modules/graphql/language/ast.js ***!
  \**********************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.isNode = isNode;
                    exports.Token = exports.Location = void 0;

                    var _defineInspect = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/defineInspect.js */ './node_modules/graphql/jsutils/defineInspect.js'
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    /**
                     * Contains a range of UTF-8 character offsets and token references that
                     * identify the region of the source from which the AST derived.
                     */
                    var Location = /*#__PURE__*/ (function () {
                        /**
                         * The character offset at which this Node begins.
                         */

                        /**
                         * The character offset at which this Node ends.
                         */

                        /**
                         * The Token at which this Node begins.
                         */

                        /**
                         * The Token at which this Node ends.
                         */

                        /**
                         * The Source document the AST represents.
                         */
                        function Location(startToken, endToken, source) {
                            this.start = startToken.start;
                            this.end = endToken.end;
                            this.startToken = startToken;
                            this.endToken = endToken;
                            this.source = source;
                        }

                        var _proto = Location.prototype;

                        _proto.toJSON = function toJSON() {
                            return {
                                start: this.start,
                                end: this.end,
                            };
                        };

                        return Location;
                    })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

                    exports.Location = Location;
                    (0, _defineInspect.default)(Location);
                    /**
                     * Represents a range of characters represented by a lexical token
                     * within a Source.
                     */

                    var Token = /*#__PURE__*/ (function () {
                        /**
                         * The kind of Token.
                         */

                        /**
                         * The character offset at which this Node begins.
                         */

                        /**
                         * The character offset at which this Node ends.
                         */

                        /**
                         * The 1-indexed line number on which this Token appears.
                         */

                        /**
                         * The 1-indexed column number at which this Token begins.
                         */

                        /**
                         * For non-punctuation tokens, represents the interpreted value of the token.
                         */

                        /**
                         * Tokens exist as nodes in a double-linked-list amongst all tokens
                         * including ignored tokens. <SOF> is always the first node and <EOF>
                         * the last.
                         */
                        function Token(
                            kind,
                            start,
                            end,
                            line,
                            column,
                            prev,
                            value
                        ) {
                            this.kind = kind;
                            this.start = start;
                            this.end = end;
                            this.line = line;
                            this.column = column;
                            this.value = value;
                            this.prev = prev;
                            this.next = null;
                        }

                        var _proto2 = Token.prototype;

                        _proto2.toJSON = function toJSON() {
                            return {
                                kind: this.kind,
                                value: this.value,
                                line: this.line,
                                column: this.column,
                            };
                        };

                        return Token;
                    })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

                    exports.Token = Token;
                    (0, _defineInspect.default)(Token);
                    /**
                     * @internal
                     */

                    function isNode(maybeNode) {
                        return (
                            maybeNode != null &&
                            typeof maybeNode.kind === 'string'
                        );
                    }
                    /**
                     * The list of all possible AST node types.
                     */

                    /***/
                },

            /***/ './node_modules/graphql/language/ast.mjs':
                /*!***********************************************!*\
  !*** ./node_modules/graphql/language/ast.mjs ***!
  \***********************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ Location: () =>
                                /* binding */ Location,
                            /* harmony export */ Token: () =>
                                /* binding */ Token,
                            /* harmony export */ isNode: () =>
                                /* binding */ isNode,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ../jsutils/defineInspect.mjs */ './node_modules/graphql/jsutils/defineInspect.mjs'
                    );

                    /**
                     * Contains a range of UTF-8 character offsets and token references that
                     * identify the region of the source from which the AST derived.
                     */
                    var Location = /*#__PURE__*/ (function () {
                        /**
                         * The character offset at which this Node begins.
                         */

                        /**
                         * The character offset at which this Node ends.
                         */

                        /**
                         * The Token at which this Node begins.
                         */

                        /**
                         * The Token at which this Node ends.
                         */

                        /**
                         * The Source document the AST represents.
                         */
                        function Location(startToken, endToken, source) {
                            this.start = startToken.start;
                            this.end = endToken.end;
                            this.startToken = startToken;
                            this.endToken = endToken;
                            this.source = source;
                        }

                        var _proto = Location.prototype;

                        _proto.toJSON = function toJSON() {
                            return {
                                start: this.start,
                                end: this.end,
                            };
                        };

                        return Location;
                    })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

                    (0,
                    _jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__.default)(
                        Location
                    );
                    /**
                     * Represents a range of characters represented by a lexical token
                     * within a Source.
                     */

                    var Token = /*#__PURE__*/ (function () {
                        /**
                         * The kind of Token.
                         */

                        /**
                         * The character offset at which this Node begins.
                         */

                        /**
                         * The character offset at which this Node ends.
                         */

                        /**
                         * The 1-indexed line number on which this Token appears.
                         */

                        /**
                         * The 1-indexed column number at which this Token begins.
                         */

                        /**
                         * For non-punctuation tokens, represents the interpreted value of the token.
                         */

                        /**
                         * Tokens exist as nodes in a double-linked-list amongst all tokens
                         * including ignored tokens. <SOF> is always the first node and <EOF>
                         * the last.
                         */
                        function Token(
                            kind,
                            start,
                            end,
                            line,
                            column,
                            prev,
                            value
                        ) {
                            this.kind = kind;
                            this.start = start;
                            this.end = end;
                            this.line = line;
                            this.column = column;
                            this.value = value;
                            this.prev = prev;
                            this.next = null;
                        }

                        var _proto2 = Token.prototype;

                        _proto2.toJSON = function toJSON() {
                            return {
                                kind: this.kind,
                                value: this.value,
                                line: this.line,
                                column: this.column,
                            };
                        };

                        return Token;
                    })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

                    (0,
                    _jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__.default)(
                        Token
                    );
                    /**
                     * @internal
                     */

                    function isNode(maybeNode) {
                        return (
                            maybeNode != null &&
                            typeof maybeNode.kind === 'string'
                        );
                    }
                    /**
                     * The list of all possible AST node types.
                     */

                    /***/
                },

            /***/ './node_modules/graphql/language/blockString.js':
                /*!******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.js ***!
  \******************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.dedentBlockStringValue = dedentBlockStringValue;
                    exports.getBlockStringIndentation = getBlockStringIndentation;
                    exports.printBlockString = printBlockString;

                    /**
                     * Produces the value of a block string from its parsed raw value, similar to
                     * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
                     *
                     * This implements the GraphQL spec's BlockStringValue() static algorithm.
                     *
                     * @internal
                     */
                    function dedentBlockStringValue(rawString) {
                        // Expand a block string's raw value into independent lines.
                        var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

                        var commonIndent = getBlockStringIndentation(rawString);

                        if (commonIndent !== 0) {
                            for (var i = 1; i < lines.length; i++) {
                                lines[i] = lines[i].slice(commonIndent);
                            }
                        } // Remove leading and trailing blank lines.

                        var startLine = 0;

                        while (
                            startLine < lines.length &&
                            isBlank(lines[startLine])
                        ) {
                            ++startLine;
                        }

                        var endLine = lines.length;

                        while (
                            endLine > startLine &&
                            isBlank(lines[endLine - 1])
                        ) {
                            --endLine;
                        } // Return a string of the lines joined with U+000A.

                        return lines.slice(startLine, endLine).join('\n');
                    }

                    function isBlank(str) {
                        for (var i = 0; i < str.length; ++i) {
                            if (str[i] !== ' ' && str[i] !== '\t') {
                                return false;
                            }
                        }

                        return true;
                    }
                    /**
                     * @internal
                     */

                    function getBlockStringIndentation(value) {
                        var _commonIndent;

                        var isFirstLine = true;
                        var isEmptyLine = true;
                        var indent = 0;
                        var commonIndent = null;

                        for (var i = 0; i < value.length; ++i) {
                            switch (value.charCodeAt(i)) {
                                case 13:
                                    //  \r
                                    if (value.charCodeAt(i + 1) === 10) {
                                        ++i; // skip \r\n as one symbol
                                    }

                                // falls through

                                case 10:
                                    //  \n
                                    isFirstLine = false;
                                    isEmptyLine = true;
                                    indent = 0;
                                    break;

                                case 9: //   \t

                                case 32:
                                    //  <space>
                                    ++indent;
                                    break;

                                default:
                                    if (
                                        isEmptyLine &&
                                        !isFirstLine &&
                                        (commonIndent === null ||
                                            indent < commonIndent)
                                    ) {
                                        commonIndent = indent;
                                    }

                                    isEmptyLine = false;
                            }
                        }

                        return (_commonIndent = commonIndent) !== null &&
                            _commonIndent !== void 0
                            ? _commonIndent
                            : 0;
                    }
                    /**
                     * Print a block string in the indented block form by adding a leading and
                     * trailing blank line. However, if a block string starts with whitespace and is
                     * a single-line, adding a leading blank line would strip that whitespace.
                     *
                     * @internal
                     */

                    function printBlockString(value) {
                        var indentation =
                            arguments.length > 1 && arguments[1] !== undefined
                                ? arguments[1]
                                : '';
                        var preferMultipleLines =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : false;
                        var isSingleLine = value.indexOf('\n') === -1;
                        var hasLeadingSpace =
                            value[0] === ' ' || value[0] === '\t';
                        var hasTrailingQuote = value[value.length - 1] === '"';
                        var hasTrailingSlash = value[value.length - 1] === '\\';
                        var printAsMultipleLines =
                            !isSingleLine ||
                            hasTrailingQuote ||
                            hasTrailingSlash ||
                            preferMultipleLines;
                        var result = ''; // Format a multi-line block quote to account for leading space.

                        if (
                            printAsMultipleLines &&
                            !(isSingleLine && hasLeadingSpace)
                        ) {
                            result += '\n' + indentation;
                        }

                        result += indentation
                            ? value.replace(/\n/g, '\n' + indentation)
                            : value;

                        if (printAsMultipleLines) {
                            result += '\n';
                        }

                        return '"""' + result.replace(/"""/g, '\\"""') + '"""';
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/blockString.mjs':
                /*!*******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.mjs ***!
  \*******************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ dedentBlockStringValue: () =>
                                /* binding */ dedentBlockStringValue,
                            /* harmony export */ getBlockStringIndentation: () =>
                                /* binding */ getBlockStringIndentation,
                            /* harmony export */ printBlockString: () =>
                                /* binding */ printBlockString,
                            /* harmony export */
                        }
                    );
                    /**
                     * Produces the value of a block string from its parsed raw value, similar to
                     * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
                     *
                     * This implements the GraphQL spec's BlockStringValue() static algorithm.
                     *
                     * @internal
                     */
                    function dedentBlockStringValue(rawString) {
                        // Expand a block string's raw value into independent lines.
                        var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

                        var commonIndent = getBlockStringIndentation(rawString);

                        if (commonIndent !== 0) {
                            for (var i = 1; i < lines.length; i++) {
                                lines[i] = lines[i].slice(commonIndent);
                            }
                        } // Remove leading and trailing blank lines.

                        var startLine = 0;

                        while (
                            startLine < lines.length &&
                            isBlank(lines[startLine])
                        ) {
                            ++startLine;
                        }

                        var endLine = lines.length;

                        while (
                            endLine > startLine &&
                            isBlank(lines[endLine - 1])
                        ) {
                            --endLine;
                        } // Return a string of the lines joined with U+000A.

                        return lines.slice(startLine, endLine).join('\n');
                    }

                    function isBlank(str) {
                        for (var i = 0; i < str.length; ++i) {
                            if (str[i] !== ' ' && str[i] !== '\t') {
                                return false;
                            }
                        }

                        return true;
                    }
                    /**
                     * @internal
                     */

                    function getBlockStringIndentation(value) {
                        var _commonIndent;

                        var isFirstLine = true;
                        var isEmptyLine = true;
                        var indent = 0;
                        var commonIndent = null;

                        for (var i = 0; i < value.length; ++i) {
                            switch (value.charCodeAt(i)) {
                                case 13:
                                    //  \r
                                    if (value.charCodeAt(i + 1) === 10) {
                                        ++i; // skip \r\n as one symbol
                                    }

                                // falls through

                                case 10:
                                    //  \n
                                    isFirstLine = false;
                                    isEmptyLine = true;
                                    indent = 0;
                                    break;

                                case 9: //   \t

                                case 32:
                                    //  <space>
                                    ++indent;
                                    break;

                                default:
                                    if (
                                        isEmptyLine &&
                                        !isFirstLine &&
                                        (commonIndent === null ||
                                            indent < commonIndent)
                                    ) {
                                        commonIndent = indent;
                                    }

                                    isEmptyLine = false;
                            }
                        }

                        return (_commonIndent = commonIndent) !== null &&
                            _commonIndent !== void 0
                            ? _commonIndent
                            : 0;
                    }
                    /**
                     * Print a block string in the indented block form by adding a leading and
                     * trailing blank line. However, if a block string starts with whitespace and is
                     * a single-line, adding a leading blank line would strip that whitespace.
                     *
                     * @internal
                     */

                    function printBlockString(value) {
                        var indentation =
                            arguments.length > 1 && arguments[1] !== undefined
                                ? arguments[1]
                                : '';
                        var preferMultipleLines =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : false;
                        var isSingleLine = value.indexOf('\n') === -1;
                        var hasLeadingSpace =
                            value[0] === ' ' || value[0] === '\t';
                        var hasTrailingQuote = value[value.length - 1] === '"';
                        var hasTrailingSlash = value[value.length - 1] === '\\';
                        var printAsMultipleLines =
                            !isSingleLine ||
                            hasTrailingQuote ||
                            hasTrailingSlash ||
                            preferMultipleLines;
                        var result = ''; // Format a multi-line block quote to account for leading space.

                        if (
                            printAsMultipleLines &&
                            !(isSingleLine && hasLeadingSpace)
                        ) {
                            result += '\n' + indentation;
                        }

                        result += indentation
                            ? value.replace(/\n/g, '\n' + indentation)
                            : value;

                        if (printAsMultipleLines) {
                            result += '\n';
                        }

                        return '"""' + result.replace(/"""/g, '\\"""') + '"""';
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/directiveLocation.js':
                /*!************************************************************!*\
  !*** ./node_modules/graphql/language/directiveLocation.js ***!
  \************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.DirectiveLocation = void 0;

                    /**
                     * The set of allowed directive location values.
                     */
                    var DirectiveLocation = Object.freeze({
                        // Request Definitions
                        QUERY: 'QUERY',
                        MUTATION: 'MUTATION',
                        SUBSCRIPTION: 'SUBSCRIPTION',
                        FIELD: 'FIELD',
                        FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
                        FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
                        INLINE_FRAGMENT: 'INLINE_FRAGMENT',
                        VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
                        // Type System Definitions
                        SCHEMA: 'SCHEMA',
                        SCALAR: 'SCALAR',
                        OBJECT: 'OBJECT',
                        FIELD_DEFINITION: 'FIELD_DEFINITION',
                        ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
                        INTERFACE: 'INTERFACE',
                        UNION: 'UNION',
                        ENUM: 'ENUM',
                        ENUM_VALUE: 'ENUM_VALUE',
                        INPUT_OBJECT: 'INPUT_OBJECT',
                        INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION',
                    });
                    /**
                     * The enum type representing the directive location values.
                     */

                    exports.DirectiveLocation = DirectiveLocation;

                    /***/
                },

            /***/ './node_modules/graphql/language/kinds.js':
                /*!************************************************!*\
  !*** ./node_modules/graphql/language/kinds.js ***!
  \************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.Kind = void 0;

                    /**
                     * The set of allowed kind values for AST nodes.
                     */
                    var Kind = Object.freeze({
                        // Name
                        NAME: 'Name',
                        // Document
                        DOCUMENT: 'Document',
                        OPERATION_DEFINITION: 'OperationDefinition',
                        VARIABLE_DEFINITION: 'VariableDefinition',
                        SELECTION_SET: 'SelectionSet',
                        FIELD: 'Field',
                        ARGUMENT: 'Argument',
                        // Fragments
                        FRAGMENT_SPREAD: 'FragmentSpread',
                        INLINE_FRAGMENT: 'InlineFragment',
                        FRAGMENT_DEFINITION: 'FragmentDefinition',
                        // Values
                        VARIABLE: 'Variable',
                        INT: 'IntValue',
                        FLOAT: 'FloatValue',
                        STRING: 'StringValue',
                        BOOLEAN: 'BooleanValue',
                        NULL: 'NullValue',
                        ENUM: 'EnumValue',
                        LIST: 'ListValue',
                        OBJECT: 'ObjectValue',
                        OBJECT_FIELD: 'ObjectField',
                        // Directives
                        DIRECTIVE: 'Directive',
                        // Types
                        NAMED_TYPE: 'NamedType',
                        LIST_TYPE: 'ListType',
                        NON_NULL_TYPE: 'NonNullType',
                        // Type System Definitions
                        SCHEMA_DEFINITION: 'SchemaDefinition',
                        OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
                        // Type Definitions
                        SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
                        OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
                        FIELD_DEFINITION: 'FieldDefinition',
                        INPUT_VALUE_DEFINITION: 'InputValueDefinition',
                        INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
                        UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
                        ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
                        ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
                        INPUT_OBJECT_TYPE_DEFINITION:
                            'InputObjectTypeDefinition',
                        // Directive Definitions
                        DIRECTIVE_DEFINITION: 'DirectiveDefinition',
                        // Type System Extensions
                        SCHEMA_EXTENSION: 'SchemaExtension',
                        // Type Extensions
                        SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
                        OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
                        INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
                        UNION_TYPE_EXTENSION: 'UnionTypeExtension',
                        ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
                        INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',
                    });
                    /**
                     * The enum type representing the possible kind values of AST nodes.
                     */

                    exports.Kind = Kind;

                    /***/
                },

            /***/ './node_modules/graphql/language/lexer.js':
                /*!************************************************!*\
  !*** ./node_modules/graphql/language/lexer.js ***!
  \************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
                    exports.Lexer = void 0;

                    var _syntaxError = __webpack_require__(
                        /*! ../error/syntaxError.js */ './node_modules/graphql/error/syntaxError.js'
                    );

                    var _ast = __webpack_require__(
                        /*! ./ast.js */ './node_modules/graphql/language/ast.js'
                    );

                    var _tokenKind = __webpack_require__(
                        /*! ./tokenKind.js */ './node_modules/graphql/language/tokenKind.js'
                    );

                    var _blockString = __webpack_require__(
                        /*! ./blockString.js */ './node_modules/graphql/language/blockString.js'
                    );

                    /**
                     * Given a Source object, creates a Lexer for that source.
                     * A Lexer is a stateful stream generator in that every time
                     * it is advanced, it returns the next token in the Source. Assuming the
                     * source lexes, the final Token emitted by the lexer will be of kind
                     * EOF, after which the lexer will repeatedly return the same EOF token
                     * whenever called.
                     */
                    var Lexer = /*#__PURE__*/ (function () {
                        /**
                         * The previously focused non-ignored token.
                         */

                        /**
                         * The currently focused non-ignored token.
                         */

                        /**
                         * The (1-indexed) line containing the current token.
                         */

                        /**
                         * The character offset at which the current line begins.
                         */
                        function Lexer(source) {
                            var startOfFileToken = new _ast.Token(
                                _tokenKind.TokenKind.SOF,
                                0,
                                0,
                                0,
                                0,
                                null
                            );
                            this.source = source;
                            this.lastToken = startOfFileToken;
                            this.token = startOfFileToken;
                            this.line = 1;
                            this.lineStart = 0;
                        }
                        /**
                         * Advances the token stream to the next non-ignored token.
                         */

                        var _proto = Lexer.prototype;

                        _proto.advance = function advance() {
                            this.lastToken = this.token;
                            var token = (this.token = this.lookahead());
                            return token;
                        };
                        /**
                         * Looks ahead and returns the next non-ignored token, but does not change
                         * the state of Lexer.
                         */

                        _proto.lookahead = function lookahead() {
                            var token = this.token;

                            if (token.kind !== _tokenKind.TokenKind.EOF) {
                                do {
                                    var _token$next;

                                    // Note: next is only mutable during parsing, so we cast to allow this.
                                    token =
                                        (_token$next = token.next) !== null &&
                                        _token$next !== void 0
                                            ? _token$next
                                            : (token.next = readToken(
                                                  this,
                                                  token
                                              ));
                                } while (
                                    token.kind === _tokenKind.TokenKind.COMMENT
                                );
                            }

                            return token;
                        };

                        return Lexer;
                    })();
                    /**
                     * @internal
                     */

                    exports.Lexer = Lexer;

                    function isPunctuatorTokenKind(kind) {
                        return (
                            kind === _tokenKind.TokenKind.BANG ||
                            kind === _tokenKind.TokenKind.DOLLAR ||
                            kind === _tokenKind.TokenKind.AMP ||
                            kind === _tokenKind.TokenKind.PAREN_L ||
                            kind === _tokenKind.TokenKind.PAREN_R ||
                            kind === _tokenKind.TokenKind.SPREAD ||
                            kind === _tokenKind.TokenKind.COLON ||
                            kind === _tokenKind.TokenKind.EQUALS ||
                            kind === _tokenKind.TokenKind.AT ||
                            kind === _tokenKind.TokenKind.BRACKET_L ||
                            kind === _tokenKind.TokenKind.BRACKET_R ||
                            kind === _tokenKind.TokenKind.BRACE_L ||
                            kind === _tokenKind.TokenKind.PIPE ||
                            kind === _tokenKind.TokenKind.BRACE_R
                        );
                    }

                    function printCharCode(code) {
                        return (
                            // NaN/undefined represents access beyond the end of the file.
                            isNaN(code)
                                ? _tokenKind.TokenKind.EOF // Trust JSON for ASCII.
                                : code < 0x007f
                                ? JSON.stringify(String.fromCharCode(code)) // Otherwise print the escaped form.
                                : '"\\u'.concat(
                                      (
                                          '00' + code.toString(16).toUpperCase()
                                      ).slice(-4),
                                      '"'
                                  )
                        );
                    }
                    /**
                     * Gets the next token from the source starting at the given position.
                     *
                     * This skips over whitespace until it finds the next lexable token, then lexes
                     * punctuators immediately or calls the appropriate helper function for more
                     * complicated tokens.
                     */

                    function readToken(lexer, prev) {
                        var source = lexer.source;
                        var body = source.body;
                        var bodyLength = body.length;
                        var pos = prev.end;

                        while (pos < bodyLength) {
                            var code = body.charCodeAt(pos);
                            var _line = lexer.line;

                            var _col = 1 + pos - lexer.lineStart; // SourceCharacter

                            switch (code) {
                                case 0xfeff: // <BOM>

                                case 9: //   \t

                                case 32: //  <space>

                                case 44:
                                    //  ,
                                    ++pos;
                                    continue;

                                case 10:
                                    //  \n
                                    ++pos;
                                    ++lexer.line;
                                    lexer.lineStart = pos;
                                    continue;

                                case 13:
                                    //  \r
                                    if (body.charCodeAt(pos + 1) === 10) {
                                        pos += 2;
                                    } else {
                                        ++pos;
                                    }

                                    ++lexer.line;
                                    lexer.lineStart = pos;
                                    continue;

                                case 33:
                                    //  !
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.BANG,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 35:
                                    //  #
                                    return readComment(
                                        source,
                                        pos,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 36:
                                    //  $
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.DOLLAR,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 38:
                                    //  &
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.AMP,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 40:
                                    //  (
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.PAREN_L,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 41:
                                    //  )
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.PAREN_R,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 46:
                                    //  .
                                    if (
                                        body.charCodeAt(pos + 1) === 46 &&
                                        body.charCodeAt(pos + 2) === 46
                                    ) {
                                        return new _ast.Token(
                                            _tokenKind.TokenKind.SPREAD,
                                            pos,
                                            pos + 3,
                                            _line,
                                            _col,
                                            prev
                                        );
                                    }

                                    break;

                                case 58:
                                    //  :
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.COLON,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 61:
                                    //  =
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.EQUALS,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 64:
                                    //  @
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.AT,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 91:
                                    //  [
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.BRACKET_L,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 93:
                                    //  ]
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.BRACKET_R,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 123:
                                    // {
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.BRACE_L,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 124:
                                    // |
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.PIPE,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 125:
                                    // }
                                    return new _ast.Token(
                                        _tokenKind.TokenKind.BRACE_R,
                                        pos,
                                        pos + 1,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 34:
                                    //  "
                                    if (
                                        body.charCodeAt(pos + 1) === 34 &&
                                        body.charCodeAt(pos + 2) === 34
                                    ) {
                                        return readBlockString(
                                            source,
                                            pos,
                                            _line,
                                            _col,
                                            prev,
                                            lexer
                                        );
                                    }

                                    return readString(
                                        source,
                                        pos,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 45: //  -

                                case 48: //  0

                                case 49: //  1

                                case 50: //  2

                                case 51: //  3

                                case 52: //  4

                                case 53: //  5

                                case 54: //  6

                                case 55: //  7

                                case 56: //  8

                                case 57:
                                    //  9
                                    return readNumber(
                                        source,
                                        pos,
                                        code,
                                        _line,
                                        _col,
                                        prev
                                    );

                                case 65: //  A

                                case 66: //  B

                                case 67: //  C

                                case 68: //  D

                                case 69: //  E

                                case 70: //  F

                                case 71: //  G

                                case 72: //  H

                                case 73: //  I

                                case 74: //  J

                                case 75: //  K

                                case 76: //  L

                                case 77: //  M

                                case 78: //  N

                                case 79: //  O

                                case 80: //  P

                                case 81: //  Q

                                case 82: //  R

                                case 83: //  S

                                case 84: //  T

                                case 85: //  U

                                case 86: //  V

                                case 87: //  W

                                case 88: //  X

                                case 89: //  Y

                                case 90: //  Z

                                case 95: //  _

                                case 97: //  a

                                case 98: //  b

                                case 99: //  c

                                case 100: // d

                                case 101: // e

                                case 102: // f

                                case 103: // g

                                case 104: // h

                                case 105: // i

                                case 106: // j

                                case 107: // k

                                case 108: // l

                                case 109: // m

                                case 110: // n

                                case 111: // o

                                case 112: // p

                                case 113: // q

                                case 114: // r

                                case 115: // s

                                case 116: // t

                                case 117: // u

                                case 118: // v

                                case 119: // w

                                case 120: // x

                                case 121: // y

                                case 122:
                                    // z
                                    return readName(
                                        source,
                                        pos,
                                        _line,
                                        _col,
                                        prev
                                    );
                            }

                            throw (0, _syntaxError.syntaxError)(
                                source,
                                pos,
                                unexpectedCharacterMessage(code)
                            );
                        }

                        var line = lexer.line;
                        var col = 1 + pos - lexer.lineStart;
                        return new _ast.Token(
                            _tokenKind.TokenKind.EOF,
                            bodyLength,
                            bodyLength,
                            line,
                            col,
                            prev
                        );
                    }
                    /**
                     * Report a message that an unexpected character was encountered.
                     */

                    function unexpectedCharacterMessage(code) {
                        if (
                            code < 0x0020 &&
                            code !== 0x0009 &&
                            code !== 0x000a &&
                            code !== 0x000d
                        ) {
                            return 'Cannot contain the invalid character '.concat(
                                printCharCode(code),
                                '.'
                            );
                        }

                        if (code === 39) {
                            // '
                            return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
                        }

                        return 'Cannot parse the unexpected character '.concat(
                            printCharCode(code),
                            '.'
                        );
                    }
                    /**
                     * Reads a comment token from the source file.
                     *
                     * #[\u0009\u0020-\uFFFF]*
                     */

                    function readComment(source, start, line, col, prev) {
                        var body = source.body;
                        var code;
                        var position = start;

                        do {
                            code = body.charCodeAt(++position);
                        } while (
                            !isNaN(code) && // SourceCharacter but not LineTerminator
                            (code > 0x001f || code === 0x0009)
                        );

                        return new _ast.Token(
                            _tokenKind.TokenKind.COMMENT,
                            start,
                            position,
                            line,
                            col,
                            prev,
                            body.slice(start + 1, position)
                        );
                    }
                    /**
                     * Reads a number token from the source file, either a float
                     * or an int depending on whether a decimal point appears.
                     *
                     * Int:   -?(0|[1-9][0-9]*)
                     * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
                     */

                    function readNumber(
                        source,
                        start,
                        firstCode,
                        line,
                        col,
                        prev
                    ) {
                        var body = source.body;
                        var code = firstCode;
                        var position = start;
                        var isFloat = false;

                        if (code === 45) {
                            // -
                            code = body.charCodeAt(++position);
                        }

                        if (code === 48) {
                            // 0
                            code = body.charCodeAt(++position);

                            if (code >= 48 && code <= 57) {
                                throw (0, _syntaxError.syntaxError)(
                                    source,
                                    position,
                                    'Invalid number, unexpected digit after 0: '.concat(
                                        printCharCode(code),
                                        '.'
                                    )
                                );
                            }
                        } else {
                            position = readDigits(source, position, code);
                            code = body.charCodeAt(position);
                        }

                        if (code === 46) {
                            // .
                            isFloat = true;
                            code = body.charCodeAt(++position);
                            position = readDigits(source, position, code);
                            code = body.charCodeAt(position);
                        }

                        if (code === 69 || code === 101) {
                            // E e
                            isFloat = true;
                            code = body.charCodeAt(++position);

                            if (code === 43 || code === 45) {
                                // + -
                                code = body.charCodeAt(++position);
                            }

                            position = readDigits(source, position, code);
                            code = body.charCodeAt(position);
                        } // Numbers cannot be followed by . or NameStart

                        if (code === 46 || isNameStart(code)) {
                            throw (0, _syntaxError.syntaxError)(
                                source,
                                position,
                                'Invalid number, expected digit but got: '.concat(
                                    printCharCode(code),
                                    '.'
                                )
                            );
                        }

                        return new _ast.Token(
                            isFloat
                                ? _tokenKind.TokenKind.FLOAT
                                : _tokenKind.TokenKind.INT,
                            start,
                            position,
                            line,
                            col,
                            prev,
                            body.slice(start, position)
                        );
                    }
                    /**
                     * Returns the new position in the source after reading digits.
                     */

                    function readDigits(source, start, firstCode) {
                        var body = source.body;
                        var position = start;
                        var code = firstCode;

                        if (code >= 48 && code <= 57) {
                            // 0 - 9
                            do {
                                code = body.charCodeAt(++position);
                            } while (code >= 48 && code <= 57); // 0 - 9

                            return position;
                        }

                        throw (0, _syntaxError.syntaxError)(
                            source,
                            position,
                            'Invalid number, expected digit but got: '.concat(
                                printCharCode(code),
                                '.'
                            )
                        );
                    }
                    /**
                     * Reads a string token from the source file.
                     *
                     * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
                     */

                    function readString(source, start, line, col, prev) {
                        var body = source.body;
                        var position = start + 1;
                        var chunkStart = position;
                        var code = 0;
                        var value = '';

                        while (
                            position < body.length &&
                            !isNaN((code = body.charCodeAt(position))) && // not LineTerminator
                            code !== 0x000a &&
                            code !== 0x000d
                        ) {
                            // Closing Quote (")
                            if (code === 34) {
                                value += body.slice(chunkStart, position);
                                return new _ast.Token(
                                    _tokenKind.TokenKind.STRING,
                                    start,
                                    position + 1,
                                    line,
                                    col,
                                    prev,
                                    value
                                );
                            } // SourceCharacter

                            if (code < 0x0020 && code !== 0x0009) {
                                throw (0, _syntaxError.syntaxError)(
                                    source,
                                    position,
                                    'Invalid character within String: '.concat(
                                        printCharCode(code),
                                        '.'
                                    )
                                );
                            }

                            ++position;

                            if (code === 92) {
                                // \
                                value += body.slice(chunkStart, position - 1);
                                code = body.charCodeAt(position);

                                switch (code) {
                                    case 34:
                                        value += '"';
                                        break;

                                    case 47:
                                        value += '/';
                                        break;

                                    case 92:
                                        value += '\\';
                                        break;

                                    case 98:
                                        value += '\b';
                                        break;

                                    case 102:
                                        value += '\f';
                                        break;

                                    case 110:
                                        value += '\n';
                                        break;

                                    case 114:
                                        value += '\r';
                                        break;

                                    case 116:
                                        value += '\t';
                                        break;

                                    case 117: {
                                        // uXXXX
                                        var charCode = uniCharCode(
                                            body.charCodeAt(position + 1),
                                            body.charCodeAt(position + 2),
                                            body.charCodeAt(position + 3),
                                            body.charCodeAt(position + 4)
                                        );

                                        if (charCode < 0) {
                                            var invalidSequence = body.slice(
                                                position + 1,
                                                position + 5
                                            );
                                            throw (0, _syntaxError.syntaxError)(
                                                source,
                                                position,
                                                'Invalid character escape sequence: \\u'.concat(
                                                    invalidSequence,
                                                    '.'
                                                )
                                            );
                                        }

                                        value += String.fromCharCode(charCode);
                                        position += 4;
                                        break;
                                    }

                                    default:
                                        throw (0, _syntaxError.syntaxError)(
                                            source,
                                            position,
                                            'Invalid character escape sequence: \\'.concat(
                                                String.fromCharCode(code),
                                                '.'
                                            )
                                        );
                                }

                                ++position;
                                chunkStart = position;
                            }
                        }

                        throw (0, _syntaxError.syntaxError)(
                            source,
                            position,
                            'Unterminated string.'
                        );
                    }
                    /**
                     * Reads a block string token from the source file.
                     *
                     * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
                     */

                    function readBlockString(
                        source,
                        start,
                        line,
                        col,
                        prev,
                        lexer
                    ) {
                        var body = source.body;
                        var position = start + 3;
                        var chunkStart = position;
                        var code = 0;
                        var rawValue = '';

                        while (
                            position < body.length &&
                            !isNaN((code = body.charCodeAt(position)))
                        ) {
                            // Closing Triple-Quote (""")
                            if (
                                code === 34 &&
                                body.charCodeAt(position + 1) === 34 &&
                                body.charCodeAt(position + 2) === 34
                            ) {
                                rawValue += body.slice(chunkStart, position);
                                return new _ast.Token(
                                    _tokenKind.TokenKind.BLOCK_STRING,
                                    start,
                                    position + 3,
                                    line,
                                    col,
                                    prev,
                                    (0, _blockString.dedentBlockStringValue)(
                                        rawValue
                                    )
                                );
                            } // SourceCharacter

                            if (
                                code < 0x0020 &&
                                code !== 0x0009 &&
                                code !== 0x000a &&
                                code !== 0x000d
                            ) {
                                throw (0, _syntaxError.syntaxError)(
                                    source,
                                    position,
                                    'Invalid character within String: '.concat(
                                        printCharCode(code),
                                        '.'
                                    )
                                );
                            }

                            if (code === 10) {
                                // new line
                                ++position;
                                ++lexer.line;
                                lexer.lineStart = position;
                            } else if (code === 13) {
                                // carriage return
                                if (body.charCodeAt(position + 1) === 10) {
                                    position += 2;
                                } else {
                                    ++position;
                                }

                                ++lexer.line;
                                lexer.lineStart = position;
                            } else if (
                                // Escape Triple-Quote (\""")
                                code === 92 &&
                                body.charCodeAt(position + 1) === 34 &&
                                body.charCodeAt(position + 2) === 34 &&
                                body.charCodeAt(position + 3) === 34
                            ) {
                                rawValue +=
                                    body.slice(chunkStart, position) + '"""';
                                position += 4;
                                chunkStart = position;
                            } else {
                                ++position;
                            }
                        }

                        throw (0, _syntaxError.syntaxError)(
                            source,
                            position,
                            'Unterminated string.'
                        );
                    }
                    /**
                     * Converts four hexadecimal chars to the integer that the
                     * string represents. For example, uniCharCode('0','0','0','f')
                     * will return 15, and uniCharCode('0','0','f','f') returns 255.
                     *
                     * Returns a negative number on error, if a char was invalid.
                     *
                     * This is implemented by noting that char2hex() returns -1 on error,
                     * which means the result of ORing the char2hex() will also be negative.
                     */

                    function uniCharCode(a, b, c, d) {
                        return (
                            (char2hex(a) << 12) |
                            (char2hex(b) << 8) |
                            (char2hex(c) << 4) |
                            char2hex(d)
                        );
                    }
                    /**
                     * Converts a hex character to its integer value.
                     * '0' becomes 0, '9' becomes 9
                     * 'A' becomes 10, 'F' becomes 15
                     * 'a' becomes 10, 'f' becomes 15
                     *
                     * Returns -1 on error.
                     */

                    function char2hex(a) {
                        return a >= 48 && a <= 57
                            ? a - 48 // 0-9
                            : a >= 65 && a <= 70
                            ? a - 55 // A-F
                            : a >= 97 && a <= 102
                            ? a - 87 // a-f
                            : -1;
                    }
                    /**
                     * Reads an alphanumeric + underscore name from the source.
                     *
                     * [_A-Za-z][_0-9A-Za-z]*
                     */

                    function readName(source, start, line, col, prev) {
                        var body = source.body;
                        var bodyLength = body.length;
                        var position = start + 1;
                        var code = 0;

                        while (
                            position !== bodyLength &&
                            !isNaN((code = body.charCodeAt(position))) &&
                            (code === 95 || // _
                                (code >= 48 && code <= 57) || // 0-9
                                (code >= 65 && code <= 90) || // A-Z
                                (code >= 97 && code <= 122)) // a-z
                        ) {
                            ++position;
                        }

                        return new _ast.Token(
                            _tokenKind.TokenKind.NAME,
                            start,
                            position,
                            line,
                            col,
                            prev,
                            body.slice(start, position)
                        );
                    } // _ A-Z a-z

                    function isNameStart(code) {
                        return (
                            code === 95 ||
                            (code >= 65 && code <= 90) ||
                            (code >= 97 && code <= 122)
                        );
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/location.js':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/language/location.js ***!
  \***************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.getLocation = getLocation;

                    /**
                     * Represents a location in a Source.
                     */

                    /**
                     * Takes a Source and a UTF-8 character offset, and returns the corresponding
                     * line and column as a SourceLocation.
                     */
                    function getLocation(source, position) {
                        var lineRegexp = /\r\n|[\n\r]/g;
                        var line = 1;
                        var column = position + 1;
                        var match;

                        while (
                            (match = lineRegexp.exec(source.body)) &&
                            match.index < position
                        ) {
                            line += 1;
                            column =
                                position + 1 - (match.index + match[0].length);
                        }

                        return {
                            line: line,
                            column: column,
                        };
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/parser.js':
                /*!*************************************************!*\
  !*** ./node_modules/graphql/language/parser.js ***!
  \*************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.parse = parse;
                    exports.parseValue = parseValue;
                    exports.parseType = parseType;
                    exports.Parser = void 0;

                    var _syntaxError = __webpack_require__(
                        /*! ../error/syntaxError.js */ './node_modules/graphql/error/syntaxError.js'
                    );

                    var _kinds = __webpack_require__(
                        /*! ./kinds.js */ './node_modules/graphql/language/kinds.js'
                    );

                    var _ast = __webpack_require__(
                        /*! ./ast.js */ './node_modules/graphql/language/ast.js'
                    );

                    var _tokenKind = __webpack_require__(
                        /*! ./tokenKind.js */ './node_modules/graphql/language/tokenKind.js'
                    );

                    var _source = __webpack_require__(
                        /*! ./source.js */ './node_modules/graphql/language/source.js'
                    );

                    var _directiveLocation = __webpack_require__(
                        /*! ./directiveLocation.js */ './node_modules/graphql/language/directiveLocation.js'
                    );

                    var _lexer = __webpack_require__(
                        /*! ./lexer.js */ './node_modules/graphql/language/lexer.js'
                    );

                    /**
                     * Given a GraphQL source, parses it into a Document.
                     * Throws GraphQLError if a syntax error is encountered.
                     */
                    function parse(source, options) {
                        var parser = new Parser(source, options);
                        return parser.parseDocument();
                    }
                    /**
                     * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
                     * that value.
                     * Throws GraphQLError if a syntax error is encountered.
                     *
                     * This is useful within tools that operate upon GraphQL Values directly and
                     * in isolation of complete GraphQL documents.
                     *
                     * Consider providing the results to the utility function: valueFromAST().
                     */

                    function parseValue(source, options) {
                        var parser = new Parser(source, options);
                        parser.expectToken(_tokenKind.TokenKind.SOF);
                        var value = parser.parseValueLiteral(false);
                        parser.expectToken(_tokenKind.TokenKind.EOF);
                        return value;
                    }
                    /**
                     * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
                     * that type.
                     * Throws GraphQLError if a syntax error is encountered.
                     *
                     * This is useful within tools that operate upon GraphQL Types directly and
                     * in isolation of complete GraphQL documents.
                     *
                     * Consider providing the results to the utility function: typeFromAST().
                     */

                    function parseType(source, options) {
                        var parser = new Parser(source, options);
                        parser.expectToken(_tokenKind.TokenKind.SOF);
                        var type = parser.parseTypeReference();
                        parser.expectToken(_tokenKind.TokenKind.EOF);
                        return type;
                    }
                    /**
                     * This class is exported only to assist people in implementing their own parsers
                     * without duplicating too much code and should be used only as last resort for cases
                     * such as experimental syntax or if certain features could not be contributed upstream.
                     *
                     * It is still part of the internal API and is versioned, so any changes to it are never
                     * considered breaking changes. If you still need to support multiple versions of the
                     * library, please use the `versionInfo` variable for version detection.
                     *
                     * @internal
                     */

                    var Parser = /*#__PURE__*/ (function () {
                        function Parser(source, options) {
                            var sourceObj = (0, _source.isSource)(source)
                                ? source
                                : new _source.Source(source);
                            this._lexer = new _lexer.Lexer(sourceObj);
                            this._options = options;
                        }
                        /**
                         * Converts a name lex token into a name parse node.
                         */

                        var _proto = Parser.prototype;

                        _proto.parseName = function parseName() {
                            var token = this.expectToken(
                                _tokenKind.TokenKind.NAME
                            );
                            return {
                                kind: _kinds.Kind.NAME,
                                value: token.value,
                                loc: this.loc(token),
                            };
                        }; // Implements the parsing rules in the Document section.

                        /**
                         * Document : Definition+
                         */

                        _proto.parseDocument = function parseDocument() {
                            var start = this._lexer.token;
                            return {
                                kind: _kinds.Kind.DOCUMENT,
                                definitions: this.many(
                                    _tokenKind.TokenKind.SOF,
                                    this.parseDefinition,
                                    _tokenKind.TokenKind.EOF
                                ),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * Definition :
                         *   - ExecutableDefinition
                         *   - TypeSystemDefinition
                         *   - TypeSystemExtension
                         *
                         * ExecutableDefinition :
                         *   - OperationDefinition
                         *   - FragmentDefinition
                         */

                        _proto.parseDefinition = function parseDefinition() {
                            if (this.peek(_tokenKind.TokenKind.NAME)) {
                                switch (this._lexer.token.value) {
                                    case 'query':
                                    case 'mutation':
                                    case 'subscription':
                                        return this.parseOperationDefinition();

                                    case 'fragment':
                                        return this.parseFragmentDefinition();

                                    case 'schema':
                                    case 'scalar':
                                    case 'type':
                                    case 'interface':
                                    case 'union':
                                    case 'enum':
                                    case 'input':
                                    case 'directive':
                                        return this.parseTypeSystemDefinition();

                                    case 'extend':
                                        return this.parseTypeSystemExtension();
                                }
                            } else if (
                                this.peek(_tokenKind.TokenKind.BRACE_L)
                            ) {
                                return this.parseOperationDefinition();
                            } else if (this.peekDescription()) {
                                return this.parseTypeSystemDefinition();
                            }

                            throw this.unexpected();
                        }; // Implements the parsing rules in the Operations section.

                        /**
                         * OperationDefinition :
                         *  - SelectionSet
                         *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
                         */

                        _proto.parseOperationDefinition = function parseOperationDefinition() {
                            var start = this._lexer.token;

                            if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
                                return {
                                    kind: _kinds.Kind.OPERATION_DEFINITION,
                                    operation: 'query',
                                    name: undefined,
                                    variableDefinitions: [],
                                    directives: [],
                                    selectionSet: this.parseSelectionSet(),
                                    loc: this.loc(start),
                                };
                            }

                            var operation = this.parseOperationType();
                            var name;

                            if (this.peek(_tokenKind.TokenKind.NAME)) {
                                name = this.parseName();
                            }

                            return {
                                kind: _kinds.Kind.OPERATION_DEFINITION,
                                operation: operation,
                                name: name,
                                variableDefinitions: this.parseVariableDefinitions(),
                                directives: this.parseDirectives(false),
                                selectionSet: this.parseSelectionSet(),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * OperationType : one of query mutation subscription
                         */

                        _proto.parseOperationType = function parseOperationType() {
                            var operationToken = this.expectToken(
                                _tokenKind.TokenKind.NAME
                            );

                            switch (operationToken.value) {
                                case 'query':
                                    return 'query';

                                case 'mutation':
                                    return 'mutation';

                                case 'subscription':
                                    return 'subscription';
                            }

                            throw this.unexpected(operationToken);
                        };
                        /**
                         * VariableDefinitions : ( VariableDefinition+ )
                         */

                        _proto.parseVariableDefinitions = function parseVariableDefinitions() {
                            return this.optionalMany(
                                _tokenKind.TokenKind.PAREN_L,
                                this.parseVariableDefinition,
                                _tokenKind.TokenKind.PAREN_R
                            );
                        };
                        /**
                         * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
                         */

                        _proto.parseVariableDefinition = function parseVariableDefinition() {
                            var start = this._lexer.token;
                            return {
                                kind: _kinds.Kind.VARIABLE_DEFINITION,
                                variable: this.parseVariable(),
                                type:
                                    (this.expectToken(
                                        _tokenKind.TokenKind.COLON
                                    ),
                                    this.parseTypeReference()),
                                defaultValue: this.expectOptionalToken(
                                    _tokenKind.TokenKind.EQUALS
                                )
                                    ? this.parseValueLiteral(true)
                                    : undefined,
                                directives: this.parseDirectives(true),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * Variable : $ Name
                         */

                        _proto.parseVariable = function parseVariable() {
                            var start = this._lexer.token;
                            this.expectToken(_tokenKind.TokenKind.DOLLAR);
                            return {
                                kind: _kinds.Kind.VARIABLE,
                                name: this.parseName(),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * SelectionSet : { Selection+ }
                         */

                        _proto.parseSelectionSet = function parseSelectionSet() {
                            var start = this._lexer.token;
                            return {
                                kind: _kinds.Kind.SELECTION_SET,
                                selections: this.many(
                                    _tokenKind.TokenKind.BRACE_L,
                                    this.parseSelection,
                                    _tokenKind.TokenKind.BRACE_R
                                ),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * Selection :
                         *   - Field
                         *   - FragmentSpread
                         *   - InlineFragment
                         */

                        _proto.parseSelection = function parseSelection() {
                            return this.peek(_tokenKind.TokenKind.SPREAD)
                                ? this.parseFragment()
                                : this.parseField();
                        };
                        /**
                         * Field : Alias? Name Arguments? Directives? SelectionSet?
                         *
                         * Alias : Name :
                         */

                        _proto.parseField = function parseField() {
                            var start = this._lexer.token;
                            var nameOrAlias = this.parseName();
                            var alias;
                            var name;

                            if (
                                this.expectOptionalToken(
                                    _tokenKind.TokenKind.COLON
                                )
                            ) {
                                alias = nameOrAlias;
                                name = this.parseName();
                            } else {
                                name = nameOrAlias;
                            }

                            return {
                                kind: _kinds.Kind.FIELD,
                                alias: alias,
                                name: name,
                                arguments: this.parseArguments(false),
                                directives: this.parseDirectives(false),
                                selectionSet: this.peek(
                                    _tokenKind.TokenKind.BRACE_L
                                )
                                    ? this.parseSelectionSet()
                                    : undefined,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * Arguments[Const] : ( Argument[?Const]+ )
                         */

                        _proto.parseArguments = function parseArguments(
                            isConst
                        ) {
                            var item = isConst
                                ? this.parseConstArgument
                                : this.parseArgument;
                            return this.optionalMany(
                                _tokenKind.TokenKind.PAREN_L,
                                item,
                                _tokenKind.TokenKind.PAREN_R
                            );
                        };
                        /**
                         * Argument[Const] : Name : Value[?Const]
                         */

                        _proto.parseArgument = function parseArgument() {
                            var start = this._lexer.token;
                            var name = this.parseName();
                            this.expectToken(_tokenKind.TokenKind.COLON);
                            return {
                                kind: _kinds.Kind.ARGUMENT,
                                name: name,
                                value: this.parseValueLiteral(false),
                                loc: this.loc(start),
                            };
                        };

                        _proto.parseConstArgument = function parseConstArgument() {
                            var start = this._lexer.token;
                            return {
                                kind: _kinds.Kind.ARGUMENT,
                                name: this.parseName(),
                                value:
                                    (this.expectToken(
                                        _tokenKind.TokenKind.COLON
                                    ),
                                    this.parseValueLiteral(true)),
                                loc: this.loc(start),
                            };
                        }; // Implements the parsing rules in the Fragments section.

                        /**
                         * Corresponds to both FragmentSpread and InlineFragment in the spec.
                         *
                         * FragmentSpread : ... FragmentName Directives?
                         *
                         * InlineFragment : ... TypeCondition? Directives? SelectionSet
                         */

                        _proto.parseFragment = function parseFragment() {
                            var start = this._lexer.token;
                            this.expectToken(_tokenKind.TokenKind.SPREAD);
                            var hasTypeCondition = this.expectOptionalKeyword(
                                'on'
                            );

                            if (
                                !hasTypeCondition &&
                                this.peek(_tokenKind.TokenKind.NAME)
                            ) {
                                return {
                                    kind: _kinds.Kind.FRAGMENT_SPREAD,
                                    name: this.parseFragmentName(),
                                    directives: this.parseDirectives(false),
                                    loc: this.loc(start),
                                };
                            }

                            return {
                                kind: _kinds.Kind.INLINE_FRAGMENT,
                                typeCondition: hasTypeCondition
                                    ? this.parseNamedType()
                                    : undefined,
                                directives: this.parseDirectives(false),
                                selectionSet: this.parseSelectionSet(),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * FragmentDefinition :
                         *   - fragment FragmentName on TypeCondition Directives? SelectionSet
                         *
                         * TypeCondition : NamedType
                         */

                        _proto.parseFragmentDefinition = function parseFragmentDefinition() {
                            var _this$_options;

                            var start = this._lexer.token;
                            this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
                            // the grammar of FragmentDefinition:
                            //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

                            if (
                                ((_this$_options = this._options) === null ||
                                _this$_options === void 0
                                    ? void 0
                                    : _this$_options.experimentalFragmentVariables) ===
                                true
                            ) {
                                return {
                                    kind: _kinds.Kind.FRAGMENT_DEFINITION,
                                    name: this.parseFragmentName(),
                                    variableDefinitions: this.parseVariableDefinitions(),
                                    typeCondition:
                                        (this.expectKeyword('on'),
                                        this.parseNamedType()),
                                    directives: this.parseDirectives(false),
                                    selectionSet: this.parseSelectionSet(),
                                    loc: this.loc(start),
                                };
                            }

                            return {
                                kind: _kinds.Kind.FRAGMENT_DEFINITION,
                                name: this.parseFragmentName(),
                                typeCondition:
                                    (this.expectKeyword('on'),
                                    this.parseNamedType()),
                                directives: this.parseDirectives(false),
                                selectionSet: this.parseSelectionSet(),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * FragmentName : Name but not `on`
                         */

                        _proto.parseFragmentName = function parseFragmentName() {
                            if (this._lexer.token.value === 'on') {
                                throw this.unexpected();
                            }

                            return this.parseName();
                        }; // Implements the parsing rules in the Values section.

                        /**
                         * Value[Const] :
                         *   - [~Const] Variable
                         *   - IntValue
                         *   - FloatValue
                         *   - StringValue
                         *   - BooleanValue
                         *   - NullValue
                         *   - EnumValue
                         *   - ListValue[?Const]
                         *   - ObjectValue[?Const]
                         *
                         * BooleanValue : one of `true` `false`
                         *
                         * NullValue : `null`
                         *
                         * EnumValue : Name but not `true`, `false` or `null`
                         */

                        _proto.parseValueLiteral = function parseValueLiteral(
                            isConst
                        ) {
                            var token = this._lexer.token;

                            switch (token.kind) {
                                case _tokenKind.TokenKind.BRACKET_L:
                                    return this.parseList(isConst);

                                case _tokenKind.TokenKind.BRACE_L:
                                    return this.parseObject(isConst);

                                case _tokenKind.TokenKind.INT:
                                    this._lexer.advance();

                                    return {
                                        kind: _kinds.Kind.INT,
                                        value: token.value,
                                        loc: this.loc(token),
                                    };

                                case _tokenKind.TokenKind.FLOAT:
                                    this._lexer.advance();

                                    return {
                                        kind: _kinds.Kind.FLOAT,
                                        value: token.value,
                                        loc: this.loc(token),
                                    };

                                case _tokenKind.TokenKind.STRING:
                                case _tokenKind.TokenKind.BLOCK_STRING:
                                    return this.parseStringLiteral();

                                case _tokenKind.TokenKind.NAME:
                                    this._lexer.advance();

                                    switch (token.value) {
                                        case 'true':
                                            return {
                                                kind: _kinds.Kind.BOOLEAN,
                                                value: true,
                                                loc: this.loc(token),
                                            };

                                        case 'false':
                                            return {
                                                kind: _kinds.Kind.BOOLEAN,
                                                value: false,
                                                loc: this.loc(token),
                                            };

                                        case 'null':
                                            return {
                                                kind: _kinds.Kind.NULL,
                                                loc: this.loc(token),
                                            };

                                        default:
                                            return {
                                                kind: _kinds.Kind.ENUM,
                                                value: token.value,
                                                loc: this.loc(token),
                                            };
                                    }

                                case _tokenKind.TokenKind.DOLLAR:
                                    if (!isConst) {
                                        return this.parseVariable();
                                    }

                                    break;
                            }

                            throw this.unexpected();
                        };

                        _proto.parseStringLiteral = function parseStringLiteral() {
                            var token = this._lexer.token;

                            this._lexer.advance();

                            return {
                                kind: _kinds.Kind.STRING,
                                value: token.value,
                                block:
                                    token.kind ===
                                    _tokenKind.TokenKind.BLOCK_STRING,
                                loc: this.loc(token),
                            };
                        };
                        /**
                         * ListValue[Const] :
                         *   - [ ]
                         *   - [ Value[?Const]+ ]
                         */

                        _proto.parseList = function parseList(isConst) {
                            var _this = this;

                            var start = this._lexer.token;

                            var item = function item() {
                                return _this.parseValueLiteral(isConst);
                            };

                            return {
                                kind: _kinds.Kind.LIST,
                                values: this.any(
                                    _tokenKind.TokenKind.BRACKET_L,
                                    item,
                                    _tokenKind.TokenKind.BRACKET_R
                                ),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ObjectValue[Const] :
                         *   - { }
                         *   - { ObjectField[?Const]+ }
                         */

                        _proto.parseObject = function parseObject(isConst) {
                            var _this2 = this;

                            var start = this._lexer.token;

                            var item = function item() {
                                return _this2.parseObjectField(isConst);
                            };

                            return {
                                kind: _kinds.Kind.OBJECT,
                                fields: this.any(
                                    _tokenKind.TokenKind.BRACE_L,
                                    item,
                                    _tokenKind.TokenKind.BRACE_R
                                ),
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ObjectField[Const] : Name : Value[?Const]
                         */

                        _proto.parseObjectField = function parseObjectField(
                            isConst
                        ) {
                            var start = this._lexer.token;
                            var name = this.parseName();
                            this.expectToken(_tokenKind.TokenKind.COLON);
                            return {
                                kind: _kinds.Kind.OBJECT_FIELD,
                                name: name,
                                value: this.parseValueLiteral(isConst),
                                loc: this.loc(start),
                            };
                        }; // Implements the parsing rules in the Directives section.

                        /**
                         * Directives[Const] : Directive[?Const]+
                         */

                        _proto.parseDirectives = function parseDirectives(
                            isConst
                        ) {
                            var directives = [];

                            while (this.peek(_tokenKind.TokenKind.AT)) {
                                directives.push(this.parseDirective(isConst));
                            }

                            return directives;
                        };
                        /**
                         * Directive[Const] : @ Name Arguments[?Const]?
                         */

                        _proto.parseDirective = function parseDirective(
                            isConst
                        ) {
                            var start = this._lexer.token;
                            this.expectToken(_tokenKind.TokenKind.AT);
                            return {
                                kind: _kinds.Kind.DIRECTIVE,
                                name: this.parseName(),
                                arguments: this.parseArguments(isConst),
                                loc: this.loc(start),
                            };
                        }; // Implements the parsing rules in the Types section.

                        /**
                         * Type :
                         *   - NamedType
                         *   - ListType
                         *   - NonNullType
                         */

                        _proto.parseTypeReference = function parseTypeReference() {
                            var start = this._lexer.token;
                            var type;

                            if (
                                this.expectOptionalToken(
                                    _tokenKind.TokenKind.BRACKET_L
                                )
                            ) {
                                type = this.parseTypeReference();
                                this.expectToken(
                                    _tokenKind.TokenKind.BRACKET_R
                                );
                                type = {
                                    kind: _kinds.Kind.LIST_TYPE,
                                    type: type,
                                    loc: this.loc(start),
                                };
                            } else {
                                type = this.parseNamedType();
                            }

                            if (
                                this.expectOptionalToken(
                                    _tokenKind.TokenKind.BANG
                                )
                            ) {
                                return {
                                    kind: _kinds.Kind.NON_NULL_TYPE,
                                    type: type,
                                    loc: this.loc(start),
                                };
                            }

                            return type;
                        };
                        /**
                         * NamedType : Name
                         */

                        _proto.parseNamedType = function parseNamedType() {
                            var start = this._lexer.token;
                            return {
                                kind: _kinds.Kind.NAMED_TYPE,
                                name: this.parseName(),
                                loc: this.loc(start),
                            };
                        }; // Implements the parsing rules in the Type Definition section.

                        /**
                         * TypeSystemDefinition :
                         *   - SchemaDefinition
                         *   - TypeDefinition
                         *   - DirectiveDefinition
                         *
                         * TypeDefinition :
                         *   - ScalarTypeDefinition
                         *   - ObjectTypeDefinition
                         *   - InterfaceTypeDefinition
                         *   - UnionTypeDefinition
                         *   - EnumTypeDefinition
                         *   - InputObjectTypeDefinition
                         */

                        _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
                            // Many definitions begin with a description and require a lookahead.
                            var keywordToken = this.peekDescription()
                                ? this._lexer.lookahead()
                                : this._lexer.token;

                            if (
                                keywordToken.kind === _tokenKind.TokenKind.NAME
                            ) {
                                switch (keywordToken.value) {
                                    case 'schema':
                                        return this.parseSchemaDefinition();

                                    case 'scalar':
                                        return this.parseScalarTypeDefinition();

                                    case 'type':
                                        return this.parseObjectTypeDefinition();

                                    case 'interface':
                                        return this.parseInterfaceTypeDefinition();

                                    case 'union':
                                        return this.parseUnionTypeDefinition();

                                    case 'enum':
                                        return this.parseEnumTypeDefinition();

                                    case 'input':
                                        return this.parseInputObjectTypeDefinition();

                                    case 'directive':
                                        return this.parseDirectiveDefinition();
                                }
                            }

                            throw this.unexpected(keywordToken);
                        };

                        _proto.peekDescription = function peekDescription() {
                            return (
                                this.peek(_tokenKind.TokenKind.STRING) ||
                                this.peek(_tokenKind.TokenKind.BLOCK_STRING)
                            );
                        };
                        /**
                         * Description : StringValue
                         */

                        _proto.parseDescription = function parseDescription() {
                            if (this.peekDescription()) {
                                return this.parseStringLiteral();
                            }
                        };
                        /**
                         * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
                         */

                        _proto.parseSchemaDefinition = function parseSchemaDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('schema');
                            var directives = this.parseDirectives(true);
                            var operationTypes = this.many(
                                _tokenKind.TokenKind.BRACE_L,
                                this.parseOperationTypeDefinition,
                                _tokenKind.TokenKind.BRACE_R
                            );
                            return {
                                kind: _kinds.Kind.SCHEMA_DEFINITION,
                                description: description,
                                directives: directives,
                                operationTypes: operationTypes,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * OperationTypeDefinition : OperationType : NamedType
                         */

                        _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
                            var start = this._lexer.token;
                            var operation = this.parseOperationType();
                            this.expectToken(_tokenKind.TokenKind.COLON);
                            var type = this.parseNamedType();
                            return {
                                kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
                                operation: operation,
                                type: type,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
                         */

                        _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('scalar');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            return {
                                kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                directives: directives,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ObjectTypeDefinition :
                         *   Description?
                         *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
                         */

                        _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('type');
                            var name = this.parseName();
                            var interfaces = this.parseImplementsInterfaces();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseFieldsDefinition();
                            return {
                                kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                interfaces: interfaces,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ImplementsInterfaces :
                         *   - implements `&`? NamedType
                         *   - ImplementsInterfaces & NamedType
                         */

                        _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
                            var _this$_options2;

                            if (!this.expectOptionalKeyword('implements')) {
                                return [];
                            }

                            if (
                                ((_this$_options2 = this._options) === null ||
                                _this$_options2 === void 0
                                    ? void 0
                                    : _this$_options2.allowLegacySDLImplementsInterfaces) ===
                                true
                            ) {
                                var types = []; // Optional leading ampersand

                                this.expectOptionalToken(
                                    _tokenKind.TokenKind.AMP
                                );

                                do {
                                    types.push(this.parseNamedType());
                                } while (
                                    this.expectOptionalToken(
                                        _tokenKind.TokenKind.AMP
                                    ) ||
                                    this.peek(_tokenKind.TokenKind.NAME)
                                );

                                return types;
                            }

                            return this.delimitedMany(
                                _tokenKind.TokenKind.AMP,
                                this.parseNamedType
                            );
                        };
                        /**
                         * FieldsDefinition : { FieldDefinition+ }
                         */

                        _proto.parseFieldsDefinition = function parseFieldsDefinition() {
                            var _this$_options3;

                            // Legacy support for the SDL?
                            if (
                                ((_this$_options3 = this._options) === null ||
                                _this$_options3 === void 0
                                    ? void 0
                                    : _this$_options3.allowLegacySDLEmptyFields) ===
                                    true &&
                                this.peek(_tokenKind.TokenKind.BRACE_L) &&
                                this._lexer.lookahead().kind ===
                                    _tokenKind.TokenKind.BRACE_R
                            ) {
                                this._lexer.advance();

                                this._lexer.advance();

                                return [];
                            }

                            return this.optionalMany(
                                _tokenKind.TokenKind.BRACE_L,
                                this.parseFieldDefinition,
                                _tokenKind.TokenKind.BRACE_R
                            );
                        };
                        /**
                         * FieldDefinition :
                         *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
                         */

                        _proto.parseFieldDefinition = function parseFieldDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            var name = this.parseName();
                            var args = this.parseArgumentDefs();
                            this.expectToken(_tokenKind.TokenKind.COLON);
                            var type = this.parseTypeReference();
                            var directives = this.parseDirectives(true);
                            return {
                                kind: _kinds.Kind.FIELD_DEFINITION,
                                description: description,
                                name: name,
                                arguments: args,
                                type: type,
                                directives: directives,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ArgumentsDefinition : ( InputValueDefinition+ )
                         */

                        _proto.parseArgumentDefs = function parseArgumentDefs() {
                            return this.optionalMany(
                                _tokenKind.TokenKind.PAREN_L,
                                this.parseInputValueDef,
                                _tokenKind.TokenKind.PAREN_R
                            );
                        };
                        /**
                         * InputValueDefinition :
                         *   - Description? Name : Type DefaultValue? Directives[Const]?
                         */

                        _proto.parseInputValueDef = function parseInputValueDef() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            var name = this.parseName();
                            this.expectToken(_tokenKind.TokenKind.COLON);
                            var type = this.parseTypeReference();
                            var defaultValue;

                            if (
                                this.expectOptionalToken(
                                    _tokenKind.TokenKind.EQUALS
                                )
                            ) {
                                defaultValue = this.parseValueLiteral(true);
                            }

                            var directives = this.parseDirectives(true);
                            return {
                                kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
                                description: description,
                                name: name,
                                type: type,
                                defaultValue: defaultValue,
                                directives: directives,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * InterfaceTypeDefinition :
                         *   - Description? interface Name Directives[Const]? FieldsDefinition?
                         */

                        _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('interface');
                            var name = this.parseName();
                            var interfaces = this.parseImplementsInterfaces();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseFieldsDefinition();
                            return {
                                kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                interfaces: interfaces,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * UnionTypeDefinition :
                         *   - Description? union Name Directives[Const]? UnionMemberTypes?
                         */

                        _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('union');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var types = this.parseUnionMemberTypes();
                            return {
                                kind: _kinds.Kind.UNION_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                directives: directives,
                                types: types,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * UnionMemberTypes :
                         *   - = `|`? NamedType
                         *   - UnionMemberTypes | NamedType
                         */

                        _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
                            return this.expectOptionalToken(
                                _tokenKind.TokenKind.EQUALS
                            )
                                ? this.delimitedMany(
                                      _tokenKind.TokenKind.PIPE,
                                      this.parseNamedType
                                  )
                                : [];
                        };
                        /**
                         * EnumTypeDefinition :
                         *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
                         */

                        _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('enum');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var values = this.parseEnumValuesDefinition();
                            return {
                                kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                directives: directives,
                                values: values,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * EnumValuesDefinition : { EnumValueDefinition+ }
                         */

                        _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
                            return this.optionalMany(
                                _tokenKind.TokenKind.BRACE_L,
                                this.parseEnumValueDefinition,
                                _tokenKind.TokenKind.BRACE_R
                            );
                        };
                        /**
                         * EnumValueDefinition : Description? EnumValue Directives[Const]?
                         *
                         * EnumValue : Name
                         */

                        _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            return {
                                kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
                                description: description,
                                name: name,
                                directives: directives,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * InputObjectTypeDefinition :
                         *   - Description? input Name Directives[Const]? InputFieldsDefinition?
                         */

                        _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('input');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseInputFieldsDefinition();
                            return {
                                kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
                                description: description,
                                name: name,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * InputFieldsDefinition : { InputValueDefinition+ }
                         */

                        _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
                            return this.optionalMany(
                                _tokenKind.TokenKind.BRACE_L,
                                this.parseInputValueDef,
                                _tokenKind.TokenKind.BRACE_R
                            );
                        };
                        /**
                         * TypeSystemExtension :
                         *   - SchemaExtension
                         *   - TypeExtension
                         *
                         * TypeExtension :
                         *   - ScalarTypeExtension
                         *   - ObjectTypeExtension
                         *   - InterfaceTypeExtension
                         *   - UnionTypeExtension
                         *   - EnumTypeExtension
                         *   - InputObjectTypeDefinition
                         */

                        _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
                            var keywordToken = this._lexer.lookahead();

                            if (
                                keywordToken.kind === _tokenKind.TokenKind.NAME
                            ) {
                                switch (keywordToken.value) {
                                    case 'schema':
                                        return this.parseSchemaExtension();

                                    case 'scalar':
                                        return this.parseScalarTypeExtension();

                                    case 'type':
                                        return this.parseObjectTypeExtension();

                                    case 'interface':
                                        return this.parseInterfaceTypeExtension();

                                    case 'union':
                                        return this.parseUnionTypeExtension();

                                    case 'enum':
                                        return this.parseEnumTypeExtension();

                                    case 'input':
                                        return this.parseInputObjectTypeExtension();
                                }
                            }

                            throw this.unexpected(keywordToken);
                        };
                        /**
                         * SchemaExtension :
                         *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
                         *  - extend schema Directives[Const]
                         */

                        _proto.parseSchemaExtension = function parseSchemaExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('schema');
                            var directives = this.parseDirectives(true);
                            var operationTypes = this.optionalMany(
                                _tokenKind.TokenKind.BRACE_L,
                                this.parseOperationTypeDefinition,
                                _tokenKind.TokenKind.BRACE_R
                            );

                            if (
                                directives.length === 0 &&
                                operationTypes.length === 0
                            ) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.SCHEMA_EXTENSION,
                                directives: directives,
                                operationTypes: operationTypes,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ScalarTypeExtension :
                         *   - extend scalar Name Directives[Const]
                         */

                        _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('scalar');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);

                            if (directives.length === 0) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
                                name: name,
                                directives: directives,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * ObjectTypeExtension :
                         *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
                         *  - extend type Name ImplementsInterfaces? Directives[Const]
                         *  - extend type Name ImplementsInterfaces
                         */

                        _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('type');
                            var name = this.parseName();
                            var interfaces = this.parseImplementsInterfaces();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseFieldsDefinition();

                            if (
                                interfaces.length === 0 &&
                                directives.length === 0 &&
                                fields.length === 0
                            ) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
                                name: name,
                                interfaces: interfaces,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * InterfaceTypeExtension :
                         *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
                         *  - extend interface Name ImplementsInterfaces? Directives[Const]
                         *  - extend interface Name ImplementsInterfaces
                         */

                        _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('interface');
                            var name = this.parseName();
                            var interfaces = this.parseImplementsInterfaces();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseFieldsDefinition();

                            if (
                                interfaces.length === 0 &&
                                directives.length === 0 &&
                                fields.length === 0
                            ) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
                                name: name,
                                interfaces: interfaces,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * UnionTypeExtension :
                         *   - extend union Name Directives[Const]? UnionMemberTypes
                         *   - extend union Name Directives[Const]
                         */

                        _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('union');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var types = this.parseUnionMemberTypes();

                            if (directives.length === 0 && types.length === 0) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.UNION_TYPE_EXTENSION,
                                name: name,
                                directives: directives,
                                types: types,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * EnumTypeExtension :
                         *   - extend enum Name Directives[Const]? EnumValuesDefinition
                         *   - extend enum Name Directives[Const]
                         */

                        _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('enum');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var values = this.parseEnumValuesDefinition();

                            if (
                                directives.length === 0 &&
                                values.length === 0
                            ) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
                                name: name,
                                directives: directives,
                                values: values,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * InputObjectTypeExtension :
                         *   - extend input Name Directives[Const]? InputFieldsDefinition
                         *   - extend input Name Directives[Const]
                         */

                        _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
                            var start = this._lexer.token;
                            this.expectKeyword('extend');
                            this.expectKeyword('input');
                            var name = this.parseName();
                            var directives = this.parseDirectives(true);
                            var fields = this.parseInputFieldsDefinition();

                            if (
                                directives.length === 0 &&
                                fields.length === 0
                            ) {
                                throw this.unexpected();
                            }

                            return {
                                kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
                                name: name,
                                directives: directives,
                                fields: fields,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * DirectiveDefinition :
                         *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
                         */

                        _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
                            var start = this._lexer.token;
                            var description = this.parseDescription();
                            this.expectKeyword('directive');
                            this.expectToken(_tokenKind.TokenKind.AT);
                            var name = this.parseName();
                            var args = this.parseArgumentDefs();
                            var repeatable = this.expectOptionalKeyword(
                                'repeatable'
                            );
                            this.expectKeyword('on');
                            var locations = this.parseDirectiveLocations();
                            return {
                                kind: _kinds.Kind.DIRECTIVE_DEFINITION,
                                description: description,
                                name: name,
                                arguments: args,
                                repeatable: repeatable,
                                locations: locations,
                                loc: this.loc(start),
                            };
                        };
                        /**
                         * DirectiveLocations :
                         *   - `|`? DirectiveLocation
                         *   - DirectiveLocations | DirectiveLocation
                         */

                        _proto.parseDirectiveLocations = function parseDirectiveLocations() {
                            return this.delimitedMany(
                                _tokenKind.TokenKind.PIPE,
                                this.parseDirectiveLocation
                            );
                        };
                        /*
                         * DirectiveLocation :
                         *   - ExecutableDirectiveLocation
                         *   - TypeSystemDirectiveLocation
                         *
                         * ExecutableDirectiveLocation : one of
                         *   `QUERY`
                         *   `MUTATION`
                         *   `SUBSCRIPTION`
                         *   `FIELD`
                         *   `FRAGMENT_DEFINITION`
                         *   `FRAGMENT_SPREAD`
                         *   `INLINE_FRAGMENT`
                         *
                         * TypeSystemDirectiveLocation : one of
                         *   `SCHEMA`
                         *   `SCALAR`
                         *   `OBJECT`
                         *   `FIELD_DEFINITION`
                         *   `ARGUMENT_DEFINITION`
                         *   `INTERFACE`
                         *   `UNION`
                         *   `ENUM`
                         *   `ENUM_VALUE`
                         *   `INPUT_OBJECT`
                         *   `INPUT_FIELD_DEFINITION`
                         */

                        _proto.parseDirectiveLocation = function parseDirectiveLocation() {
                            var start = this._lexer.token;
                            var name = this.parseName();

                            if (
                                _directiveLocation.DirectiveLocation[
                                    name.value
                                ] !== undefined
                            ) {
                                return name;
                            }

                            throw this.unexpected(start);
                        }; // Core parsing utility functions

                        /**
                         * Returns a location object, used to identify the place in the source that created a given parsed object.
                         */

                        _proto.loc = function loc(startToken) {
                            var _this$_options4;

                            if (
                                ((_this$_options4 = this._options) === null ||
                                _this$_options4 === void 0
                                    ? void 0
                                    : _this$_options4.noLocation) !== true
                            ) {
                                return new _ast.Location(
                                    startToken,
                                    this._lexer.lastToken,
                                    this._lexer.source
                                );
                            }
                        };
                        /**
                         * Determines if the next token is of a given kind
                         */

                        _proto.peek = function peek(kind) {
                            return this._lexer.token.kind === kind;
                        };
                        /**
                         * If the next token is of the given kind, return that token after advancing the lexer.
                         * Otherwise, do not change the parser state and throw an error.
                         */

                        _proto.expectToken = function expectToken(kind) {
                            var token = this._lexer.token;

                            if (token.kind === kind) {
                                this._lexer.advance();

                                return token;
                            }

                            throw (0, _syntaxError.syntaxError)(
                                this._lexer.source,
                                token.start,
                                'Expected '
                                    .concat(getTokenKindDesc(kind), ', found ')
                                    .concat(getTokenDesc(token), '.')
                            );
                        };
                        /**
                         * If the next token is of the given kind, return that token after advancing the lexer.
                         * Otherwise, do not change the parser state and return undefined.
                         */

                        _proto.expectOptionalToken = function expectOptionalToken(
                            kind
                        ) {
                            var token = this._lexer.token;

                            if (token.kind === kind) {
                                this._lexer.advance();

                                return token;
                            }

                            return undefined;
                        };
                        /**
                         * If the next token is a given keyword, advance the lexer.
                         * Otherwise, do not change the parser state and throw an error.
                         */

                        _proto.expectKeyword = function expectKeyword(value) {
                            var token = this._lexer.token;

                            if (
                                token.kind === _tokenKind.TokenKind.NAME &&
                                token.value === value
                            ) {
                                this._lexer.advance();
                            } else {
                                throw (0, _syntaxError.syntaxError)(
                                    this._lexer.source,
                                    token.start,
                                    'Expected "'
                                        .concat(value, '", found ')
                                        .concat(getTokenDesc(token), '.')
                                );
                            }
                        };
                        /**
                         * If the next token is a given keyword, return "true" after advancing the lexer.
                         * Otherwise, do not change the parser state and return "false".
                         */

                        _proto.expectOptionalKeyword = function expectOptionalKeyword(
                            value
                        ) {
                            var token = this._lexer.token;

                            if (
                                token.kind === _tokenKind.TokenKind.NAME &&
                                token.value === value
                            ) {
                                this._lexer.advance();

                                return true;
                            }

                            return false;
                        };
                        /**
                         * Helper function for creating an error when an unexpected lexed token is encountered.
                         */

                        _proto.unexpected = function unexpected(atToken) {
                            var token =
                                atToken !== null && atToken !== void 0
                                    ? atToken
                                    : this._lexer.token;
                            return (0, _syntaxError.syntaxError)(
                                this._lexer.source,
                                token.start,
                                'Unexpected '.concat(getTokenDesc(token), '.')
                            );
                        };
                        /**
                         * Returns a possibly empty list of parse nodes, determined by the parseFn.
                         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
                         * Advances the parser to the next lex token after the closing token.
                         */

                        _proto.any = function any(
                            openKind,
                            parseFn,
                            closeKind
                        ) {
                            this.expectToken(openKind);
                            var nodes = [];

                            while (!this.expectOptionalToken(closeKind)) {
                                nodes.push(parseFn.call(this));
                            }

                            return nodes;
                        };
                        /**
                         * Returns a list of parse nodes, determined by the parseFn.
                         * It can be empty only if open token is missing otherwise it will always return non-empty list
                         * that begins with a lex token of openKind and ends with a lex token of closeKind.
                         * Advances the parser to the next lex token after the closing token.
                         */

                        _proto.optionalMany = function optionalMany(
                            openKind,
                            parseFn,
                            closeKind
                        ) {
                            if (this.expectOptionalToken(openKind)) {
                                var nodes = [];

                                do {
                                    nodes.push(parseFn.call(this));
                                } while (!this.expectOptionalToken(closeKind));

                                return nodes;
                            }

                            return [];
                        };
                        /**
                         * Returns a non-empty list of parse nodes, determined by the parseFn.
                         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
                         * Advances the parser to the next lex token after the closing token.
                         */

                        _proto.many = function many(
                            openKind,
                            parseFn,
                            closeKind
                        ) {
                            this.expectToken(openKind);
                            var nodes = [];

                            do {
                                nodes.push(parseFn.call(this));
                            } while (!this.expectOptionalToken(closeKind));

                            return nodes;
                        };
                        /**
                         * Returns a non-empty list of parse nodes, determined by the parseFn.
                         * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
                         * Advances the parser to the next lex token after last item in the list.
                         */

                        _proto.delimitedMany = function delimitedMany(
                            delimiterKind,
                            parseFn
                        ) {
                            this.expectOptionalToken(delimiterKind);
                            var nodes = [];

                            do {
                                nodes.push(parseFn.call(this));
                            } while (this.expectOptionalToken(delimiterKind));

                            return nodes;
                        };

                        return Parser;
                    })();
                    /**
                     * A helper function to describe a token as a string for debugging.
                     */

                    exports.Parser = Parser;

                    function getTokenDesc(token) {
                        var value = token.value;
                        return (
                            getTokenKindDesc(token.kind) +
                            (value != null ? ' "'.concat(value, '"') : '')
                        );
                    }
                    /**
                     * A helper function to describe a token kind as a string for debugging.
                     */

                    function getTokenKindDesc(kind) {
                        return (0, _lexer.isPunctuatorTokenKind)(kind)
                            ? '"'.concat(kind, '"')
                            : kind;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/printLocation.js':
                /*!********************************************************!*\
  !*** ./node_modules/graphql/language/printLocation.js ***!
  \********************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.printLocation = printLocation;
                    exports.printSourceLocation = printSourceLocation;

                    var _location = __webpack_require__(
                        /*! ./location.js */ './node_modules/graphql/language/location.js'
                    );

                    /**
                     * Render a helpful description of the location in the GraphQL Source document.
                     */
                    function printLocation(location) {
                        return printSourceLocation(
                            location.source,
                            (0, _location.getLocation)(
                                location.source,
                                location.start
                            )
                        );
                    }
                    /**
                     * Render a helpful description of the location in the GraphQL Source document.
                     */

                    function printSourceLocation(source, sourceLocation) {
                        var firstLineColumnOffset =
                            source.locationOffset.column - 1;
                        var body =
                            whitespace(firstLineColumnOffset) + source.body;
                        var lineIndex = sourceLocation.line - 1;
                        var lineOffset = source.locationOffset.line - 1;
                        var lineNum = sourceLocation.line + lineOffset;
                        var columnOffset =
                            sourceLocation.line === 1
                                ? firstLineColumnOffset
                                : 0;
                        var columnNum = sourceLocation.column + columnOffset;
                        var locationStr = ''
                            .concat(source.name, ':')
                            .concat(lineNum, ':')
                            .concat(columnNum, '\n');
                        var lines = body.split(/\r\n|[\n\r]/g);
                        var locationLine = lines[lineIndex]; // Special case for minified documents

                        if (locationLine.length > 120) {
                            var subLineIndex = Math.floor(columnNum / 80);
                            var subLineColumnNum = columnNum % 80;
                            var subLines = [];

                            for (var i = 0; i < locationLine.length; i += 80) {
                                subLines.push(locationLine.slice(i, i + 80));
                            }

                            return (
                                locationStr +
                                printPrefixedLines(
                                    [[''.concat(lineNum), subLines[0]]].concat(
                                        subLines
                                            .slice(1, subLineIndex + 1)
                                            .map(function (subLine) {
                                                return ['', subLine];
                                            }),
                                        [
                                            [
                                                ' ',
                                                whitespace(
                                                    subLineColumnNum - 1
                                                ) + '^',
                                            ],
                                            ['', subLines[subLineIndex + 1]],
                                        ]
                                    )
                                )
                            );
                        }

                        return (
                            locationStr +
                            printPrefixedLines([
                                // Lines specified like this: ["prefix", "string"],
                                [''.concat(lineNum - 1), lines[lineIndex - 1]],
                                [''.concat(lineNum), locationLine],
                                ['', whitespace(columnNum - 1) + '^'],
                                [''.concat(lineNum + 1), lines[lineIndex + 1]],
                            ])
                        );
                    }

                    function printPrefixedLines(lines) {
                        var existingLines = lines.filter(function (_ref) {
                            var _ = _ref[0],
                                line = _ref[1];
                            return line !== undefined;
                        });
                        var padLen = Math.max.apply(
                            Math,
                            existingLines.map(function (_ref2) {
                                var prefix = _ref2[0];
                                return prefix.length;
                            })
                        );
                        return existingLines
                            .map(function (_ref3) {
                                var prefix = _ref3[0],
                                    line = _ref3[1];
                                return (
                                    leftPad(padLen, prefix) +
                                    (line ? ' | ' + line : ' |')
                                );
                            })
                            .join('\n');
                    }

                    function whitespace(len) {
                        return Array(len + 1).join(' ');
                    }

                    function leftPad(len, str) {
                        return whitespace(len - str.length) + str;
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/printer.js':
                /*!**************************************************!*\
  !*** ./node_modules/graphql/language/printer.js ***!
  \**************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.print = print;

                    var _visitor = __webpack_require__(
                        /*! ./visitor.js */ './node_modules/graphql/language/visitor.js'
                    );

                    var _blockString = __webpack_require__(
                        /*! ./blockString.js */ './node_modules/graphql/language/blockString.js'
                    );

                    /**
                     * Converts an AST into a string, using one set of reasonable
                     * formatting rules.
                     */
                    function print(ast) {
                        return (0, _visitor.visit)(ast, {
                            leave: printDocASTReducer,
                        });
                    }

                    var MAX_LINE_LENGTH = 80; // TODO: provide better type coverage in future

                    var printDocASTReducer = {
                        Name: function Name(node) {
                            return node.value;
                        },
                        Variable: function Variable(node) {
                            return '$' + node.name;
                        },
                        // Document
                        Document: function Document(node) {
                            return join(node.definitions, '\n\n') + '\n';
                        },
                        OperationDefinition: function OperationDefinition(
                            node
                        ) {
                            var op = node.operation;
                            var name = node.name;
                            var varDefs = wrap(
                                '(',
                                join(node.variableDefinitions, ', '),
                                ')'
                            );
                            var directives = join(node.directives, ' ');
                            var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
                            // the query short form.

                            return !name &&
                                !directives &&
                                !varDefs &&
                                op === 'query'
                                ? selectionSet
                                : join(
                                      [
                                          op,
                                          join([name, varDefs]),
                                          directives,
                                          selectionSet,
                                      ],
                                      ' '
                                  );
                        },
                        VariableDefinition: function VariableDefinition(_ref) {
                            var variable = _ref.variable,
                                type = _ref.type,
                                defaultValue = _ref.defaultValue,
                                directives = _ref.directives;
                            return (
                                variable +
                                ': ' +
                                type +
                                wrap(' = ', defaultValue) +
                                wrap(' ', join(directives, ' '))
                            );
                        },
                        SelectionSet: function SelectionSet(_ref2) {
                            var selections = _ref2.selections;
                            return block(selections);
                        },
                        Field: function Field(_ref3) {
                            var alias = _ref3.alias,
                                name = _ref3.name,
                                args = _ref3.arguments,
                                directives = _ref3.directives,
                                selectionSet = _ref3.selectionSet;
                            var prefix = wrap('', alias, ': ') + name;
                            var argsLine =
                                prefix + wrap('(', join(args, ', '), ')');

                            if (argsLine.length > MAX_LINE_LENGTH) {
                                argsLine =
                                    prefix +
                                    wrap(
                                        '(\n',
                                        indent(join(args, '\n')),
                                        '\n)'
                                    );
                            }

                            return join(
                                [argsLine, join(directives, ' '), selectionSet],
                                ' '
                            );
                        },
                        Argument: function Argument(_ref4) {
                            var name = _ref4.name,
                                value = _ref4.value;
                            return name + ': ' + value;
                        },
                        // Fragments
                        FragmentSpread: function FragmentSpread(_ref5) {
                            var name = _ref5.name,
                                directives = _ref5.directives;
                            return (
                                '...' + name + wrap(' ', join(directives, ' '))
                            );
                        },
                        InlineFragment: function InlineFragment(_ref6) {
                            var typeCondition = _ref6.typeCondition,
                                directives = _ref6.directives,
                                selectionSet = _ref6.selectionSet;
                            return join(
                                [
                                    '...',
                                    wrap('on ', typeCondition),
                                    join(directives, ' '),
                                    selectionSet,
                                ],
                                ' '
                            );
                        },
                        FragmentDefinition: function FragmentDefinition(_ref7) {
                            var name = _ref7.name,
                                typeCondition = _ref7.typeCondition,
                                variableDefinitions = _ref7.variableDefinitions,
                                directives = _ref7.directives,
                                selectionSet = _ref7.selectionSet;
                            return (
                                // Note: fragment variable definitions are experimental and may be changed
                                // or removed in the future.
                                'fragment '
                                    .concat(name)
                                    .concat(
                                        wrap(
                                            '(',
                                            join(variableDefinitions, ', '),
                                            ')'
                                        ),
                                        ' '
                                    ) +
                                'on '
                                    .concat(typeCondition, ' ')
                                    .concat(
                                        wrap('', join(directives, ' '), ' ')
                                    ) +
                                selectionSet
                            );
                        },
                        // Value
                        IntValue: function IntValue(_ref8) {
                            var value = _ref8.value;
                            return value;
                        },
                        FloatValue: function FloatValue(_ref9) {
                            var value = _ref9.value;
                            return value;
                        },
                        StringValue: function StringValue(_ref10, key) {
                            var value = _ref10.value,
                                isBlockString = _ref10.block;
                            return isBlockString
                                ? (0, _blockString.printBlockString)(
                                      value,
                                      key === 'description' ? '' : '  '
                                  )
                                : JSON.stringify(value);
                        },
                        BooleanValue: function BooleanValue(_ref11) {
                            var value = _ref11.value;
                            return value ? 'true' : 'false';
                        },
                        NullValue: function NullValue() {
                            return 'null';
                        },
                        EnumValue: function EnumValue(_ref12) {
                            var value = _ref12.value;
                            return value;
                        },
                        ListValue: function ListValue(_ref13) {
                            var values = _ref13.values;
                            return '[' + join(values, ', ') + ']';
                        },
                        ObjectValue: function ObjectValue(_ref14) {
                            var fields = _ref14.fields;
                            return '{' + join(fields, ', ') + '}';
                        },
                        ObjectField: function ObjectField(_ref15) {
                            var name = _ref15.name,
                                value = _ref15.value;
                            return name + ': ' + value;
                        },
                        // Directive
                        Directive: function Directive(_ref16) {
                            var name = _ref16.name,
                                args = _ref16.arguments;
                            return (
                                '@' + name + wrap('(', join(args, ', '), ')')
                            );
                        },
                        // Type
                        NamedType: function NamedType(_ref17) {
                            var name = _ref17.name;
                            return name;
                        },
                        ListType: function ListType(_ref18) {
                            var type = _ref18.type;
                            return '[' + type + ']';
                        },
                        NonNullType: function NonNullType(_ref19) {
                            var type = _ref19.type;
                            return type + '!';
                        },
                        // Type System Definitions
                        SchemaDefinition: addDescription(function (_ref20) {
                            var directives = _ref20.directives,
                                operationTypes = _ref20.operationTypes;
                            return join(
                                [
                                    'schema',
                                    join(directives, ' '),
                                    block(operationTypes),
                                ],
                                ' '
                            );
                        }),
                        OperationTypeDefinition: function OperationTypeDefinition(
                            _ref21
                        ) {
                            var operation = _ref21.operation,
                                type = _ref21.type;
                            return operation + ': ' + type;
                        },
                        ScalarTypeDefinition: addDescription(function (_ref22) {
                            var name = _ref22.name,
                                directives = _ref22.directives;
                            return join(
                                ['scalar', name, join(directives, ' ')],
                                ' '
                            );
                        }),
                        ObjectTypeDefinition: addDescription(function (_ref23) {
                            var name = _ref23.name,
                                interfaces = _ref23.interfaces,
                                directives = _ref23.directives,
                                fields = _ref23.fields;
                            return join(
                                [
                                    'type',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        FieldDefinition: addDescription(function (_ref24) {
                            var name = _ref24.name,
                                args = _ref24.arguments,
                                type = _ref24.type,
                                directives = _ref24.directives;
                            return (
                                name +
                                (hasMultilineItems(args)
                                    ? wrap(
                                          '(\n',
                                          indent(join(args, '\n')),
                                          '\n)'
                                      )
                                    : wrap('(', join(args, ', '), ')')) +
                                ': ' +
                                type +
                                wrap(' ', join(directives, ' '))
                            );
                        }),
                        InputValueDefinition: addDescription(function (_ref25) {
                            var name = _ref25.name,
                                type = _ref25.type,
                                defaultValue = _ref25.defaultValue,
                                directives = _ref25.directives;
                            return join(
                                [
                                    name + ': ' + type,
                                    wrap('= ', defaultValue),
                                    join(directives, ' '),
                                ],
                                ' '
                            );
                        }),
                        InterfaceTypeDefinition: addDescription(function (
                            _ref26
                        ) {
                            var name = _ref26.name,
                                interfaces = _ref26.interfaces,
                                directives = _ref26.directives,
                                fields = _ref26.fields;
                            return join(
                                [
                                    'interface',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        UnionTypeDefinition: addDescription(function (_ref27) {
                            var name = _ref27.name,
                                directives = _ref27.directives,
                                types = _ref27.types;
                            return join(
                                [
                                    'union',
                                    name,
                                    join(directives, ' '),
                                    types && types.length !== 0
                                        ? '= ' + join(types, ' | ')
                                        : '',
                                ],
                                ' '
                            );
                        }),
                        EnumTypeDefinition: addDescription(function (_ref28) {
                            var name = _ref28.name,
                                directives = _ref28.directives,
                                values = _ref28.values;
                            return join(
                                [
                                    'enum',
                                    name,
                                    join(directives, ' '),
                                    block(values),
                                ],
                                ' '
                            );
                        }),
                        EnumValueDefinition: addDescription(function (_ref29) {
                            var name = _ref29.name,
                                directives = _ref29.directives;
                            return join([name, join(directives, ' ')], ' ');
                        }),
                        InputObjectTypeDefinition: addDescription(function (
                            _ref30
                        ) {
                            var name = _ref30.name,
                                directives = _ref30.directives,
                                fields = _ref30.fields;
                            return join(
                                [
                                    'input',
                                    name,
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        DirectiveDefinition: addDescription(function (_ref31) {
                            var name = _ref31.name,
                                args = _ref31.arguments,
                                repeatable = _ref31.repeatable,
                                locations = _ref31.locations;
                            return (
                                'directive @' +
                                name +
                                (hasMultilineItems(args)
                                    ? wrap(
                                          '(\n',
                                          indent(join(args, '\n')),
                                          '\n)'
                                      )
                                    : wrap('(', join(args, ', '), ')')) +
                                (repeatable ? ' repeatable' : '') +
                                ' on ' +
                                join(locations, ' | ')
                            );
                        }),
                        SchemaExtension: function SchemaExtension(_ref32) {
                            var directives = _ref32.directives,
                                operationTypes = _ref32.operationTypes;
                            return join(
                                [
                                    'extend schema',
                                    join(directives, ' '),
                                    block(operationTypes),
                                ],
                                ' '
                            );
                        },
                        ScalarTypeExtension: function ScalarTypeExtension(
                            _ref33
                        ) {
                            var name = _ref33.name,
                                directives = _ref33.directives;
                            return join(
                                ['extend scalar', name, join(directives, ' ')],
                                ' '
                            );
                        },
                        ObjectTypeExtension: function ObjectTypeExtension(
                            _ref34
                        ) {
                            var name = _ref34.name,
                                interfaces = _ref34.interfaces,
                                directives = _ref34.directives,
                                fields = _ref34.fields;
                            return join(
                                [
                                    'extend type',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                        InterfaceTypeExtension: function InterfaceTypeExtension(
                            _ref35
                        ) {
                            var name = _ref35.name,
                                interfaces = _ref35.interfaces,
                                directives = _ref35.directives,
                                fields = _ref35.fields;
                            return join(
                                [
                                    'extend interface',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                        UnionTypeExtension: function UnionTypeExtension(
                            _ref36
                        ) {
                            var name = _ref36.name,
                                directives = _ref36.directives,
                                types = _ref36.types;
                            return join(
                                [
                                    'extend union',
                                    name,
                                    join(directives, ' '),
                                    types && types.length !== 0
                                        ? '= ' + join(types, ' | ')
                                        : '',
                                ],
                                ' '
                            );
                        },
                        EnumTypeExtension: function EnumTypeExtension(_ref37) {
                            var name = _ref37.name,
                                directives = _ref37.directives,
                                values = _ref37.values;
                            return join(
                                [
                                    'extend enum',
                                    name,
                                    join(directives, ' '),
                                    block(values),
                                ],
                                ' '
                            );
                        },
                        InputObjectTypeExtension: function InputObjectTypeExtension(
                            _ref38
                        ) {
                            var name = _ref38.name,
                                directives = _ref38.directives,
                                fields = _ref38.fields;
                            return join(
                                [
                                    'extend input',
                                    name,
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                    };

                    function addDescription(cb) {
                        return function (node) {
                            return join([node.description, cb(node)], '\n');
                        };
                    }
                    /**
                     * Given maybeArray, print an empty string if it is null or empty, otherwise
                     * print all items together separated by separator if provided
                     */

                    function join(maybeArray) {
                        var _maybeArray$filter$jo;

                        var separator =
                            arguments.length > 1 && arguments[1] !== undefined
                                ? arguments[1]
                                : '';
                        return (_maybeArray$filter$jo =
                            maybeArray === null || maybeArray === void 0
                                ? void 0
                                : maybeArray
                                      .filter(function (x) {
                                          return x;
                                      })
                                      .join(separator)) !== null &&
                            _maybeArray$filter$jo !== void 0
                            ? _maybeArray$filter$jo
                            : '';
                    }
                    /**
                     * Given array, print each item on its own line, wrapped in an
                     * indented "{ }" block.
                     */

                    function block(array) {
                        return wrap('{\n', indent(join(array, '\n')), '\n}');
                    }
                    /**
                     * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.
                     */

                    function wrap(start, maybeString) {
                        var end =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : '';
                        return maybeString != null && maybeString !== ''
                            ? start + maybeString + end
                            : '';
                    }

                    function indent(str) {
                        return wrap('  ', str.replace(/\n/g, '\n  '));
                    }

                    function isMultiline(str) {
                        return str.indexOf('\n') !== -1;
                    }

                    function hasMultilineItems(maybeArray) {
                        return (
                            maybeArray != null && maybeArray.some(isMultiline)
                        );
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/printer.mjs':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/language/printer.mjs ***!
  \***************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ print: () =>
                                /* binding */ print,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _visitor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ./visitor.mjs */ './node_modules/graphql/language/visitor.mjs'
                    );
                    /* harmony import */ var _blockString_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                        /*! ./blockString.mjs */ './node_modules/graphql/language/blockString.mjs'
                    );

                    /**
                     * Converts an AST into a string, using one set of reasonable
                     * formatting rules.
                     */

                    function print(ast) {
                        return (0,
                        _visitor_mjs__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, {
                            leave: printDocASTReducer,
                        });
                    }
                    var MAX_LINE_LENGTH = 80; // TODO: provide better type coverage in future

                    var printDocASTReducer = {
                        Name: function Name(node) {
                            return node.value;
                        },
                        Variable: function Variable(node) {
                            return '$' + node.name;
                        },
                        // Document
                        Document: function Document(node) {
                            return join(node.definitions, '\n\n') + '\n';
                        },
                        OperationDefinition: function OperationDefinition(
                            node
                        ) {
                            var op = node.operation;
                            var name = node.name;
                            var varDefs = wrap(
                                '(',
                                join(node.variableDefinitions, ', '),
                                ')'
                            );
                            var directives = join(node.directives, ' ');
                            var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
                            // the query short form.

                            return !name &&
                                !directives &&
                                !varDefs &&
                                op === 'query'
                                ? selectionSet
                                : join(
                                      [
                                          op,
                                          join([name, varDefs]),
                                          directives,
                                          selectionSet,
                                      ],
                                      ' '
                                  );
                        },
                        VariableDefinition: function VariableDefinition(_ref) {
                            var variable = _ref.variable,
                                type = _ref.type,
                                defaultValue = _ref.defaultValue,
                                directives = _ref.directives;
                            return (
                                variable +
                                ': ' +
                                type +
                                wrap(' = ', defaultValue) +
                                wrap(' ', join(directives, ' '))
                            );
                        },
                        SelectionSet: function SelectionSet(_ref2) {
                            var selections = _ref2.selections;
                            return block(selections);
                        },
                        Field: function Field(_ref3) {
                            var alias = _ref3.alias,
                                name = _ref3.name,
                                args = _ref3.arguments,
                                directives = _ref3.directives,
                                selectionSet = _ref3.selectionSet;
                            var prefix = wrap('', alias, ': ') + name;
                            var argsLine =
                                prefix + wrap('(', join(args, ', '), ')');

                            if (argsLine.length > MAX_LINE_LENGTH) {
                                argsLine =
                                    prefix +
                                    wrap(
                                        '(\n',
                                        indent(join(args, '\n')),
                                        '\n)'
                                    );
                            }

                            return join(
                                [argsLine, join(directives, ' '), selectionSet],
                                ' '
                            );
                        },
                        Argument: function Argument(_ref4) {
                            var name = _ref4.name,
                                value = _ref4.value;
                            return name + ': ' + value;
                        },
                        // Fragments
                        FragmentSpread: function FragmentSpread(_ref5) {
                            var name = _ref5.name,
                                directives = _ref5.directives;
                            return (
                                '...' + name + wrap(' ', join(directives, ' '))
                            );
                        },
                        InlineFragment: function InlineFragment(_ref6) {
                            var typeCondition = _ref6.typeCondition,
                                directives = _ref6.directives,
                                selectionSet = _ref6.selectionSet;
                            return join(
                                [
                                    '...',
                                    wrap('on ', typeCondition),
                                    join(directives, ' '),
                                    selectionSet,
                                ],
                                ' '
                            );
                        },
                        FragmentDefinition: function FragmentDefinition(_ref7) {
                            var name = _ref7.name,
                                typeCondition = _ref7.typeCondition,
                                variableDefinitions = _ref7.variableDefinitions,
                                directives = _ref7.directives,
                                selectionSet = _ref7.selectionSet;
                            return (
                                // Note: fragment variable definitions are experimental and may be changed
                                // or removed in the future.
                                'fragment '
                                    .concat(name)
                                    .concat(
                                        wrap(
                                            '(',
                                            join(variableDefinitions, ', '),
                                            ')'
                                        ),
                                        ' '
                                    ) +
                                'on '
                                    .concat(typeCondition, ' ')
                                    .concat(
                                        wrap('', join(directives, ' '), ' ')
                                    ) +
                                selectionSet
                            );
                        },
                        // Value
                        IntValue: function IntValue(_ref8) {
                            var value = _ref8.value;
                            return value;
                        },
                        FloatValue: function FloatValue(_ref9) {
                            var value = _ref9.value;
                            return value;
                        },
                        StringValue: function StringValue(_ref10, key) {
                            var value = _ref10.value,
                                isBlockString = _ref10.block;
                            return isBlockString
                                ? (0,
                                  _blockString_mjs__WEBPACK_IMPORTED_MODULE_1__.printBlockString)(
                                      value,
                                      key === 'description' ? '' : '  '
                                  )
                                : JSON.stringify(value);
                        },
                        BooleanValue: function BooleanValue(_ref11) {
                            var value = _ref11.value;
                            return value ? 'true' : 'false';
                        },
                        NullValue: function NullValue() {
                            return 'null';
                        },
                        EnumValue: function EnumValue(_ref12) {
                            var value = _ref12.value;
                            return value;
                        },
                        ListValue: function ListValue(_ref13) {
                            var values = _ref13.values;
                            return '[' + join(values, ', ') + ']';
                        },
                        ObjectValue: function ObjectValue(_ref14) {
                            var fields = _ref14.fields;
                            return '{' + join(fields, ', ') + '}';
                        },
                        ObjectField: function ObjectField(_ref15) {
                            var name = _ref15.name,
                                value = _ref15.value;
                            return name + ': ' + value;
                        },
                        // Directive
                        Directive: function Directive(_ref16) {
                            var name = _ref16.name,
                                args = _ref16.arguments;
                            return (
                                '@' + name + wrap('(', join(args, ', '), ')')
                            );
                        },
                        // Type
                        NamedType: function NamedType(_ref17) {
                            var name = _ref17.name;
                            return name;
                        },
                        ListType: function ListType(_ref18) {
                            var type = _ref18.type;
                            return '[' + type + ']';
                        },
                        NonNullType: function NonNullType(_ref19) {
                            var type = _ref19.type;
                            return type + '!';
                        },
                        // Type System Definitions
                        SchemaDefinition: addDescription(function (_ref20) {
                            var directives = _ref20.directives,
                                operationTypes = _ref20.operationTypes;
                            return join(
                                [
                                    'schema',
                                    join(directives, ' '),
                                    block(operationTypes),
                                ],
                                ' '
                            );
                        }),
                        OperationTypeDefinition: function OperationTypeDefinition(
                            _ref21
                        ) {
                            var operation = _ref21.operation,
                                type = _ref21.type;
                            return operation + ': ' + type;
                        },
                        ScalarTypeDefinition: addDescription(function (_ref22) {
                            var name = _ref22.name,
                                directives = _ref22.directives;
                            return join(
                                ['scalar', name, join(directives, ' ')],
                                ' '
                            );
                        }),
                        ObjectTypeDefinition: addDescription(function (_ref23) {
                            var name = _ref23.name,
                                interfaces = _ref23.interfaces,
                                directives = _ref23.directives,
                                fields = _ref23.fields;
                            return join(
                                [
                                    'type',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        FieldDefinition: addDescription(function (_ref24) {
                            var name = _ref24.name,
                                args = _ref24.arguments,
                                type = _ref24.type,
                                directives = _ref24.directives;
                            return (
                                name +
                                (hasMultilineItems(args)
                                    ? wrap(
                                          '(\n',
                                          indent(join(args, '\n')),
                                          '\n)'
                                      )
                                    : wrap('(', join(args, ', '), ')')) +
                                ': ' +
                                type +
                                wrap(' ', join(directives, ' '))
                            );
                        }),
                        InputValueDefinition: addDescription(function (_ref25) {
                            var name = _ref25.name,
                                type = _ref25.type,
                                defaultValue = _ref25.defaultValue,
                                directives = _ref25.directives;
                            return join(
                                [
                                    name + ': ' + type,
                                    wrap('= ', defaultValue),
                                    join(directives, ' '),
                                ],
                                ' '
                            );
                        }),
                        InterfaceTypeDefinition: addDescription(function (
                            _ref26
                        ) {
                            var name = _ref26.name,
                                interfaces = _ref26.interfaces,
                                directives = _ref26.directives,
                                fields = _ref26.fields;
                            return join(
                                [
                                    'interface',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        UnionTypeDefinition: addDescription(function (_ref27) {
                            var name = _ref27.name,
                                directives = _ref27.directives,
                                types = _ref27.types;
                            return join(
                                [
                                    'union',
                                    name,
                                    join(directives, ' '),
                                    types && types.length !== 0
                                        ? '= ' + join(types, ' | ')
                                        : '',
                                ],
                                ' '
                            );
                        }),
                        EnumTypeDefinition: addDescription(function (_ref28) {
                            var name = _ref28.name,
                                directives = _ref28.directives,
                                values = _ref28.values;
                            return join(
                                [
                                    'enum',
                                    name,
                                    join(directives, ' '),
                                    block(values),
                                ],
                                ' '
                            );
                        }),
                        EnumValueDefinition: addDescription(function (_ref29) {
                            var name = _ref29.name,
                                directives = _ref29.directives;
                            return join([name, join(directives, ' ')], ' ');
                        }),
                        InputObjectTypeDefinition: addDescription(function (
                            _ref30
                        ) {
                            var name = _ref30.name,
                                directives = _ref30.directives,
                                fields = _ref30.fields;
                            return join(
                                [
                                    'input',
                                    name,
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        }),
                        DirectiveDefinition: addDescription(function (_ref31) {
                            var name = _ref31.name,
                                args = _ref31.arguments,
                                repeatable = _ref31.repeatable,
                                locations = _ref31.locations;
                            return (
                                'directive @' +
                                name +
                                (hasMultilineItems(args)
                                    ? wrap(
                                          '(\n',
                                          indent(join(args, '\n')),
                                          '\n)'
                                      )
                                    : wrap('(', join(args, ', '), ')')) +
                                (repeatable ? ' repeatable' : '') +
                                ' on ' +
                                join(locations, ' | ')
                            );
                        }),
                        SchemaExtension: function SchemaExtension(_ref32) {
                            var directives = _ref32.directives,
                                operationTypes = _ref32.operationTypes;
                            return join(
                                [
                                    'extend schema',
                                    join(directives, ' '),
                                    block(operationTypes),
                                ],
                                ' '
                            );
                        },
                        ScalarTypeExtension: function ScalarTypeExtension(
                            _ref33
                        ) {
                            var name = _ref33.name,
                                directives = _ref33.directives;
                            return join(
                                ['extend scalar', name, join(directives, ' ')],
                                ' '
                            );
                        },
                        ObjectTypeExtension: function ObjectTypeExtension(
                            _ref34
                        ) {
                            var name = _ref34.name,
                                interfaces = _ref34.interfaces,
                                directives = _ref34.directives,
                                fields = _ref34.fields;
                            return join(
                                [
                                    'extend type',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                        InterfaceTypeExtension: function InterfaceTypeExtension(
                            _ref35
                        ) {
                            var name = _ref35.name,
                                interfaces = _ref35.interfaces,
                                directives = _ref35.directives,
                                fields = _ref35.fields;
                            return join(
                                [
                                    'extend interface',
                                    name,
                                    wrap(
                                        'implements ',
                                        join(interfaces, ' & ')
                                    ),
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                        UnionTypeExtension: function UnionTypeExtension(
                            _ref36
                        ) {
                            var name = _ref36.name,
                                directives = _ref36.directives,
                                types = _ref36.types;
                            return join(
                                [
                                    'extend union',
                                    name,
                                    join(directives, ' '),
                                    types && types.length !== 0
                                        ? '= ' + join(types, ' | ')
                                        : '',
                                ],
                                ' '
                            );
                        },
                        EnumTypeExtension: function EnumTypeExtension(_ref37) {
                            var name = _ref37.name,
                                directives = _ref37.directives,
                                values = _ref37.values;
                            return join(
                                [
                                    'extend enum',
                                    name,
                                    join(directives, ' '),
                                    block(values),
                                ],
                                ' '
                            );
                        },
                        InputObjectTypeExtension: function InputObjectTypeExtension(
                            _ref38
                        ) {
                            var name = _ref38.name,
                                directives = _ref38.directives,
                                fields = _ref38.fields;
                            return join(
                                [
                                    'extend input',
                                    name,
                                    join(directives, ' '),
                                    block(fields),
                                ],
                                ' '
                            );
                        },
                    };

                    function addDescription(cb) {
                        return function (node) {
                            return join([node.description, cb(node)], '\n');
                        };
                    }
                    /**
                     * Given maybeArray, print an empty string if it is null or empty, otherwise
                     * print all items together separated by separator if provided
                     */

                    function join(maybeArray) {
                        var _maybeArray$filter$jo;

                        var separator =
                            arguments.length > 1 && arguments[1] !== undefined
                                ? arguments[1]
                                : '';
                        return (_maybeArray$filter$jo =
                            maybeArray === null || maybeArray === void 0
                                ? void 0
                                : maybeArray
                                      .filter(function (x) {
                                          return x;
                                      })
                                      .join(separator)) !== null &&
                            _maybeArray$filter$jo !== void 0
                            ? _maybeArray$filter$jo
                            : '';
                    }
                    /**
                     * Given array, print each item on its own line, wrapped in an
                     * indented "{ }" block.
                     */

                    function block(array) {
                        return wrap('{\n', indent(join(array, '\n')), '\n}');
                    }
                    /**
                     * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.
                     */

                    function wrap(start, maybeString) {
                        var end =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : '';
                        return maybeString != null && maybeString !== ''
                            ? start + maybeString + end
                            : '';
                    }

                    function indent(str) {
                        return wrap('  ', str.replace(/\n/g, '\n  '));
                    }

                    function isMultiline(str) {
                        return str.indexOf('\n') !== -1;
                    }

                    function hasMultilineItems(maybeArray) {
                        return (
                            maybeArray != null && maybeArray.some(isMultiline)
                        );
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/source.js':
                /*!*************************************************!*\
  !*** ./node_modules/graphql/language/source.js ***!
  \*************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.isSource = isSource;
                    exports.Source = void 0;

                    var _symbols = __webpack_require__(
                        /*! ../polyfills/symbols.js */ './node_modules/graphql/polyfills/symbols.js'
                    );

                    var _inspect = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/inspect.js */ './node_modules/graphql/jsutils/inspect.js'
                        )
                    );

                    var _devAssert = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/devAssert.js */ './node_modules/graphql/jsutils/devAssert.js'
                        )
                    );

                    var _instanceOf = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/instanceOf.js */ './node_modules/graphql/jsutils/instanceOf.js'
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    /**
                     * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are
                     * optional, but they are useful for clients who store GraphQL documents in source files.
                     * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might
                     * be useful for `name` to be `"Foo.graphql"` and location to be `{ line: 40, column: 1 }`.
                     * The `line` and `column` properties in `locationOffset` are 1-indexed.
                     */
                    var Source = /*#__PURE__*/ (function () {
                        function Source(body) {
                            var name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : 'GraphQL request';
                            var locationOffset =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : {
                                          line: 1,
                                          column: 1,
                                      };
                            typeof body === 'string' ||
                                (0, _devAssert.default)(
                                    0,
                                    'Body must be a string. Received: '.concat(
                                        (0, _inspect.default)(body),
                                        '.'
                                    )
                                );
                            this.body = body;
                            this.name = name;
                            this.locationOffset = locationOffset;
                            this.locationOffset.line > 0 ||
                                (0, _devAssert.default)(
                                    0,
                                    'line in locationOffset is 1-indexed and must be positive.'
                                );
                            this.locationOffset.column > 0 ||
                                (0, _devAssert.default)(
                                    0,
                                    'column in locationOffset is 1-indexed and must be positive.'
                                );
                        } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet

                        _createClass(Source, [
                            {
                                key: _symbols.SYMBOL_TO_STRING_TAG,
                                get: function get() {
                                    return 'Source';
                                },
                            },
                        ]);

                        return Source;
                    })();
                    /**
                     * Test if the given value is a Source object.
                     *
                     * @internal
                     */

                    exports.Source = Source;

                    // eslint-disable-next-line no-redeclare
                    function isSource(source) {
                        return (0, _instanceOf.default)(source, Source);
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/tokenKind.js':
                /*!****************************************************!*\
  !*** ./node_modules/graphql/language/tokenKind.js ***!
  \****************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.TokenKind = void 0;

                    /**
                     * An exported enum describing the different kinds of tokens that the
                     * lexer emits.
                     */
                    var TokenKind = Object.freeze({
                        SOF: '<SOF>',
                        EOF: '<EOF>',
                        BANG: '!',
                        DOLLAR: '$',
                        AMP: '&',
                        PAREN_L: '(',
                        PAREN_R: ')',
                        SPREAD: '...',
                        COLON: ':',
                        EQUALS: '=',
                        AT: '@',
                        BRACKET_L: '[',
                        BRACKET_R: ']',
                        BRACE_L: '{',
                        PIPE: '|',
                        BRACE_R: '}',
                        NAME: 'Name',
                        INT: 'Int',
                        FLOAT: 'Float',
                        STRING: 'String',
                        BLOCK_STRING: 'BlockString',
                        COMMENT: 'Comment',
                    });
                    /**
                     * The enum type representing the token kinds values.
                     */

                    exports.TokenKind = TokenKind;

                    /***/
                },

            /***/ './node_modules/graphql/language/visitor.js':
                /*!**************************************************!*\
  !*** ./node_modules/graphql/language/visitor.js ***!
  \**************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.visit = visit;
                    exports.visitInParallel = visitInParallel;
                    exports.getVisitFn = getVisitFn;
                    exports.BREAK = exports.QueryDocumentKeys = void 0;

                    var _inspect = _interopRequireDefault(
                        __webpack_require__(
                            /*! ../jsutils/inspect.js */ './node_modules/graphql/jsutils/inspect.js'
                        )
                    );

                    var _ast = __webpack_require__(
                        /*! ./ast.js */ './node_modules/graphql/language/ast.js'
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    var QueryDocumentKeys = {
                        Name: [],
                        Document: ['definitions'],
                        OperationDefinition: [
                            'name',
                            'variableDefinitions',
                            'directives',
                            'selectionSet',
                        ],
                        VariableDefinition: [
                            'variable',
                            'type',
                            'defaultValue',
                            'directives',
                        ],
                        Variable: ['name'],
                        SelectionSet: ['selections'],
                        Field: [
                            'alias',
                            'name',
                            'arguments',
                            'directives',
                            'selectionSet',
                        ],
                        Argument: ['name', 'value'],
                        FragmentSpread: ['name', 'directives'],
                        InlineFragment: [
                            'typeCondition',
                            'directives',
                            'selectionSet',
                        ],
                        FragmentDefinition: [
                            'name', // Note: fragment variable definitions are experimental and may be changed
                            // or removed in the future.
                            'variableDefinitions',
                            'typeCondition',
                            'directives',
                            'selectionSet',
                        ],
                        IntValue: [],
                        FloatValue: [],
                        StringValue: [],
                        BooleanValue: [],
                        NullValue: [],
                        EnumValue: [],
                        ListValue: ['values'],
                        ObjectValue: ['fields'],
                        ObjectField: ['name', 'value'],
                        Directive: ['name', 'arguments'],
                        NamedType: ['name'],
                        ListType: ['type'],
                        NonNullType: ['type'],
                        SchemaDefinition: [
                            'description',
                            'directives',
                            'operationTypes',
                        ],
                        OperationTypeDefinition: ['type'],
                        ScalarTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                        ],
                        ObjectTypeDefinition: [
                            'description',
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        FieldDefinition: [
                            'description',
                            'name',
                            'arguments',
                            'type',
                            'directives',
                        ],
                        InputValueDefinition: [
                            'description',
                            'name',
                            'type',
                            'defaultValue',
                            'directives',
                        ],
                        InterfaceTypeDefinition: [
                            'description',
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        UnionTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'types',
                        ],
                        EnumTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'values',
                        ],
                        EnumValueDefinition: [
                            'description',
                            'name',
                            'directives',
                        ],
                        InputObjectTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'fields',
                        ],
                        DirectiveDefinition: [
                            'description',
                            'name',
                            'arguments',
                            'locations',
                        ],
                        SchemaExtension: ['directives', 'operationTypes'],
                        ScalarTypeExtension: ['name', 'directives'],
                        ObjectTypeExtension: [
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        InterfaceTypeExtension: [
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        UnionTypeExtension: ['name', 'directives', 'types'],
                        EnumTypeExtension: ['name', 'directives', 'values'],
                        InputObjectTypeExtension: [
                            'name',
                            'directives',
                            'fields',
                        ],
                    };
                    exports.QueryDocumentKeys = QueryDocumentKeys;
                    var BREAK = Object.freeze({});
                    /**
                     * visit() will walk through an AST using a depth-first traversal, calling
                     * the visitor's enter function at each node in the traversal, and calling the
                     * leave function after visiting that node and all of its child nodes.
                     *
                     * By returning different values from the enter and leave functions, the
                     * behavior of the visitor can be altered, including skipping over a sub-tree of
                     * the AST (by returning false), editing the AST by returning a value or null
                     * to remove the value, or to stop the whole traversal by returning BREAK.
                     *
                     * When using visit() to edit an AST, the original AST will not be modified, and
                     * a new version of the AST with the changes applied will be returned from the
                     * visit function.
                     *
                     *     const editedAST = visit(ast, {
                     *       enter(node, key, parent, path, ancestors) {
                     *         // @return
                     *         //   undefined: no action
                     *         //   false: skip visiting this node
                     *         //   visitor.BREAK: stop visiting altogether
                     *         //   null: delete this node
                     *         //   any value: replace this node with the returned value
                     *       },
                     *       leave(node, key, parent, path, ancestors) {
                     *         // @return
                     *         //   undefined: no action
                     *         //   false: no action
                     *         //   visitor.BREAK: stop visiting altogether
                     *         //   null: delete this node
                     *         //   any value: replace this node with the returned value
                     *       }
                     *     });
                     *
                     * Alternatively to providing enter() and leave() functions, a visitor can
                     * instead provide functions named the same as the kinds of AST nodes, or
                     * enter/leave visitors at a named key, leading to four permutations of the
                     * visitor API:
                     *
                     * 1) Named visitors triggered when entering a node of a specific kind.
                     *
                     *     visit(ast, {
                     *       Kind(node) {
                     *         // enter the "Kind" node
                     *       }
                     *     })
                     *
                     * 2) Named visitors that trigger upon entering and leaving a node of
                     *    a specific kind.
                     *
                     *     visit(ast, {
                     *       Kind: {
                     *         enter(node) {
                     *           // enter the "Kind" node
                     *         }
                     *         leave(node) {
                     *           // leave the "Kind" node
                     *         }
                     *       }
                     *     })
                     *
                     * 3) Generic visitors that trigger upon entering and leaving any node.
                     *
                     *     visit(ast, {
                     *       enter(node) {
                     *         // enter any node
                     *       },
                     *       leave(node) {
                     *         // leave any node
                     *       }
                     *     })
                     *
                     * 4) Parallel visitors for entering and leaving nodes of a specific kind.
                     *
                     *     visit(ast, {
                     *       enter: {
                     *         Kind(node) {
                     *           // enter the "Kind" node
                     *         }
                     *       },
                     *       leave: {
                     *         Kind(node) {
                     *           // leave the "Kind" node
                     *         }
                     *       }
                     *     })
                     */

                    exports.BREAK = BREAK;

                    function visit(root, visitor) {
                        var visitorKeys =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : QueryDocumentKeys;

                        /* eslint-disable no-undef-init */
                        var stack = undefined;
                        var inArray = Array.isArray(root);
                        var keys = [root];
                        var index = -1;
                        var edits = [];
                        var node = undefined;
                        var key = undefined;
                        var parent = undefined;
                        var path = [];
                        var ancestors = [];
                        var newRoot = root;
                        /* eslint-enable no-undef-init */

                        do {
                            index++;
                            var isLeaving = index === keys.length;
                            var isEdited = isLeaving && edits.length !== 0;

                            if (isLeaving) {
                                key =
                                    ancestors.length === 0
                                        ? undefined
                                        : path[path.length - 1];
                                node = parent;
                                parent = ancestors.pop();

                                if (isEdited) {
                                    if (inArray) {
                                        node = node.slice();
                                    } else {
                                        var clone = {};

                                        for (
                                            var _i2 = 0,
                                                _Object$keys2 = Object.keys(
                                                    node
                                                );
                                            _i2 < _Object$keys2.length;
                                            _i2++
                                        ) {
                                            var k = _Object$keys2[_i2];
                                            clone[k] = node[k];
                                        }

                                        node = clone;
                                    }

                                    var editOffset = 0;

                                    for (var ii = 0; ii < edits.length; ii++) {
                                        var editKey = edits[ii][0];
                                        var editValue = edits[ii][1];

                                        if (inArray) {
                                            editKey -= editOffset;
                                        }

                                        if (inArray && editValue === null) {
                                            node.splice(editKey, 1);
                                            editOffset++;
                                        } else {
                                            node[editKey] = editValue;
                                        }
                                    }
                                }

                                index = stack.index;
                                keys = stack.keys;
                                edits = stack.edits;
                                inArray = stack.inArray;
                                stack = stack.prev;
                            } else {
                                key = parent
                                    ? inArray
                                        ? index
                                        : keys[index]
                                    : undefined;
                                node = parent ? parent[key] : newRoot;

                                if (node === null || node === undefined) {
                                    continue;
                                }

                                if (parent) {
                                    path.push(key);
                                }
                            }

                            var result = void 0;

                            if (!Array.isArray(node)) {
                                if (!(0, _ast.isNode)(node)) {
                                    throw new Error(
                                        'Invalid AST Node: '.concat(
                                            (0, _inspect.default)(node),
                                            '.'
                                        )
                                    );
                                }

                                var visitFn = getVisitFn(
                                    visitor,
                                    node.kind,
                                    isLeaving
                                );

                                if (visitFn) {
                                    result = visitFn.call(
                                        visitor,
                                        node,
                                        key,
                                        parent,
                                        path,
                                        ancestors
                                    );

                                    if (result === BREAK) {
                                        break;
                                    }

                                    if (result === false) {
                                        if (!isLeaving) {
                                            path.pop();
                                            continue;
                                        }
                                    } else if (result !== undefined) {
                                        edits.push([key, result]);

                                        if (!isLeaving) {
                                            if ((0, _ast.isNode)(result)) {
                                                node = result;
                                            } else {
                                                path.pop();
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }

                            if (result === undefined && isEdited) {
                                edits.push([key, node]);
                            }

                            if (isLeaving) {
                                path.pop();
                            } else {
                                var _visitorKeys$node$kin;

                                stack = {
                                    inArray: inArray,
                                    index: index,
                                    keys: keys,
                                    edits: edits,
                                    prev: stack,
                                };
                                inArray = Array.isArray(node);
                                keys = inArray
                                    ? node
                                    : (_visitorKeys$node$kin =
                                          visitorKeys[node.kind]) !== null &&
                                      _visitorKeys$node$kin !== void 0
                                    ? _visitorKeys$node$kin
                                    : [];
                                index = -1;
                                edits = [];

                                if (parent) {
                                    ancestors.push(parent);
                                }

                                parent = node;
                            }
                        } while (stack !== undefined);

                        if (edits.length !== 0) {
                            newRoot = edits[edits.length - 1][1];
                        }

                        return newRoot;
                    }
                    /**
                     * Creates a new visitor instance which delegates to many visitors to run in
                     * parallel. Each visitor will be visited for each node before moving on.
                     *
                     * If a prior visitor edits a node, no following visitors will see that node.
                     */

                    function visitInParallel(visitors) {
                        var skipping = new Array(visitors.length);
                        return {
                            enter: function enter(node) {
                                for (var i = 0; i < visitors.length; i++) {
                                    if (skipping[i] == null) {
                                        var fn = getVisitFn(
                                            visitors[i],
                                            node.kind,
                                            /* isLeaving */
                                            false
                                        );

                                        if (fn) {
                                            var result = fn.apply(
                                                visitors[i],
                                                arguments
                                            );

                                            if (result === false) {
                                                skipping[i] = node;
                                            } else if (result === BREAK) {
                                                skipping[i] = BREAK;
                                            } else if (result !== undefined) {
                                                return result;
                                            }
                                        }
                                    }
                                }
                            },
                            leave: function leave(node) {
                                for (var i = 0; i < visitors.length; i++) {
                                    if (skipping[i] == null) {
                                        var fn = getVisitFn(
                                            visitors[i],
                                            node.kind,
                                            /* isLeaving */
                                            true
                                        );

                                        if (fn) {
                                            var result = fn.apply(
                                                visitors[i],
                                                arguments
                                            );

                                            if (result === BREAK) {
                                                skipping[i] = BREAK;
                                            } else if (
                                                result !== undefined &&
                                                result !== false
                                            ) {
                                                return result;
                                            }
                                        }
                                    } else if (skipping[i] === node) {
                                        skipping[i] = null;
                                    }
                                }
                            },
                        };
                    }
                    /**
                     * Given a visitor instance, if it is leaving or not, and a node kind, return
                     * the function the visitor runtime should call.
                     */

                    function getVisitFn(visitor, kind, isLeaving) {
                        var kindVisitor = visitor[kind];

                        if (kindVisitor) {
                            if (
                                !isLeaving &&
                                typeof kindVisitor === 'function'
                            ) {
                                // { Kind() {} }
                                return kindVisitor;
                            }

                            var kindSpecificVisitor = isLeaving
                                ? kindVisitor.leave
                                : kindVisitor.enter;

                            if (typeof kindSpecificVisitor === 'function') {
                                // { Kind: { enter() {}, leave() {} } }
                                return kindSpecificVisitor;
                            }
                        } else {
                            var specificVisitor = isLeaving
                                ? visitor.leave
                                : visitor.enter;

                            if (specificVisitor) {
                                if (typeof specificVisitor === 'function') {
                                    // { enter() {}, leave() {} }
                                    return specificVisitor;
                                }

                                var specificKindVisitor = specificVisitor[kind];

                                if (typeof specificKindVisitor === 'function') {
                                    // { enter: { Kind() {} }, leave: { Kind() {} } }
                                    return specificKindVisitor;
                                }
                            }
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/language/visitor.mjs':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/language/visitor.mjs ***!
  \***************************************************/
                /***/ (
                    __unused_webpack___webpack_module__,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ QueryDocumentKeys: () =>
                                /* binding */ QueryDocumentKeys,
                            /* harmony export */ BREAK: () =>
                                /* binding */ BREAK,
                            /* harmony export */ visit: () =>
                                /* binding */ visit,
                            /* harmony export */ visitInParallel: () =>
                                /* binding */ visitInParallel,
                            /* harmony export */ getVisitFn: () =>
                                /* binding */ getVisitFn,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                        /*! ../jsutils/inspect.mjs */ './node_modules/graphql/jsutils/inspect.mjs'
                    );
                    /* harmony import */ var _ast_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ./ast.mjs */ './node_modules/graphql/language/ast.mjs'
                    );

                    /**
                     * A visitor is provided to visit, it contains the collection of
                     * relevant functions to be called during the visitor's traversal.
                     */

                    var QueryDocumentKeys = {
                        Name: [],
                        Document: ['definitions'],
                        OperationDefinition: [
                            'name',
                            'variableDefinitions',
                            'directives',
                            'selectionSet',
                        ],
                        VariableDefinition: [
                            'variable',
                            'type',
                            'defaultValue',
                            'directives',
                        ],
                        Variable: ['name'],
                        SelectionSet: ['selections'],
                        Field: [
                            'alias',
                            'name',
                            'arguments',
                            'directives',
                            'selectionSet',
                        ],
                        Argument: ['name', 'value'],
                        FragmentSpread: ['name', 'directives'],
                        InlineFragment: [
                            'typeCondition',
                            'directives',
                            'selectionSet',
                        ],
                        FragmentDefinition: [
                            'name', // Note: fragment variable definitions are experimental and may be changed
                            // or removed in the future.
                            'variableDefinitions',
                            'typeCondition',
                            'directives',
                            'selectionSet',
                        ],
                        IntValue: [],
                        FloatValue: [],
                        StringValue: [],
                        BooleanValue: [],
                        NullValue: [],
                        EnumValue: [],
                        ListValue: ['values'],
                        ObjectValue: ['fields'],
                        ObjectField: ['name', 'value'],
                        Directive: ['name', 'arguments'],
                        NamedType: ['name'],
                        ListType: ['type'],
                        NonNullType: ['type'],
                        SchemaDefinition: [
                            'description',
                            'directives',
                            'operationTypes',
                        ],
                        OperationTypeDefinition: ['type'],
                        ScalarTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                        ],
                        ObjectTypeDefinition: [
                            'description',
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        FieldDefinition: [
                            'description',
                            'name',
                            'arguments',
                            'type',
                            'directives',
                        ],
                        InputValueDefinition: [
                            'description',
                            'name',
                            'type',
                            'defaultValue',
                            'directives',
                        ],
                        InterfaceTypeDefinition: [
                            'description',
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        UnionTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'types',
                        ],
                        EnumTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'values',
                        ],
                        EnumValueDefinition: [
                            'description',
                            'name',
                            'directives',
                        ],
                        InputObjectTypeDefinition: [
                            'description',
                            'name',
                            'directives',
                            'fields',
                        ],
                        DirectiveDefinition: [
                            'description',
                            'name',
                            'arguments',
                            'locations',
                        ],
                        SchemaExtension: ['directives', 'operationTypes'],
                        ScalarTypeExtension: ['name', 'directives'],
                        ObjectTypeExtension: [
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        InterfaceTypeExtension: [
                            'name',
                            'interfaces',
                            'directives',
                            'fields',
                        ],
                        UnionTypeExtension: ['name', 'directives', 'types'],
                        EnumTypeExtension: ['name', 'directives', 'values'],
                        InputObjectTypeExtension: [
                            'name',
                            'directives',
                            'fields',
                        ],
                    };
                    var BREAK = Object.freeze({});
                    /**
                     * visit() will walk through an AST using a depth-first traversal, calling
                     * the visitor's enter function at each node in the traversal, and calling the
                     * leave function after visiting that node and all of its child nodes.
                     *
                     * By returning different values from the enter and leave functions, the
                     * behavior of the visitor can be altered, including skipping over a sub-tree of
                     * the AST (by returning false), editing the AST by returning a value or null
                     * to remove the value, or to stop the whole traversal by returning BREAK.
                     *
                     * When using visit() to edit an AST, the original AST will not be modified, and
                     * a new version of the AST with the changes applied will be returned from the
                     * visit function.
                     *
                     *     const editedAST = visit(ast, {
                     *       enter(node, key, parent, path, ancestors) {
                     *         // @return
                     *         //   undefined: no action
                     *         //   false: skip visiting this node
                     *         //   visitor.BREAK: stop visiting altogether
                     *         //   null: delete this node
                     *         //   any value: replace this node with the returned value
                     *       },
                     *       leave(node, key, parent, path, ancestors) {
                     *         // @return
                     *         //   undefined: no action
                     *         //   false: no action
                     *         //   visitor.BREAK: stop visiting altogether
                     *         //   null: delete this node
                     *         //   any value: replace this node with the returned value
                     *       }
                     *     });
                     *
                     * Alternatively to providing enter() and leave() functions, a visitor can
                     * instead provide functions named the same as the kinds of AST nodes, or
                     * enter/leave visitors at a named key, leading to four permutations of the
                     * visitor API:
                     *
                     * 1) Named visitors triggered when entering a node of a specific kind.
                     *
                     *     visit(ast, {
                     *       Kind(node) {
                     *         // enter the "Kind" node
                     *       }
                     *     })
                     *
                     * 2) Named visitors that trigger upon entering and leaving a node of
                     *    a specific kind.
                     *
                     *     visit(ast, {
                     *       Kind: {
                     *         enter(node) {
                     *           // enter the "Kind" node
                     *         }
                     *         leave(node) {
                     *           // leave the "Kind" node
                     *         }
                     *       }
                     *     })
                     *
                     * 3) Generic visitors that trigger upon entering and leaving any node.
                     *
                     *     visit(ast, {
                     *       enter(node) {
                     *         // enter any node
                     *       },
                     *       leave(node) {
                     *         // leave any node
                     *       }
                     *     })
                     *
                     * 4) Parallel visitors for entering and leaving nodes of a specific kind.
                     *
                     *     visit(ast, {
                     *       enter: {
                     *         Kind(node) {
                     *           // enter the "Kind" node
                     *         }
                     *       },
                     *       leave: {
                     *         Kind(node) {
                     *           // leave the "Kind" node
                     *         }
                     *       }
                     *     })
                     */

                    function visit(root, visitor) {
                        var visitorKeys =
                            arguments.length > 2 && arguments[2] !== undefined
                                ? arguments[2]
                                : QueryDocumentKeys;

                        /* eslint-disable no-undef-init */
                        var stack = undefined;
                        var inArray = Array.isArray(root);
                        var keys = [root];
                        var index = -1;
                        var edits = [];
                        var node = undefined;
                        var key = undefined;
                        var parent = undefined;
                        var path = [];
                        var ancestors = [];
                        var newRoot = root;
                        /* eslint-enable no-undef-init */

                        do {
                            index++;
                            var isLeaving = index === keys.length;
                            var isEdited = isLeaving && edits.length !== 0;

                            if (isLeaving) {
                                key =
                                    ancestors.length === 0
                                        ? undefined
                                        : path[path.length - 1];
                                node = parent;
                                parent = ancestors.pop();

                                if (isEdited) {
                                    if (inArray) {
                                        node = node.slice();
                                    } else {
                                        var clone = {};

                                        for (
                                            var _i2 = 0,
                                                _Object$keys2 = Object.keys(
                                                    node
                                                );
                                            _i2 < _Object$keys2.length;
                                            _i2++
                                        ) {
                                            var k = _Object$keys2[_i2];
                                            clone[k] = node[k];
                                        }

                                        node = clone;
                                    }

                                    var editOffset = 0;

                                    for (var ii = 0; ii < edits.length; ii++) {
                                        var editKey = edits[ii][0];
                                        var editValue = edits[ii][1];

                                        if (inArray) {
                                            editKey -= editOffset;
                                        }

                                        if (inArray && editValue === null) {
                                            node.splice(editKey, 1);
                                            editOffset++;
                                        } else {
                                            node[editKey] = editValue;
                                        }
                                    }
                                }

                                index = stack.index;
                                keys = stack.keys;
                                edits = stack.edits;
                                inArray = stack.inArray;
                                stack = stack.prev;
                            } else {
                                key = parent
                                    ? inArray
                                        ? index
                                        : keys[index]
                                    : undefined;
                                node = parent ? parent[key] : newRoot;

                                if (node === null || node === undefined) {
                                    continue;
                                }

                                if (parent) {
                                    path.push(key);
                                }
                            }

                            var result = void 0;

                            if (!Array.isArray(node)) {
                                if (
                                    !(0,
                                    _ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(
                                        node
                                    )
                                ) {
                                    throw new Error(
                                        'Invalid AST Node: '.concat(
                                            (0,
                                            _jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_1__.default)(
                                                node
                                            ),
                                            '.'
                                        )
                                    );
                                }

                                var visitFn = getVisitFn(
                                    visitor,
                                    node.kind,
                                    isLeaving
                                );

                                if (visitFn) {
                                    result = visitFn.call(
                                        visitor,
                                        node,
                                        key,
                                        parent,
                                        path,
                                        ancestors
                                    );

                                    if (result === BREAK) {
                                        break;
                                    }

                                    if (result === false) {
                                        if (!isLeaving) {
                                            path.pop();
                                            continue;
                                        }
                                    } else if (result !== undefined) {
                                        edits.push([key, result]);

                                        if (!isLeaving) {
                                            if (
                                                (0,
                                                _ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(
                                                    result
                                                )
                                            ) {
                                                node = result;
                                            } else {
                                                path.pop();
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }

                            if (result === undefined && isEdited) {
                                edits.push([key, node]);
                            }

                            if (isLeaving) {
                                path.pop();
                            } else {
                                var _visitorKeys$node$kin;

                                stack = {
                                    inArray: inArray,
                                    index: index,
                                    keys: keys,
                                    edits: edits,
                                    prev: stack,
                                };
                                inArray = Array.isArray(node);
                                keys = inArray
                                    ? node
                                    : (_visitorKeys$node$kin =
                                          visitorKeys[node.kind]) !== null &&
                                      _visitorKeys$node$kin !== void 0
                                    ? _visitorKeys$node$kin
                                    : [];
                                index = -1;
                                edits = [];

                                if (parent) {
                                    ancestors.push(parent);
                                }

                                parent = node;
                            }
                        } while (stack !== undefined);

                        if (edits.length !== 0) {
                            newRoot = edits[edits.length - 1][1];
                        }

                        return newRoot;
                    }
                    /**
                     * Creates a new visitor instance which delegates to many visitors to run in
                     * parallel. Each visitor will be visited for each node before moving on.
                     *
                     * If a prior visitor edits a node, no following visitors will see that node.
                     */

                    function visitInParallel(visitors) {
                        var skipping = new Array(visitors.length);
                        return {
                            enter: function enter(node) {
                                for (var i = 0; i < visitors.length; i++) {
                                    if (skipping[i] == null) {
                                        var fn = getVisitFn(
                                            visitors[i],
                                            node.kind,
                                            /* isLeaving */
                                            false
                                        );

                                        if (fn) {
                                            var result = fn.apply(
                                                visitors[i],
                                                arguments
                                            );

                                            if (result === false) {
                                                skipping[i] = node;
                                            } else if (result === BREAK) {
                                                skipping[i] = BREAK;
                                            } else if (result !== undefined) {
                                                return result;
                                            }
                                        }
                                    }
                                }
                            },
                            leave: function leave(node) {
                                for (var i = 0; i < visitors.length; i++) {
                                    if (skipping[i] == null) {
                                        var fn = getVisitFn(
                                            visitors[i],
                                            node.kind,
                                            /* isLeaving */
                                            true
                                        );

                                        if (fn) {
                                            var result = fn.apply(
                                                visitors[i],
                                                arguments
                                            );

                                            if (result === BREAK) {
                                                skipping[i] = BREAK;
                                            } else if (
                                                result !== undefined &&
                                                result !== false
                                            ) {
                                                return result;
                                            }
                                        }
                                    } else if (skipping[i] === node) {
                                        skipping[i] = null;
                                    }
                                }
                            },
                        };
                    }
                    /**
                     * Given a visitor instance, if it is leaving or not, and a node kind, return
                     * the function the visitor runtime should call.
                     */

                    function getVisitFn(visitor, kind, isLeaving) {
                        var kindVisitor = visitor[kind];

                        if (kindVisitor) {
                            if (
                                !isLeaving &&
                                typeof kindVisitor === 'function'
                            ) {
                                // { Kind() {} }
                                return kindVisitor;
                            }

                            var kindSpecificVisitor = isLeaving
                                ? kindVisitor.leave
                                : kindVisitor.enter;

                            if (typeof kindSpecificVisitor === 'function') {
                                // { Kind: { enter() {}, leave() {} } }
                                return kindSpecificVisitor;
                            }
                        } else {
                            var specificVisitor = isLeaving
                                ? visitor.leave
                                : visitor.enter;

                            if (specificVisitor) {
                                if (typeof specificVisitor === 'function') {
                                    // { enter() {}, leave() {} }
                                    return specificVisitor;
                                }

                                var specificKindVisitor = specificVisitor[kind];

                                if (typeof specificKindVisitor === 'function') {
                                    // { enter: { Kind() {} }, leave: { Kind() {} } }
                                    return specificKindVisitor;
                                }
                            }
                        }
                    }

                    /***/
                },

            /***/ './node_modules/graphql/polyfills/symbols.js':
                /*!***************************************************!*\
  !*** ./node_modules/graphql/polyfills/symbols.js ***!
  \***************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    'use strict';

                    Object.defineProperty(exports, '__esModule', {
                        value: true,
                    });
                    exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = void 0;
                    // In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
                    var SYMBOL_ITERATOR =
                        typeof Symbol === 'function' && Symbol.iterator != null
                            ? Symbol.iterator
                            : '@@iterator'; // In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

                    exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
                    var SYMBOL_ASYNC_ITERATOR =
                        typeof Symbol === 'function' &&
                        Symbol.asyncIterator != null
                            ? Symbol.asyncIterator
                            : '@@asyncIterator'; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

                    exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
                    var SYMBOL_TO_STRING_TAG =
                        typeof Symbol === 'function' &&
                        Symbol.toStringTag != null
                            ? Symbol.toStringTag
                            : '@@toStringTag';
                    exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;

                    /***/
                },

            /***/ './node_modules/stack-generator/stack-generator.js':
                /*!*********************************************************!*\
  !*** ./node_modules/stack-generator/stack-generator.js ***!
  \*********************************************************/
                /***/ function (module, exports, __webpack_require__) {
                    var __WEBPACK_AMD_DEFINE_FACTORY__,
                        __WEBPACK_AMD_DEFINE_ARRAY__,
                        __WEBPACK_AMD_DEFINE_RESULT__;
                    (function (root, factory) {
                        'use strict';
                        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

                        /* istanbul ignore next */
                        if (true) {
                            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                                __webpack_require__(
                                    /*! stackframe */ './node_modules/stackframe/stackframe.js'
                                ),
                            ]),
                            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
                            (__WEBPACK_AMD_DEFINE_RESULT__ =
                                typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
                                'function'
                                    ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                          exports,
                                          __WEBPACK_AMD_DEFINE_ARRAY__
                                      )
                                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else {
                        }
                    })(this, function (StackFrame) {
                        return {
                            backtrace: function StackGenerator$$backtrace(
                                opts
                            ) {
                                var stack = [];
                                var maxStackSize = 10;

                                if (
                                    typeof opts === 'object' &&
                                    typeof opts.maxStackSize === 'number'
                                ) {
                                    maxStackSize = opts.maxStackSize;
                                }

                                var curr = arguments.callee;
                                while (
                                    curr &&
                                    stack.length < maxStackSize &&
                                    curr['arguments']
                                ) {
                                    // Allow V8 optimizations
                                    var args = new Array(
                                        curr['arguments'].length
                                    );
                                    for (var i = 0; i < args.length; ++i) {
                                        args[i] = curr['arguments'][i];
                                    }
                                    if (
                                        /function(?:\s+([\w$]+))+\s*\(/.test(
                                            curr.toString()
                                        )
                                    ) {
                                        stack.push(
                                            new StackFrame({
                                                functionName:
                                                    RegExp.$1 || undefined,
                                                args: args,
                                            })
                                        );
                                    } else {
                                        stack.push(
                                            new StackFrame({ args: args })
                                        );
                                    }

                                    try {
                                        curr = curr.caller;
                                    } catch (e) {
                                        break;
                                    }
                                }
                                return stack;
                            },
                        };
                    });

                    /***/
                },

            /***/ './node_modules/stackframe/stackframe.js':
                /*!***********************************************!*\
  !*** ./node_modules/stackframe/stackframe.js ***!
  \***********************************************/
                /***/ function (module, exports) {
                    var __WEBPACK_AMD_DEFINE_FACTORY__,
                        __WEBPACK_AMD_DEFINE_ARRAY__,
                        __WEBPACK_AMD_DEFINE_RESULT__;
                    (function (root, factory) {
                        'use strict';
                        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

                        /* istanbul ignore next */
                        if (true) {
                            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
                            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
                            (__WEBPACK_AMD_DEFINE_RESULT__ =
                                typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
                                'function'
                                    ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                          exports,
                                          __WEBPACK_AMD_DEFINE_ARRAY__
                                      )
                                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else {
                        }
                    })(this, function () {
                        'use strict';
                        function _isNumber(n) {
                            return !isNaN(parseFloat(n)) && isFinite(n);
                        }

                        function _capitalize(str) {
                            return (
                                str.charAt(0).toUpperCase() + str.substring(1)
                            );
                        }

                        function _getter(p) {
                            return function () {
                                return this[p];
                            };
                        }

                        var booleanProps = [
                            'isConstructor',
                            'isEval',
                            'isNative',
                            'isToplevel',
                        ];
                        var numericProps = ['columnNumber', 'lineNumber'];
                        var stringProps = [
                            'fileName',
                            'functionName',
                            'source',
                        ];
                        var arrayProps = ['args'];
                        var objectProps = ['evalOrigin'];

                        var props = booleanProps.concat(
                            numericProps,
                            stringProps,
                            arrayProps,
                            objectProps
                        );

                        function StackFrame(obj) {
                            if (!obj) return;
                            for (var i = 0; i < props.length; i++) {
                                if (obj[props[i]] !== undefined) {
                                    this['set' + _capitalize(props[i])](
                                        obj[props[i]]
                                    );
                                }
                            }
                        }

                        StackFrame.prototype = {
                            getArgs: function () {
                                return this.args;
                            },
                            setArgs: function (v) {
                                if (
                                    Object.prototype.toString.call(v) !==
                                    '[object Array]'
                                ) {
                                    throw new TypeError(
                                        'Args must be an Array'
                                    );
                                }
                                this.args = v;
                            },

                            getEvalOrigin: function () {
                                return this.evalOrigin;
                            },
                            setEvalOrigin: function (v) {
                                if (v instanceof StackFrame) {
                                    this.evalOrigin = v;
                                } else if (v instanceof Object) {
                                    this.evalOrigin = new StackFrame(v);
                                } else {
                                    throw new TypeError(
                                        'Eval Origin must be an Object or StackFrame'
                                    );
                                }
                            },

                            toString: function () {
                                var fileName = this.getFileName() || '';
                                var lineNumber = this.getLineNumber() || '';
                                var columnNumber = this.getColumnNumber() || '';
                                var functionName = this.getFunctionName() || '';
                                if (this.getIsEval()) {
                                    if (fileName) {
                                        return (
                                            '[eval] (' +
                                            fileName +
                                            ':' +
                                            lineNumber +
                                            ':' +
                                            columnNumber +
                                            ')'
                                        );
                                    }
                                    return (
                                        '[eval]:' +
                                        lineNumber +
                                        ':' +
                                        columnNumber
                                    );
                                }
                                if (functionName) {
                                    return (
                                        functionName +
                                        ' (' +
                                        fileName +
                                        ':' +
                                        lineNumber +
                                        ':' +
                                        columnNumber +
                                        ')'
                                    );
                                }
                                return (
                                    fileName +
                                    ':' +
                                    lineNumber +
                                    ':' +
                                    columnNumber
                                );
                            },
                        };

                        StackFrame.fromString = function StackFrame$$fromString(
                            str
                        ) {
                            var argsStartIndex = str.indexOf('(');
                            var argsEndIndex = str.lastIndexOf(')');

                            var functionName = str.substring(0, argsStartIndex);
                            var args = str
                                .substring(argsStartIndex + 1, argsEndIndex)
                                .split(',');
                            var locationString = str.substring(
                                argsEndIndex + 1
                            );

                            if (locationString.indexOf('@') === 0) {
                                var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(
                                    locationString,
                                    ''
                                );
                                var fileName = parts[1];
                                var lineNumber = parts[2];
                                var columnNumber = parts[3];
                            }

                            return new StackFrame({
                                functionName: functionName,
                                args: args || undefined,
                                fileName: fileName,
                                lineNumber: lineNumber || undefined,
                                columnNumber: columnNumber || undefined,
                            });
                        };

                        for (var i = 0; i < booleanProps.length; i++) {
                            StackFrame.prototype[
                                'get' + _capitalize(booleanProps[i])
                            ] = _getter(booleanProps[i]);
                            StackFrame.prototype[
                                'set' + _capitalize(booleanProps[i])
                            ] = (function (p) {
                                return function (v) {
                                    this[p] = Boolean(v);
                                };
                            })(booleanProps[i]);
                        }

                        for (var j = 0; j < numericProps.length; j++) {
                            StackFrame.prototype[
                                'get' + _capitalize(numericProps[j])
                            ] = _getter(numericProps[j]);
                            StackFrame.prototype[
                                'set' + _capitalize(numericProps[j])
                            ] = (function (p) {
                                return function (v) {
                                    if (!_isNumber(v)) {
                                        throw new TypeError(
                                            p + ' must be a Number'
                                        );
                                    }
                                    this[p] = Number(v);
                                };
                            })(numericProps[j]);
                        }

                        for (var k = 0; k < stringProps.length; k++) {
                            StackFrame.prototype[
                                'get' + _capitalize(stringProps[k])
                            ] = _getter(stringProps[k]);
                            StackFrame.prototype[
                                'set' + _capitalize(stringProps[k])
                            ] = (function (p) {
                                return function (v) {
                                    this[p] = String(v);
                                };
                            })(stringProps[k]);
                        }

                        return StackFrame;
                    });

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/array-set.js':
                /*!******************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/array-set.js ***!
  \******************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var util = __webpack_require__(
                        /*! ./util */ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js'
                    );
                    var has = Object.prototype.hasOwnProperty;

                    /**
                     * A data structure which is a combination of an array and a set. Adding a new
                     * member is O(1), testing for membership is O(1), and finding the index of an
                     * element is O(1). Removing elements from the set is not supported. Only
                     * strings are supported for membership.
                     */
                    function ArraySet() {
                        this._array = [];
                        this._set = Object.create(null);
                    }

                    /**
                     * Static method for creating ArraySet instances from an existing array.
                     */
                    ArraySet.fromArray = function ArraySet_fromArray(
                        aArray,
                        aAllowDuplicates
                    ) {
                        var set = new ArraySet();
                        for (var i = 0, len = aArray.length; i < len; i++) {
                            set.add(aArray[i], aAllowDuplicates);
                        }
                        return set;
                    };

                    /**
                     * Return how many unique items are in this ArraySet. If duplicates have been
                     * added, than those do not count towards the size.
                     *
                     * @returns Number
                     */
                    ArraySet.prototype.size = function ArraySet_size() {
                        return Object.getOwnPropertyNames(this._set).length;
                    };

                    /**
                     * Add the given string to this set.
                     *
                     * @param String aStr
                     */
                    ArraySet.prototype.add = function ArraySet_add(
                        aStr,
                        aAllowDuplicates
                    ) {
                        var sStr = util.toSetString(aStr);
                        var isDuplicate = has.call(this._set, sStr);
                        var idx = this._array.length;
                        if (!isDuplicate || aAllowDuplicates) {
                            this._array.push(aStr);
                        }
                        if (!isDuplicate) {
                            this._set[sStr] = idx;
                        }
                    };

                    /**
                     * Is the given string a member of this set?
                     *
                     * @param String aStr
                     */
                    ArraySet.prototype.has = function ArraySet_has(aStr) {
                        var sStr = util.toSetString(aStr);
                        return has.call(this._set, sStr);
                    };

                    /**
                     * What is the index of the given string in the array?
                     *
                     * @param String aStr
                     */
                    ArraySet.prototype.indexOf = function ArraySet_indexOf(
                        aStr
                    ) {
                        var sStr = util.toSetString(aStr);
                        if (has.call(this._set, sStr)) {
                            return this._set[sStr];
                        }
                        throw new Error('"' + aStr + '" is not in the set.');
                    };

                    /**
                     * What is the element at the given index?
                     *
                     * @param Number aIdx
                     */
                    ArraySet.prototype.at = function ArraySet_at(aIdx) {
                        if (aIdx >= 0 && aIdx < this._array.length) {
                            return this._array[aIdx];
                        }
                        throw new Error('No element indexed by ' + aIdx);
                    };

                    /**
                     * Returns the array representation of this set (which has the proper indices
                     * indicated by indexOf). Note that this is a copy of the internal array used
                     * for storing the members so that no one can mess with internal state.
                     */
                    ArraySet.prototype.toArray = function ArraySet_toArray() {
                        return this._array.slice();
                    };

                    exports.ArraySet = ArraySet;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/base64-vlq.js':
                /*!*******************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/base64-vlq.js ***!
  \*******************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     *
                     * Based on the Base 64 VLQ implementation in Closure Compiler:
                     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
                     *
                     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
                     * Redistribution and use in source and binary forms, with or without
                     * modification, are permitted provided that the following conditions are
                     * met:
                     *
                     *  * Redistributions of source code must retain the above copyright
                     *    notice, this list of conditions and the following disclaimer.
                     *  * Redistributions in binary form must reproduce the above
                     *    copyright notice, this list of conditions and the following
                     *    disclaimer in the documentation and/or other materials provided
                     *    with the distribution.
                     *  * Neither the name of Google Inc. nor the names of its
                     *    contributors may be used to endorse or promote products derived
                     *    from this software without specific prior written permission.
                     *
                     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
                     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
                     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
                     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
                     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
                     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
                     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
                     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                     */

                    var base64 = __webpack_require__(
                        /*! ./base64 */ './node_modules/stacktrace-gps/node_modules/source-map/lib/base64.js'
                    );

                    // A single base 64 digit can contain 6 bits of data. For the base 64 variable
                    // length quantities we use in the source map spec, the first bit is the sign,
                    // the next four bits are the actual value, and the 6th bit is the
                    // continuation bit. The continuation bit tells us whether there are more
                    // digits in this value following this digit.
                    //
                    //   Continuation
                    //   |    Sign
                    //   |    |
                    //   V    V
                    //   101011

                    var VLQ_BASE_SHIFT = 5;

                    // binary: 100000
                    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

                    // binary: 011111
                    var VLQ_BASE_MASK = VLQ_BASE - 1;

                    // binary: 100000
                    var VLQ_CONTINUATION_BIT = VLQ_BASE;

                    /**
                     * Converts from a two-complement value to a value where the sign bit is
                     * placed in the least significant bit.  For example, as decimals:
                     *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
                     *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
                     */
                    function toVLQSigned(aValue) {
                        return aValue < 0
                            ? (-aValue << 1) + 1
                            : (aValue << 1) + 0;
                    }

                    /**
                     * Converts to a two-complement value from a value where the sign bit is
                     * placed in the least significant bit.  For example, as decimals:
                     *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
                     *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
                     */
                    function fromVLQSigned(aValue) {
                        var isNegative = (aValue & 1) === 1;
                        var shifted = aValue >> 1;
                        return isNegative ? -shifted : shifted;
                    }

                    /**
                     * Returns the base 64 VLQ encoded value.
                     */
                    exports.encode = function base64VLQ_encode(aValue) {
                        var encoded = '';
                        var digit;

                        var vlq = toVLQSigned(aValue);

                        do {
                            digit = vlq & VLQ_BASE_MASK;
                            vlq >>>= VLQ_BASE_SHIFT;
                            if (vlq > 0) {
                                // There are still more digits in this value, so we must make sure the
                                // continuation bit is marked.
                                digit |= VLQ_CONTINUATION_BIT;
                            }
                            encoded += base64.encode(digit);
                        } while (vlq > 0);

                        return encoded;
                    };

                    /**
                     * Decodes the next base 64 VLQ value from the given string and returns the
                     * value and the rest of the string via the out parameter.
                     */
                    exports.decode = function base64VLQ_decode(
                        aStr,
                        aIndex,
                        aOutParam
                    ) {
                        var strLen = aStr.length;
                        var result = 0;
                        var shift = 0;
                        var continuation, digit;

                        do {
                            if (aIndex >= strLen) {
                                throw new Error(
                                    'Expected more digits in base 64 VLQ value.'
                                );
                            }

                            digit = base64.decode(aStr.charCodeAt(aIndex++));
                            if (digit === -1) {
                                throw new Error(
                                    'Invalid base64 digit: ' +
                                        aStr.charAt(aIndex - 1)
                                );
                            }

                            continuation = !!(digit & VLQ_CONTINUATION_BIT);
                            digit &= VLQ_BASE_MASK;
                            result = result + (digit << shift);
                            shift += VLQ_BASE_SHIFT;
                        } while (continuation);

                        aOutParam.value = fromVLQSigned(result);
                        aOutParam.rest = aIndex;
                    };

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/base64.js':
                /*!***************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/base64.js ***!
  \***************************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
                        ''
                    );

                    /**
                     * Encode an integer in the range of 0 to 63 to a single base 64 digit.
                     */
                    exports.encode = function (number) {
                        if (0 <= number && number < intToCharMap.length) {
                            return intToCharMap[number];
                        }
                        throw new TypeError(
                            'Must be between 0 and 63: ' + number
                        );
                    };

                    /**
                     * Decode a single base 64 character code digit to an integer. Returns -1 on
                     * failure.
                     */
                    exports.decode = function (charCode) {
                        var bigA = 65; // 'A'
                        var bigZ = 90; // 'Z'

                        var littleA = 97; // 'a'
                        var littleZ = 122; // 'z'

                        var zero = 48; // '0'
                        var nine = 57; // '9'

                        var plus = 43; // '+'
                        var slash = 47; // '/'

                        var littleOffset = 26;
                        var numberOffset = 52;

                        // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
                        if (bigA <= charCode && charCode <= bigZ) {
                            return charCode - bigA;
                        }

                        // 26 - 51: abcdefghijklmnopqrstuvwxyz
                        if (littleA <= charCode && charCode <= littleZ) {
                            return charCode - littleA + littleOffset;
                        }

                        // 52 - 61: 0123456789
                        if (zero <= charCode && charCode <= nine) {
                            return charCode - zero + numberOffset;
                        }

                        // 62: +
                        if (charCode == plus) {
                            return 62;
                        }

                        // 63: /
                        if (charCode == slash) {
                            return 63;
                        }

                        // Invalid base64 digit.
                        return -1;
                    };

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/binary-search.js':
                /*!**********************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/binary-search.js ***!
  \**********************************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    exports.GREATEST_LOWER_BOUND = 1;
                    exports.LEAST_UPPER_BOUND = 2;

                    /**
                     * Recursive implementation of binary search.
                     *
                     * @param aLow Indices here and lower do not contain the needle.
                     * @param aHigh Indices here and higher do not contain the needle.
                     * @param aNeedle The element being searched for.
                     * @param aHaystack The non-empty array being searched.
                     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
                     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
                     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
                     *     closest element that is smaller than or greater than the one we are
                     *     searching for, respectively, if the exact element cannot be found.
                     */
                    function recursiveSearch(
                        aLow,
                        aHigh,
                        aNeedle,
                        aHaystack,
                        aCompare,
                        aBias
                    ) {
                        // This function terminates when one of the following is true:
                        //
                        //   1. We find the exact element we are looking for.
                        //
                        //   2. We did not find the exact element, but we can return the index of
                        //      the next-closest element.
                        //
                        //   3. We did not find the exact element, and there is no next-closest
                        //      element than the one we are searching for, so we return -1.
                        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
                        var cmp = aCompare(aNeedle, aHaystack[mid], true);
                        if (cmp === 0) {
                            // Found the element we are looking for.
                            return mid;
                        } else if (cmp > 0) {
                            // Our needle is greater than aHaystack[mid].
                            if (aHigh - mid > 1) {
                                // The element is in the upper half.
                                return recursiveSearch(
                                    mid,
                                    aHigh,
                                    aNeedle,
                                    aHaystack,
                                    aCompare,
                                    aBias
                                );
                            }

                            // The exact needle element was not found in this haystack. Determine if
                            // we are in termination case (3) or (2) and return the appropriate thing.
                            if (aBias == exports.LEAST_UPPER_BOUND) {
                                return aHigh < aHaystack.length ? aHigh : -1;
                            } else {
                                return mid;
                            }
                        } else {
                            // Our needle is less than aHaystack[mid].
                            if (mid - aLow > 1) {
                                // The element is in the lower half.
                                return recursiveSearch(
                                    aLow,
                                    mid,
                                    aNeedle,
                                    aHaystack,
                                    aCompare,
                                    aBias
                                );
                            }

                            // we are in termination case (3) or (2) and return the appropriate thing.
                            if (aBias == exports.LEAST_UPPER_BOUND) {
                                return mid;
                            } else {
                                return aLow < 0 ? -1 : aLow;
                            }
                        }
                    }

                    /**
                     * This is an implementation of binary search which will always try and return
                     * the index of the closest element if there is no exact hit. This is because
                     * mappings between original and generated line/col pairs are single points,
                     * and there is an implicit region between each of them, so a miss just means
                     * that you aren't on the very start of a region.
                     *
                     * @param aNeedle The element you are looking for.
                     * @param aHaystack The array that is being searched.
                     * @param aCompare A function which takes the needle and an element in the
                     *     array and returns -1, 0, or 1 depending on whether the needle is less
                     *     than, equal to, or greater than the element, respectively.
                     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
                     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
                     *     closest element that is smaller than or greater than the one we are
                     *     searching for, respectively, if the exact element cannot be found.
                     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
                     */
                    exports.search = function search(
                        aNeedle,
                        aHaystack,
                        aCompare,
                        aBias
                    ) {
                        if (aHaystack.length === 0) {
                            return -1;
                        }

                        var index = recursiveSearch(
                            -1,
                            aHaystack.length,
                            aNeedle,
                            aHaystack,
                            aCompare,
                            aBias || exports.GREATEST_LOWER_BOUND
                        );
                        if (index < 0) {
                            return -1;
                        }

                        // We have found either the exact element, or the next-closest element than
                        // the one we are searching for. However, there may be more than one such
                        // element. Make sure we always return the smallest of these.
                        while (index - 1 >= 0) {
                            if (
                                aCompare(
                                    aHaystack[index],
                                    aHaystack[index - 1],
                                    true
                                ) !== 0
                            ) {
                                break;
                            }
                            --index;
                        }

                        return index;
                    };

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/mapping-list.js':
                /*!*********************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/mapping-list.js ***!
  \*********************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2014 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var util = __webpack_require__(
                        /*! ./util */ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js'
                    );

                    /**
                     * Determine whether mappingB is after mappingA with respect to generated
                     * position.
                     */
                    function generatedPositionAfter(mappingA, mappingB) {
                        // Optimized for most common case
                        var lineA = mappingA.generatedLine;
                        var lineB = mappingB.generatedLine;
                        var columnA = mappingA.generatedColumn;
                        var columnB = mappingB.generatedColumn;
                        return (
                            lineB > lineA ||
                            (lineB == lineA && columnB >= columnA) ||
                            util.compareByGeneratedPositionsInflated(
                                mappingA,
                                mappingB
                            ) <= 0
                        );
                    }

                    /**
                     * A data structure to provide a sorted view of accumulated mappings in a
                     * performance conscious manner. It trades a neglibable overhead in general
                     * case for a large speedup in case of mappings being added in order.
                     */
                    function MappingList() {
                        this._array = [];
                        this._sorted = true;
                        // Serves as infimum
                        this._last = { generatedLine: -1, generatedColumn: 0 };
                    }

                    /**
                     * Iterate through internal items. This method takes the same arguments that
                     * `Array.prototype.forEach` takes.
                     *
                     * NOTE: The order of the mappings is NOT guaranteed.
                     */
                    MappingList.prototype.unsortedForEach = function MappingList_forEach(
                        aCallback,
                        aThisArg
                    ) {
                        this._array.forEach(aCallback, aThisArg);
                    };

                    /**
                     * Add the given source mapping.
                     *
                     * @param Object aMapping
                     */
                    MappingList.prototype.add = function MappingList_add(
                        aMapping
                    ) {
                        if (generatedPositionAfter(this._last, aMapping)) {
                            this._last = aMapping;
                            this._array.push(aMapping);
                        } else {
                            this._sorted = false;
                            this._array.push(aMapping);
                        }
                    };

                    /**
                     * Returns the flat, sorted array of mappings. The mappings are sorted by
                     * generated position.
                     *
                     * WARNING: This method returns internal data without copying, for
                     * performance. The return value must NOT be mutated, and should be treated as
                     * an immutable borrow. If you want to take ownership, you must make your own
                     * copy.
                     */
                    MappingList.prototype.toArray = function MappingList_toArray() {
                        if (!this._sorted) {
                            this._array.sort(
                                util.compareByGeneratedPositionsInflated
                            );
                            this._sorted = true;
                        }
                        return this._array;
                    };

                    exports.MappingList = MappingList;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/quick-sort.js':
                /*!*******************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/quick-sort.js ***!
  \*******************************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    // It turns out that some (most?) JavaScript engines don't self-host
                    // `Array.prototype.sort`. This makes sense because C++ will likely remain
                    // faster than JS when doing raw CPU-intensive sorting. However, when using a
                    // custom comparator function, calling back and forth between the VM's C++ and
                    // JIT'd JS is rather slow *and* loses JIT type information, resulting in
                    // worse generated code for the comparator function than would be optimal. In
                    // fact, when sorting with a comparator, these costs outweigh the benefits of
                    // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
                    // a ~3500ms mean speed-up in `bench/bench.html`.

                    /**
                     * Swap the elements indexed by `x` and `y` in the array `ary`.
                     *
                     * @param {Array} ary
                     *        The array.
                     * @param {Number} x
                     *        The index of the first item.
                     * @param {Number} y
                     *        The index of the second item.
                     */
                    function swap(ary, x, y) {
                        var temp = ary[x];
                        ary[x] = ary[y];
                        ary[y] = temp;
                    }

                    /**
                     * Returns a random integer within the range `low .. high` inclusive.
                     *
                     * @param {Number} low
                     *        The lower bound on the range.
                     * @param {Number} high
                     *        The upper bound on the range.
                     */
                    function randomIntInRange(low, high) {
                        return Math.round(low + Math.random() * (high - low));
                    }

                    /**
                     * The Quick Sort algorithm.
                     *
                     * @param {Array} ary
                     *        An array to sort.
                     * @param {function} comparator
                     *        Function to use to compare two items.
                     * @param {Number} p
                     *        Start index of the array
                     * @param {Number} r
                     *        End index of the array
                     */
                    function doQuickSort(ary, comparator, p, r) {
                        // If our lower bound is less than our upper bound, we (1) partition the
                        // array into two pieces and (2) recurse on each half. If it is not, this is
                        // the empty array and our base case.

                        if (p < r) {
                            // (1) Partitioning.
                            //
                            // The partitioning chooses a pivot between `p` and `r` and moves all
                            // elements that are less than or equal to the pivot to the before it, and
                            // all the elements that are greater than it after it. The effect is that
                            // once partition is done, the pivot is in the exact place it will be when
                            // the array is put in sorted order, and it will not need to be moved
                            // again. This runs in O(n) time.

                            // Always choose a random pivot so that an input array which is reverse
                            // sorted does not cause O(n^2) running time.
                            var pivotIndex = randomIntInRange(p, r);
                            var i = p - 1;

                            swap(ary, pivotIndex, r);
                            var pivot = ary[r];

                            // Immediately after `j` is incremented in this loop, the following hold
                            // true:
                            //
                            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
                            //
                            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
                            for (var j = p; j < r; j++) {
                                if (comparator(ary[j], pivot) <= 0) {
                                    i += 1;
                                    swap(ary, i, j);
                                }
                            }

                            swap(ary, i + 1, j);
                            var q = i + 1;

                            // (2) Recurse on each half.

                            doQuickSort(ary, comparator, p, q - 1);
                            doQuickSort(ary, comparator, q + 1, r);
                        }
                    }

                    /**
                     * Sort the given array in-place with the given comparator function.
                     *
                     * @param {Array} ary
                     *        An array to sort.
                     * @param {function} comparator
                     *        Function to use to compare two items.
                     */
                    exports.quickSort = function (ary, comparator) {
                        doQuickSort(ary, comparator, 0, ary.length - 1);
                    };

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-consumer.js':
                /*!****************************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-consumer.js ***!
  \****************************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var util = __webpack_require__(
                        /*! ./util */ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js'
                    );
                    var binarySearch = __webpack_require__(
                        /*! ./binary-search */ './node_modules/stacktrace-gps/node_modules/source-map/lib/binary-search.js'
                    );
                    var ArraySet = __webpack_require__(
                        /*! ./array-set */ './node_modules/stacktrace-gps/node_modules/source-map/lib/array-set.js'
                    ).ArraySet;
                    var base64VLQ = __webpack_require__(
                        /*! ./base64-vlq */ './node_modules/stacktrace-gps/node_modules/source-map/lib/base64-vlq.js'
                    );
                    var quickSort = __webpack_require__(
                        /*! ./quick-sort */ './node_modules/stacktrace-gps/node_modules/source-map/lib/quick-sort.js'
                    ).quickSort;

                    function SourceMapConsumer(aSourceMap) {
                        var sourceMap = aSourceMap;
                        if (typeof aSourceMap === 'string') {
                            sourceMap = JSON.parse(
                                aSourceMap.replace(/^\)\]\}'/, '')
                            );
                        }

                        return sourceMap.sections != null
                            ? new IndexedSourceMapConsumer(sourceMap)
                            : new BasicSourceMapConsumer(sourceMap);
                    }

                    SourceMapConsumer.fromSourceMap = function (aSourceMap) {
                        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
                    };

                    /**
                     * The version of the source mapping spec that we are consuming.
                     */
                    SourceMapConsumer.prototype._version = 3;

                    // `__generatedMappings` and `__originalMappings` are arrays that hold the
                    // parsed mapping coordinates from the source map's "mappings" attribute. They
                    // are lazily instantiated, accessed via the `_generatedMappings` and
                    // `_originalMappings` getters respectively, and we only parse the mappings
                    // and create these arrays once queried for a source location. We jump through
                    // these hoops because there can be many thousands of mappings, and parsing
                    // them is expensive, so we only want to do it if we must.
                    //
                    // Each object in the arrays is of the form:
                    //
                    //     {
                    //       generatedLine: The line number in the generated code,
                    //       generatedColumn: The column number in the generated code,
                    //       source: The path to the original source file that generated this
                    //               chunk of code,
                    //       originalLine: The line number in the original source that
                    //                     corresponds to this chunk of generated code,
                    //       originalColumn: The column number in the original source that
                    //                       corresponds to this chunk of generated code,
                    //       name: The name of the original symbol which generated this chunk of
                    //             code.
                    //     }
                    //
                    // All properties except for `generatedLine` and `generatedColumn` can be
                    // `null`.
                    //
                    // `_generatedMappings` is ordered by the generated positions.
                    //
                    // `_originalMappings` is ordered by the original positions.

                    SourceMapConsumer.prototype.__generatedMappings = null;
                    Object.defineProperty(
                        SourceMapConsumer.prototype,
                        '_generatedMappings',
                        {
                            get: function () {
                                if (!this.__generatedMappings) {
                                    this._parseMappings(
                                        this._mappings,
                                        this.sourceRoot
                                    );
                                }

                                return this.__generatedMappings;
                            },
                        }
                    );

                    SourceMapConsumer.prototype.__originalMappings = null;
                    Object.defineProperty(
                        SourceMapConsumer.prototype,
                        '_originalMappings',
                        {
                            get: function () {
                                if (!this.__originalMappings) {
                                    this._parseMappings(
                                        this._mappings,
                                        this.sourceRoot
                                    );
                                }

                                return this.__originalMappings;
                            },
                        }
                    );

                    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(
                        aStr,
                        index
                    ) {
                        var c = aStr.charAt(index);
                        return c === ';' || c === ',';
                    };

                    /**
                     * Parse the mappings in a string in to a data structure which we can easily
                     * query (the ordered arrays in the `this.__generatedMappings` and
                     * `this.__originalMappings` properties).
                     */
                    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
                        aStr,
                        aSourceRoot
                    ) {
                        throw new Error(
                            'Subclasses must implement _parseMappings'
                        );
                    };

                    SourceMapConsumer.GENERATED_ORDER = 1;
                    SourceMapConsumer.ORIGINAL_ORDER = 2;

                    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
                    SourceMapConsumer.LEAST_UPPER_BOUND = 2;

                    /**
                     * Iterate over each mapping between an original source/line/column and a
                     * generated line/column in this source map.
                     *
                     * @param Function aCallback
                     *        The function that is called with each mapping.
                     * @param Object aContext
                     *        Optional. If specified, this object will be the value of `this` every
                     *        time that `aCallback` is called.
                     * @param aOrder
                     *        Either `SourceMapConsumer.GENERATED_ORDER` or
                     *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
                     *        iterate over the mappings sorted by the generated file's line/column
                     *        order or the original's source/line/column order, respectively. Defaults to
                     *        `SourceMapConsumer.GENERATED_ORDER`.
                     */
                    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
                        aCallback,
                        aContext,
                        aOrder
                    ) {
                        var context = aContext || null;
                        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

                        var mappings;
                        switch (order) {
                            case SourceMapConsumer.GENERATED_ORDER:
                                mappings = this._generatedMappings;
                                break;
                            case SourceMapConsumer.ORIGINAL_ORDER:
                                mappings = this._originalMappings;
                                break;
                            default:
                                throw new Error('Unknown order of iteration.');
                        }

                        var sourceRoot = this.sourceRoot;
                        mappings
                            .map(function (mapping) {
                                var source =
                                    mapping.source === null
                                        ? null
                                        : this._sources.at(mapping.source);
                                if (source != null && sourceRoot != null) {
                                    source = util.join(sourceRoot, source);
                                }
                                return {
                                    source: source,
                                    generatedLine: mapping.generatedLine,
                                    generatedColumn: mapping.generatedColumn,
                                    originalLine: mapping.originalLine,
                                    originalColumn: mapping.originalColumn,
                                    name:
                                        mapping.name === null
                                            ? null
                                            : this._names.at(mapping.name),
                                };
                            }, this)
                            .forEach(aCallback, context);
                    };

                    /**
                     * Returns all generated line and column information for the original source,
                     * line, and column provided. If no column is provided, returns all mappings
                     * corresponding to a either the line we are searching for or the next
                     * closest line that has any mappings. Otherwise, returns all mappings
                     * corresponding to the given line and either the column we are searching for
                     * or the next closest column that has any offsets.
                     *
                     * The only argument is an object with the following properties:
                     *
                     *   - source: The filename of the original source.
                     *   - line: The line number in the original source.
                     *   - column: Optional. the column number in the original source.
                     *
                     * and an array of objects is returned, each with the following properties:
                     *
                     *   - line: The line number in the generated source, or null.
                     *   - column: The column number in the generated source, or null.
                     */
                    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(
                        aArgs
                    ) {
                        var line = util.getArg(aArgs, 'line');

                        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
                        // returns the index of the closest mapping less than the needle. By
                        // setting needle.originalColumn to 0, we thus find the last mapping for
                        // the given line, provided such a mapping exists.
                        var needle = {
                            source: util.getArg(aArgs, 'source'),
                            originalLine: line,
                            originalColumn: util.getArg(aArgs, 'column', 0),
                        };

                        if (this.sourceRoot != null) {
                            needle.source = util.relative(
                                this.sourceRoot,
                                needle.source
                            );
                        }
                        if (!this._sources.has(needle.source)) {
                            return [];
                        }
                        needle.source = this._sources.indexOf(needle.source);

                        var mappings = [];

                        var index = this._findMapping(
                            needle,
                            this._originalMappings,
                            'originalLine',
                            'originalColumn',
                            util.compareByOriginalPositions,
                            binarySearch.LEAST_UPPER_BOUND
                        );
                        if (index >= 0) {
                            var mapping = this._originalMappings[index];

                            if (aArgs.column === undefined) {
                                var originalLine = mapping.originalLine;

                                // Iterate until either we run out of mappings, or we run into
                                // a mapping for a different line than the one we found. Since
                                // mappings are sorted, this is guaranteed to find all mappings for
                                // the line we found.
                                while (
                                    mapping &&
                                    mapping.originalLine === originalLine
                                ) {
                                    mappings.push({
                                        line: util.getArg(
                                            mapping,
                                            'generatedLine',
                                            null
                                        ),
                                        column: util.getArg(
                                            mapping,
                                            'generatedColumn',
                                            null
                                        ),
                                        lastColumn: util.getArg(
                                            mapping,
                                            'lastGeneratedColumn',
                                            null
                                        ),
                                    });

                                    mapping = this._originalMappings[++index];
                                }
                            } else {
                                var originalColumn = mapping.originalColumn;

                                // Iterate until either we run out of mappings, or we run into
                                // a mapping for a different line than the one we were searching for.
                                // Since mappings are sorted, this is guaranteed to find all mappings for
                                // the line we are searching for.
                                while (
                                    mapping &&
                                    mapping.originalLine === line &&
                                    mapping.originalColumn == originalColumn
                                ) {
                                    mappings.push({
                                        line: util.getArg(
                                            mapping,
                                            'generatedLine',
                                            null
                                        ),
                                        column: util.getArg(
                                            mapping,
                                            'generatedColumn',
                                            null
                                        ),
                                        lastColumn: util.getArg(
                                            mapping,
                                            'lastGeneratedColumn',
                                            null
                                        ),
                                    });

                                    mapping = this._originalMappings[++index];
                                }
                            }
                        }

                        return mappings;
                    };

                    exports.SourceMapConsumer = SourceMapConsumer;

                    /**
                     * A BasicSourceMapConsumer instance represents a parsed source map which we can
                     * query for information about the original file positions by giving it a file
                     * position in the generated source.
                     *
                     * The only parameter is the raw source map (either as a JSON string, or
                     * already parsed to an object). According to the spec, source maps have the
                     * following attributes:
                     *
                     *   - version: Which version of the source map spec this map is following.
                     *   - sources: An array of URLs to the original source files.
                     *   - names: An array of identifiers which can be referrenced by individual mappings.
                     *   - sourceRoot: Optional. The URL root from which all sources are relative.
                     *   - sourcesContent: Optional. An array of contents of the original source files.
                     *   - mappings: A string of base64 VLQs which contain the actual mappings.
                     *   - file: Optional. The generated file this source map is associated with.
                     *
                     * Here is an example source map, taken from the source map spec[0]:
                     *
                     *     {
                     *       version : 3,
                     *       file: "out.js",
                     *       sourceRoot : "",
                     *       sources: ["foo.js", "bar.js"],
                     *       names: ["src", "maps", "are", "fun"],
                     *       mappings: "AA,AB;;ABCDE;"
                     *     }
                     *
                     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
                     */
                    function BasicSourceMapConsumer(aSourceMap) {
                        var sourceMap = aSourceMap;
                        if (typeof aSourceMap === 'string') {
                            sourceMap = JSON.parse(
                                aSourceMap.replace(/^\)\]\}'/, '')
                            );
                        }

                        var version = util.getArg(sourceMap, 'version');
                        var sources = util.getArg(sourceMap, 'sources');
                        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
                        // requires the array) to play nice here.
                        var names = util.getArg(sourceMap, 'names', []);
                        var sourceRoot = util.getArg(
                            sourceMap,
                            'sourceRoot',
                            null
                        );
                        var sourcesContent = util.getArg(
                            sourceMap,
                            'sourcesContent',
                            null
                        );
                        var mappings = util.getArg(sourceMap, 'mappings');
                        var file = util.getArg(sourceMap, 'file', null);

                        // Once again, Sass deviates from the spec and supplies the version as a
                        // string rather than a number, so we use loose equality checking here.
                        if (version != this._version) {
                            throw new Error('Unsupported version: ' + version);
                        }

                        sources = sources
                            .map(String)
                            // Some source maps produce relative source paths like "./foo.js" instead of
                            // "foo.js".  Normalize these first so that future comparisons will succeed.
                            // See bugzil.la/1090768.
                            .map(util.normalize)
                            // Always ensure that absolute sources are internally stored relative to
                            // the source root, if the source root is absolute. Not doing this would
                            // be particularly problematic when the source root is a prefix of the
                            // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
                            .map(function (source) {
                                return sourceRoot &&
                                    util.isAbsolute(sourceRoot) &&
                                    util.isAbsolute(source)
                                    ? util.relative(sourceRoot, source)
                                    : source;
                            });

                        // Pass `true` below to allow duplicate names and sources. While source maps
                        // are intended to be compressed and deduplicated, the TypeScript compiler
                        // sometimes generates source maps with duplicates in them. See Github issue
                        // #72 and bugzil.la/889492.
                        this._names = ArraySet.fromArray(
                            names.map(String),
                            true
                        );
                        this._sources = ArraySet.fromArray(sources, true);

                        this.sourceRoot = sourceRoot;
                        this.sourcesContent = sourcesContent;
                        this._mappings = mappings;
                        this.file = file;
                    }

                    BasicSourceMapConsumer.prototype = Object.create(
                        SourceMapConsumer.prototype
                    );
                    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

                    /**
                     * Create a BasicSourceMapConsumer from a SourceMapGenerator.
                     *
                     * @param SourceMapGenerator aSourceMap
                     *        The source map that will be consumed.
                     * @returns BasicSourceMapConsumer
                     */
                    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
                        aSourceMap
                    ) {
                        var smc = Object.create(
                            BasicSourceMapConsumer.prototype
                        );

                        var names = (smc._names = ArraySet.fromArray(
                            aSourceMap._names.toArray(),
                            true
                        ));
                        var sources = (smc._sources = ArraySet.fromArray(
                            aSourceMap._sources.toArray(),
                            true
                        ));
                        smc.sourceRoot = aSourceMap._sourceRoot;
                        smc.sourcesContent = aSourceMap._generateSourcesContent(
                            smc._sources.toArray(),
                            smc.sourceRoot
                        );
                        smc.file = aSourceMap._file;

                        // Because we are modifying the entries (by converting string sources and
                        // names to indices into the sources and names ArraySets), we have to make
                        // a copy of the entry or else bad things happen. Shared mutable state
                        // strikes again! See github issue #191.

                        var generatedMappings = aSourceMap._mappings
                            .toArray()
                            .slice();
                        var destGeneratedMappings = (smc.__generatedMappings = []);
                        var destOriginalMappings = (smc.__originalMappings = []);

                        for (
                            var i = 0, length = generatedMappings.length;
                            i < length;
                            i++
                        ) {
                            var srcMapping = generatedMappings[i];
                            var destMapping = new Mapping();
                            destMapping.generatedLine =
                                srcMapping.generatedLine;
                            destMapping.generatedColumn =
                                srcMapping.generatedColumn;

                            if (srcMapping.source) {
                                destMapping.source = sources.indexOf(
                                    srcMapping.source
                                );
                                destMapping.originalLine =
                                    srcMapping.originalLine;
                                destMapping.originalColumn =
                                    srcMapping.originalColumn;

                                if (srcMapping.name) {
                                    destMapping.name = names.indexOf(
                                        srcMapping.name
                                    );
                                }

                                destOriginalMappings.push(destMapping);
                            }

                            destGeneratedMappings.push(destMapping);
                        }

                        quickSort(
                            smc.__originalMappings,
                            util.compareByOriginalPositions
                        );

                        return smc;
                    };

                    /**
                     * The version of the source mapping spec that we are consuming.
                     */
                    BasicSourceMapConsumer.prototype._version = 3;

                    /**
                     * The list of original sources.
                     */
                    Object.defineProperty(
                        BasicSourceMapConsumer.prototype,
                        'sources',
                        {
                            get: function () {
                                return this._sources
                                    .toArray()
                                    .map(function (s) {
                                        return this.sourceRoot != null
                                            ? util.join(this.sourceRoot, s)
                                            : s;
                                    }, this);
                            },
                        }
                    );

                    /**
                     * Provide the JIT with a nice shape / hidden class.
                     */
                    function Mapping() {
                        this.generatedLine = 0;
                        this.generatedColumn = 0;
                        this.source = null;
                        this.originalLine = null;
                        this.originalColumn = null;
                        this.name = null;
                    }

                    /**
                     * Parse the mappings in a string in to a data structure which we can easily
                     * query (the ordered arrays in the `this.__generatedMappings` and
                     * `this.__originalMappings` properties).
                     */
                    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
                        aStr,
                        aSourceRoot
                    ) {
                        var generatedLine = 1;
                        var previousGeneratedColumn = 0;
                        var previousOriginalLine = 0;
                        var previousOriginalColumn = 0;
                        var previousSource = 0;
                        var previousName = 0;
                        var length = aStr.length;
                        var index = 0;
                        var cachedSegments = {};
                        var temp = {};
                        var originalMappings = [];
                        var generatedMappings = [];
                        var mapping, str, segment, end, value;

                        while (index < length) {
                            if (aStr.charAt(index) === ';') {
                                generatedLine++;
                                index++;
                                previousGeneratedColumn = 0;
                            } else if (aStr.charAt(index) === ',') {
                                index++;
                            } else {
                                mapping = new Mapping();
                                mapping.generatedLine = generatedLine;

                                // Because each offset is encoded relative to the previous one,
                                // many segments often have the same encoding. We can exploit this
                                // fact by caching the parsed variable length fields of each segment,
                                // allowing us to avoid a second parse if we encounter the same
                                // segment again.
                                for (end = index; end < length; end++) {
                                    if (
                                        this._charIsMappingSeparator(aStr, end)
                                    ) {
                                        break;
                                    }
                                }
                                str = aStr.slice(index, end);

                                segment = cachedSegments[str];
                                if (segment) {
                                    index += str.length;
                                } else {
                                    segment = [];
                                    while (index < end) {
                                        base64VLQ.decode(aStr, index, temp);
                                        value = temp.value;
                                        index = temp.rest;
                                        segment.push(value);
                                    }

                                    if (segment.length === 2) {
                                        throw new Error(
                                            'Found a source, but no line and column'
                                        );
                                    }

                                    if (segment.length === 3) {
                                        throw new Error(
                                            'Found a source and line, but no column'
                                        );
                                    }

                                    cachedSegments[str] = segment;
                                }

                                // Generated column.
                                mapping.generatedColumn =
                                    previousGeneratedColumn + segment[0];
                                previousGeneratedColumn =
                                    mapping.generatedColumn;

                                if (segment.length > 1) {
                                    // Original source.
                                    mapping.source =
                                        previousSource + segment[1];
                                    previousSource += segment[1];

                                    // Original line.
                                    mapping.originalLine =
                                        previousOriginalLine + segment[2];
                                    previousOriginalLine = mapping.originalLine;
                                    // Lines are stored 0-based
                                    mapping.originalLine += 1;

                                    // Original column.
                                    mapping.originalColumn =
                                        previousOriginalColumn + segment[3];
                                    previousOriginalColumn =
                                        mapping.originalColumn;

                                    if (segment.length > 4) {
                                        // Original name.
                                        mapping.name =
                                            previousName + segment[4];
                                        previousName += segment[4];
                                    }
                                }

                                generatedMappings.push(mapping);
                                if (typeof mapping.originalLine === 'number') {
                                    originalMappings.push(mapping);
                                }
                            }
                        }

                        quickSort(
                            generatedMappings,
                            util.compareByGeneratedPositionsDeflated
                        );
                        this.__generatedMappings = generatedMappings;

                        quickSort(
                            originalMappings,
                            util.compareByOriginalPositions
                        );
                        this.__originalMappings = originalMappings;
                    };

                    /**
                     * Find the mapping that best matches the hypothetical "needle" mapping that
                     * we are searching for in the given "haystack" of mappings.
                     */
                    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
                        aNeedle,
                        aMappings,
                        aLineName,
                        aColumnName,
                        aComparator,
                        aBias
                    ) {
                        // To return the position we are searching for, we must first find the
                        // mapping for the given position and then return the opposite position it
                        // points to. Because the mappings are sorted, we can use binary search to
                        // find the best mapping.

                        if (aNeedle[aLineName] <= 0) {
                            throw new TypeError(
                                'Line must be greater than or equal to 1, got ' +
                                    aNeedle[aLineName]
                            );
                        }
                        if (aNeedle[aColumnName] < 0) {
                            throw new TypeError(
                                'Column must be greater than or equal to 0, got ' +
                                    aNeedle[aColumnName]
                            );
                        }

                        return binarySearch.search(
                            aNeedle,
                            aMappings,
                            aComparator,
                            aBias
                        );
                    };

                    /**
                     * Compute the last column for each generated mapping. The last column is
                     * inclusive.
                     */
                    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
                        for (
                            var index = 0;
                            index < this._generatedMappings.length;
                            ++index
                        ) {
                            var mapping = this._generatedMappings[index];

                            // Mappings do not contain a field for the last generated columnt. We
                            // can come up with an optimistic estimate, however, by assuming that
                            // mappings are contiguous (i.e. given two consecutive mappings, the
                            // first mapping ends where the second one starts).
                            if (index + 1 < this._generatedMappings.length) {
                                var nextMapping = this._generatedMappings[
                                    index + 1
                                ];

                                if (
                                    mapping.generatedLine ===
                                    nextMapping.generatedLine
                                ) {
                                    mapping.lastGeneratedColumn =
                                        nextMapping.generatedColumn - 1;
                                    continue;
                                }
                            }

                            // The last mapping for each line spans the entire line.
                            mapping.lastGeneratedColumn = Infinity;
                        }
                    };

                    /**
                     * Returns the original source, line, and column information for the generated
                     * source's line and column positions provided. The only argument is an object
                     * with the following properties:
                     *
                     *   - line: The line number in the generated source.
                     *   - column: The column number in the generated source.
                     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
                     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
                     *     closest element that is smaller than or greater than the one we are
                     *     searching for, respectively, if the exact element cannot be found.
                     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
                     *
                     * and an object is returned with the following properties:
                     *
                     *   - source: The original source file, or null.
                     *   - line: The line number in the original source, or null.
                     *   - column: The column number in the original source, or null.
                     *   - name: The original identifier, or null.
                     */
                    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(
                        aArgs
                    ) {
                        var needle = {
                            generatedLine: util.getArg(aArgs, 'line'),
                            generatedColumn: util.getArg(aArgs, 'column'),
                        };

                        var index = this._findMapping(
                            needle,
                            this._generatedMappings,
                            'generatedLine',
                            'generatedColumn',
                            util.compareByGeneratedPositionsDeflated,
                            util.getArg(
                                aArgs,
                                'bias',
                                SourceMapConsumer.GREATEST_LOWER_BOUND
                            )
                        );

                        if (index >= 0) {
                            var mapping = this._generatedMappings[index];

                            if (
                                mapping.generatedLine === needle.generatedLine
                            ) {
                                var source = util.getArg(
                                    mapping,
                                    'source',
                                    null
                                );
                                if (source !== null) {
                                    source = this._sources.at(source);
                                    if (this.sourceRoot != null) {
                                        source = util.join(
                                            this.sourceRoot,
                                            source
                                        );
                                    }
                                }
                                var name = util.getArg(mapping, 'name', null);
                                if (name !== null) {
                                    name = this._names.at(name);
                                }
                                return {
                                    source: source,
                                    line: util.getArg(
                                        mapping,
                                        'originalLine',
                                        null
                                    ),
                                    column: util.getArg(
                                        mapping,
                                        'originalColumn',
                                        null
                                    ),
                                    name: name,
                                };
                            }
                        }

                        return {
                            source: null,
                            line: null,
                            column: null,
                            name: null,
                        };
                    };

                    /**
                     * Return true if we have the source content for every source in the source
                     * map, false otherwise.
                     */
                    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
                        if (!this.sourcesContent) {
                            return false;
                        }
                        return (
                            this.sourcesContent.length >=
                                this._sources.size() &&
                            !this.sourcesContent.some(function (sc) {
                                return sc == null;
                            })
                        );
                    };

                    /**
                     * Returns the original source content. The only argument is the url of the
                     * original source file. Returns null if no original source content is
                     * available.
                     */
                    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
                        aSource,
                        nullOnMissing
                    ) {
                        if (!this.sourcesContent) {
                            return null;
                        }

                        if (this.sourceRoot != null) {
                            aSource = util.relative(this.sourceRoot, aSource);
                        }

                        if (this._sources.has(aSource)) {
                            return this.sourcesContent[
                                this._sources.indexOf(aSource)
                            ];
                        }

                        var url;
                        if (
                            this.sourceRoot != null &&
                            (url = util.urlParse(this.sourceRoot))
                        ) {
                            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
                            // many users. We can help them out when they expect file:// URIs to
                            // behave like it would if they were running a local HTTP server. See
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
                            var fileUriAbsPath = aSource.replace(
                                /^file:\/\//,
                                ''
                            );
                            if (
                                url.scheme == 'file' &&
                                this._sources.has(fileUriAbsPath)
                            ) {
                                return this.sourcesContent[
                                    this._sources.indexOf(fileUriAbsPath)
                                ];
                            }

                            if (
                                (!url.path || url.path == '/') &&
                                this._sources.has('/' + aSource)
                            ) {
                                return this.sourcesContent[
                                    this._sources.indexOf('/' + aSource)
                                ];
                            }
                        }

                        // This function is used recursively from
                        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
                        // don't want to throw if we can't find the source - we just want to
                        // return null, so we provide a flag to exit gracefully.
                        if (nullOnMissing) {
                            return null;
                        } else {
                            throw new Error(
                                '"' + aSource + '" is not in the SourceMap.'
                            );
                        }
                    };

                    /**
                     * Returns the generated line and column information for the original source,
                     * line, and column positions provided. The only argument is an object with
                     * the following properties:
                     *
                     *   - source: The filename of the original source.
                     *   - line: The line number in the original source.
                     *   - column: The column number in the original source.
                     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
                     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
                     *     closest element that is smaller than or greater than the one we are
                     *     searching for, respectively, if the exact element cannot be found.
                     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
                     *
                     * and an object is returned with the following properties:
                     *
                     *   - line: The line number in the generated source, or null.
                     *   - column: The column number in the generated source, or null.
                     */
                    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(
                        aArgs
                    ) {
                        var source = util.getArg(aArgs, 'source');
                        if (this.sourceRoot != null) {
                            source = util.relative(this.sourceRoot, source);
                        }
                        if (!this._sources.has(source)) {
                            return {
                                line: null,
                                column: null,
                                lastColumn: null,
                            };
                        }
                        source = this._sources.indexOf(source);

                        var needle = {
                            source: source,
                            originalLine: util.getArg(aArgs, 'line'),
                            originalColumn: util.getArg(aArgs, 'column'),
                        };

                        var index = this._findMapping(
                            needle,
                            this._originalMappings,
                            'originalLine',
                            'originalColumn',
                            util.compareByOriginalPositions,
                            util.getArg(
                                aArgs,
                                'bias',
                                SourceMapConsumer.GREATEST_LOWER_BOUND
                            )
                        );

                        if (index >= 0) {
                            var mapping = this._originalMappings[index];

                            if (mapping.source === needle.source) {
                                return {
                                    line: util.getArg(
                                        mapping,
                                        'generatedLine',
                                        null
                                    ),
                                    column: util.getArg(
                                        mapping,
                                        'generatedColumn',
                                        null
                                    ),
                                    lastColumn: util.getArg(
                                        mapping,
                                        'lastGeneratedColumn',
                                        null
                                    ),
                                };
                            }
                        }

                        return {
                            line: null,
                            column: null,
                            lastColumn: null,
                        };
                    };

                    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

                    /**
                     * An IndexedSourceMapConsumer instance represents a parsed source map which
                     * we can query for information. It differs from BasicSourceMapConsumer in
                     * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
                     * input.
                     *
                     * The only parameter is a raw source map (either as a JSON string, or already
                     * parsed to an object). According to the spec for indexed source maps, they
                     * have the following attributes:
                     *
                     *   - version: Which version of the source map spec this map is following.
                     *   - file: Optional. The generated file this source map is associated with.
                     *   - sections: A list of section definitions.
                     *
                     * Each value under the "sections" field has two fields:
                     *   - offset: The offset into the original specified at which this section
                     *       begins to apply, defined as an object with a "line" and "column"
                     *       field.
                     *   - map: A source map definition. This source map could also be indexed,
                     *       but doesn't have to be.
                     *
                     * Instead of the "map" field, it's also possible to have a "url" field
                     * specifying a URL to retrieve a source map from, but that's currently
                     * unsupported.
                     *
                     * Here's an example source map, taken from the source map spec[0], but
                     * modified to omit a section which uses the "url" field.
                     *
                     *  {
                     *    version : 3,
                     *    file: "app.js",
                     *    sections: [{
                     *      offset: {line:100, column:10},
                     *      map: {
                     *        version : 3,
                     *        file: "section.js",
                     *        sources: ["foo.js", "bar.js"],
                     *        names: ["src", "maps", "are", "fun"],
                     *        mappings: "AAAA,E;;ABCDE;"
                     *      }
                     *    }],
                     *  }
                     *
                     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
                     */
                    function IndexedSourceMapConsumer(aSourceMap) {
                        var sourceMap = aSourceMap;
                        if (typeof aSourceMap === 'string') {
                            sourceMap = JSON.parse(
                                aSourceMap.replace(/^\)\]\}'/, '')
                            );
                        }

                        var version = util.getArg(sourceMap, 'version');
                        var sections = util.getArg(sourceMap, 'sections');

                        if (version != this._version) {
                            throw new Error('Unsupported version: ' + version);
                        }

                        this._sources = new ArraySet();
                        this._names = new ArraySet();

                        var lastOffset = {
                            line: -1,
                            column: 0,
                        };
                        this._sections = sections.map(function (s) {
                            if (s.url) {
                                // The url field will require support for asynchronicity.
                                // See https://github.com/mozilla/source-map/issues/16
                                throw new Error(
                                    'Support for url field in sections not implemented.'
                                );
                            }
                            var offset = util.getArg(s, 'offset');
                            var offsetLine = util.getArg(offset, 'line');
                            var offsetColumn = util.getArg(offset, 'column');

                            if (
                                offsetLine < lastOffset.line ||
                                (offsetLine === lastOffset.line &&
                                    offsetColumn < lastOffset.column)
                            ) {
                                throw new Error(
                                    'Section offsets must be ordered and non-overlapping.'
                                );
                            }
                            lastOffset = offset;

                            return {
                                generatedOffset: {
                                    // The offset fields are 0-based, but we use 1-based indices when
                                    // encoding/decoding from VLQ.
                                    generatedLine: offsetLine + 1,
                                    generatedColumn: offsetColumn + 1,
                                },
                                consumer: new SourceMapConsumer(
                                    util.getArg(s, 'map')
                                ),
                            };
                        });
                    }

                    IndexedSourceMapConsumer.prototype = Object.create(
                        SourceMapConsumer.prototype
                    );
                    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

                    /**
                     * The version of the source mapping spec that we are consuming.
                     */
                    IndexedSourceMapConsumer.prototype._version = 3;

                    /**
                     * The list of original sources.
                     */
                    Object.defineProperty(
                        IndexedSourceMapConsumer.prototype,
                        'sources',
                        {
                            get: function () {
                                var sources = [];
                                for (
                                    var i = 0;
                                    i < this._sections.length;
                                    i++
                                ) {
                                    for (
                                        var j = 0;
                                        j <
                                        this._sections[i].consumer.sources
                                            .length;
                                        j++
                                    ) {
                                        sources.push(
                                            this._sections[i].consumer.sources[
                                                j
                                            ]
                                        );
                                    }
                                }
                                return sources;
                            },
                        }
                    );

                    /**
                     * Returns the original source, line, and column information for the generated
                     * source's line and column positions provided. The only argument is an object
                     * with the following properties:
                     *
                     *   - line: The line number in the generated source.
                     *   - column: The column number in the generated source.
                     *
                     * and an object is returned with the following properties:
                     *
                     *   - source: The original source file, or null.
                     *   - line: The line number in the original source, or null.
                     *   - column: The column number in the original source, or null.
                     *   - name: The original identifier, or null.
                     */
                    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(
                        aArgs
                    ) {
                        var needle = {
                            generatedLine: util.getArg(aArgs, 'line'),
                            generatedColumn: util.getArg(aArgs, 'column'),
                        };

                        // Find the section containing the generated position we're trying to map
                        // to an original position.
                        var sectionIndex = binarySearch.search(
                            needle,
                            this._sections,
                            function (needle, section) {
                                var cmp =
                                    needle.generatedLine -
                                    section.generatedOffset.generatedLine;
                                if (cmp) {
                                    return cmp;
                                }

                                return (
                                    needle.generatedColumn -
                                    section.generatedOffset.generatedColumn
                                );
                            }
                        );
                        var section = this._sections[sectionIndex];

                        if (!section) {
                            return {
                                source: null,
                                line: null,
                                column: null,
                                name: null,
                            };
                        }

                        return section.consumer.originalPositionFor({
                            line:
                                needle.generatedLine -
                                (section.generatedOffset.generatedLine - 1),
                            column:
                                needle.generatedColumn -
                                (section.generatedOffset.generatedLine ===
                                needle.generatedLine
                                    ? section.generatedOffset.generatedColumn -
                                      1
                                    : 0),
                            bias: aArgs.bias,
                        });
                    };

                    /**
                     * Return true if we have the source content for every source in the source
                     * map, false otherwise.
                     */
                    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
                        return this._sections.every(function (s) {
                            return s.consumer.hasContentsOfAllSources();
                        });
                    };

                    /**
                     * Returns the original source content. The only argument is the url of the
                     * original source file. Returns null if no original source content is
                     * available.
                     */
                    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(
                        aSource,
                        nullOnMissing
                    ) {
                        for (var i = 0; i < this._sections.length; i++) {
                            var section = this._sections[i];

                            var content = section.consumer.sourceContentFor(
                                aSource,
                                true
                            );
                            if (content) {
                                return content;
                            }
                        }
                        if (nullOnMissing) {
                            return null;
                        } else {
                            throw new Error(
                                '"' + aSource + '" is not in the SourceMap.'
                            );
                        }
                    };

                    /**
                     * Returns the generated line and column information for the original source,
                     * line, and column positions provided. The only argument is an object with
                     * the following properties:
                     *
                     *   - source: The filename of the original source.
                     *   - line: The line number in the original source.
                     *   - column: The column number in the original source.
                     *
                     * and an object is returned with the following properties:
                     *
                     *   - line: The line number in the generated source, or null.
                     *   - column: The column number in the generated source, or null.
                     */
                    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(
                        aArgs
                    ) {
                        for (var i = 0; i < this._sections.length; i++) {
                            var section = this._sections[i];

                            // Only consider this section if the requested source is in the list of
                            // sources of the consumer.
                            if (
                                section.consumer.sources.indexOf(
                                    util.getArg(aArgs, 'source')
                                ) === -1
                            ) {
                                continue;
                            }
                            var generatedPosition = section.consumer.generatedPositionFor(
                                aArgs
                            );
                            if (generatedPosition) {
                                var ret = {
                                    line:
                                        generatedPosition.line +
                                        (section.generatedOffset.generatedLine -
                                            1),
                                    column:
                                        generatedPosition.column +
                                        (section.generatedOffset
                                            .generatedLine ===
                                        generatedPosition.line
                                            ? section.generatedOffset
                                                  .generatedColumn - 1
                                            : 0),
                                };
                                return ret;
                            }
                        }

                        return {
                            line: null,
                            column: null,
                        };
                    };

                    /**
                     * Parse the mappings in a string in to a data structure which we can easily
                     * query (the ordered arrays in the `this.__generatedMappings` and
                     * `this.__originalMappings` properties).
                     */
                    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(
                        aStr,
                        aSourceRoot
                    ) {
                        this.__generatedMappings = [];
                        this.__originalMappings = [];
                        for (var i = 0; i < this._sections.length; i++) {
                            var section = this._sections[i];
                            var sectionMappings =
                                section.consumer._generatedMappings;
                            for (var j = 0; j < sectionMappings.length; j++) {
                                var mapping = sectionMappings[j];

                                var source = section.consumer._sources.at(
                                    mapping.source
                                );
                                if (section.consumer.sourceRoot !== null) {
                                    source = util.join(
                                        section.consumer.sourceRoot,
                                        source
                                    );
                                }
                                this._sources.add(source);
                                source = this._sources.indexOf(source);

                                var name = section.consumer._names.at(
                                    mapping.name
                                );
                                this._names.add(name);
                                name = this._names.indexOf(name);

                                // The mappings coming from the consumer for the section have
                                // generated positions relative to the start of the section, so we
                                // need to offset them to be relative to the start of the concatenated
                                // generated file.
                                var adjustedMapping = {
                                    source: source,
                                    generatedLine:
                                        mapping.generatedLine +
                                        (section.generatedOffset.generatedLine -
                                            1),
                                    generatedColumn:
                                        mapping.generatedColumn +
                                        (section.generatedOffset
                                            .generatedLine ===
                                        mapping.generatedLine
                                            ? section.generatedOffset
                                                  .generatedColumn - 1
                                            : 0),
                                    originalLine: mapping.originalLine,
                                    originalColumn: mapping.originalColumn,
                                    name: name,
                                };

                                this.__generatedMappings.push(adjustedMapping);
                                if (
                                    typeof adjustedMapping.originalLine ===
                                    'number'
                                ) {
                                    this.__originalMappings.push(
                                        adjustedMapping
                                    );
                                }
                            }
                        }

                        quickSort(
                            this.__generatedMappings,
                            util.compareByGeneratedPositionsDeflated
                        );
                        quickSort(
                            this.__originalMappings,
                            util.compareByOriginalPositions
                        );
                    };

                    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-generator.js':
                /*!*****************************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-generator.js ***!
  \*****************************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var base64VLQ = __webpack_require__(
                        /*! ./base64-vlq */ './node_modules/stacktrace-gps/node_modules/source-map/lib/base64-vlq.js'
                    );
                    var util = __webpack_require__(
                        /*! ./util */ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js'
                    );
                    var ArraySet = __webpack_require__(
                        /*! ./array-set */ './node_modules/stacktrace-gps/node_modules/source-map/lib/array-set.js'
                    ).ArraySet;
                    var MappingList = __webpack_require__(
                        /*! ./mapping-list */ './node_modules/stacktrace-gps/node_modules/source-map/lib/mapping-list.js'
                    ).MappingList;

                    /**
                     * An instance of the SourceMapGenerator represents a source map which is
                     * being built incrementally. You may pass an object with the following
                     * properties:
                     *
                     *   - file: The filename of the generated source.
                     *   - sourceRoot: A root for all relative URLs in this source map.
                     */
                    function SourceMapGenerator(aArgs) {
                        if (!aArgs) {
                            aArgs = {};
                        }
                        this._file = util.getArg(aArgs, 'file', null);
                        this._sourceRoot = util.getArg(
                            aArgs,
                            'sourceRoot',
                            null
                        );
                        this._skipValidation = util.getArg(
                            aArgs,
                            'skipValidation',
                            false
                        );
                        this._sources = new ArraySet();
                        this._names = new ArraySet();
                        this._mappings = new MappingList();
                        this._sourcesContents = null;
                    }

                    SourceMapGenerator.prototype._version = 3;

                    /**
                     * Creates a new SourceMapGenerator based on a SourceMapConsumer
                     *
                     * @param aSourceMapConsumer The SourceMap.
                     */
                    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
                        aSourceMapConsumer
                    ) {
                        var sourceRoot = aSourceMapConsumer.sourceRoot;
                        var generator = new SourceMapGenerator({
                            file: aSourceMapConsumer.file,
                            sourceRoot: sourceRoot,
                        });
                        aSourceMapConsumer.eachMapping(function (mapping) {
                            var newMapping = {
                                generated: {
                                    line: mapping.generatedLine,
                                    column: mapping.generatedColumn,
                                },
                            };

                            if (mapping.source != null) {
                                newMapping.source = mapping.source;
                                if (sourceRoot != null) {
                                    newMapping.source = util.relative(
                                        sourceRoot,
                                        newMapping.source
                                    );
                                }

                                newMapping.original = {
                                    line: mapping.originalLine,
                                    column: mapping.originalColumn,
                                };

                                if (mapping.name != null) {
                                    newMapping.name = mapping.name;
                                }
                            }

                            generator.addMapping(newMapping);
                        });
                        aSourceMapConsumer.sources.forEach(function (
                            sourceFile
                        ) {
                            var content = aSourceMapConsumer.sourceContentFor(
                                sourceFile
                            );
                            if (content != null) {
                                generator.setSourceContent(sourceFile, content);
                            }
                        });
                        return generator;
                    };

                    /**
                     * Add a single mapping from original source line and column to the generated
                     * source's line and column for this source map being created. The mapping
                     * object should have the following properties:
                     *
                     *   - generated: An object with the generated line and column positions.
                     *   - original: An object with the original line and column positions.
                     *   - source: The original source file (relative to the sourceRoot).
                     *   - name: An optional original token name for this mapping.
                     */
                    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(
                        aArgs
                    ) {
                        var generated = util.getArg(aArgs, 'generated');
                        var original = util.getArg(aArgs, 'original', null);
                        var source = util.getArg(aArgs, 'source', null);
                        var name = util.getArg(aArgs, 'name', null);

                        if (!this._skipValidation) {
                            this._validateMapping(
                                generated,
                                original,
                                source,
                                name
                            );
                        }

                        if (source != null) {
                            source = String(source);
                            if (!this._sources.has(source)) {
                                this._sources.add(source);
                            }
                        }

                        if (name != null) {
                            name = String(name);
                            if (!this._names.has(name)) {
                                this._names.add(name);
                            }
                        }

                        this._mappings.add({
                            generatedLine: generated.line,
                            generatedColumn: generated.column,
                            originalLine: original != null && original.line,
                            originalColumn: original != null && original.column,
                            source: source,
                            name: name,
                        });
                    };

                    /**
                     * Set the source content for a source file.
                     */
                    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(
                        aSourceFile,
                        aSourceContent
                    ) {
                        var source = aSourceFile;
                        if (this._sourceRoot != null) {
                            source = util.relative(this._sourceRoot, source);
                        }

                        if (aSourceContent != null) {
                            // Add the source content to the _sourcesContents map.
                            // Create a new _sourcesContents map if the property is null.
                            if (!this._sourcesContents) {
                                this._sourcesContents = Object.create(null);
                            }
                            this._sourcesContents[
                                util.toSetString(source)
                            ] = aSourceContent;
                        } else if (this._sourcesContents) {
                            // Remove the source file from the _sourcesContents map.
                            // If the _sourcesContents map is empty, set the property to null.
                            delete this._sourcesContents[
                                util.toSetString(source)
                            ];
                            if (
                                Object.keys(this._sourcesContents).length === 0
                            ) {
                                this._sourcesContents = null;
                            }
                        }
                    };

                    /**
                     * Applies the mappings of a sub-source-map for a specific source file to the
                     * source map being generated. Each mapping to the supplied source file is
                     * rewritten using the supplied source map. Note: The resolution for the
                     * resulting mappings is the minimium of this map and the supplied map.
                     *
                     * @param aSourceMapConsumer The source map to be applied.
                     * @param aSourceFile Optional. The filename of the source file.
                     *        If omitted, SourceMapConsumer's file property will be used.
                     * @param aSourceMapPath Optional. The dirname of the path to the source map
                     *        to be applied. If relative, it is relative to the SourceMapConsumer.
                     *        This parameter is needed when the two source maps aren't in the same
                     *        directory, and the source map to be applied contains relative source
                     *        paths. If so, those relative source paths need to be rewritten
                     *        relative to the SourceMapGenerator.
                     */
                    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
                        aSourceMapConsumer,
                        aSourceFile,
                        aSourceMapPath
                    ) {
                        var sourceFile = aSourceFile;
                        // If aSourceFile is omitted, we will use the file property of the SourceMap
                        if (aSourceFile == null) {
                            if (aSourceMapConsumer.file == null) {
                                throw new Error(
                                    'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                                        'or the source map\'s "file" property. Both were omitted.'
                                );
                            }
                            sourceFile = aSourceMapConsumer.file;
                        }
                        var sourceRoot = this._sourceRoot;
                        // Make "sourceFile" relative if an absolute Url is passed.
                        if (sourceRoot != null) {
                            sourceFile = util.relative(sourceRoot, sourceFile);
                        }
                        // Applying the SourceMap can add and remove items from the sources and
                        // the names array.
                        var newSources = new ArraySet();
                        var newNames = new ArraySet();

                        // Find mappings for the "sourceFile"
                        this._mappings.unsortedForEach(function (mapping) {
                            if (
                                mapping.source === sourceFile &&
                                mapping.originalLine != null
                            ) {
                                // Check if it can be mapped by the source map, then update the mapping.
                                var original = aSourceMapConsumer.originalPositionFor(
                                    {
                                        line: mapping.originalLine,
                                        column: mapping.originalColumn,
                                    }
                                );
                                if (original.source != null) {
                                    // Copy mapping
                                    mapping.source = original.source;
                                    if (aSourceMapPath != null) {
                                        mapping.source = util.join(
                                            aSourceMapPath,
                                            mapping.source
                                        );
                                    }
                                    if (sourceRoot != null) {
                                        mapping.source = util.relative(
                                            sourceRoot,
                                            mapping.source
                                        );
                                    }
                                    mapping.originalLine = original.line;
                                    mapping.originalColumn = original.column;
                                    if (original.name != null) {
                                        mapping.name = original.name;
                                    }
                                }
                            }

                            var source = mapping.source;
                            if (source != null && !newSources.has(source)) {
                                newSources.add(source);
                            }

                            var name = mapping.name;
                            if (name != null && !newNames.has(name)) {
                                newNames.add(name);
                            }
                        }, this);
                        this._sources = newSources;
                        this._names = newNames;

                        // Copy sourcesContents of applied map.
                        aSourceMapConsumer.sources.forEach(function (
                            sourceFile
                        ) {
                            var content = aSourceMapConsumer.sourceContentFor(
                                sourceFile
                            );
                            if (content != null) {
                                if (aSourceMapPath != null) {
                                    sourceFile = util.join(
                                        aSourceMapPath,
                                        sourceFile
                                    );
                                }
                                if (sourceRoot != null) {
                                    sourceFile = util.relative(
                                        sourceRoot,
                                        sourceFile
                                    );
                                }
                                this.setSourceContent(sourceFile, content);
                            }
                        },
                        this);
                    };

                    /**
                     * A mapping can have one of the three levels of data:
                     *
                     *   1. Just the generated position.
                     *   2. The Generated position, original position, and original source.
                     *   3. Generated and original position, original source, as well as a name
                     *      token.
                     *
                     * To maintain consistency, we validate that any new mapping being added falls
                     * in to one of these categories.
                     */
                    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
                        aGenerated,
                        aOriginal,
                        aSource,
                        aName
                    ) {
                        if (
                            aGenerated &&
                            'line' in aGenerated &&
                            'column' in aGenerated &&
                            aGenerated.line > 0 &&
                            aGenerated.column >= 0 &&
                            !aOriginal &&
                            !aSource &&
                            !aName
                        ) {
                            // Case 1.
                            return;
                        } else if (
                            aGenerated &&
                            'line' in aGenerated &&
                            'column' in aGenerated &&
                            aOriginal &&
                            'line' in aOriginal &&
                            'column' in aOriginal &&
                            aGenerated.line > 0 &&
                            aGenerated.column >= 0 &&
                            aOriginal.line > 0 &&
                            aOriginal.column >= 0 &&
                            aSource
                        ) {
                            // Cases 2 and 3.
                            return;
                        } else {
                            throw new Error(
                                'Invalid mapping: ' +
                                    JSON.stringify({
                                        generated: aGenerated,
                                        source: aSource,
                                        original: aOriginal,
                                        name: aName,
                                    })
                            );
                        }
                    };

                    /**
                     * Serialize the accumulated mappings in to the stream of base 64 VLQs
                     * specified by the source map format.
                     */
                    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
                        var previousGeneratedColumn = 0;
                        var previousGeneratedLine = 1;
                        var previousOriginalColumn = 0;
                        var previousOriginalLine = 0;
                        var previousName = 0;
                        var previousSource = 0;
                        var result = '';
                        var next;
                        var mapping;
                        var nameIdx;
                        var sourceIdx;

                        var mappings = this._mappings.toArray();
                        for (var i = 0, len = mappings.length; i < len; i++) {
                            mapping = mappings[i];
                            next = '';

                            if (
                                mapping.generatedLine !== previousGeneratedLine
                            ) {
                                previousGeneratedColumn = 0;
                                while (
                                    mapping.generatedLine !==
                                    previousGeneratedLine
                                ) {
                                    next += ';';
                                    previousGeneratedLine++;
                                }
                            } else {
                                if (i > 0) {
                                    if (
                                        !util.compareByGeneratedPositionsInflated(
                                            mapping,
                                            mappings[i - 1]
                                        )
                                    ) {
                                        continue;
                                    }
                                    next += ',';
                                }
                            }

                            next += base64VLQ.encode(
                                mapping.generatedColumn -
                                    previousGeneratedColumn
                            );
                            previousGeneratedColumn = mapping.generatedColumn;

                            if (mapping.source != null) {
                                sourceIdx = this._sources.indexOf(
                                    mapping.source
                                );
                                next += base64VLQ.encode(
                                    sourceIdx - previousSource
                                );
                                previousSource = sourceIdx;

                                // lines are stored 0-based in SourceMap spec version 3
                                next += base64VLQ.encode(
                                    mapping.originalLine -
                                        1 -
                                        previousOriginalLine
                                );
                                previousOriginalLine = mapping.originalLine - 1;

                                next += base64VLQ.encode(
                                    mapping.originalColumn -
                                        previousOriginalColumn
                                );
                                previousOriginalColumn = mapping.originalColumn;

                                if (mapping.name != null) {
                                    nameIdx = this._names.indexOf(mapping.name);
                                    next += base64VLQ.encode(
                                        nameIdx - previousName
                                    );
                                    previousName = nameIdx;
                                }
                            }

                            result += next;
                        }

                        return result;
                    };

                    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(
                        aSources,
                        aSourceRoot
                    ) {
                        return aSources.map(function (source) {
                            if (!this._sourcesContents) {
                                return null;
                            }
                            if (aSourceRoot != null) {
                                source = util.relative(aSourceRoot, source);
                            }
                            var key = util.toSetString(source);
                            return Object.prototype.hasOwnProperty.call(
                                this._sourcesContents,
                                key
                            )
                                ? this._sourcesContents[key]
                                : null;
                        }, this);
                    };

                    /**
                     * Externalize the source map.
                     */
                    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
                        var map = {
                            version: this._version,
                            sources: this._sources.toArray(),
                            names: this._names.toArray(),
                            mappings: this._serializeMappings(),
                        };
                        if (this._file != null) {
                            map.file = this._file;
                        }
                        if (this._sourceRoot != null) {
                            map.sourceRoot = this._sourceRoot;
                        }
                        if (this._sourcesContents) {
                            map.sourcesContent = this._generateSourcesContent(
                                map.sources,
                                map.sourceRoot
                            );
                        }

                        return map;
                    };

                    /**
                     * Render the source map being generated to a string.
                     */
                    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
                        return JSON.stringify(this.toJSON());
                    };

                    exports.SourceMapGenerator = SourceMapGenerator;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js':
                /*!********************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js ***!
  \********************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    var SourceMapGenerator = __webpack_require__(
                        /*! ./source-map-generator */ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-generator.js'
                    ).SourceMapGenerator;
                    var util = __webpack_require__(
                        /*! ./util */ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js'
                    );

                    // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
                    // operating systems these days (capturing the result).
                    var REGEX_NEWLINE = /(\r?\n)/;

                    // Newline character code for charCodeAt() comparisons
                    var NEWLINE_CODE = 10;

                    // Private symbol for identifying `SourceNode`s when multiple versions of
                    // the source-map library are loaded. This MUST NOT CHANGE across
                    // versions!
                    var isSourceNode = '$$$isSourceNode$$$';

                    /**
                     * SourceNodes provide a way to abstract over interpolating/concatenating
                     * snippets of generated JavaScript source code while maintaining the line and
                     * column information associated with the original source code.
                     *
                     * @param aLine The original line number.
                     * @param aColumn The original column number.
                     * @param aSource The original source's filename.
                     * @param aChunks Optional. An array of strings which are snippets of
                     *        generated JS, or other SourceNodes.
                     * @param aName The original identifier.
                     */
                    function SourceNode(
                        aLine,
                        aColumn,
                        aSource,
                        aChunks,
                        aName
                    ) {
                        this.children = [];
                        this.sourceContents = {};
                        this.line = aLine == null ? null : aLine;
                        this.column = aColumn == null ? null : aColumn;
                        this.source = aSource == null ? null : aSource;
                        this.name = aName == null ? null : aName;
                        this[isSourceNode] = true;
                        if (aChunks != null) this.add(aChunks);
                    }

                    /**
                     * Creates a SourceNode from generated code and a SourceMapConsumer.
                     *
                     * @param aGeneratedCode The generated code
                     * @param aSourceMapConsumer The SourceMap for the generated code
                     * @param aRelativePath Optional. The path that relative sources in the
                     *        SourceMapConsumer should be relative to.
                     */
                    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
                        aGeneratedCode,
                        aSourceMapConsumer,
                        aRelativePath
                    ) {
                        // The SourceNode we want to fill with the generated code
                        // and the SourceMap
                        var node = new SourceNode();

                        // All even indices of this array are one line of the generated code,
                        // while all odd indices are the newlines between two adjacent lines
                        // (since `REGEX_NEWLINE` captures its match).
                        // Processed fragments are removed from this array, by calling `shiftNextLine`.
                        var remainingLines = aGeneratedCode.split(
                            REGEX_NEWLINE
                        );
                        var shiftNextLine = function () {
                            var lineContents = remainingLines.shift();
                            // The last line of a file might not have a newline.
                            var newLine = remainingLines.shift() || '';
                            return lineContents + newLine;
                        };

                        // We need to remember the position of "remainingLines"
                        var lastGeneratedLine = 1,
                            lastGeneratedColumn = 0;

                        // The generate SourceNodes we need a code range.
                        // To extract it current and last mapping is used.
                        // Here we store the last mapping.
                        var lastMapping = null;

                        aSourceMapConsumer.eachMapping(function (mapping) {
                            if (lastMapping !== null) {
                                // We add the code from "lastMapping" to "mapping":
                                // First check if there is a new line in between.
                                if (lastGeneratedLine < mapping.generatedLine) {
                                    // Associate first line with "lastMapping"
                                    addMappingWithCode(
                                        lastMapping,
                                        shiftNextLine()
                                    );
                                    lastGeneratedLine++;
                                    lastGeneratedColumn = 0;
                                    // The remaining code is added without mapping
                                } else {
                                    // There is no new line in between.
                                    // Associate the code between "lastGeneratedColumn" and
                                    // "mapping.generatedColumn" with "lastMapping"
                                    var nextLine = remainingLines[0];
                                    var code = nextLine.substr(
                                        0,
                                        mapping.generatedColumn -
                                            lastGeneratedColumn
                                    );
                                    remainingLines[0] = nextLine.substr(
                                        mapping.generatedColumn -
                                            lastGeneratedColumn
                                    );
                                    lastGeneratedColumn =
                                        mapping.generatedColumn;
                                    addMappingWithCode(lastMapping, code);
                                    // No more remaining code, continue
                                    lastMapping = mapping;
                                    return;
                                }
                            }
                            // We add the generated code until the first mapping
                            // to the SourceNode without any mapping.
                            // Each line is added as separate string.
                            while (lastGeneratedLine < mapping.generatedLine) {
                                node.add(shiftNextLine());
                                lastGeneratedLine++;
                            }
                            if (lastGeneratedColumn < mapping.generatedColumn) {
                                var nextLine = remainingLines[0];
                                node.add(
                                    nextLine.substr(0, mapping.generatedColumn)
                                );
                                remainingLines[0] = nextLine.substr(
                                    mapping.generatedColumn
                                );
                                lastGeneratedColumn = mapping.generatedColumn;
                            }
                            lastMapping = mapping;
                        }, this);
                        // We have processed all mappings.
                        if (remainingLines.length > 0) {
                            if (lastMapping) {
                                // Associate the remaining code in the current line with "lastMapping"
                                addMappingWithCode(
                                    lastMapping,
                                    shiftNextLine()
                                );
                            }
                            // and add the remaining lines without any mapping
                            node.add(remainingLines.join(''));
                        }

                        // Copy sourcesContent into SourceNode
                        aSourceMapConsumer.sources.forEach(function (
                            sourceFile
                        ) {
                            var content = aSourceMapConsumer.sourceContentFor(
                                sourceFile
                            );
                            if (content != null) {
                                if (aRelativePath != null) {
                                    sourceFile = util.join(
                                        aRelativePath,
                                        sourceFile
                                    );
                                }
                                node.setSourceContent(sourceFile, content);
                            }
                        });

                        return node;

                        function addMappingWithCode(mapping, code) {
                            if (
                                mapping === null ||
                                mapping.source === undefined
                            ) {
                                node.add(code);
                            } else {
                                var source = aRelativePath
                                    ? util.join(aRelativePath, mapping.source)
                                    : mapping.source;
                                node.add(
                                    new SourceNode(
                                        mapping.originalLine,
                                        mapping.originalColumn,
                                        source,
                                        code,
                                        mapping.name
                                    )
                                );
                            }
                        }
                    };

                    /**
                     * Add a chunk of generated JS to this source node.
                     *
                     * @param aChunk A string snippet of generated JS code, another instance of
                     *        SourceNode, or an array where each member is one of those things.
                     */
                    SourceNode.prototype.add = function SourceNode_add(aChunk) {
                        if (Array.isArray(aChunk)) {
                            aChunk.forEach(function (chunk) {
                                this.add(chunk);
                            }, this);
                        } else if (
                            aChunk[isSourceNode] ||
                            typeof aChunk === 'string'
                        ) {
                            if (aChunk) {
                                this.children.push(aChunk);
                            }
                        } else {
                            throw new TypeError(
                                'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
                                    aChunk
                            );
                        }
                        return this;
                    };

                    /**
                     * Add a chunk of generated JS to the beginning of this source node.
                     *
                     * @param aChunk A string snippet of generated JS code, another instance of
                     *        SourceNode, or an array where each member is one of those things.
                     */
                    SourceNode.prototype.prepend = function SourceNode_prepend(
                        aChunk
                    ) {
                        if (Array.isArray(aChunk)) {
                            for (var i = aChunk.length - 1; i >= 0; i--) {
                                this.prepend(aChunk[i]);
                            }
                        } else if (
                            aChunk[isSourceNode] ||
                            typeof aChunk === 'string'
                        ) {
                            this.children.unshift(aChunk);
                        } else {
                            throw new TypeError(
                                'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
                                    aChunk
                            );
                        }
                        return this;
                    };

                    /**
                     * Walk over the tree of JS snippets in this node and its children. The
                     * walking function is called once for each snippet of JS and is passed that
                     * snippet and the its original associated source's line/column location.
                     *
                     * @param aFn The traversal function.
                     */
                    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
                        var chunk;
                        for (
                            var i = 0, len = this.children.length;
                            i < len;
                            i++
                        ) {
                            chunk = this.children[i];
                            if (chunk[isSourceNode]) {
                                chunk.walk(aFn);
                            } else {
                                if (chunk !== '') {
                                    aFn(chunk, {
                                        source: this.source,
                                        line: this.line,
                                        column: this.column,
                                        name: this.name,
                                    });
                                }
                            }
                        }
                    };

                    /**
                     * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
                     * each of `this.children`.
                     *
                     * @param aSep The separator.
                     */
                    SourceNode.prototype.join = function SourceNode_join(aSep) {
                        var newChildren;
                        var i;
                        var len = this.children.length;
                        if (len > 0) {
                            newChildren = [];
                            for (i = 0; i < len - 1; i++) {
                                newChildren.push(this.children[i]);
                                newChildren.push(aSep);
                            }
                            newChildren.push(this.children[i]);
                            this.children = newChildren;
                        }
                        return this;
                    };

                    /**
                     * Call String.prototype.replace on the very right-most source snippet. Useful
                     * for trimming whitespace from the end of a source node, etc.
                     *
                     * @param aPattern The pattern to replace.
                     * @param aReplacement The thing to replace the pattern with.
                     */
                    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
                        aPattern,
                        aReplacement
                    ) {
                        var lastChild = this.children[this.children.length - 1];
                        if (lastChild[isSourceNode]) {
                            lastChild.replaceRight(aPattern, aReplacement);
                        } else if (typeof lastChild === 'string') {
                            this.children[
                                this.children.length - 1
                            ] = lastChild.replace(aPattern, aReplacement);
                        } else {
                            this.children.push(
                                ''.replace(aPattern, aReplacement)
                            );
                        }
                        return this;
                    };

                    /**
                     * Set the source content for a source file. This will be added to the SourceMapGenerator
                     * in the sourcesContent field.
                     *
                     * @param aSourceFile The filename of the source file
                     * @param aSourceContent The content of the source file
                     */
                    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
                        aSourceFile,
                        aSourceContent
                    ) {
                        this.sourceContents[
                            util.toSetString(aSourceFile)
                        ] = aSourceContent;
                    };

                    /**
                     * Walk over the tree of SourceNodes. The walking function is called for each
                     * source file content and is passed the filename and source content.
                     *
                     * @param aFn The traversal function.
                     */
                    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(
                        aFn
                    ) {
                        for (
                            var i = 0, len = this.children.length;
                            i < len;
                            i++
                        ) {
                            if (this.children[i][isSourceNode]) {
                                this.children[i].walkSourceContents(aFn);
                            }
                        }

                        var sources = Object.keys(this.sourceContents);
                        for (var i = 0, len = sources.length; i < len; i++) {
                            aFn(
                                util.fromSetString(sources[i]),
                                this.sourceContents[sources[i]]
                            );
                        }
                    };

                    /**
                     * Return the string representation of this source node. Walks over the tree
                     * and concatenates all the various snippets together to one string.
                     */
                    SourceNode.prototype.toString = function SourceNode_toString() {
                        var str = '';
                        this.walk(function (chunk) {
                            str += chunk;
                        });
                        return str;
                    };

                    /**
                     * Returns the string representation of this source node along with a source
                     * map.
                     */
                    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(
                        aArgs
                    ) {
                        var generated = {
                            code: '',
                            line: 1,
                            column: 0,
                        };
                        var map = new SourceMapGenerator(aArgs);
                        var sourceMappingActive = false;
                        var lastOriginalSource = null;
                        var lastOriginalLine = null;
                        var lastOriginalColumn = null;
                        var lastOriginalName = null;
                        this.walk(function (chunk, original) {
                            generated.code += chunk;
                            if (
                                original.source !== null &&
                                original.line !== null &&
                                original.column !== null
                            ) {
                                if (
                                    lastOriginalSource !== original.source ||
                                    lastOriginalLine !== original.line ||
                                    lastOriginalColumn !== original.column ||
                                    lastOriginalName !== original.name
                                ) {
                                    map.addMapping({
                                        source: original.source,
                                        original: {
                                            line: original.line,
                                            column: original.column,
                                        },
                                        generated: {
                                            line: generated.line,
                                            column: generated.column,
                                        },
                                        name: original.name,
                                    });
                                }
                                lastOriginalSource = original.source;
                                lastOriginalLine = original.line;
                                lastOriginalColumn = original.column;
                                lastOriginalName = original.name;
                                sourceMappingActive = true;
                            } else if (sourceMappingActive) {
                                map.addMapping({
                                    generated: {
                                        line: generated.line,
                                        column: generated.column,
                                    },
                                });
                                lastOriginalSource = null;
                                sourceMappingActive = false;
                            }
                            for (
                                var idx = 0, length = chunk.length;
                                idx < length;
                                idx++
                            ) {
                                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                                    generated.line++;
                                    generated.column = 0;
                                    // Mappings end at eol
                                    if (idx + 1 === length) {
                                        lastOriginalSource = null;
                                        sourceMappingActive = false;
                                    } else if (sourceMappingActive) {
                                        map.addMapping({
                                            source: original.source,
                                            original: {
                                                line: original.line,
                                                column: original.column,
                                            },
                                            generated: {
                                                line: generated.line,
                                                column: generated.column,
                                            },
                                            name: original.name,
                                        });
                                    }
                                } else {
                                    generated.column++;
                                }
                            }
                        });
                        this.walkSourceContents(function (
                            sourceFile,
                            sourceContent
                        ) {
                            map.setSourceContent(sourceFile, sourceContent);
                        });

                        return { code: generated.code, map: map };
                    };

                    exports.SourceNode = SourceNode;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/lib/util.js':
                /*!*************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/lib/util.js ***!
  \*************************************************************************/
                /***/ (__unused_webpack_module, exports) => {
                    /* -*- Mode: js; js-indent-level: 2; -*- */
                    /*
                     * Copyright 2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */

                    /**
                     * This is a helper function for getting values from parameter/options
                     * objects.
                     *
                     * @param args The object we are extracting values from
                     * @param name The name of the property we are getting.
                     * @param defaultValue An optional value to return if the property is missing
                     * from the object. If this is not specified and the property is missing, an
                     * error will be thrown.
                     */
                    function getArg(aArgs, aName, aDefaultValue) {
                        if (aName in aArgs) {
                            return aArgs[aName];
                        } else if (arguments.length === 3) {
                            return aDefaultValue;
                        } else {
                            throw new Error(
                                '"' + aName + '" is a required argument.'
                            );
                        }
                    }
                    exports.getArg = getArg;

                    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
                    var dataUrlRegexp = /^data:.+\,.+$/;

                    function urlParse(aUrl) {
                        var match = aUrl.match(urlRegexp);
                        if (!match) {
                            return null;
                        }
                        return {
                            scheme: match[1],
                            auth: match[2],
                            host: match[3],
                            port: match[4],
                            path: match[5],
                        };
                    }
                    exports.urlParse = urlParse;

                    function urlGenerate(aParsedUrl) {
                        var url = '';
                        if (aParsedUrl.scheme) {
                            url += aParsedUrl.scheme + ':';
                        }
                        url += '//';
                        if (aParsedUrl.auth) {
                            url += aParsedUrl.auth + '@';
                        }
                        if (aParsedUrl.host) {
                            url += aParsedUrl.host;
                        }
                        if (aParsedUrl.port) {
                            url += ':' + aParsedUrl.port;
                        }
                        if (aParsedUrl.path) {
                            url += aParsedUrl.path;
                        }
                        return url;
                    }
                    exports.urlGenerate = urlGenerate;

                    /**
                     * Normalizes a path, or the path portion of a URL:
                     *
                     * - Replaces consecutive slashes with one slash.
                     * - Removes unnecessary '.' parts.
                     * - Removes unnecessary '<dir>/..' parts.
                     *
                     * Based on code in the Node.js 'path' core module.
                     *
                     * @param aPath The path or url to normalize.
                     */
                    function normalize(aPath) {
                        var path = aPath;
                        var url = urlParse(aPath);
                        if (url) {
                            if (!url.path) {
                                return aPath;
                            }
                            path = url.path;
                        }
                        var isAbsolute = exports.isAbsolute(path);

                        var parts = path.split(/\/+/);
                        for (
                            var part, up = 0, i = parts.length - 1;
                            i >= 0;
                            i--
                        ) {
                            part = parts[i];
                            if (part === '.') {
                                parts.splice(i, 1);
                            } else if (part === '..') {
                                up++;
                            } else if (up > 0) {
                                if (part === '') {
                                    // The first part is blank if the path is absolute. Trying to go
                                    // above the root is a no-op. Therefore we can remove all '..' parts
                                    // directly after the root.
                                    parts.splice(i + 1, up);
                                    up = 0;
                                } else {
                                    parts.splice(i, 2);
                                    up--;
                                }
                            }
                        }
                        path = parts.join('/');

                        if (path === '') {
                            path = isAbsolute ? '/' : '.';
                        }

                        if (url) {
                            url.path = path;
                            return urlGenerate(url);
                        }
                        return path;
                    }
                    exports.normalize = normalize;

                    /**
                     * Joins two paths/URLs.
                     *
                     * @param aRoot The root path or URL.
                     * @param aPath The path or URL to be joined with the root.
                     *
                     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
                     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
                     *   first.
                     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
                     *   is updated with the result and aRoot is returned. Otherwise the result
                     *   is returned.
                     *   - If aPath is absolute, the result is aPath.
                     *   - Otherwise the two paths are joined with a slash.
                     * - Joining for example 'http://' and 'www.example.com' is also supported.
                     */
                    function join(aRoot, aPath) {
                        if (aRoot === '') {
                            aRoot = '.';
                        }
                        if (aPath === '') {
                            aPath = '.';
                        }
                        var aPathUrl = urlParse(aPath);
                        var aRootUrl = urlParse(aRoot);
                        if (aRootUrl) {
                            aRoot = aRootUrl.path || '/';
                        }

                        // `join(foo, '//www.example.org')`
                        if (aPathUrl && !aPathUrl.scheme) {
                            if (aRootUrl) {
                                aPathUrl.scheme = aRootUrl.scheme;
                            }
                            return urlGenerate(aPathUrl);
                        }

                        if (aPathUrl || aPath.match(dataUrlRegexp)) {
                            return aPath;
                        }

                        // `join('http://', 'www.example.com')`
                        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                            aRootUrl.host = aPath;
                            return urlGenerate(aRootUrl);
                        }

                        var joined =
                            aPath.charAt(0) === '/'
                                ? aPath
                                : normalize(
                                      aRoot.replace(/\/+$/, '') + '/' + aPath
                                  );

                        if (aRootUrl) {
                            aRootUrl.path = joined;
                            return urlGenerate(aRootUrl);
                        }
                        return joined;
                    }
                    exports.join = join;

                    exports.isAbsolute = function (aPath) {
                        return (
                            aPath.charAt(0) === '/' || !!aPath.match(urlRegexp)
                        );
                    };

                    /**
                     * Make a path relative to a URL or another path.
                     *
                     * @param aRoot The root path or URL.
                     * @param aPath The path or URL to be made relative to aRoot.
                     */
                    function relative(aRoot, aPath) {
                        if (aRoot === '') {
                            aRoot = '.';
                        }

                        aRoot = aRoot.replace(/\/$/, '');

                        // It is possible for the path to be above the root. In this case, simply
                        // checking whether the root is a prefix of the path won't work. Instead, we
                        // need to remove components from the root one by one, until either we find
                        // a prefix that fits, or we run out of components to remove.
                        var level = 0;
                        while (aPath.indexOf(aRoot + '/') !== 0) {
                            var index = aRoot.lastIndexOf('/');
                            if (index < 0) {
                                return aPath;
                            }

                            // If the only part of the root that is left is the scheme (i.e. http://,
                            // file:///, etc.), one or more slashes (/), or simply nothing at all, we
                            // have exhausted all components, so the path is not relative to the root.
                            aRoot = aRoot.slice(0, index);
                            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                                return aPath;
                            }

                            ++level;
                        }

                        // Make sure we add a "../" for each component we removed from the root.
                        return (
                            Array(level + 1).join('../') +
                            aPath.substr(aRoot.length + 1)
                        );
                    }
                    exports.relative = relative;

                    var supportsNullProto = (function () {
                        var obj = Object.create(null);
                        return !('__proto__' in obj);
                    })();

                    function identity(s) {
                        return s;
                    }

                    /**
                     * Because behavior goes wacky when you set `__proto__` on objects, we
                     * have to prefix all the strings in our set with an arbitrary character.
                     *
                     * See https://github.com/mozilla/source-map/pull/31 and
                     * https://github.com/mozilla/source-map/issues/30
                     *
                     * @param String aStr
                     */
                    function toSetString(aStr) {
                        if (isProtoString(aStr)) {
                            return '$' + aStr;
                        }

                        return aStr;
                    }
                    exports.toSetString = supportsNullProto
                        ? identity
                        : toSetString;

                    function fromSetString(aStr) {
                        if (isProtoString(aStr)) {
                            return aStr.slice(1);
                        }

                        return aStr;
                    }
                    exports.fromSetString = supportsNullProto
                        ? identity
                        : fromSetString;

                    function isProtoString(s) {
                        if (!s) {
                            return false;
                        }

                        var length = s.length;

                        if (length < 9 /* "__proto__".length */) {
                            return false;
                        }

                        if (
                            s.charCodeAt(length - 1) !== 95 /* '_' */ ||
                            s.charCodeAt(length - 2) !== 95 /* '_' */ ||
                            s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
                            s.charCodeAt(length - 4) !== 116 /* 't' */ ||
                            s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
                            s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
                            s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
                            s.charCodeAt(length - 8) !== 95 /* '_' */ ||
                            s.charCodeAt(length - 9) !== 95 /* '_' */
                        ) {
                            return false;
                        }

                        for (var i = length - 10; i >= 0; i--) {
                            if (s.charCodeAt(i) !== 36 /* '$' */) {
                                return false;
                            }
                        }

                        return true;
                    }

                    /**
                     * Comparator between two mappings where the original positions are compared.
                     *
                     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
                     * mappings with the same original source/line/column, but different generated
                     * line and column the same. Useful when searching for a mapping with a
                     * stubbed out mapping.
                     */
                    function compareByOriginalPositions(
                        mappingA,
                        mappingB,
                        onlyCompareOriginal
                    ) {
                        var cmp = mappingA.source - mappingB.source;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalLine - mappingB.originalLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalColumn - mappingB.originalColumn;
                        if (cmp !== 0 || onlyCompareOriginal) {
                            return cmp;
                        }

                        cmp =
                            mappingA.generatedColumn - mappingB.generatedColumn;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.generatedLine - mappingB.generatedLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        return mappingA.name - mappingB.name;
                    }
                    exports.compareByOriginalPositions = compareByOriginalPositions;

                    /**
                     * Comparator between two mappings with deflated source and name indices where
                     * the generated positions are compared.
                     *
                     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
                     * mappings with the same generated line and column, but different
                     * source/name/original line and column the same. Useful when searching for a
                     * mapping with a stubbed out mapping.
                     */
                    function compareByGeneratedPositionsDeflated(
                        mappingA,
                        mappingB,
                        onlyCompareGenerated
                    ) {
                        var cmp =
                            mappingA.generatedLine - mappingB.generatedLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp =
                            mappingA.generatedColumn - mappingB.generatedColumn;
                        if (cmp !== 0 || onlyCompareGenerated) {
                            return cmp;
                        }

                        cmp = mappingA.source - mappingB.source;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalLine - mappingB.originalLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalColumn - mappingB.originalColumn;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        return mappingA.name - mappingB.name;
                    }
                    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

                    function strcmp(aStr1, aStr2) {
                        if (aStr1 === aStr2) {
                            return 0;
                        }

                        if (aStr1 > aStr2) {
                            return 1;
                        }

                        return -1;
                    }

                    /**
                     * Comparator between two mappings with inflated source and name strings where
                     * the generated positions are compared.
                     */
                    function compareByGeneratedPositionsInflated(
                        mappingA,
                        mappingB
                    ) {
                        var cmp =
                            mappingA.generatedLine - mappingB.generatedLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp =
                            mappingA.generatedColumn - mappingB.generatedColumn;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = strcmp(mappingA.source, mappingB.source);
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalLine - mappingB.originalLine;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        cmp = mappingA.originalColumn - mappingB.originalColumn;
                        if (cmp !== 0) {
                            return cmp;
                        }

                        return strcmp(mappingA.name, mappingB.name);
                    }
                    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/node_modules/source-map/source-map.js':
                /*!***************************************************************************!*\
  !*** ./node_modules/stacktrace-gps/node_modules/source-map/source-map.js ***!
  \***************************************************************************/
                /***/ (
                    __unused_webpack_module,
                    exports,
                    __webpack_require__
                ) => {
                    /*
                     * Copyright 2009-2011 Mozilla Foundation and contributors
                     * Licensed under the New BSD license. See LICENSE.txt or:
                     * http://opensource.org/licenses/BSD-3-Clause
                     */
                    exports.SourceMapGenerator = __webpack_require__(
                        /*! ./lib/source-map-generator */ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-generator.js'
                    ).SourceMapGenerator;
                    exports.SourceMapConsumer = __webpack_require__(
                        /*! ./lib/source-map-consumer */ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-consumer.js'
                    ).SourceMapConsumer;
                    exports.SourceNode = __webpack_require__(
                        /*! ./lib/source-node */ './node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js'
                    ).SourceNode;

                    /***/
                },

            /***/ './node_modules/stacktrace-gps/stacktrace-gps.js':
                /*!*******************************************************!*\
  !*** ./node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \*******************************************************/
                /***/ function (module, exports, __webpack_require__) {
                    var __WEBPACK_AMD_DEFINE_FACTORY__,
                        __WEBPACK_AMD_DEFINE_ARRAY__,
                        __WEBPACK_AMD_DEFINE_RESULT__;
                    (function (root, factory) {
                        'use strict';
                        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

                        /* istanbul ignore next */
                        if (true) {
                            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                                __webpack_require__(
                                    /*! source-map */ './node_modules/stacktrace-gps/node_modules/source-map/source-map.js'
                                ),
                                __webpack_require__(
                                    /*! stackframe */ './node_modules/stackframe/stackframe.js'
                                ),
                            ]),
                            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
                            (__WEBPACK_AMD_DEFINE_RESULT__ =
                                typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
                                'function'
                                    ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                          exports,
                                          __WEBPACK_AMD_DEFINE_ARRAY__
                                      )
                                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else {
                        }
                    })(this, function (SourceMap, StackFrame) {
                        'use strict';

                        /**
                         * Make a X-Domain request to url and callback.
                         *
                         * @param {String} url
                         * @returns {Promise} with response text if fulfilled
                         */
                        function _xdr(url) {
                            return new Promise(function (resolve, reject) {
                                var req = new XMLHttpRequest();
                                req.open('get', url);
                                req.onerror = reject;
                                req.onreadystatechange = function onreadystatechange() {
                                    if (req.readyState === 4) {
                                        if (
                                            (req.status >= 200 &&
                                                req.status < 300) ||
                                            (url.substr(0, 7) === 'file://' &&
                                                req.responseText)
                                        ) {
                                            resolve(req.responseText);
                                        } else {
                                            reject(
                                                new Error(
                                                    'HTTP status: ' +
                                                        req.status +
                                                        ' retrieving ' +
                                                        url
                                                )
                                            );
                                        }
                                    }
                                };
                                req.send();
                            });
                        }

                        /**
                         * Convert a Base64-encoded string into its original representation.
                         * Used for inline sourcemaps.
                         *
                         * @param {String} b64str Base-64 encoded string
                         * @returns {String} original representation of the base64-encoded string.
                         */
                        function _atob(b64str) {
                            if (typeof window !== 'undefined' && window.atob) {
                                return window.atob(b64str);
                            } else {
                                throw new Error(
                                    'You must supply a polyfill for window.atob in this environment'
                                );
                            }
                        }

                        function _parseJson(string) {
                            if (typeof JSON !== 'undefined' && JSON.parse) {
                                return JSON.parse(string);
                            } else {
                                throw new Error(
                                    'You must supply a polyfill for JSON.parse in this environment'
                                );
                            }
                        }

                        function _findFunctionName(
                            source,
                            lineNumber /*, columnNumber*/
                        ) {
                            var syntaxes = [
                                // {name} = function ({args}) TODO args capture
                                /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/,
                                // function {name}({args}) m[1]=name m[2]=args
                                /function\s+([^('"`]*?)\s*\(([^)]*)\)/,
                                // {name} = eval()
                                /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/,
                                // fn_name() {
                                /\b(?!(?:if|for|switch|while|with|catch)\b)(?:(?:static)\s+)?(\S+)\s*\(.*?\)\s*\{/,
                                // {name} = () => {
                                /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*\(.*?\)\s*=>/,
                            ];
                            var lines = source.split('\n');

                            // Walk backwards in the source lines until we find the line which matches one of the patterns above
                            var code = '';
                            var maxLines = Math.min(lineNumber, 20);
                            for (var i = 0; i < maxLines; ++i) {
                                // lineNo is 1-based, source[] is 0-based
                                var line = lines[lineNumber - i - 1];
                                var commentPos = line.indexOf('//');
                                if (commentPos >= 0) {
                                    line = line.substr(0, commentPos);
                                }

                                if (line) {
                                    code = line + code;
                                    var len = syntaxes.length;
                                    for (var index = 0; index < len; index++) {
                                        var m = syntaxes[index].exec(code);
                                        if (m && m[1]) {
                                            return m[1];
                                        }
                                    }
                                }
                            }
                            return undefined;
                        }

                        function _ensureSupportedEnvironment() {
                            if (
                                typeof Object.defineProperty !== 'function' ||
                                typeof Object.create !== 'function'
                            ) {
                                throw new Error(
                                    'Unable to consume source maps in older browsers'
                                );
                            }
                        }

                        function _ensureStackFrameIsLegit(stackframe) {
                            if (typeof stackframe !== 'object') {
                                throw new TypeError(
                                    'Given StackFrame is not an object'
                                );
                            } else if (
                                typeof stackframe.fileName !== 'string'
                            ) {
                                throw new TypeError(
                                    'Given file name is not a String'
                                );
                            } else if (
                                typeof stackframe.lineNumber !== 'number' ||
                                stackframe.lineNumber % 1 !== 0 ||
                                stackframe.lineNumber < 1
                            ) {
                                throw new TypeError(
                                    'Given line number must be a positive integer'
                                );
                            } else if (
                                typeof stackframe.columnNumber !== 'number' ||
                                stackframe.columnNumber % 1 !== 0 ||
                                stackframe.columnNumber < 0
                            ) {
                                throw new TypeError(
                                    'Given column number must be a non-negative integer'
                                );
                            }
                            return true;
                        }

                        function _findSourceMappingURL(source) {
                            var sourceMappingUrlRegExp = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/gm;
                            var lastSourceMappingUrl;
                            var matchSourceMappingUrl;
                            // eslint-disable-next-line no-cond-assign
                            while (
                                (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(
                                    source
                                ))
                            ) {
                                lastSourceMappingUrl = matchSourceMappingUrl[1];
                            }
                            if (lastSourceMappingUrl) {
                                return lastSourceMappingUrl;
                            } else {
                                throw new Error('sourceMappingURL not found');
                            }
                        }

                        function _extractLocationInfoFromSourceMapSource(
                            stackframe,
                            sourceMapConsumer,
                            sourceCache
                        ) {
                            return new Promise(function (resolve, reject) {
                                var loc = sourceMapConsumer.originalPositionFor(
                                    {
                                        line: stackframe.lineNumber,
                                        column: stackframe.columnNumber,
                                    }
                                );

                                if (loc.source) {
                                    // cache mapped sources
                                    var mappedSource = sourceMapConsumer.sourceContentFor(
                                        loc.source
                                    );
                                    if (mappedSource) {
                                        sourceCache[loc.source] = mappedSource;
                                    }

                                    resolve(
                                        // given stackframe and source location, update stackframe
                                        new StackFrame({
                                            functionName:
                                                loc.name ||
                                                stackframe.functionName,
                                            args: stackframe.args,
                                            fileName: loc.source,
                                            lineNumber: loc.line,
                                            columnNumber: loc.column,
                                        })
                                    );
                                } else {
                                    reject(
                                        new Error(
                                            'Could not get original source for given stackframe and source map'
                                        )
                                    );
                                }
                            });
                        }

                        /**
                         * @constructor
                         * @param {Object} opts
                         *      opts.sourceCache = {url: "Source String"} => preload source cache
                         *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}
                         *      opts.offline = True to prevent network requests.
                         *              Best effort without sources or source maps.
                         *      opts.ajax = Promise returning function to make X-Domain requests
                         */
                        return function StackTraceGPS(opts) {
                            if (!(this instanceof StackTraceGPS)) {
                                return new StackTraceGPS(opts);
                            }
                            opts = opts || {};

                            this.sourceCache = opts.sourceCache || {};
                            this.sourceMapConsumerCache =
                                opts.sourceMapConsumerCache || {};

                            this.ajax = opts.ajax || _xdr;

                            this._atob = opts.atob || _atob;

                            this._get = function _get(location) {
                                return new Promise(
                                    function (resolve, reject) {
                                        var isDataUrl =
                                            location.substr(0, 5) === 'data:';
                                        if (this.sourceCache[location]) {
                                            resolve(this.sourceCache[location]);
                                        } else if (opts.offline && !isDataUrl) {
                                            reject(
                                                new Error(
                                                    'Cannot make network requests in offline mode'
                                                )
                                            );
                                        } else {
                                            if (isDataUrl) {
                                                // data URLs can have parameters.
                                                // see http://tools.ietf.org/html/rfc2397
                                                var supportedEncodingRegexp = /^data:application\/json;([\w=:"-]+;)*base64,/;
                                                var match = location.match(
                                                    supportedEncodingRegexp
                                                );
                                                if (match) {
                                                    var sourceMapStart =
                                                        match[0].length;
                                                    var encodedSource = location.substr(
                                                        sourceMapStart
                                                    );
                                                    var source = this._atob(
                                                        encodedSource
                                                    );
                                                    this.sourceCache[
                                                        location
                                                    ] = source;
                                                    resolve(source);
                                                } else {
                                                    reject(
                                                        new Error(
                                                            'The encoding of the inline sourcemap is not supported'
                                                        )
                                                    );
                                                }
                                            } else {
                                                var xhrPromise = this.ajax(
                                                    location,
                                                    { method: 'get' }
                                                );
                                                // Cache the Promise to prevent duplicate in-flight requests
                                                this.sourceCache[
                                                    location
                                                ] = xhrPromise;
                                                xhrPromise.then(
                                                    resolve,
                                                    reject
                                                );
                                            }
                                        }
                                    }.bind(this)
                                );
                            };

                            /**
                             * Creating SourceMapConsumers is expensive, so this wraps the creation of a
                             * SourceMapConsumer in a per-instance cache.
                             *
                             * @param {String} sourceMappingURL = URL to fetch source map from
                             * @param {String} defaultSourceRoot = Default source root for source map if undefined
                             * @returns {Promise} that resolves a SourceMapConsumer
                             */
                            this._getSourceMapConsumer = function _getSourceMapConsumer(
                                sourceMappingURL,
                                defaultSourceRoot
                            ) {
                                return new Promise(
                                    function (resolve) {
                                        if (
                                            this.sourceMapConsumerCache[
                                                sourceMappingURL
                                            ]
                                        ) {
                                            resolve(
                                                this.sourceMapConsumerCache[
                                                    sourceMappingURL
                                                ]
                                            );
                                        } else {
                                            var sourceMapConsumerPromise = new Promise(
                                                function (resolve, reject) {
                                                    return this._get(
                                                        sourceMappingURL
                                                    ).then(function (
                                                        sourceMapSource
                                                    ) {
                                                        if (
                                                            typeof sourceMapSource ===
                                                            'string'
                                                        ) {
                                                            sourceMapSource = _parseJson(
                                                                sourceMapSource.replace(
                                                                    /^\)\]\}'/,
                                                                    ''
                                                                )
                                                            );
                                                        }
                                                        if (
                                                            typeof sourceMapSource.sourceRoot ===
                                                            'undefined'
                                                        ) {
                                                            sourceMapSource.sourceRoot = defaultSourceRoot;
                                                        }

                                                        resolve(
                                                            new SourceMap.SourceMapConsumer(
                                                                sourceMapSource
                                                            )
                                                        );
                                                    },
                                                    reject);
                                                }.bind(this)
                                            );
                                            this.sourceMapConsumerCache[
                                                sourceMappingURL
                                            ] = sourceMapConsumerPromise;
                                            resolve(sourceMapConsumerPromise);
                                        }
                                    }.bind(this)
                                );
                            };

                            /**
                             * Given a StackFrame, enhance function name and use source maps for a
                             * better StackFrame.
                             *
                             * @param {StackFrame} stackframe object
                             * @returns {Promise} that resolves with with source-mapped StackFrame
                             */
                            this.pinpoint = function StackTraceGPS$$pinpoint(
                                stackframe
                            ) {
                                return new Promise(
                                    function (resolve, reject) {
                                        this.getMappedLocation(stackframe).then(
                                            function (mappedStackFrame) {
                                                function resolveMappedStackFrame() {
                                                    resolve(mappedStackFrame);
                                                }

                                                this.findFunctionName(
                                                    mappedStackFrame
                                                )
                                                    .then(
                                                        resolve,
                                                        resolveMappedStackFrame
                                                    )
                                                    [
                                                        // eslint-disable-next-line no-unexpected-multiline
                                                        'catch'
                                                    ](resolveMappedStackFrame);
                                            }.bind(this),
                                            reject
                                        );
                                    }.bind(this)
                                );
                            };

                            /**
                             * Given a StackFrame, guess function name from location information.
                             *
                             * @param {StackFrame} stackframe
                             * @returns {Promise} that resolves with enhanced StackFrame.
                             */
                            this.findFunctionName = function StackTraceGPS$$findFunctionName(
                                stackframe
                            ) {
                                return new Promise(
                                    function (resolve, reject) {
                                        _ensureStackFrameIsLegit(stackframe);
                                        this._get(stackframe.fileName)
                                            .then(function getSourceCallback(
                                                source
                                            ) {
                                                var lineNumber =
                                                    stackframe.lineNumber;
                                                var columnNumber =
                                                    stackframe.columnNumber;
                                                var guessedFunctionName = _findFunctionName(
                                                    source,
                                                    lineNumber,
                                                    columnNumber
                                                );
                                                // Only replace functionName if we found something
                                                if (guessedFunctionName) {
                                                    resolve(
                                                        new StackFrame({
                                                            functionName: guessedFunctionName,
                                                            args:
                                                                stackframe.args,
                                                            fileName:
                                                                stackframe.fileName,
                                                            lineNumber: lineNumber,
                                                            columnNumber: columnNumber,
                                                        })
                                                    );
                                                } else {
                                                    resolve(stackframe);
                                                }
                                            },
                                            reject)
                                            ['catch'](reject);
                                    }.bind(this)
                                );
                            };

                            /**
                             * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
                             *
                             * @param {StackFrame} stackframe
                             * @returns {Promise} that resolves with enhanced StackFrame.
                             */
                            this.getMappedLocation = function StackTraceGPS$$getMappedLocation(
                                stackframe
                            ) {
                                return new Promise(
                                    function (resolve, reject) {
                                        _ensureSupportedEnvironment();
                                        _ensureStackFrameIsLegit(stackframe);

                                        var sourceCache = this.sourceCache;
                                        var fileName = stackframe.fileName;
                                        this._get(fileName)
                                            .then(
                                                function (source) {
                                                    var sourceMappingURL = _findSourceMappingURL(
                                                        source
                                                    );
                                                    var isDataUrl =
                                                        sourceMappingURL.substr(
                                                            0,
                                                            5
                                                        ) === 'data:';
                                                    var defaultSourceRoot = fileName.substring(
                                                        0,
                                                        fileName.lastIndexOf(
                                                            '/'
                                                        ) + 1
                                                    );

                                                    if (
                                                        sourceMappingURL[0] !==
                                                            '/' &&
                                                        !isDataUrl &&
                                                        !/^https?:\/\/|^\/\//i.test(
                                                            sourceMappingURL
                                                        )
                                                    ) {
                                                        sourceMappingURL =
                                                            defaultSourceRoot +
                                                            sourceMappingURL;
                                                    }

                                                    return this._getSourceMapConsumer(
                                                        sourceMappingURL,
                                                        defaultSourceRoot
                                                    ).then(function (
                                                        sourceMapConsumer
                                                    ) {
                                                        return _extractLocationInfoFromSourceMapSource(
                                                            stackframe,
                                                            sourceMapConsumer,
                                                            sourceCache
                                                        )
                                                            .then(resolve)
                                                            ['catch'](
                                                                function () {
                                                                    resolve(
                                                                        stackframe
                                                                    );
                                                                }
                                                            );
                                                    });
                                                }.bind(this),
                                                reject
                                            )
                                            ['catch'](reject);
                                    }.bind(this)
                                );
                            };
                        };
                    });

                    /***/
                },

            /***/ './node_modules/stacktrace-js/stacktrace.js':
                /*!**************************************************!*\
  !*** ./node_modules/stacktrace-js/stacktrace.js ***!
  \**************************************************/
                /***/ function (module, exports, __webpack_require__) {
                    var __WEBPACK_AMD_DEFINE_FACTORY__,
                        __WEBPACK_AMD_DEFINE_ARRAY__,
                        __WEBPACK_AMD_DEFINE_RESULT__;
                    (function (root, factory) {
                        'use strict';
                        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

                        /* istanbul ignore next */
                        if (true) {
                            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                                __webpack_require__(
                                    /*! error-stack-parser */ './node_modules/error-stack-parser/error-stack-parser.js'
                                ),
                                __webpack_require__(
                                    /*! stack-generator */ './node_modules/stack-generator/stack-generator.js'
                                ),
                                __webpack_require__(
                                    /*! stacktrace-gps */ './node_modules/stacktrace-gps/stacktrace-gps.js'
                                ),
                            ]),
                            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
                            (__WEBPACK_AMD_DEFINE_RESULT__ =
                                typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
                                'function'
                                    ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                          exports,
                                          __WEBPACK_AMD_DEFINE_ARRAY__
                                      )
                                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else {
                        }
                    })(
                        this,
                        function StackTrace(
                            ErrorStackParser,
                            StackGenerator,
                            StackTraceGPS
                        ) {
                            var _options = {
                                filter: function (stackframe) {
                                    // Filter out stackframes for this library by default
                                    return (
                                        (stackframe.functionName || '').indexOf(
                                            'StackTrace$$'
                                        ) === -1 &&
                                        (stackframe.functionName || '').indexOf(
                                            'ErrorStackParser$$'
                                        ) === -1 &&
                                        (stackframe.functionName || '').indexOf(
                                            'StackTraceGPS$$'
                                        ) === -1 &&
                                        (stackframe.functionName || '').indexOf(
                                            'StackGenerator$$'
                                        ) === -1
                                    );
                                },
                                sourceCache: {},
                            };

                            var _generateError = function StackTrace$$GenerateError() {
                                try {
                                    // Error must be thrown to get stack in IE
                                    throw new Error();
                                } catch (err) {
                                    return err;
                                }
                            };

                            /**
                             * Merge 2 given Objects. If a conflict occurs the second object wins.
                             * Does not do deep merges.
                             *
                             * @param {Object} first base object
                             * @param {Object} second overrides
                             * @returns {Object} merged first and second
                             * @private
                             */
                            function _merge(first, second) {
                                var target = {};

                                [first, second].forEach(function (obj) {
                                    for (var prop in obj) {
                                        if (
                                            Object.prototype.hasOwnProperty.call(
                                                obj,
                                                prop
                                            )
                                        ) {
                                            target[prop] = obj[prop];
                                        }
                                    }
                                    return target;
                                });

                                return target;
                            }

                            function _isShapedLikeParsableError(err) {
                                return err.stack || err['opera#sourceloc'];
                            }

                            function _filtered(stackframes, filter) {
                                if (typeof filter === 'function') {
                                    return stackframes.filter(filter);
                                }
                                return stackframes;
                            }

                            return {
                                /**
                                 * Get a backtrace from invocation point.
                                 *
                                 * @param {Object} opts
                                 * @returns {Array} of StackFrame
                                 */
                                get: function StackTrace$$get(opts) {
                                    var err = _generateError();
                                    return _isShapedLikeParsableError(err)
                                        ? this.fromError(err, opts)
                                        : this.generateArtificially(opts);
                                },

                                /**
                                 * Get a backtrace from invocation point.
                                 * IMPORTANT: Does not handle source maps or guess function names!
                                 *
                                 * @param {Object} opts
                                 * @returns {Array} of StackFrame
                                 */
                                getSync: function StackTrace$$getSync(opts) {
                                    opts = _merge(_options, opts);
                                    var err = _generateError();
                                    var stack = _isShapedLikeParsableError(err)
                                        ? ErrorStackParser.parse(err)
                                        : StackGenerator.backtrace(opts);
                                    return _filtered(stack, opts.filter);
                                },

                                /**
                                 * Given an error object, parse it.
                                 *
                                 * @param {Error} error object
                                 * @param {Object} opts
                                 * @returns {Promise} for Array[StackFrame}
                                 */
                                fromError: function StackTrace$$fromError(
                                    error,
                                    opts
                                ) {
                                    opts = _merge(_options, opts);
                                    var gps = new StackTraceGPS(opts);
                                    return new Promise(
                                        function (resolve) {
                                            var stackframes = _filtered(
                                                ErrorStackParser.parse(error),
                                                opts.filter
                                            );
                                            resolve(
                                                Promise.all(
                                                    stackframes.map(function (
                                                        sf
                                                    ) {
                                                        return new Promise(
                                                            function (resolve) {
                                                                function resolveOriginal() {
                                                                    resolve(sf);
                                                                }

                                                                gps.pinpoint(sf)
                                                                    .then(
                                                                        resolve,
                                                                        resolveOriginal
                                                                    )
                                                                    ['catch'](
                                                                        resolveOriginal
                                                                    );
                                                            }
                                                        );
                                                    })
                                                )
                                            );
                                        }.bind(this)
                                    );
                                },

                                /**
                                 * Use StackGenerator to generate a backtrace.
                                 *
                                 * @param {Object} opts
                                 * @returns {Promise} of Array[StackFrame]
                                 */
                                generateArtificially: function StackTrace$$generateArtificially(
                                    opts
                                ) {
                                    opts = _merge(_options, opts);
                                    var stackFrames = StackGenerator.backtrace(
                                        opts
                                    );
                                    if (typeof opts.filter === 'function') {
                                        stackFrames = stackFrames.filter(
                                            opts.filter
                                        );
                                    }
                                    return Promise.resolve(stackFrames);
                                },

                                /**
                                 * Given a function, wrap it such that invocations trigger a callback that
                                 * is called with a stack trace.
                                 *
                                 * @param {Function} fn to be instrumented
                                 * @param {Function} callback function to call with a stack trace on invocation
                                 * @param {Function} errback optional function to call with error if unable to get stack trace.
                                 * @param {Object} thisArg optional context object (e.g. window)
                                 */
                                instrument: function StackTrace$$instrument(
                                    fn,
                                    callback,
                                    errback,
                                    thisArg
                                ) {
                                    if (typeof fn !== 'function') {
                                        throw new Error(
                                            'Cannot instrument non-function object'
                                        );
                                    } else if (
                                        typeof fn.__stacktraceOriginalFn ===
                                        'function'
                                    ) {
                                        // Already instrumented, return given Function
                                        return fn;
                                    }

                                    var instrumented = function StackTrace$$instrumented() {
                                        try {
                                            this.get()
                                                .then(callback, errback)
                                                ['catch'](errback);
                                            return fn.apply(
                                                thisArg || this,
                                                arguments
                                            );
                                        } catch (e) {
                                            if (_isShapedLikeParsableError(e)) {
                                                this.fromError(e)
                                                    .then(callback, errback)
                                                    ['catch'](errback);
                                            }
                                            throw e;
                                        }
                                    }.bind(this);
                                    instrumented.__stacktraceOriginalFn = fn;

                                    return instrumented;
                                },

                                /**
                                 * Given a function that has been instrumented,
                                 * revert the function to it's original (non-instrumented) state.
                                 *
                                 * @param {Function} fn to de-instrument
                                 */
                                deinstrument: function StackTrace$$deinstrument(
                                    fn
                                ) {
                                    if (typeof fn !== 'function') {
                                        throw new Error(
                                            'Cannot de-instrument non-function object'
                                        );
                                    } else if (
                                        typeof fn.__stacktraceOriginalFn ===
                                        'function'
                                    ) {
                                        return fn.__stacktraceOriginalFn;
                                    } else {
                                        // Function not instrumented, return original
                                        return fn;
                                    }
                                },

                                /**
                                 * Given an error message and Array of StackFrames, serialize and POST to given URL.
                                 *
                                 * @param {Array} stackframes
                                 * @param {String} url
                                 * @param {String} errorMsg
                                 * @param {Object} requestOptions
                                 */
                                report: function StackTrace$$report(
                                    stackframes,
                                    url,
                                    errorMsg,
                                    requestOptions
                                ) {
                                    return new Promise(function (
                                        resolve,
                                        reject
                                    ) {
                                        var req = new XMLHttpRequest();
                                        req.onerror = reject;
                                        req.onreadystatechange = function onreadystatechange() {
                                            if (req.readyState === 4) {
                                                if (
                                                    req.status >= 200 &&
                                                    req.status < 400
                                                ) {
                                                    resolve(req.responseText);
                                                } else {
                                                    reject(
                                                        new Error(
                                                            'POST to ' +
                                                                url +
                                                                ' failed with status: ' +
                                                                req.status
                                                        )
                                                    );
                                                }
                                            }
                                        };
                                        req.open('post', url);

                                        // Set request headers
                                        req.setRequestHeader(
                                            'Content-Type',
                                            'application/json'
                                        );
                                        if (
                                            requestOptions &&
                                            typeof requestOptions.headers ===
                                                'object'
                                        ) {
                                            var headers =
                                                requestOptions.headers;
                                            for (var header in headers) {
                                                if (
                                                    Object.prototype.hasOwnProperty.call(
                                                        headers,
                                                        header
                                                    )
                                                ) {
                                                    req.setRequestHeader(
                                                        header,
                                                        headers[header]
                                                    );
                                                }
                                            }
                                        }

                                        var reportPayload = {
                                            stack: stackframes,
                                        };
                                        if (
                                            errorMsg !== undefined &&
                                            errorMsg !== null
                                        ) {
                                            reportPayload.message = errorMsg;
                                        }

                                        req.send(JSON.stringify(reportPayload));
                                    });
                                },
                            };
                        }
                    );

                    /***/
                },

            /***/ './src/graph/generated/operations.ts':
                /*!*******************************************!*\
  !*** ./src/graph/generated/operations.ts ***!
  \*******************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ PushPayloadDocument: () =>
                                /* binding */ PushPayloadDocument,
                            /* harmony export */ IdentifySessionDocument: () =>
                                /* binding */ IdentifySessionDocument,
                            /* harmony export */ AddSessionPropertiesDocument: () =>
                                /* binding */ AddSessionPropertiesDocument,
                            /* harmony export */ AddTrackPropertiesDocument: () =>
                                /* binding */ AddTrackPropertiesDocument,
                            /* harmony export */ InitializeSessionDocument: () =>
                                /* binding */ InitializeSessionDocument,
                            /* harmony export */ IgnoreDocument: () =>
                                /* binding */ IgnoreDocument,
                            /* harmony export */ getSdk: () =>
                                /* binding */ getSdk,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                        /*! graphql */ './node_modules/graphql/language/printer.mjs'
                    );
                    /* harmony import */ var graphql_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! graphql-tag */ './node_modules/graphql-tag/src/index.js'
                    );
                    /* harmony import */ var graphql_tag__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                        graphql_tag__WEBPACK_IMPORTED_MODULE_0__
                    );
                    var __makeTemplateObject =
                        (undefined && undefined.__makeTemplateObject) ||
                        function (cooked, raw) {
                            if (Object.defineProperty) {
                                Object.defineProperty(cooked, 'raw', {
                                    value: raw,
                                });
                            } else {
                                cooked.raw = raw;
                            }
                            return cooked;
                        };

                    var PushPayloadDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_1 ||
                            (templateObject_1 = __makeTemplateObject(
                                [
                                    '\n    mutation PushPayload($session_id: ID!, $events: ReplayEventsInput!, $messages: String!, $resources: String!, $errors: [ErrorObjectInput]!) {\n  pushPayload(\n    session_id: $session_id\n    events: $events\n    messages: $messages\n    resources: $resources\n    errors: $errors\n  )\n}\n    ',
                                ],
                                [
                                    '\n    mutation PushPayload($session_id: ID!, $events: ReplayEventsInput!, $messages: String!, $resources: String!, $errors: [ErrorObjectInput]!) {\n  pushPayload(\n    session_id: $session_id\n    events: $events\n    messages: $messages\n    resources: $resources\n    errors: $errors\n  )\n}\n    ',
                                ]
                            ))
                    );
                    var IdentifySessionDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_2 ||
                            (templateObject_2 = __makeTemplateObject(
                                [
                                    '\n    mutation identifySession($session_id: ID!, $user_identifier: String!, $user_object: Any) {\n  identifySession(\n    session_id: $session_id\n    user_identifier: $user_identifier\n    user_object: $user_object\n  )\n}\n    ',
                                ],
                                [
                                    '\n    mutation identifySession($session_id: ID!, $user_identifier: String!, $user_object: Any) {\n  identifySession(\n    session_id: $session_id\n    user_identifier: $user_identifier\n    user_object: $user_object\n  )\n}\n    ',
                                ]
                            ))
                    );
                    var AddSessionPropertiesDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_3 ||
                            (templateObject_3 = __makeTemplateObject(
                                [
                                    '\n    mutation addSessionProperties($session_id: ID!, $properties_object: Any) {\n  addSessionProperties(\n    session_id: $session_id\n    properties_object: $properties_object\n  )\n}\n    ',
                                ],
                                [
                                    '\n    mutation addSessionProperties($session_id: ID!, $properties_object: Any) {\n  addSessionProperties(\n    session_id: $session_id\n    properties_object: $properties_object\n  )\n}\n    ',
                                ]
                            ))
                    );
                    var AddTrackPropertiesDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_4 ||
                            (templateObject_4 = __makeTemplateObject(
                                [
                                    '\n    mutation addTrackProperties($session_id: ID!, $properties_object: Any) {\n  addTrackProperties(\n    session_id: $session_id\n    properties_object: $properties_object\n  )\n}\n    ',
                                ],
                                [
                                    '\n    mutation addTrackProperties($session_id: ID!, $properties_object: Any) {\n  addTrackProperties(\n    session_id: $session_id\n    properties_object: $properties_object\n  )\n}\n    ',
                                ]
                            ))
                    );
                    var InitializeSessionDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_5 ||
                            (templateObject_5 = __makeTemplateObject(
                                [
                                    '\n    mutation initializeSession($organization_verbose_id: String!) {\n  initializeSession(organization_verbose_id: $organization_verbose_id) {\n    id\n    user_id\n    organization_id\n  }\n}\n    ',
                                ],
                                [
                                    '\n    mutation initializeSession($organization_verbose_id: String!) {\n  initializeSession(organization_verbose_id: $organization_verbose_id) {\n    id\n    user_id\n    organization_id\n  }\n}\n    ',
                                ]
                            ))
                    );
                    var IgnoreDocument = graphql_tag__WEBPACK_IMPORTED_MODULE_0___default()(
                        templateObject_6 ||
                            (templateObject_6 = __makeTemplateObject(
                                [
                                    '\n    query Ignore($id: ID!) {\n  ignore(id: $id)\n}\n    ',
                                ],
                                [
                                    '\n    query Ignore($id: ID!) {\n  ignore(id: $id)\n}\n    ',
                                ]
                            ))
                    );
                    var defaultWrapper = function (sdkFunction) {
                        return sdkFunction();
                    };
                    function getSdk(client, withWrapper) {
                        if (withWrapper === void 0) {
                            withWrapper = defaultWrapper;
                        }
                        return {
                            PushPayload: function (variables, requestHeaders) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            PushPayloadDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                            identifySession: function (
                                variables,
                                requestHeaders
                            ) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            IdentifySessionDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                            addSessionProperties: function (
                                variables,
                                requestHeaders
                            ) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            AddSessionPropertiesDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                            addTrackProperties: function (
                                variables,
                                requestHeaders
                            ) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            AddTrackPropertiesDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                            initializeSession: function (
                                variables,
                                requestHeaders
                            ) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            InitializeSessionDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                            Ignore: function (variables, requestHeaders) {
                                return withWrapper(function () {
                                    return client.request(
                                        (0,
                                        graphql__WEBPACK_IMPORTED_MODULE_1__.print)(
                                            IgnoreDocument
                                        ),
                                        variables,
                                        requestHeaders
                                    );
                                });
                            },
                        };
                    }
                    var templateObject_1,
                        templateObject_2,
                        templateObject_3,
                        templateObject_4,
                        templateObject_5,
                        templateObject_6;

                    /***/
                },

            /***/ './src/index.tsx':
                /*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ HighlightWarning: () =>
                                /* binding */ HighlightWarning,
                            /* harmony export */ Highlight: () =>
                                /* binding */ Highlight,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
                        /*! @highlight-run/rrweb */ './node_modules/@highlight-run/rrweb/dist/index.js'
                    );
                    /* harmony import */ var _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/ __webpack_require__.n(
                        _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__
                    );
                    /* harmony import */ var _listeners_console_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ./listeners/console-listener */ './src/listeners/console-listener.tsx'
                    );
                    /* harmony import */ var _listeners_error_listener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                        /*! ./listeners/error-listener */ './src/listeners/error-listener.tsx'
                    );
                    /* harmony import */ var _listeners_path_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
                        /*! ./listeners/path-listener */ './src/listeners/path-listener.tsx'
                    );
                    /* harmony import */ var graphql_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
                        /*! graphql-request */ './node_modules/graphql-request/dist/index.js'
                    );
                    /* harmony import */ var graphql_request__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(
                        graphql_request__WEBPACK_IMPORTED_MODULE_3__
                    );
                    /* harmony import */ var _graph_generated_operations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
                        /*! ./graph/generated/operations */ './src/graph/generated/operations.ts'
                    );
                    /* harmony import */ var _listeners_tab_state_listener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
                        /*! ./listeners/tab-state-listener */ './src/listeners/tab-state-listener.tsx'
                    );
                    /* harmony import */ var _listeners_viewport_resize_listener__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
                        /*! ./listeners/viewport-resize-listener */ './src/listeners/viewport-resize-listener.tsx'
                    );
                    /* harmony import */ var _listeners_segment_integration_listener__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
                        /*! ./listeners/segment-integration-listener */ './src/listeners/segment-integration-listener.tsx'
                    );
                    /* harmony import */ var _listeners_click_listener_click_listener__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
                        /*! ./listeners/click-listener/click-listener */ './src/listeners/click-listener/click-listener.ts'
                    );
                    /* harmony import */ var _listeners_focus_listener_focus_listener__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
                        /*! ./listeners/focus-listener/focus-listener */ './src/listeners/focus-listener/focus-listener.ts'
                    );
                    var __assign =
                        (undefined && undefined.__assign) ||
                        function () {
                            __assign =
                                Object.assign ||
                                function (t) {
                                    for (
                                        var s, i = 1, n = arguments.length;
                                        i < n;
                                        i++
                                    ) {
                                        s = arguments[i];
                                        for (var p in s)
                                            if (
                                                Object.prototype.hasOwnProperty.call(
                                                    s,
                                                    p
                                                )
                                            )
                                                t[p] = s[p];
                                    }
                                    return t;
                                };
                            return __assign.apply(this, arguments);
                        };
                    var __awaiter =
                        (undefined && undefined.__awaiter) ||
                        function (thisArg, _arguments, P, generator) {
                            function adopt(value) {
                                return value instanceof P
                                    ? value
                                    : new P(function (resolve) {
                                          resolve(value);
                                      });
                            }
                            return new (P || (P = Promise))(function (
                                resolve,
                                reject
                            ) {
                                function fulfilled(value) {
                                    try {
                                        step(generator.next(value));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                                function rejected(value) {
                                    try {
                                        step(generator['throw'](value));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                                function step(result) {
                                    result.done
                                        ? resolve(result.value)
                                        : adopt(result.value).then(
                                              fulfilled,
                                              rejected
                                          );
                                }
                                step(
                                    (generator = generator.apply(
                                        thisArg,
                                        _arguments || []
                                    )).next()
                                );
                            });
                        };
                    var __generator =
                        (undefined && undefined.__generator) ||
                        function (thisArg, body) {
                            var _ = {
                                    label: 0,
                                    sent: function () {
                                        if (t[0] & 1) throw t[1];
                                        return t[1];
                                    },
                                    trys: [],
                                    ops: [],
                                },
                                f,
                                y,
                                t,
                                g;
                            return (
                                (g = {
                                    next: verb(0),
                                    throw: verb(1),
                                    return: verb(2),
                                }),
                                typeof Symbol === 'function' &&
                                    (g[Symbol.iterator] = function () {
                                        return this;
                                    }),
                                g
                            );
                            function verb(n) {
                                return function (v) {
                                    return step([n, v]);
                                };
                            }
                            function step(op) {
                                if (f)
                                    throw new TypeError(
                                        'Generator is already executing.'
                                    );
                                while (_)
                                    try {
                                        if (
                                            ((f = 1),
                                            y &&
                                                (t =
                                                    op[0] & 2
                                                        ? y['return']
                                                        : op[0]
                                                        ? y['throw'] ||
                                                          ((t = y['return']) &&
                                                              t.call(y),
                                                          0)
                                                        : y.next) &&
                                                !(t = t.call(y, op[1])).done)
                                        )
                                            return t;
                                        if (((y = 0), t))
                                            op = [op[0] & 2, t.value];
                                        switch (op[0]) {
                                            case 0:
                                            case 1:
                                                t = op;
                                                break;
                                            case 4:
                                                _.label++;
                                                return {
                                                    value: op[1],
                                                    done: false,
                                                };
                                            case 5:
                                                _.label++;
                                                y = op[1];
                                                op = [0];
                                                continue;
                                            case 7:
                                                op = _.ops.pop();
                                                _.trys.pop();
                                                continue;
                                            default:
                                                if (
                                                    !((t = _.trys),
                                                    (t =
                                                        t.length > 0 &&
                                                        t[t.length - 1])) &&
                                                    (op[0] === 6 || op[0] === 2)
                                                ) {
                                                    _ = 0;
                                                    continue;
                                                }
                                                if (
                                                    op[0] === 3 &&
                                                    (!t ||
                                                        (op[1] > t[0] &&
                                                            op[1] < t[3]))
                                                ) {
                                                    _.label = op[1];
                                                    break;
                                                }
                                                if (
                                                    op[0] === 6 &&
                                                    _.label < t[1]
                                                ) {
                                                    _.label = t[1];
                                                    t = op;
                                                    break;
                                                }
                                                if (t && _.label < t[2]) {
                                                    _.label = t[2];
                                                    _.ops.push(op);
                                                    break;
                                                }
                                                if (t[2]) _.ops.pop();
                                                _.trys.pop();
                                                continue;
                                        }
                                        op = body.call(thisArg, _);
                                    } catch (e) {
                                        op = [6, e];
                                        y = 0;
                                    } finally {
                                        f = t = 0;
                                    }
                                if (op[0] & 5) throw op[1];
                                return {
                                    value: op[0] ? op[1] : void 0,
                                    done: true,
                                };
                            }
                        };

                    var HighlightWarning = function (context, msg) {
                        console.warn('Highlight Warning: (' + context + '): ', {
                            output: msg,
                        });
                    };
                    var Logger = /** @class */ (function () {
                        function Logger(debug) {
                            this.debug = debug;
                        }
                        Logger.prototype.log = function () {
                            var data = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                data[_i] = arguments[_i];
                            }
                            if (this.debug) {
                                console.log.apply(console, data);
                            }
                        };
                        return Logger;
                    })();
                    /**
                     * The amount of time between sending the client-side payload to Highlight backend client.
                     * In milliseconds.
                     */
                    var SEND_FREQUENCY = 1000 * 5;
                    var Highlight = /** @class */ (function () {
                        function Highlight(options) {
                            var _a;
                            if (
                                typeof (options === null || options === void 0
                                    ? void 0
                                    : options.debug) === 'boolean'
                            ) {
                                this.debugOptions = options.debug
                                    ? { clientInteractions: true }
                                    : {};
                            } else {
                                this.debugOptions =
                                    (_a =
                                        options === null || options === void 0
                                            ? void 0
                                            : options.debug) !== null &&
                                    _a !== void 0
                                        ? _a
                                        : {};
                            }
                            this.ready = false;
                            this.disableNetworkRecording =
                                options.disableNetworkRecording;
                            this.disableConsoleRecording =
                                options.disableConsoleRecording;
                            this.enableSegmentIntegration =
                                options.enableSegmentIntegration;
                            this.logger = new Logger(
                                this.debugOptions.clientInteractions
                            );
                            var backend = (
                                options === null || options === void 0
                                    ? void 0
                                    : options.backendUrl
                            )
                                ? options.backendUrl
                                : 'https://api.highlight.run';
                            var client = new graphql_request__WEBPACK_IMPORTED_MODULE_3__.GraphQLClient(
                                backend + '/client',
                                { headers: {} }
                            );
                            this.graphqlSDK = (0,
                            _graph_generated_operations__WEBPACK_IMPORTED_MODULE_4__.getSdk)(
                                client
                            );
                            if (typeof options.organizationID === 'string') {
                                this.organizationID = options.organizationID;
                            } else if (
                                typeof options.organizationID === 'number'
                            ) {
                                this.organizationID = options.organizationID.toString();
                            } else {
                                this.organizationID = '';
                            }
                            this.sessionID = 0;
                            this.events = [];
                            this.errors = [];
                            this.networkContents = [];
                            this.messages = [];
                        }
                        Highlight.prototype.identify = function (
                            user_identifier,
                            user_object,
                            source
                        ) {
                            if (user_object === void 0) {
                                user_object = {};
                            }
                            return __awaiter(this, void 0, void 0, function () {
                                var sourceString;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (source === 'segment') {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                    'Segment Identify',
                                                    JSON.stringify(
                                                        __assign(
                                                            {
                                                                user_identifier: user_identifier,
                                                            },
                                                            user_object
                                                        )
                                                    )
                                                );
                                            } else {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                    'Identify',
                                                    JSON.stringify(
                                                        __assign(
                                                            {
                                                                user_identifier: user_identifier,
                                                            },
                                                            user_object
                                                        )
                                                    )
                                                );
                                            }
                                            return [
                                                4 /*yield*/,
                                                this.graphqlSDK.identifySession(
                                                    {
                                                        session_id: this.sessionID.toString(),
                                                        user_identifier: user_identifier,
                                                        user_object: user_object,
                                                    }
                                                ),
                                            ];
                                        case 1:
                                            _a.sent();
                                            sourceString =
                                                source === 'segment'
                                                    ? source
                                                    : 'default';
                                            this.logger.log(
                                                'Identify (' +
                                                    user_identifier +
                                                    ', source: ' +
                                                    sourceString +
                                                    ') w/ obj: ' +
                                                    JSON.stringify(
                                                        user_object
                                                    ) +
                                                    ' @ ' +
                                                    'https://api.highlight.run'
                                            );
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        Highlight.prototype.addProperties = function (
                            properties_obj,
                            typeArg
                        ) {
                            if (properties_obj === void 0) {
                                properties_obj = {};
                            }
                            return __awaiter(this, void 0, void 0, function () {
                                var sourceString;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (
                                                !(
                                                    (typeArg === null ||
                                                    typeArg === void 0
                                                        ? void 0
                                                        : typeArg.type) ===
                                                    'session'
                                                )
                                            )
                                                return [3 /*break*/, 2];
                                            return [
                                                4 /*yield*/,
                                                this.graphqlSDK.addSessionProperties(
                                                    {
                                                        session_id: this.sessionID.toString(),
                                                        properties_object: properties_obj,
                                                    }
                                                ),
                                            ];
                                        case 1:
                                            _a.sent();
                                            this.logger.log(
                                                'AddSessionProperties to session (' +
                                                    this.sessionID +
                                                    ') w/ obj: ' +
                                                    JSON.stringify(
                                                        properties_obj
                                                    ) +
                                                    ' @ ' +
                                                    'https://api.highlight.run'
                                            );
                                            return [3 /*break*/, 4];
                                        case 2:
                                            if (
                                                (typeArg === null ||
                                                typeArg === void 0
                                                    ? void 0
                                                    : typeArg.source) ===
                                                'segment'
                                            ) {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                    'Segment Track',
                                                    JSON.stringify(
                                                        properties_obj
                                                    )
                                                );
                                            } else {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                    'Track',
                                                    JSON.stringify(
                                                        properties_obj
                                                    )
                                                );
                                            }
                                            return [
                                                4 /*yield*/,
                                                this.graphqlSDK.addTrackProperties(
                                                    {
                                                        session_id: this.sessionID.toString(),
                                                        properties_object: properties_obj,
                                                    }
                                                ),
                                            ];
                                        case 3:
                                            _a.sent();
                                            sourceString =
                                                (typeArg === null ||
                                                typeArg === void 0
                                                    ? void 0
                                                    : typeArg.source) ===
                                                'segment'
                                                    ? typeArg.source
                                                    : 'default';
                                            this.logger.log(
                                                'AddTrackProperties to session (' +
                                                    this.sessionID +
                                                    ', source: ' +
                                                    sourceString +
                                                    ') w/ obj: ' +
                                                    JSON.stringify(
                                                        properties_obj
                                                    ) +
                                                    ' @ ' +
                                                    'https://api.highlight.run'
                                            );
                                            _a.label = 4;
                                        case 4:
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        // TODO: (organization_id is only here because of old clients, we should figure out how to version stuff).
                        Highlight.prototype.initialize = function (
                            organization_id
                        ) {
                            var _a, _b;
                            return __awaiter(this, void 0, void 0, function () {
                                var org_id,
                                    storedID,
                                    reloaded_1,
                                    gr,
                                    organization_id_1,
                                    emit,
                                    highlightThis_1,
                                    e_1;
                                var _this = this;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            org_id = '';
                                            if (
                                                typeof organization_id ===
                                                'number'
                                            ) {
                                                org_id = organization_id.toString();
                                            } else if (
                                                typeof organization_id ===
                                                'string'
                                            ) {
                                                org_id = organization_id;
                                            } else {
                                                org_id = '0';
                                            }
                                            _c.label = 1;
                                        case 1:
                                            _c.trys.push([1, 5, , 6]);
                                            if (organization_id) {
                                                this.organizationID = org_id;
                                            }
                                            storedID =
                                                Number(
                                                    window.sessionStorage.getItem(
                                                        'currentSessionID'
                                                    )
                                                ) || null;
                                            reloaded_1 = false;
                                            if (!storedID)
                                                return [3 /*break*/, 2];
                                            this.sessionID = storedID;
                                            reloaded_1 = true;
                                            return [3 /*break*/, 4];
                                        case 2:
                                            return [
                                                4 /*yield*/,
                                                this.graphqlSDK.initializeSession(
                                                    {
                                                        organization_verbose_id: this
                                                            .organizationID,
                                                    }
                                                ),
                                            ];
                                        case 3:
                                            gr = _c.sent();
                                            this.sessionID = parseInt(
                                                ((_a =
                                                    gr === null || gr === void 0
                                                        ? void 0
                                                        : gr.initializeSession) ===
                                                    null || _a === void 0
                                                    ? void 0
                                                    : _a.id) || '0'
                                            );
                                            organization_id_1 =
                                                (_b =
                                                    gr === null || gr === void 0
                                                        ? void 0
                                                        : gr.initializeSession) ===
                                                    null || _b === void 0
                                                    ? void 0
                                                    : _b.organization_id;
                                            this.logger.log(
                                                'Loaded Highlight\n  Remote: ' +
                                                    'https://api.highlight.run' +
                                                    '\n  Org ID: ' +
                                                    organization_id_1 +
                                                    '\n  Verbose Org ID: ' +
                                                    this.organizationID +
                                                    '\n  SessionID: ' +
                                                    this.sessionID +
                                                    '\n  Session Data:\n  ',
                                                gr.initializeSession
                                            );
                                            window.sessionStorage.setItem(
                                                'currentSessionID',
                                                this.sessionID.toString()
                                            );
                                            _c.label = 4;
                                        case 4:
                                            setTimeout(function () {
                                                _this._save();
                                            }, SEND_FREQUENCY);
                                            emit = function (event) {
                                                _this.events.push(event);
                                            };
                                            emit.bind(this);
                                            (0,
                                            _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.record)({
                                                ignoreClass: 'highlight-ignore',
                                                blockClass: 'highlight-block',
                                                emit: emit,
                                            });
                                            (0,
                                            _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)('Viewport', {
                                                height: window.innerHeight,
                                                width: window.innerWidth,
                                            });
                                            highlightThis_1 = this;
                                            if (this.enableSegmentIntegration) {
                                                (0,
                                                _listeners_segment_integration_listener__WEBPACK_IMPORTED_MODULE_7__.SegmentIntegrationListener)(
                                                    function (obj) {
                                                        if (
                                                            obj.type === 'track'
                                                        ) {
                                                            var properties = {};
                                                            properties[
                                                                'segment-event'
                                                            ] = obj.event;
                                                            highlightThis_1.addProperties(
                                                                properties,
                                                                {
                                                                    type:
                                                                        'track',
                                                                    source:
                                                                        'segment',
                                                                }
                                                            );
                                                        } else if (
                                                            obj.type ===
                                                            'identify'
                                                        ) {
                                                            highlightThis_1.identify(
                                                                obj.userId,
                                                                obj.traits,
                                                                'segment'
                                                            );
                                                        }
                                                    }
                                                );
                                            }
                                            if (document.referrer) {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                    'Referrer',
                                                    document.referrer
                                                );
                                                highlightThis_1.addProperties(
                                                    {
                                                        referrer:
                                                            document.referrer,
                                                    },
                                                    { type: 'session' }
                                                );
                                            }
                                            (0,
                                            _listeners_path_listener__WEBPACK_IMPORTED_MODULE_2__.PathListener)(function (url) {
                                                if (reloaded_1) {
                                                    (0,
                                                    _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                        'Reload',
                                                        url
                                                    );
                                                    reloaded_1 = false;
                                                    highlightThis_1.addProperties(
                                                        { reload: true },
                                                        { type: 'session' }
                                                    );
                                                } else {
                                                    (0,
                                                    _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                        'Navigate',
                                                        url
                                                    );
                                                }
                                                highlightThis_1.addProperties(
                                                    { 'visited-url': url },
                                                    { type: 'session' }
                                                );
                                            });
                                            if (!this.disableConsoleRecording) {
                                                (0,
                                                _listeners_console_listener__WEBPACK_IMPORTED_MODULE_0__.ConsoleListener)(
                                                    function (c) {
                                                        if (
                                                            c.type == 'Error' &&
                                                            c.value &&
                                                            c.trace
                                                        )
                                                            highlightThis_1.errors.push(
                                                                {
                                                                    event: JSON.stringify(
                                                                        c.value
                                                                    ),
                                                                    type:
                                                                        'console.error',
                                                                    url:
                                                                        window
                                                                            .location
                                                                            .href,
                                                                    source: c
                                                                        .trace[0]
                                                                        .fileName
                                                                        ? c
                                                                              .trace[0]
                                                                              .fileName
                                                                        : '',
                                                                    lineNumber: c
                                                                        .trace[0]
                                                                        .lineNumber
                                                                        ? c
                                                                              .trace[0]
                                                                              .lineNumber
                                                                        : 0,
                                                                    columnNumber: c
                                                                        .trace[0]
                                                                        .columnNumber
                                                                        ? c
                                                                              .trace[0]
                                                                              .columnNumber
                                                                        : 0,
                                                                    trace:
                                                                        c.trace,
                                                                }
                                                            );
                                                        highlightThis_1.messages.push(
                                                            c
                                                        );
                                                    }
                                                );
                                            }
                                            (0,
                                            _listeners_error_listener__WEBPACK_IMPORTED_MODULE_1__.ErrorListener)(function (e) {
                                                return highlightThis_1.errors.push(
                                                    e
                                                );
                                            });
                                            (0,
                                            _listeners_tab_state_listener__WEBPACK_IMPORTED_MODULE_5__.TabStateListener)(function (tabIsActive) {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)('Tab', tabIsActive);
                                            });
                                            (0,
                                            _listeners_viewport_resize_listener__WEBPACK_IMPORTED_MODULE_6__.ViewportResizeListener)(function (viewport) {
                                                (0,
                                                _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)('Viewport', viewport);
                                            });
                                            (0,
                                            _listeners_click_listener_click_listener__WEBPACK_IMPORTED_MODULE_8__.ClickListener)(function (clickTarget) {
                                                if (clickTarget) {
                                                    (0,
                                                    _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                        'Click',
                                                        clickTarget
                                                    );
                                                }
                                            });
                                            (0,
                                            _listeners_focus_listener_focus_listener__WEBPACK_IMPORTED_MODULE_9__.FocusListener)(function (focusTarget) {
                                                if (focusTarget) {
                                                    (0,
                                                    _highlight_run_rrweb__WEBPACK_IMPORTED_MODULE_10__.addCustomEvent)(
                                                        'Focus',
                                                        focusTarget
                                                    );
                                                }
                                            });
                                            this.ready = true;
                                            return [3 /*break*/, 6];
                                        case 5:
                                            e_1 = _c.sent();
                                            HighlightWarning(
                                                'initializeSession',
                                                e_1
                                            );
                                            return [3 /*break*/, 6];
                                        case 6:
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        // Reset the events array and push to a backend.
                        Highlight.prototype._save = function () {
                            return __awaiter(this, void 0, void 0, function () {
                                var resources,
                                    resourcesString,
                                    messagesString,
                                    e_2;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 2, , 3]);
                                            if (!this.sessionID) {
                                                return [2 /*return*/];
                                            }
                                            resources = [];
                                            if (!this.disableNetworkRecording) {
                                                // get all resources that don't include 'api.highlight.run'
                                                resources = performance
                                                    .getEntriesByType(
                                                        'resource'
                                                    )
                                                    .filter(function (r) {
                                                        var _a;
                                                        return !r.name.includes(
                                                            (_a =
                                                                'https://api.highlight.run') !==
                                                                null &&
                                                                _a !== void 0
                                                                ? _a
                                                                : 'https://api.highlight.run'
                                                        );
                                                    });
                                            }
                                            resourcesString = JSON.stringify({
                                                resources: resources,
                                            });
                                            messagesString = JSON.stringify({
                                                messages: this.messages,
                                            });
                                            this.logger.log(
                                                'Sending: ' +
                                                    this.events.length +
                                                    ' events, ' +
                                                    this.messages.length +
                                                    ' messages, ' +
                                                    resources.length +
                                                    ' network resources, ' +
                                                    this.errors.length +
                                                    ' errors \nTo: ' +
                                                    'https://api.highlight.run' +
                                                    '\nOrg: ' +
                                                    this.organizationID +
                                                    '\nSessionID: ' +
                                                    this.sessionID
                                            );
                                            if (!this.disableNetworkRecording) {
                                                performance.clearResourceTimings();
                                            }
                                            return [
                                                4 /*yield*/,
                                                this.graphqlSDK.PushPayload({
                                                    session_id: this.sessionID.toString(),
                                                    events: {
                                                        events: this.events,
                                                    },
                                                    messages: messagesString,
                                                    resources: resourcesString,
                                                    errors: this.errors,
                                                }),
                                            ];
                                        case 1:
                                            _a.sent();
                                            this.events = [];
                                            this.errors = [];
                                            this.messages = [];
                                            this.networkContents = [];
                                            return [3 /*break*/, 3];
                                        case 2:
                                            e_2 = _a.sent();
                                            HighlightWarning('_save', e_2);
                                            return [3 /*break*/, 3];
                                        case 3:
                                            setTimeout(function () {
                                                _this._save();
                                            }, SEND_FREQUENCY);
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        return Highlight;
                    })();

                    window.Highlight = Highlight;

                    /***/
                },

            /***/ './src/listeners/click-listener/click-listener.ts':
                /*!********************************************************!*\
  !*** ./src/listeners/click-listener/click-listener.ts ***!
  \********************************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ ClickListener: () =>
                                /* binding */ ClickListener,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ../../utils/dom */ './src/utils/dom/index.ts'
                    );

                    var ClickListener = function (callback) {
                        window.addEventListener('click', function (event) {
                            if (event.target) {
                                var targetSelector = (0,
                                _utils_dom__WEBPACK_IMPORTED_MODULE_0__.getElementSelector)(
                                    event.target
                                );
                                callback(targetSelector);
                            }
                        });
                    };

                    /***/
                },

            /***/ './src/listeners/console-listener.tsx':
                /*!********************************************!*\
  !*** ./src/listeners/console-listener.tsx ***!
  \********************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ ConsoleListener: () =>
                                /* binding */ ConsoleListener,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var stacktrace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! stacktrace-js */ './node_modules/stacktrace-js/stacktrace.js'
                    );
                    /* harmony import */ var stacktrace_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                        stacktrace_js__WEBPACK_IMPORTED_MODULE_0__
                    );

                    // taken from: https://stackoverflow.com/questions/19846078/how-to-read-from-chromes-console-in-javascript
                    var ConsoleListener = function (callback) {
                        console.defaultLog = console.log.bind(console);
                        console.log = function () {
                            callback({
                                type: 'Log',
                                time: Date.now(),
                                value: Array.from(arguments),
                            });
                            console.defaultLog.apply(console, arguments);
                        };
                        console.defaultError = console.error.bind(console);
                        console.error = function () {
                            var errorArgs = arguments;
                            stacktrace_js__WEBPACK_IMPORTED_MODULE_0___default()
                                .get()
                                .then(function (result) {
                                    callback({
                                        type: 'Error',
                                        time: Date.now(),
                                        value: Array.from(errorArgs),
                                        trace: result.slice(1),
                                    });
                                });
                            console.defaultError.apply(console, arguments);
                        };
                        console.defaultWarn = console.warn.bind(console);
                        console.warn = function () {
                            callback({
                                type: 'Warn',
                                time: Date.now(),
                                value: Array.from(arguments),
                            });
                            console.defaultWarn.apply(console, arguments);
                        };
                        console.defaultDebug = console.debug.bind(console);
                        console.debug = function () {
                            callback({
                                type: 'Debug',
                                time: Date.now(),
                                value: Array.from(arguments),
                            });
                            console.defaultDebug.apply(console, arguments);
                        };
                    };

                    /***/
                },

            /***/ './src/listeners/error-listener.tsx':
                /*!******************************************!*\
  !*** ./src/listeners/error-listener.tsx ***!
  \******************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ ErrorListener: () =>
                                /* binding */ ErrorListener,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var stacktrace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! stacktrace-js */ './node_modules/stacktrace-js/stacktrace.js'
                    );
                    /* harmony import */ var stacktrace_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                        stacktrace_js__WEBPACK_IMPORTED_MODULE_0__
                    );

                    var ErrorListener = function (callback) {
                        window.onerror = function (
                            event,
                            source,
                            lineno,
                            colno,
                            error
                        ) {
                            if (error) {
                                stacktrace_js__WEBPACK_IMPORTED_MODULE_0___default()
                                    .fromError(error)
                                    .then(function (result) {
                                        callback({
                                            event: JSON.stringify(event),
                                            type: 'window.onerror',
                                            url: window.location.href,
                                            source: source ? source : '',
                                            lineNumber: result[0].lineNumber
                                                ? result[0].lineNumber
                                                : 0,
                                            columnNumber: result[0].columnNumber
                                                ? result[0].columnNumber
                                                : 0,
                                            trace: result,
                                        });
                                    });
                            }
                        };
                    };

                    /***/
                },

            /***/ './src/listeners/focus-listener/focus-listener.ts':
                /*!********************************************************!*\
  !*** ./src/listeners/focus-listener/focus-listener.ts ***!
  \********************************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ FocusListener: () =>
                                /* binding */ FocusListener,
                            /* harmony export */
                        }
                    );
                    /* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                        /*! ../../utils/dom */ './src/utils/dom/index.ts'
                    );

                    var FocusListener = function (callback) {
                        window.addEventListener('focusin', function (event) {
                            if (event.target) {
                                var targetSelector = (0,
                                _utils_dom__WEBPACK_IMPORTED_MODULE_0__.getElementSelector)(
                                    event.target
                                );
                                callback(targetSelector);
                            }
                        });
                    };

                    /***/
                },

            /***/ './src/listeners/path-listener.tsx':
                /*!*****************************************!*\
  !*** ./src/listeners/path-listener.tsx ***!
  \*****************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ PathListener: () =>
                                /* binding */ PathListener,
                            /* harmony export */
                        }
                    );
                    // taken from: https://stackoverflow.com/questions/6390341/how-to-detect-if-url-has-changed-after-hash-in-javascript/52809105#52809105
                    var PathListener = function (callback) {
                        callback(window.location.href);
                        history.pushState = (function (f) {
                            return function pushState() {
                                // @ts-ignore
                                var ret = f.apply(this, arguments);
                                window.dispatchEvent(new Event('pushstate'));
                                window.dispatchEvent(
                                    new Event('locationchange')
                                );
                                return ret;
                            };
                        })(history.pushState);
                        history.replaceState = (function (f) {
                            return function replaceState() {
                                // @ts-ignore
                                var ret = f.apply(this, arguments);
                                window.dispatchEvent(new Event('replacestate'));
                                window.dispatchEvent(
                                    new Event('locationchange')
                                );
                                return ret;
                            };
                        })(history.replaceState);
                        window.addEventListener('popstate', function () {
                            window.dispatchEvent(new Event('locationchange'));
                        });
                        window.addEventListener('locationchange', function () {
                            callback(window.location.href);
                        });
                    };

                    /***/
                },

            /***/ './src/listeners/segment-integration-listener.tsx':
                /*!********************************************************!*\
  !*** ./src/listeners/segment-integration-listener.tsx ***!
  \********************************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ SegmentIntegrationListener: () =>
                                /* binding */ SegmentIntegrationListener,
                            /* harmony export */
                        }
                    );
                    var SegmentIntegrationListener = function (callback) {
                        callback(window.location.href);
                        var send = XMLHttpRequest.prototype.send;
                        XMLHttpRequest.prototype.send = function (data) {
                            setTimeout(function () {
                                var _a;
                                var obj;
                                try {
                                    obj = JSON.parse(
                                        (_a =
                                            data === null || data === void 0
                                                ? void 0
                                                : data.toString()) !== null &&
                                            _a !== void 0
                                            ? _a
                                            : ''
                                    );
                                } catch (e) {
                                    return;
                                }
                                if (
                                    obj.type === 'track' ||
                                    obj.type === 'identify'
                                ) {
                                    callback(obj);
                                }
                            }, 100);
                            send.call(this, data);
                        };
                    };

                    /***/
                },

            /***/ './src/listeners/tab-state-listener.tsx':
                /*!**********************************************!*\
  !*** ./src/listeners/tab-state-listener.tsx ***!
  \**********************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ TabStateListener: () =>
                                /* binding */ TabStateListener,
                            /* harmony export */
                        }
                    );
                    /**
                     * Listens to when the tab becomes active or not active.
                     * Active: The tab is in focused
                     * Not Active: The user has switched to another tab or window.
                     * Supported on all browsers: https://developer.mozilla.org/en-US/docs/Web/API/Document/hidden
                     */
                    var TabStateListener = function (callback) {
                        document.addEventListener(
                            'visibilitychange',
                            function () {
                                callback(
                                    window.document.hidden ? 'Hidden' : 'Active'
                                );
                            }
                        );
                    };

                    /***/
                },

            /***/ './src/listeners/viewport-resize-listener.tsx':
                /*!****************************************************!*\
  !*** ./src/listeners/viewport-resize-listener.tsx ***!
  \****************************************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ ViewportResizeListener: () =>
                                /* binding */ ViewportResizeListener,
                            /* harmony export */
                        }
                    );
                    /**
                     * Listens to when resize events on the viewport.
                     * Takes the last value after DELAY ms passes. We're doing this to avoid taking the intermediate values while the user is resizing.
                     */
                    var ViewportResizeListener = function (callback) {
                        var id;
                        var DELAY = 500;
                        window.addEventListener('resize', function () {
                            clearTimeout(id);
                            id = setTimeout(function () {
                                callback({
                                    height: window.innerHeight,
                                    width: window.innerWidth,
                                });
                            }, DELAY);
                        });
                    };

                    /***/
                },

            /***/ './src/utils/dom/index.ts':
                /*!********************************!*\
  !*** ./src/utils/dom/index.ts ***!
  \********************************/
                /***/ (
                    __unused_webpack_module,
                    __webpack_exports__,
                    __webpack_require__
                ) => {
                    'use strict';
                    __webpack_require__.r(__webpack_exports__);
                    /* harmony export */ __webpack_require__.d(
                        __webpack_exports__,
                        {
                            /* harmony export */ getElementSelector: () =>
                                /* binding */ getElementSelector,
                            /* harmony export */
                        }
                    );
                    /**
                     * Gets a CSS selector for a given element. Will default to the element's tag name if there are no class name or id.
                     */
                    var getElementSelector = function (element) {
                        var selector = '';
                        var classNames = element.getAttribute('class');
                        var ids = element.getAttribute('id');
                        if (ids) {
                            selector = selector.concat(
                                getSelectorString(ids, '#')
                            );
                        }
                        if (classNames) {
                            selector = selector.concat(
                                getSelectorString(classNames, '.')
                            );
                        }
                        // Default to the element's tag if the element doesn't have ids or class names.
                        if (selector === '') {
                            selector = selector.concat(
                                element.tagName.toLowerCase()
                            );
                        }
                        return selector;
                    };
                    var getSelectorString = function (selector, delimiter) {
                        return (
                            '' +
                            delimiter +
                            selector.trim().split(' ').join(delimiter)
                        );
                    };

                    /***/
                },

            /******/
        }; // The module cache
        /************************************************************************/
        /******/ /******/ var __webpack_module_cache__ = {}; // The require function
        /******/
        /******/ /******/ function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ if (__webpack_module_cache__[moduleId]) {
                /******/ return __webpack_module_cache__[moduleId].exports;
                /******/
            } // Create a new module (and put it into the cache)
            /******/ /******/ var module = (__webpack_module_cache__[
                moduleId
            ] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {},
                /******/
            }); // Execute the module function
            /******/
            /******/ /******/ __webpack_modules__[moduleId].call(
                module.exports,
                module,
                module.exports,
                __webpack_require__
            ); // Return the exports of the module
            /******/
            /******/ /******/ return module.exports;
            /******/
        } /* webpack/runtime/compat get default export */
        /******/
        /************************************************************************/
        /******/ /******/ (() => {
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __webpack_require__.n = (module) => {
                /******/ var getter =
                    module && module.__esModule
                        ? /******/ () => module['default']
                        : /******/ () => module;
                /******/ __webpack_require__.d(getter, { a: getter });
                /******/ return getter;
                /******/
            };
            /******/
        })(); /* webpack/runtime/define property getters */
        /******/
        /******/ /******/ (() => {
            /******/ // define getter functions for harmony exports
            /******/ __webpack_require__.d = (exports, definition) => {
                /******/ for (var key in definition) {
                    /******/ if (
                        __webpack_require__.o(definition, key) &&
                        !__webpack_require__.o(exports, key)
                    ) {
                        /******/ Object.defineProperty(exports, key, {
                            enumerable: true,
                            get: definition[key],
                        });
                        /******/
                    }
                    /******/
                }
                /******/
            };
            /******/
        })(); /* webpack/runtime/hasOwnProperty shorthand */
        /******/
        /******/ /******/ (() => {
            /******/ __webpack_require__.o = (obj, prop) =>
                Object.prototype.hasOwnProperty.call(obj, prop);
            /******/
        })(); /* webpack/runtime/make namespace object */
        /******/
        /******/ /******/ (() => {
            /******/ // define __esModule on exports
            /******/ __webpack_require__.r = (exports) => {
                /******/ if (
                    typeof Symbol !== 'undefined' &&
                    Symbol.toStringTag
                ) {
                    /******/ Object.defineProperty(
                        exports,
                        Symbol.toStringTag,
                        { value: 'Module' }
                    );
                    /******/
                }
                /******/ Object.defineProperty(exports, '__esModule', {
                    value: true,
                });
                /******/
            };
            /******/
        })(); // module exports must be returned from runtime so entry inlining is disabled // startup // Load entry module and return exports
        /******/
        /************************************************************************/
        /******/ /******/ /******/ /******/ return __webpack_require__(
            './src/index.tsx'
        );
        /******/
    })();
});
//# sourceMappingURL=index.js.map

!(function (t, n) {
    'object' == typeof exports && 'object' == typeof module
        ? (module.exports = n())
        : 'function' == typeof define && define.amd
        ? define([], n)
        : 'object' == typeof exports
        ? (exports.highlightLib = n())
        : (t.highlightLib = n());
})(this, function () {
    return (function (t) {
        var n = {};
        function e(i) {
            if (n[i]) return n[i].exports;
            var r = (n[i] = { i: i, l: !1, exports: {} });
            return t[i].call(r.exports, r, r.exports, e), (r.l = !0), r.exports;
        }
        return (
            (e.m = t),
            (e.c = n),
            (e.d = function (t, n, i) {
                e.o(t, n) ||
                    Object.defineProperty(t, n, { enumerable: !0, get: i });
            }),
            (e.r = function (t) {
                'undefined' != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                        value: 'Module',
                    }),
                    Object.defineProperty(t, '__esModule', { value: !0 });
            }),
            (e.t = function (t, n) {
                if ((1 & n && (t = e(t)), 8 & n)) return t;
                if (4 & n && 'object' == typeof t && t && t.__esModule)
                    return t;
                var i = Object.create(null);
                if (
                    (e.r(i),
                    Object.defineProperty(i, 'default', {
                        enumerable: !0,
                        value: t,
                    }),
                    2 & n && 'string' != typeof t)
                )
                    for (var r in t)
                        e.d(
                            i,
                            r,
                            function (n) {
                                return t[n];
                            }.bind(null, r)
                        );
                return i;
            }),
            (e.n = function (t) {
                var n =
                    t && t.__esModule
                        ? function () {
                              return t.default;
                          }
                        : function () {
                              return t;
                          };
                return e.d(n, 'a', n), n;
            }),
            (e.o = function (t, n) {
                return Object.prototype.hasOwnProperty.call(t, n);
            }),
            (e.p = ''),
            e((e.s = 0))
        );
    })([
        function (t, n, e) {
            'use strict';
            e.r(n),
                e.d(n, 'H', function () {
                    return l;
                });
            var i,
                r,
                o = function () {
                    return (o =
                        Object.assign ||
                        function (t) {
                            for (var n, e = 1, i = arguments.length; e < i; e++)
                                for (var r in (n = arguments[e]))
                                    Object.prototype.hasOwnProperty.call(
                                        n,
                                        r
                                    ) && (t[r] = n[r]);
                            return t;
                        }).apply(this, arguments);
                },
                a = function (t, n) {
                    console.warn('Highlight Warning: (' + t + '): ', n);
                },
                l = {
                    options: void 0,
                    init: function (t, n) {
                        try {
                            (l.options = n),
                                (i = document.createElement('script'));
                            var e = (null == n ? void 0 : n.scriptUrl)
                                ? n.scriptUrl
                                : 'https://static.highlight.run/index.js';
                            i.setAttribute(
                                'src',
                                e + '?' + new Date().getMilliseconds()
                            ),
                                i.setAttribute('type', 'text/javascript'),
                                document
                                    .getElementsByTagName('head')[0]
                                    .appendChild(i),
                                i.addEventListener('load', function () {
                                    (r = new window.Highlight({
                                        organizationID: t,
                                        debug: null == n ? void 0 : n.debug,
                                        backendUrl:
                                            null == n ? void 0 : n.backendUrl,
                                        disableNetworkRecording:
                                            null == n
                                                ? void 0
                                                : n.disableNetworkRecording,
                                        disableConsoleRecording:
                                            null == n
                                                ? void 0
                                                : n.disableConsoleRecording,
                                        enableSegmentIntegration:
                                            null == n
                                                ? void 0
                                                : n.enableSegmentIntegration,
                                    })),
                                        (null == n ? void 0 : n.manualStart) ||
                                            r.initialize(t);
                                });
                        } catch (t) {
                            a('init', t);
                        }
                    },
                    track: function (t, n) {
                        try {
                            l.onHighlightReady(function () {
                                return r.addProperties(
                                    o(o({}, n), { event: t })
                                );
                            });
                        } catch (t) {
                            a('track', t);
                        }
                    },
                    start: function () {
                        var t;
                        try {
                            if (
                                null === (t = l.options) || void 0 === t
                                    ? void 0
                                    : t.manualStart
                            )
                                var n = setInterval(function () {
                                    r && (clearInterval(n), r.initialize());
                                }, 200);
                            else
                                console.warn(
                                    "Highlight Error: Can't call `start()` without setting `manualStart` option in `H.init`"
                                );
                        } catch (t) {
                            a('start', t);
                        }
                    },
                    identify: function (t, n) {
                        try {
                            l.onHighlightReady(function () {
                                return r.identify(t, n);
                            });
                        } catch (t) {
                            a('identify', t);
                        }
                    },
                    getSessionURL: function () {
                        return new Promise(function (t, n) {
                            l.onHighlightReady(function () {
                                var e = r.organizationID,
                                    i = r.sessionID;
                                e && i
                                    ? t(
                                          'app.highlight.run/' +
                                              e +
                                              '/sessions/' +
                                              i
                                      )
                                    : n(
                                          new Error(
                                              'org ID or session ID is empty'
                                          )
                                      );
                            });
                        });
                    },
                    onHighlightReady: function (t) {
                        try {
                            r && r.ready && t();
                            var n = setInterval(function () {
                                r && r.ready && (clearInterval(n), t());
                            }, 200);
                        } catch (t) {
                            a('onHighlightReady', t);
                        }
                    },
                };
            'undefined' != typeof window && (window.H = l);
        },
    ]);
}); //# sourceMappingURL=index.js.map

sessionStorage.removeItem('currentSessionID');
window.H.init('wve623dp');

const emails = [
    'glongmead0@msn.com',
    'nbrownsey1@archive.org',
    'jmacascaidh2@hatena.ne.jp',
    'kpicopp3@pagesperso-orange.fr',
    'cdambrogio4@g.co',
    'ebilby5@ycombinator.com',
    'bcowup6@fastcompany.com',
    'mgaffney7@illinois.edu',
    'cetherington8@altervista.org',
    'snewey9@dailymotion.com',
    'sgoldesa@wikipedia.org',
    'gjeffryb@opera.com',
    'jbrucknerc@usda.gov',
    'kchristleyd@dedecms.com',
    'dcobaine@plala.or.jp',
    'cpeidrof@sbwire.com',
    'mslowang@flavors.me',
    'jpiperleyh@mail.ru',
    'etarbeti@narod.ru',
    'mhanscombj@washingtonpost.com',
];
window.H.identify(emails[Math.floor(Math.random() * emails.length)]);
