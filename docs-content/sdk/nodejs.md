---
title: Node.JS SDK API Reference
slug: nodejs
---

<section className="section">
  <div className="left">
    <h3>Node.js SDK</h3>
    <p>
      Highlight's Node.js SDK makes it easy to monitor errors and metrics on your Node.js backend.
    </p>
  </div>
  <div className="right">
    <h6>Just getting started?</h6>
    <p>Check out our [getting started guide](../getting-started/4_server/2_js/1_overview.md) to get up and running quickly.</p>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.init</h3>
    <p>H.init() initializes the Highlight backend SDK. If you are not using any of the provided handlers for [Express](../getting-started/4_server/2_js/express.md), it is required to call this method before recording backend errors or metrics.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>options<code>NodeOptions</code> <code>required</code></h5>
      <p>The configuration for Highlight backend monitoring.</p>
      <article className="innerParameterContainer">
        <aside className="innerParameterHeading">options properties</aside>
        <aside className="parameter">
          <h5>projectID <code>string</code> <code>required</code></h5>
          <p>Your project ID as provided by the [setup page](https://app.highlight.io/setup).</p>
        </aside>
        <aside className="parameter">
          <h5>serviceName <code>string</code> <code>optional</code></h5>
          <p>The name of your app.</p>
        </aside>
        <aside className="parameter">
          <h5>serviceVersion <code>string</code> <code>optional</code></h5>
          <p>The version of this app. We recommend setting this to the most recent deploy SHA of your app.</p>
        </aside>
        <aside className="parameter">
          <h5>disableErrorSourceContext <code>boolean</code> <code>optional</code></h5>
          <p>Disables source code context lines for error reporting. This may be useful for performance if your source files are particularly large or memory is limited.</p>
        </aside>
        <aside className="parameter">
          <h5>errorSourceContextCacheSizeMB <code>number</code> <code>optional</code></h5>
          <p>Source files are cached in memory to speed up error reporting and avoid costly disk access. The default cache size is 10MB, but this can be overridden. Specifying a value <= 0 removes all cache size limits.</p>
        </aside>
      </article>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      if (!H.isInitialized()) {
        H.init({
          projectID: "<YOUR_PROJECT_ID>",
          serviceName: "my-node-app",
          serviceVersion: "git-sha",
        });
      }
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.isInitialized</h3>
    <p>H.isInitialized() returns true if the Highlight backend SDK has been initialized. This may be handy if your initialization code could be called multiple times, e.g. if it is called conditionally from a request handler when a backend error or metric needs to be recorded.</p>
  </div>
  <div className="right">
    <code>
    
      import { H } from "@highlight-run/node";

      if (!H.isInitialized()) {
        H.init({
          projectID: "<YOUR_PROJECT_ID>",
          serviceName: "my-node-app",
          serviceVersion: "git-sha",
        });
      }
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.consumeError</h3>
    <p>H.consumeError() reports an error and its corresponding stack trace to Highlight. The secureSessionId  and requestId  properties are Highlight ids used to link an error to the session in which the error was thrown. These properties are sent via a header and included in every request to your backend once the Highlight client is initialized. They can be parsed using the H.parseHeaders() helper method.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>error<code>Error</code> <code>required</code></h5>
      <p>The error being reported to Highlight.</p>
    </aside>
    <aside className="parameter">
      <h5>secureSessionId<code>string</code> <code>required</code></h5>
      <p>A randomized id representing the Highlight session in which an error was thrown. This can be parsed from the network request's headers using H.parseHeaders().</p>
    </aside>
    <aside className="parameter">
      <h5>requestId<code>string</code> <code>required</code></h5>
      <p>A randomized id generated by the Highlight client representing the request for which an error was thrown. This can be parsed from the network request's headers using H.parseHeaders().</p>
    </aside>
    <aside className="parameter">
      <h5>metadata<code>object</code> <code>optional</code></h5>
      <p>Key-value pairs of metadata that should be associated with the error.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      import * as http from 'http';
      import { H } from "@highlight-run/node";

      const onError = (request: http.IncomingMessage, error: Error): void => {
        const parsed = H.parseHeaders(request.headers);
        if (parsed !== undefined) {
          H.consumeError(error, parsed.secureSessionId, parsed.requestId, {"url": request.url})
        }
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordMetric</h3>
    <p>H.recordMetric() reports a point-in-time metric to Highlight. Backend metrics can be used just like frontend metrics for creating custom dashboards. </p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>metric<code>Object</code> <code>required</code></h5>
      <p>A metric represented by the name, value, and optional attributes.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      
      import { H } from "@highlight-run/node";

      const handler = (request) => {
        const parsed = H.parseHeaders(request.headers);
        const start = Date.now();
        doInterestingWork();
        const elapsed = Date.now() - start;
        H.recordMetric({name: "elapsedTimeMs", value: elapsed});
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordCount</h3>
    <p>H.recordCount() reports a cumulative count metric to Highlight. For instance, this may be a total number of database rows queried. </p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>metric<code>Object</code> <code>required</code></h5>
      <p>A metric represented by the name, value, and optional attributes.</p>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      const handler = (request) => {
        const rows = db.get_rows();
        H.recordCount({name: "db.rows", value: rows.length});
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordIncr</h3>
    <p>H.recordIncr() reports a cumulative increment (+1) metric to Highlight. For instance, this may be a total number of requests serviced. </p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>metric<code>Object</code> <code>required</code></h5>
      <p>A metric represented by the name, value, and optional attributes.</p>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      const handler = (request) => {
        doWork();
        H.recordIncr({name: "http.requests"});
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordHistogram</h3>
    <p>H.recordHistogram() reports a point-in-time metric to Highlight that is then aggregated into histogram quantiles for high level analysis. For instance, this may be a floating value corresponding to the difficulty of an operation. </p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>metric<code>Object</code> <code>required</code></h5>
      <p>A metric represented by the name, value, and optional attributes.</p>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      const handler = (request) => {
        doWork();
        // measure some value about the code-path
        const difficulty = 1.23;
        H.recordHistogram({name: "work.difficulty", value: difficulty});
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordUpDownCounter</h3>
    <p>H.recordUpDownCounter() reports a counter metric to Highlight that may be incremented or decremented.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>metric<code>Object</code> <code>required</code></h5>
      <p>A metric represented by the name, value, and optional attributes.</p>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      const handler = (request) => {
        const isActive = checkUserActivity();
        const value = isActive ? 1 : -1;
        H.recordUpDownCounter({name: "users", value: value});
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.parseHeaders</h3>
    <p>H.parseHeaders() is a helper function for extracting the Highlight secureSessionId and requestId from network requests. These fields are sent with network requests as the 'x-highlight-request' header, encoded as a slash-separated string: "{secureSessionId}/{requestId}"</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>headers<code>IncomingHttpHeaders</code> <code>required</code></h5>
      <p>The headers sent as part of your network request.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      import * as http from "http";
      import { H } from "@highlight-run/node";

      const onError = (request: http.IncomingMessage, error: Error): void => {
        const parsed = H.parseHeaders(request.headers);
        if (parsed !== undefined) {
          H.consumeError(error, parsed.secureSessionId, parsed.requestId)
        }
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.runWithHeaders</h3>
    <p>H.runWithHeaders() wraps its callback with a span named highlight-ctx, and spreads Highlight's secureSessionId and requestId across all spans with matching a traceId.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>headers<code>IncomingHttpHeaders</code> <code>required</code></h5>
      <p>The headers sent with your network request.</p>
    </aside>
    <aside className="parameter">
      <h5>callback <code>required</code></h5>
      <p>Code to execute</p>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>callback return value</h5>
      <p>Returns a Promise that resolves to the callback's return value.</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const onError = async (request: http.IncomingMessage, error: Error): void => {
    const callbackResult = await H.runWithHeaders&lt;ReturnType&gt;(req.headers, async () => {
        const { span } = H.startWithHeaders('custom-span-name', {})
        // do work
        span.end();
      });
};
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.startWithHeaders</h3>
    <p>H.startWithHeaders() returns a Span and a Span Context to propagate the current trace to child spans.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>name<code>string</code> <code>required</code></h5>
      <p>Custom span name</p>
    </aside>
    <aside className="parameter">
      <h5>headers<code>http.Headers</code> <code>required</code></h5>
      <p>A headers object corresponding to the incoming http request headers. Can be an empty object: <code>{}</code></p>
    </aside>
    <aside className="parameter">
      <h5>options <code>optional</code></h5>
      <p>SpanOptions as exported from @opentelemetry/api</p>
      <article className="innerParameterContainer">
        <aside className="innerParameterHeading">options properties</aside>
        <aside className="parameter">
          <h5>kind <code>SpanKind</code> <code>optional</code></h5>
          <p>import { SpanKind } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>attributes <code>SpanAttributes</code> <code>optional</code></h5>
          <p>import { SpanAttributes } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>links <code>Link[]</code> <code>optional</code></h5>
          <p>import { Link } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>startTime <code>TimeInput</code> <code>optional</code></h5>
          <p>import { TimeInput } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>root <code>boolean</code> <code>optional</code></h5>
          <p>The new span should be a root span</p>
        </aside>
        
      </article>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>span</h5>
      <p>Returns the started span</p>
    </aside>
    <aside className="parameter">
      <h5>ctx</h5>
      <p>Returns the context of the current span for trace propagation</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const { span } = H.startWithHeaders("custom-span-name", {});
        // do work
        span.end();
});
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.waitForFlush</h3>
    <p>H.waitForFlush() waits for spans to be added to the queue and for the queue to empty.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>expectedSpanNames<code>string[]</code> <code>optional</code></h5>
      <p>Span names to wait for</p>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>Promise</h5>
      <p>Returns a Promise that resolves upon a successful flush</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const { span } = await H.startWithHeaders('my-custom-span-name', {});

// do work

span.end();

await H.waitForFlush(['my-custom-span-name']);
    </code>
  </div>
</section>
