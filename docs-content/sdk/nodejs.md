---
title: Node.JS SDK API Reference
slug: nodejs
---

<section className="section">
  <div className="left">
    <h3>Node.js SDK</h3>
    <p>
      Highlight's Node.js SDK makes it easy to monitor errors and metrics on your Node.js backend.
    </p>
  </div>
  <div className="right">
    <h6>Just getting started?</h6>
    <p>Check out our [getting started guide](../getting-started/4_backend-sdk/03_js/1_overview.md) to get up and running quickly.</p>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.init</h3>
    <p>H.init() initializes the Highlight backend SDK. If you are not using any of the provided handlers for [Express](../getting-started/4_backend-sdk/03_js/express.md), it is required to call this method before recording backend errors or metrics.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>options<code>NodeOptions</code> <code>required</code></h5>
      <p>The configuration for Highlight backend monitoring.</p>
      <article className="innerParameterContainer">
        <aside className="innerParameterHeading">options properties</aside>
        <aside className="parameter">
          <h5>projectID <code>string</code> <code>required</code></h5>
          <p>Your project ID as provided by the [setup page](https://app.highlight.io/setup).</p>
        </aside>
        <aside className="parameter">
          <h5>serviceName <code>string</code> <code>optional</code></h5>
          <p>The name of your app.</p>
        </aside>
        <aside className="parameter">
          <h5>serviceVersion <code>string</code> <code>optional</code></h5>
          <p>The version of this app. We recommend setting this to the most recent deploy SHA of your app.</p>
        </aside>
        <aside className="parameter">
          <h5>disableErrorSourceContext <code>boolean</code> <code>optional</code></h5>
          <p>Disables source code context lines for error reporting. This may be useful for performance if your source files are particularly large or memory is limited.</p>
        </aside>
        <aside className="parameter">
          <h5>errorSourceContextCacheSizeMB <code>number</code> <code>optional</code></h5>
          <p>Source files are cached in memory to speed up error reporting and avoid costly disk access. The default cache size is 10MB, but this can be overridden. Specifying a value <= 0 removes all cache size limits.</p>
        </aside>
      </article>
    </aside>
  </div>
  <div className="right">
    <code>

      import { H } from "@highlight-run/node";

      if (!H.isInitialized()) {
        H.init({
          projectID: "<YOUR_PROJECT_ID>",
          serviceName: "my-node-app",
          serviceVersion: "git-sha",
        });
      }
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.isInitialized</h3>
    <p>H.isInitialized() returns true if the Highlight backend SDK has been initialized. This may be handy if your initialization code could be called multiple times, e.g. if it is called conditionally from a request handler when a backend error or metric needs to be recorded.</p>
  </div>
  <div className="right">
    <code>
    
      import { H } from "@highlight-run/node";

      if (!H.isInitialized()) {
        H.init({
          projectID: "<YOUR_PROJECT_ID>",
          serviceName: "my-node-app",
          serviceVersion: "git-sha",
        });
      }
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.consumeError</h3>
    <p>H.consumeError() reports an error and its corresponding stack trace to Highlight. The secureSessionId  and requestId  properties are Highlight ids used to link an error to the session in which the error was thrown. These properties are sent via a header and included in every request to your backend once the Highlight client is initialized. They can be parsed using the H.parseHeaders() helper method.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>error<code>Error</code> <code>required</code></h5>
      <p>The error being reported to Highlight.</p>
    </aside>
    <aside className="parameter">
      <h5>secureSessionId<code>string</code> <code>required</code></h5>
      <p>A randomized id representing the Highlight session in which an error was thrown. This can be parsed from the network request's headers using H.parseHeaders().</p>
    </aside>
    <aside className="parameter">
      <h5>requestId<code>string</code> <code>required</code></h5>
      <p>A randomized id generated by the Highlight client representing the request for which an error was thrown. This can be parsed from the network request's headers using H.parseHeaders().</p>
    </aside>
    <aside className="parameter">
      <h5>metadata<code>object</code> <code>optional</code></h5>
      <p>Key-value pairs of metadata that should be associated with the error.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      import * as http from 'http';
      import { H } from "@highlight-run/node";

      const onError = (request: http.IncomingMessage, error: Error): void => {
        const parsed = H.parseHeaders(request.headers);
        if (parsed !== undefined) {
          H.consumeError(error, parsed.secureSessionId, parsed.requestId, {"url": request.url})
        }
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.recordMetric</h3>
    <p>H.recordMetric() reports a metric to Highlight. Backend metrics can be used just like frontend metrics for creating custom dashboards. </p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>secureSessionId<code>string</code> <code>required</code></h5>
      <p>A randomized id representing the Highlight session making the network request. This can be parsed from the network request's headers using H.parseHeaders().</p>
    </aside>
    <aside className="parameter">
      <h5>name<code>string</code> <code>required</code></h5>
      <p>The name of the metric being reported.</p>
    </aside>
    <aside className="parameter">
      <h5>value<code>number</code> <code>required</code></h5>
      <p>The numeric value of the metric being reported.</p>
    </aside>
    <aside className="parameter">
      <h5>requestId<code>string</code> <code>optional</code></h5>
      <p>A randomized id generated by the Highlight client representing the request for this metric. This can be parsed from the network request's headers using H.parseHeaders(). If the metric is not request-specific, this argument can be omitted.</p>
    </aside>
    <aside className="parameter">
      <h5>tags<code>{ name: string; value: string }[]</code> <code>optional</code></h5>
      <p>Tags are arbitrary name-value pairs you can associate to your metrics. This is helpful for categorizing data in dashboards, e.g. for grouping or filtering metrics by particular tags.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      
      import { H } from "@highlight-run/node";

      const handler = (request) => {
        const parsed = H.parseHeaders(request.headers);
        const start = Date.now();
        doInterestingWork();
        const elapsed = Date.now() - start;
        H.recordMetric(parsed.secureSessionId, "elapsedTimeMs", elapsed, parsed.requestId, ["user": "Zane"]);
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.parseHeaders</h3>
    <p>H.parseHeaders() is a helper function for extracting the Highlight secureSessionId and requestId from network requests. These fields are sent with network requests as the 'x-highlight-request' header, encoded as a slash-separated string: "{secureSessionId}/{requestId}"</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>headers<code>IncomingHttpHeaders</code> <code>required</code></h5>
      <p>The headers sent as part of your network request.</p>
    </aside>
  </div>
  <div className="right">
    <code>
      import * as http from "http";
      import { H } from "@highlight-run/node";

      const onError = (request: http.IncomingMessage, error: Error): void => {
        const parsed = H.parseHeaders(request.headers);
        if (parsed !== undefined) {
          H.consumeError(error, parsed.secureSessionId, parsed.requestId)
        }
      };
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.runWithHeaders</h3>
    <p>H.runWithHeaders() wraps its callback with a span named highlight-ctx, and spreads Highlight's secureSessionId and requestId across all spans with matching a traceId.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>headers<code>IncomingHttpHeaders</code> <code>required</code></h5>
      <p>The headers sent with your network request.</p>
    </aside>
    <aside className="parameter">
      <h5>callback <code>required</code></h5>
      <p>Code to execute</p>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>callback return value</h5>
      <p>Returns a Promise that resolves to the callback's return value.</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const onError = async (request: http.IncomingMessage, error: Error): void => {
    const callbackResult = await H.runWithHeaders&lt;ReturnType&gt;(req.headers, async () => {
        const { span } = H.startWithHeaders('custom-span-name', {})
        // do work
        span.end();
      });
};
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.startWithHeaders</h3>
    <p>H.startWithHeaders() returns a Span and a Span Context to propagate the current trace to child spans.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>name<code>string</code> <code>required</code></h5>
      <p>Custom span name</p>
    </aside>
    <aside className="parameter">
      <h5>headers<code>http.Headers</code> <code>required</code></h5>
      <p>A headers object corresponding to the incoming http request headers. Can be an empty object: <code>{}</code></p>
    </aside>
    <aside className="parameter">
      <h5>options <code>optional</code></h5>
      <p>SpanOptions as exported from @opentelemetry/api</p>
      <article className="innerParameterContainer">
        <aside className="innerParameterHeading">options properties</aside>
        <aside className="parameter">
          <h5>kind <code>SpanKind</code> <code>optional</code></h5>
          <p>import { SpanKind } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>attributes <code>SpanAttributes</code> <code>optional</code></h5>
          <p>import { SpanAttributes } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>links <code>Link[]</code> <code>optional</code></h5>
          <p>import { Link } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>startTime <code>TimeInput</code> <code>optional</code></h5>
          <p>import { TimeInput } from @opentelemetry/api</p>
        </aside>
        
        <aside className="parameter">
          <h5>root <code>boolean</code> <code>optional</code></h5>
          <p>The new span should be a root span</p>
        </aside>
        
      </article>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>span</h5>
      <p>Returns the started span</p>
    </aside>
    <aside className="parameter">
      <h5>ctx</h5>
      <p>Returns the context of the current span for trace propagation</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const { span } = H.startWithHeaders("custom-span-name", {});
        // do work
        span.end();
});
    </code>
  </div>
</section>

<section className="section">
  <div className="left">
    <h3>H.waitForFlush</h3>
    <p>H.waitForFlush() waits for spans to be added to the queue and for the queue to empty.</p>
    <h6>Method Parameters</h6>
    <aside className="parameter">
      <h5>expectedSpanNames<code>string[]</code> <code>optional</code></h5>
      <p>Span names to wait for</p>
    </aside>

    <h6>Method Return</h6>
    <aside className="parameter">
      <h5>Promise</h5>
      <p>Returns a Promise that resolves upon a successful flush</p>
    </aside>
  </div>
  <div className="right">
    <code>
import * as http from "http";
import { H } from "@highlight-run/node";

const { span } = await H.startWithHeaders('my-custom-span-name', {});

// do work

span.end();

await H.waitForFlush(['my-custom-span-name']);
    </code>
  </div>
</section>
